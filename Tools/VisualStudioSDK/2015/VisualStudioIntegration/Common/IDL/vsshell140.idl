/****************************************************************************
*  The VSSHELL Interfaces
*  Copyright (c) Microsoft Corporation, All Rights Reserved
****************************************************************************/

#ifndef INTEROPLIB

// Imports - all imports should go here (inside the ifndef)
import "oaidl.idl";
import "vsshell.idl";
import "vsshell2.idl";
import "vsshell80.idl";
import "vsshell90.idl";
import "vsshell100.idl";
import "vsshell110.idl";
import "vsshell120.idl";
import "objext.idl";
import "olecm.idl";
import "VsPlatformUI.idl";
import "ImageParameters140.idl";

#endif

#include "vsshelluuids.h"
#define uuid_VsIdlCustomAttribute uuid_VsPreserveSigAttribute

/****************************************************************************

***** General notes for updating this file

***** Proxy Stub

If you modify anything in here, you may need to rebuild the proxy-stub,
msenvXXXp.dll, and update its registration file,
SetupAuthoring\env\Registry\msenvXXXp.ddr. To do that, once this file has been
built and published, build from env\msenv\proxies and observe the build output.

If you need to omit something from the proxy/stub file, then put it inside an
#ifndef PROXYSTUB_BUILD/#endif block

There is no need to define GUIDs in external header files such as
vsshelluuids.h. Instead, define the GUID directly within the [uuid(...)]
attribute and use __uuidof in native code.

***** Primary Interop Assemblies

If you modify anything in here, you may need to rebuild the primary interop
assemblies. To do that, once this file has been built and published, build
from vscommon\pias using: 'msbuild pias.nativeproj'

***** PreserveSig

Prefer "nopreservesig", which is the default for all new interfaces, because
it creates cleaner managed code. Managed implementations are free to throw
exceptions which will automatically be translated to HRESULTs in the CLR's
COM interop layer. Native implementations will return HRESULTs and they will
be converted to exceptions for managed callers.

Do not create methods returning S_FALSE. Instead use an additional
"[out] VARIANT_BOOL*" or "[out,retval] VARIANT_BOOL*" argument.

***** Interface inheritance

You may derive new interfaces from existing ones, but avoid mixing
"preservesig" (old) with "nopreservesig" (new). Derive from an older interface
if all of the methods in your interface match the preservesig attributes of the
older interface.

Remember, when implementing a derived interface in C++, you must implement
QueryInterface for the base interface(s) too.

***** Enumerators and bitwise flags passed as parameters:

When a parameter must be exactly one of a set of values (a true enumerator),
the values should be defined and used as follows:

typedef enum __VSSAMPLETYPE
{
    ST_THISTYPE     = 0,   // first value should be zero or one, except
    ST_THATTYPE     = 1,   // in special cases, and following values
    ST_THEOTHERTYPE = 2,   // should use consecutive numbers
} VSSAMPLETYPE;

interface IVsSample : IUnknown
{
    HRESULT SampleMethod([in] VSSAMPLETYPE stType);
}

When a parameter must be exactly one of a set of values (a true enumerator),
and is considered a PROPID, the values should be defined and used as follows:

enum __VSSAMPLEPROPID
{
    VSSAMPPROPID_LAST     = -7000,  // first value should be a unique
    VSSAMPPROPID_This     = -7000,  // number not used by any other
    VSSAMPPROPID_That     = -7001,  // PROPID, and following values
    VSSAMPPROPID_FIRST    = -7001,  // should use consecutive numbers
};
typedef LONG VSSAMPLEPROPID;

interface IVsSample : IUnknown
{
    HRESULT GetProperty([in] VSSAMPLEPROPID propid, [out,retval] VARIANT *pvar);
    HRESULT SetProperty([in] VSSAMPLEPROPID propid, [in] VARIANT var);
}

When a parameter can be none of or a combination of values (bitwise),
the values should be defined and used as follows:

enum __VSSAMPLEOPTS
{
    SO_THISOPTION     = 0x00000001,   // first value should be one,
    SO_THATOPTION     = 0x00000002,   // following values should use
    SO_THEOTHEROPTION = 0x00000004,   // consecutive powers of two
};
typedef DWORD VSSAMPLEOPTS;

interface IVsSample : IUnknown
{
    HRESULT SampleMethod([in] VSSAMPLEOPTS grfOptions);
}

***** Defining properties

Define properties as follows:

interface IVsSample : IUnknown
{
    [propget] HRESULT Foo([out, retval] BSTR *pbstrFoo);
    [propput] HRESULT Foo([in] LPCOLESTR strFoo);
}

Using [propget], [propput] and [out, retval] makes the interface easier
to implement and consume in managed code.

Note: The example above shows a case where the get/put methods accept slightly different
argument types (BSTR versus LPCOLESTR). As long as the equivalent interop types are the
same, this is fine (MarshalAs[..] attributes will be added as necessary). However, this
is typically seen only for string arguments.

***** Array typed args

Pass array type arguments (both in and out) using [] and size_is when the corresponding
size argument is present. You must have the array size as an argument for interop to
work correctly.

interface IVsSample : IUnknown
{
    HRESULT MethodPassesInArray([in] int cItems, [in, size_is(cItems)] int prgiItems[]);
}

DO NOT use [in] int piItems[].

For simple element types, consider using SAFEARRAY: e.g. SAFEARRAY(VARIANT_BOOL),
SAFEARRAY(BSTR), SAFEARRAY(INT), etc. because they interop cleanly to managed code, but
note that there is additional memory allocation and it may not be appropriate for high-
performance methods. Also see the following note.

******* SAFEARRAY(IVsFoo*)

SAFEARRAY(IVsFoo*) will cause MIDL warning 2456:
    SAFEARRAY(interface pointer) doesn't work using midl generated proxy

If you know for sure that implementions will never will never need to be called cross
apartment (cross thread/process), then you can add [local] to the method.

Alternatively, consider creating a custom IEnumXXX interface.

****** Strings

Use "[in] LPCOLESTR" instead of "[in] BSTR"

for faster marshaling and more convenience to native callers.
(But continue to use "[out] BSTR*" for out args.)

Generally, you don't need to specify [in,string] for NUL-terminated strings
because most of the "pointer to character" typedefs are already attributed with
[string]. (e.g. "typedef [string] const OLECHAR *LPCOLESTR")

******* Boolean

Use VARIANT_BOOL instead of BOOL because it interops as System.Boolean instead
of System.Int

However, exercise caution when assigning or comparing to/from C++ bool in native
code because VARIANT_BOOL is typedef'd as a short and VARIANT_TRUE is ((short)-1)

******* Optional (may be null) args

Use [in,unique] for optional input arguments which may be NULL.
Note that pointer_default(unique) does NOT do this automatically.

Do not use [out,unique] because unique cannot be applied to [out]-only top-level
pointer parameters. However, you can use [in,out,unique].

Do not use [optional]. It only works with VARIANT anyway and it's not
obvious for managed coders.

******* [out] NonNullableType*

Note that arguments of the type "[out] Foo* pFoo", where Foo is a "non-nullable
type" such as int, double, VARIANT_BOOL, BSTR, will be converted to
"out Foo[] pFoo" in managed code. This is a non-standard conversion applied by
an IL transformation step during the build for the interop assembly.

******* Service GUIDs

Define service GUIDs via an empty interface derived from IUnknown
and put it inside an #ifndef PROXYSTUB_BUILD/#endif block

******* HWNDs, HANDLE, and other non-marshalable types

Take care if you define an interface with HWND, HGDIOBJ or other Win32
handle types. These typically need to be marked [local] since they
cannot cross apartment (specifically, process) boundaries.

****************************************************************************/

#include "vsshelluuids.h" // for uuid_VsPreserveSigAttribute

enum __VSHIERARCHYIMAGEASPECT
{
    HIA_Icon = 0,            // The icon for the hierarchy's normal state (may correspond to icons from VSHPROPID_IconMoniker, VSHPROPID_IconIndex, VSHPROPID_IconHandle, or a system image)
    HIA_OpenFolderIcon = 1,  // The icon for the hierarchy's expanded state (may correspond to icons from VSHPROPID_OpenFolderIconMoniker, VSHPROPID_OpenFolderIconIndex, VSHPROPID_OpenFolderIconHandle, or a system image)
    HIA_OverlayIcon = 2,     // The overlay icon for the hierarchy (may correspond to icons from VSHPROPID_OverlayIconIndex)
    HIA_StateIcon = 3,       // The state icon for the hierarchy (may correspond to icons from VSHPROPID_StateIconIndex)
};

typedef int VSHIERARCHYIMAGEASPECT;

//----------------------------------------------------------------------------
// IVsImageMonikerImageList
//----------------------------------------------------------------------------
[
    uuid(8660a8eb-6c2e-45c7-920a-73a45ef4de8e),
    version(1.0),
    pointer_default(unique)
]
interface IVsImageMonikerImageList : IUnknown
{
    [propget] HRESULT ImageCount([out, retval] int* imageCount);

    HRESULT GetImageMonikers(
        [in] int firstImageIndex,                                       // The index of the first image in the image list to copy into the imageMonikers array
        [in] int imageMonikerCount,                                     // The number of images to retrieve from the image list
        [in, out, size_is(imageMonikerCount)] ImageMoniker imageMonikers[]);   // The image monikers retrieved from the image list
};

//----------------------------------------------------------------------------
// IVsImageService2
//----------------------------------------------------------------------------
[
    uuid(676ce47b-7375-4d53-b0bc-ef9322a2ae62),
    version(1.0),
    pointer_default(unique)
]
interface IVsImageService2 : IVsImageService
{
    HRESULT GetImage(
        [in] ImageMoniker moniker,                  // the moniker for the image
        [in] ImageAttributes attributes,            // the parameters describing the image
        [out, retval] IVsUIObject** imageObject);   // the image

    // returns the moniker for the icon to display for the file
    HRESULT GetImageMonikerForFile(
        [in] LPCOLESTR filename,                // the filename
        [out, retval] ImageMoniker* moniker); // the moniker for the image

    // returns the moniker for the icon to display for an IVsHierarchy item
    HRESULT GetImageMonikerForHierarchyItem(
        [in] IVsHierarchy* hierarchy,                     // The hierarchy to retrieve the image for
        [in] VSITEMID hierarchyItemID,                    // The item within the hierarchy to retrieve the image for
        [in] VSHIERARCHYIMAGEASPECT hierarchyImageAspect, // The type of image to retrieve from the hierarchy
        [out, retval] ImageMoniker* moniker);             // The moniker representing the current image for the hierarchy

    // returns the moniker for a named image from IVsImageService.Add
    HRESULT GetImageMonikerForName(
        [in] LPCOLESTR imageName,
        [out, retval] ImageMoniker* moniker);

    HRESULT AddCustomImage(
        [in] IVsUIObject* imageObject,          // the custom image
        [out, retval] IImageHandle** handle);   // the handle for the custom image

    HRESULT RemoveCustomImage(
        [in] IImageHandle* handle);           // a moniker returned from AddCustomImage

    HRESULT AddCustomImageList(
        [in] IVsImageMonikerImageList* imageList,
        [out, retval] IImageHandle** handle);

    HRESULT RemoveCustomImageList(
        [in] IImageHandle* handle);

    // Creates a new custom ImageMoniker composed of multiple images rendered together
    HRESULT AddCustomCompositeImage(
        [in] int virtualWidth,                  // The virtual width of the canvas the composite image is rendered on.  Real pixel sizes are determined by the ImageAttributes used to load the image.
        [in] int virtualHeight,                 // The virtual height of the canvas the composite image is rendered on.  Real pixel sizes are determined by the ImageAttributes used to load the image.
        [in] int layerCount,                    // The number of layers in the image.
        [in, size_is(layerCount)] ImageCompositionLayer layers[], // The collection of layers composed into the image.  Layers are stacked bottom-up (subsequent layers in the array are rendered on top of previous layers)
        [out, retval] IImageHandle** handle);   // The IImageHandle representing the composited image.  The composited image can be removed using RemoveCustomImage.

    // Replacement for IVsUIShell5.ThemeDIBits.
    //
    // Applies theming to BGRA32 device-independent bitmap bits. The luminosity of the image 
    // is transformed so that the constant "halo" luminosity blends in with the background.  
    // This has the effect of eliminating the halo visually.  The "halo" luminosity is an 
    // immutable constant, and is not calculated from the input image.
    //
    // Images which contain cyan (#00FFFF) in their top-right pixel are not inverted.  Instead, 
    // the top-right pixel is cleared (RGBA are all set to 0) and S_OK is returned without 
    // otherwise modifying the image.
    //
    // DEVNOTE: do not change the order of the [size_is, in, out] attributes on the "pixels"
    // parameter to [in, out, size_is] or [out, in, size_is], or XFormIDL.pl will remove the 
    // [In] attribute from the interop assembly.
    HRESULT ThemeDIBits(
        [in] int pixelCount,                            // the number of pixels in the pixel array
        [size_is(pixelCount), in, out] BYTE pixels[],   // the pixel array
        [in] int width,                                 // the width of the image, in pixels
        [in] int height,                                // the height of the image, in pixels
        [in] VARIANT_BOOL isTopDownBitmap,              // indicates whether the bitmap is a top-down bitmap
        [in] COLORREF backgroundColor,                  // the background color
        [out, retval] VARIANT_BOOL* themed);            // indicates whether the pixels were themed

    // Creates an association between an image name (from IVsImageService.Add and IVsImageService.Get)
    // and an ImageMoniker (from IVsImageService.GetImage).
    HRESULT TryAssociateNameWithMoniker(
        [in] LPCOLESTR imageName,                       // The image name to associate with the moniker
        [in] ImageMoniker moniker,                      // The moniker to associate with the image name
        [out, retval] VARIANT_BOOL* succeeded);         // True if the moniker was successfully associated with the name, false if some other moniker is already registered

    // Parses a moniker string. The moniker can be of the form "{guid};id" or the name of a well-known
    // moniker (e.g. "KnownMonikers.FolderClosed")
    //
    // devnote:  preservevaluetyperefparam custom attribute is used so the type used for the moniker
    // parameter in the interop assembly is "out ImageMoniker" instead of "ImageMoniker[]"
    HRESULT TryParseImageMoniker(
        [in] LPCOLESTR monikerAsString,                 // The moniker string to parse
        [custom(uuid_VsIdlCustomAttribute, "preservevaluetyperefparam")]
        [out] ImageMoniker* moniker,                    // The parsed moniker 
        [out, retval] VARIANT_BOOL* succeeded);         // True if the moniker was successfully parsed, false if not

    // Creates an instance of an IVsImageMonikerImageList that wraps a native HIMAGELIST
    [local] HRESULT CreateMonikerImageListFromHIMAGELIST(
        [in] HANDLE hImageList,                                    // The HIMAGELIST to create a wrapping IVsImageMonikerImageList for 
        [out, retval] IVsImageMonikerImageList** monikerImageList); // The returned IVsImageMonikerImageList

     // Returns whether an image is custom (registered at runtime), loaded from the manifest, or unknown (in which case the ImageMoniker is invalid or stale)
    HRESULT GetImageMonikerType(
        [in] ImageMoniker moniker,  //Moniker to test
        [out, retval] ImageMonikerType * monikerType //moniker type
        );
        
    // Returns the image monikers in an image list
    HRESULT GetImageListImageMonikers(
        [in] ImageMoniker moniker, // the image list's moniker
        [out, retval] IVsImageMonikerImageList** imageListMonikers); // contains the image monikers in the specified image list

};

//----------------------------------------------------------------------------
// IVsImageMonikerSource
//----------------------------------------------------------------------------
[
    uuid(05bcd36e-0c17-4ab6-95ac-70aefa2991ee),
    version(1.0),
    pointer_default(unique)
]
interface IVsImageMonikerSource : IUnknown
{
    [propget] HRESULT ImageMoniker([out, retval] ImageMoniker *moniker);
};

//----------------------------------------------------------------------------
// IVsTaskProvider5
//----------------------------------------------------------------------------
[
    uuid(1565244d-2daf-486f-acef-54c1a32d03fa),
    version(1.0),
    pointer_default(unique)
]
interface IVsTaskProvider5 : IVsTaskProvider4
{
    [propget] HRESULT ImageListMoniker([out, retval] ImageMoniker *moniker);
};


// Extends IVsTask (vsshell110.idl) to add support for task-specific messages to be
// shown in the Threaded Wait Dialog when the UI thread is blocked on a task. If a
// WaitMessage isn't specified then a generic message (Waiting for a required 
// operation to complete...) is used.
[
    uuid(26f21acd-a055-4f5b-97be-27c2ec4d7a33),
    version(1.0),
    pointer_default(unique)
]
interface IVsTask2 : IVsTask
{
    // When the UI thread calls GetResult or Wait and the task isn't complete, this 
    // message will be displayed in the Threaded Wait Dialog. If no WaitMessage is 
    // supplied (either null or whitespace) a generic message will be used.
    [propget] HRESULT WaitMessage([out, retval] BSTR *ppWaitMessage);
    [propput] HRESULT WaitMessage([in, unique] LPCOLESTR pWaitMessage);
}

// Extends IVsThreadedWaitDialog3 (vsshell110.idl) so that callers can know whether 
// the dialog was started or simply a no-op. 
[
    uuid(7619bd89-3b7e-4838-ad11-434bec7d9530),
    version(1.0),
    pointer_default(unique)
]
interface IVsThreadedWaitDialog4 : IVsThreadedWaitDialog3
{
    // If StartWaitDialog (or StartWaitDialogEx) is called multiple times without 
    // calling EndWaitDialog, only the first will start the dialog and subsequent 
    // calls will just be no-ops. This makes it difficult to determine how often
    // a call site caused the dialog to show. pfStarted will be set to true if the 
    // call to StartWaitDialogEx started the wait dialog (or started the timer to 
    // show the dialog).
    HRESULT StartWaitDialogEx(
        [in]			LPCWSTR			szWaitCaption,
        [in]			LPCWSTR			szWaitMessage,
        [in]			LPCWSTR			szProgressText,         // Can be NULL
        [in]			VARIANT			varStatusBmpAnim,       // Optional: should be a VT_INT_PTR containing a valid BMP, or VT_NULL
        [in]			LPCWSTR			szStatusBarText,        // Can be NULL
        [in]			LONG			iDelayToShowDialog,     // Number of seconds to delay showing dialog.
        [in]			VARIANT_BOOL	fIsCancelable,          // Should there be a cancelable button on the dialog.
        [in]			VARIANT_BOOL	fShowMarqueeProgress,   // Marquee style progress will be shown with VARIANT_BOOL, otherwise no visible progress bar.
        [out, retval]	VARIANT_BOOL	*pfStarted);			// Did we actually show the dialog or was it already visible?
}

#ifndef PROXYSTUB_BUILD

//-----------------------------------------------------------------------------
// SVsHubService
// The service type implementing the VsHub service
//-----------------------------------------------------------------------------
[uuid(95D652E5-D9B2-4EE6-BB09-BDBB1DCB5263)]
interface SVsHubService : IUnknown
{
}
cpp_quote("#define SID_SVsHubService IID_SVsHubService")

//-----------------------------------------------------------------------------
// SVsAccountManager
// The service type implementing IAccountManager
//-----------------------------------------------------------------------------
[
    uuid(231E1BD9-EECC-4E16-9FCA-A1D24A20EE71),
    version(1.0),
    pointer_default(unique)
]
interface SVsAccountManager : IUnknown
{
}
cpp_quote("#define SID_SVsAccountManager __uuidof(SVsAccountManager)")

//----------------------------------------------------------------------------
// IAsyncProgressCallback
// Provides a way for asynchronous service and package owners to report progress
// The reported progress can be shown to user in an appropiate manner by the shell
//
// The interface is implemented by Visual Studio IDE. For package loads, the instance
// is passed to package via Initialize method. For services, package can retrieve 
// the instance through IProfferAsyncService.GetServiceProgressCallback method.
//
// This interface is used for reporting progress for both package and service loads.
// For packages guidService argument is not used and will be ignored.
//----------------------------------------------------------------------------
[
    uuid(c3a2d62e-64be-4008-924f-7e303e2b0001),
    version(1.0),
    pointer_default(unique)
]
interface IAsyncProgressCallback : IUnknown
{
    HRESULT ReportProgress([in] REFGUID guidService, [in] LPCWSTR szWaitMessage, [in] LPCWSTR szProgressText, [in] LONG iCurrentStep, [in] LONG iTotalSteps);
}

//----------------------------------------------------------------------------
// IAsyncServiceProvider
// Provides a way to asynchronously request services. Similar to IServiceProvider.
// Returns the IUnknown* of the requested service via the IVsTask. Caller must
// do any further casting to get to the proper service interface.
// Implementation must be free-threaded.
//----------------------------------------------------------------------------
[
    uuid(257B63FA-8388-4FEB-9DB8-3DB22F4405DE),
    version(1.0),
    pointer_default(unique)
]
interface IAsyncServiceProvider : IUnknown
{
    HRESULT QueryServiceAsync([in] REFGUID guidService, [out, retval] IVsTask **ppTask);
}

//-----------------------------------------------------------------------------
// SAsyncServiceProvider
// The service id for the IAsyncServiceProvider service
//-----------------------------------------------------------------------------
[uuid(944774C9-7422-4E87-B01C-189182C779A6)]
interface SAsyncServiceProvider : IUnknown
{
}
cpp_quote("#define SID_SAsyncServiceProvider IID_SAsyncServiceProvider")

//----------------------------------------------------------------------------
// IProfferAsyncService
// Provides a way to register a provider for services able to be retrieved
// asynchronously. Similar to IProfferService.
// Implementation must be free-threaded.
//----------------------------------------------------------------------------
[
    uuid(5FDD1FE6-898B-4D51-B2BC-4C936760C572),
    version(1.0),
    pointer_default(unique)
]
interface IProfferAsyncService : IUnknown
{
    HRESULT ProfferAsyncService([in] REFGUID rguidService,
        [in] IAsyncServiceProvider *psp,
        [out, retval] DWORD *pdwCookie);

    HRESULT RevokeAsyncService([in] DWORD dwCookie);

    // Get the callback instance used for reporting service load progress.
    HRESULT GetServiceProgressCallback([out, retval] IAsyncProgressCallback **pProgressCallback);
}

//-----------------------------------------------------------------------------
// SProfferAsyncService
// The service for the IAsyncServiceProvider service
//-----------------------------------------------------------------------------
[uuid(594AC716-4B5C-4A85-B36F-F1E728F71603)]
interface SProfferAsyncService : IUnknown
{
}
cpp_quote("#define SID_SProfferAsyncService IID_SProfferAsyncService")

//----------------------------------------------------------------------------
// IVsServiceInfo
// Represents information about a VS service.
// Implementation must be free-threaded.
//----------------------------------------------------------------------------
[
    uuid(5B5AC77C-213B-4642-9D20-5BF902649356),
    version(1.0),
    pointer_default(unique)
]
interface IVsServiceInfo : IUnknown
{
    [propget] HRESULT ServiceGuid([out, retval] GUID *pServiceGuid);
    [propget] HRESULT Name([out, retval] BSTR *pName);
    [propget] HRESULT IsAsync([out, retval] VARIANT_BOOL *pIsAsync);
    [propget] HRESULT PackageGuid([out, retval] GUID *pPackageGuid);
    [propget] HRESULT HasOverride([out, retval] VARIANT_BOOL *pHasOverride);
    [propget] HRESULT OverridePackageGuid([out, retval] GUID *pOverridePackageGuid);
}

//----------------------------------------------------------------------------
// IVsServiceInfoQueryService
// Provides a way to get information about registered services in VS.
// Implementation must be free-threaded.
//----------------------------------------------------------------------------
[
    uuid(932AA966-86BE-44D9-8403-2F4A2C17ADB1),
    version(1.0),
    pointer_default(unique)
]
// Preservesig as you could query for a service that isn't installed, that should 
// not require throwing an exception (if the service is implemented in managed
// code).
[custom(uuid_VsPreserveSigAttribute, "preservesig")]
interface IVsServiceInfoQueryService : IUnknown
{
    HRESULT GetServiceInfo([in] REFGUID serviceGuid, [out] IVsServiceInfo **ppServiceInfo);
}

//-----------------------------------------------------------------------------
// SVsServiceInfoQueryService
// The service for the IVsServiceInfoQueryService service
//-----------------------------------------------------------------------------
[uuid(68FB1880-81F7-4939-8BBC-A957A1033345)]
interface SVsServiceInfoQueryService : IUnknown
{
}
cpp_quote("#define SID_SVsServiceInfoQueryService IID_SVsServiceInfoQueryService")

//----------------------------------------------------------------------------
// IAsyncLoadAwarePackageInitialize
// Provides a way get access to IAsyncServiceProvider, IProfferAsyncService 
// without needing to use IServiceProvider. Implemented by packages.
//----------------------------------------------------------------------------
[
    uuid(3EC4D7F6-4036-4406-A393-2FFF7B2E78A1),
    version(1.0),
    pointer_default(unique)
]
interface IAsyncLoadablePackageInitialize : IUnknown
{
    HRESULT Initialize([in] IAsyncServiceProvider *pServiceProvider,
        [in] IProfferAsyncService *pProfferService,
        [in] IAsyncProgressCallback *pProgressCallback,
        [out, retval] IVsTask **ppTask);
}

//-----------------------------------------------------------------------------
// SVsAccountManagementService
// The service type implementing the Visual Studio account management service.
//-----------------------------------------------------------------------------
[uuid(33024F95-187C-4F15-AA48-38D05C1E8B58)]
interface SVsAccountManagementService : IUnknown
{
}
cpp_quote("#define SID_SVsAccountManagementService IID_SVsAccountManagementService")

#endif

//----------------------------------------------------------------------------
// IVsShell7
//----------------------------------------------------------------------------
[
    uuid(912079DD-342A-4A53-AB7F-752553679A47),
    version(1.0),
    pointer_default(unique)
]
interface IVsShell7 : IUnknown

{
    HRESULT LoadPackageAsync([in] REFGUID guidPackage,
        [out, retval] IVsTask **ppTask);

    HRESULT LoadPackageWithContextAsync([in] REFGUID guidPackage,
        [in] int reason,
        [in] REFGUID context,
        [out, retval] IVsTask **ppTask);

    // Gets the ImageMoniker used to retrieve an HIMAGELIST from the IVsImageService2 for the SCC glyph icons (those returned by VSSPROPID_SCCGlyphsImgList).
    // Using this ImageMoniker instead of the SCCGlyphsImgList allows for better high-DPI scaling, as the image list can be requested at the correct size.
    [propget] HRESULT SccGlyphImageListImageMoniker([out, retval] ImageMoniker* pImageMoniker);
}

// This UIContext is toggled on idle after the shell has entered its main message loop
// {E80EF1CB-6D64-4609-8FAA-FEACFD3BC89F}
cpp_quote("extern const __declspec(selectany) GUID UICONTEXT_ShellInitialized = { 0xe80ef1cb, 0x6d64, 0x4609, { 0x8f, 0xaa, 0xfe, 0xac, 0xfd, 0x3b, 0xc8, 0x9f } };")

enum __VSREFERENCEAPPLYRESULT
{
    // The reference changes were applied successfully.
    APPLYRESULT_AppliedSuccessfully = 1,

    // The reference changes were NOT applied successfully but Reference Manager Dialog 
    // may stay open (e.g. operation was canceled and project was not reloaded).
    APPLYRESULT_NotApplied = 0,

    // The reference changes were NOT applied successfully and Reference Manager Dialog 
    // must close (e.g. the project was reloaded and state of project is unknown).
    APPLYRESULT_NotAppliedAndCloseDialog = -1
};

typedef int VSREFERENCEAPPLYRESULT;

//------------------------------------------------------------------------
// IVsReferenceManagerUserReloadRequired - Interface used by clients of the ReferenceManager
//   dialog to receive change requests for changes that require reloading the project in
//   order to apply the changes.
//------------------------------------------------------------------------
[
    odl,
    uuid(400C66C9-5272-418C-9113-1C9BDFD7D7BA),
    version(1.0),
    oleautomation,
]
interface IVsReferenceManagerUserReloadRequired : IUnknown
{
    // Reference Manager will call this method once when it is actually time to apply any changes that require
    // reloading of the project to make the updates. Projects that have reference changes that require reloading 
    // the project can add them to a queue when IVsReferenceManagerUser.ChangeReferences is called rather than 
    // applying them immediately and forcing possibly multiple project reloads. After all changes from all 
    // referenceProviderContexts have been propagated, then the ReferenceManager dialog will make a single call
    // to ApplyReloadRequiredReferenceChanges. The Expected behavior is to apply all possible changes that were 
    // queued up by prior calls to IVsReferenceManagerUser.ChangeReferences and return a single error through 
    // HRESULT+IErrorInfo mechanism. If the reference changes are being aborted for any reason, then
    // ApplyReloadRequiredReferenceChanges(cancelOperation:true) will be called to give the project a chance 
    // to clean up any state it has queued.
    HRESULT ApplyReloadRequiredReferenceChanges([in] VARIANT_BOOL cancelOperation, [out, retval] VSREFERENCEAPPLYRESULT* applyResult);
};

// BEGIN: Shared Project Support

//--------------------------------------------------------------------
// standard item type, to be returned from VSHPROPID_TypeGuid
//--------------------------------------------------------------------
// SharedProjectReference item (normally child of "References" folder).
// SharedProjectReference items represent imported shared MSBuild project files (e.g. *.projitems file).
// Normally these shared MSBuild project files are "owned" by a particular Shared Project
// (aka Shared Assets Project) loaded in the Solution.
// {FBA6BD9A-47F3-4C04-BDC0-7F76A9E2E582}
cpp_quote("extern const __declspec(selectany) GUID GUID_ItemType_SharedProjectReference =  { 0xfba6bd9a, 0x47f3, 0x4c04, { 0xbd, 0xc0, 0x7f, 0x76, 0xa9, 0xe2, 0xe5, 0x82 } };")

//----------------------------------------------------------------------
// IVsSharedProjectReference
//----------------------------------------------------------------------
[
    odl,
    uuid(DD928D98-26E0-4255-A3CE-3BA866296F8B),
    version(1.0),
    oleautomation,
]
interface IVsSharedProjectReference : IVsReference
{
    /*
    // This is the name/caption of the Shared Project (owner project for the imported shared MSBuild file)
    [propget] HRESULT Name([out, retval] BSTR* bstrName);
    [propput] HRESULT Name([in] LPCOLESTR strName);

    // This is the full path of Shared Project's project file (e.g. *.shproj file)
    [propget] HRESULT FullPath([out, retval] BSTR* bstrFullPath);
    [propput] HRESULT FullPath([in] LPCOLESTR bstrFullPath);

    [propget] HRESULT AlreadyReferenced([out, retval] VARIANT_BOOL* boolAlreadyReferenced);
    [propput] HRESULT AlreadyReferenced([in] VARIANT_BOOL boolAlreadyReferenced);
    */

    // This is the ProjectID Guid for the Shared Project. IVsSolution.GetGuidOfProject should 
    // be used to retrieve the IVsHierarchy for the Shared Project. 
    [propget] HRESULT SharedProjectID([out, retval] GUID* sharedProjectID);
    [propput] HRESULT SharedProjectID([in] GUID sharedProjectID);

    // This is the full path of the imported shared MSBuild file (e.g. *.projitems file).
    [propget] HRESULT SharedMSBuildFileFullPath([out, retval] BSTR* sharedMSBuildFileFullPath);
    [propput] HRESULT SharedMSBuildFileFullPath([in] LPCOLESTR sharedMSBuildFileFullPath);
}

//------------------------------------------------------------------
// IVsSharedProjectReferenceProviderContext
// ReferenceProviderContext interface for the Shared Project Reference 
// Tab in the Add Reference Manager dialog.
//------------------------------------------------------------------
[
    uuid(C4385811-F65E-4049-A60F-20B9AB884BBC),
    version(1.0),
]
interface IVsSharedProjectReferenceProviderContext : IVsReferenceProviderContext {
    [propget] HRESULT ReferencingProject([out, retval] IVsHierarchy** pRetVal);
    [propputref] HRESULT ReferencingProject([in] IVsHierarchy* val);
};

//----------------------------------------------------------------------
// IVsEnumSharedProjectReferences 
//
// Collection of IVsSharedProjectReferences.
//
// to implement on managed side:
//  class SharedProjectReferenceCollection : List<IVsSharedProjectReference>, IVsEnumSharedProjectReferences
//  {
//      System.Collections.IEnumerator IVsEnumSharedProjectReferences.GetEnumerator()
//      {
//          return this.GetEnumerator();
//      }
//  }
//----------------------------------------------------------------------
[
    uuid(FF92C68E-8503-4E30-A205-3AB4EF219990),
    version(1.0),
    pointer_default(unique)
]
interface IVsEnumSharedProjectReferences : IUnknown
{
    [id(DISPID_NEWENUM), propget]
    HRESULT _NewEnum([out, retval] IUnknown** ppUnk);

    [id(DISPID_VALUE), propget]
    HRESULT Item([in] long index, [out, retval] IVsSharedProjectReference** lppcReturn);

    [id(10), propget]
    HRESULT Count([out, retval] long* lplReturn);
}

//----------------------------------------------------------------------
// IVsSharedMSBuildFilesManagerHierarchy2
//----------------------------------------------------------------------
[
    uuid(CFCB9B0D-59AD-4BD8-B288-A2539B54633A),
    version(1.0),
    pointer_default(unique)
]
interface IVsSharedMSBuildFilesManagerHierarchy2 : IUnknown
{
    /// <summary>
    /// Returns an enumerable collection of all Shared Projects that exist in the Solution. 
    /// </summary>
    /// <param name="referencingProject">IVsHierarchy of a project that may be referencing a 
    /// Shared Project (i.e. importing the shared project file owned by the Shared Project).
    /// If a referencingProject is provided, then the information of 
    /// whether that project is already referencing the Shared Project will be provided. 
    /// referencingProject may be null.
    /// </param>
    /// <returns>IVsEnumSharedProjectReferences</returns>
    /// <remarks>
    /// Shared Projects (aka Shared Assets Projects) are loaded projects that are considered as 
    /// the "Owner" of a shared MSBuild project file (e.g. *.projitems) that can be imported by 
    /// multiple client (aka "Head") projects. Shared Projects register their shared MSBuild file 
    /// with the IVsSharedMSBuildFilesManagerHierarchy with the SFUSEROPT_SharedMSBuildFileOwnerProject 
    /// flag. There normally should only be one project that registers as the "SharedMSBuildFileOwnerProject" 
    /// of a shared MSBuild file in the Solution. In this case this project is the assigned OwnerProject. 
    /// In the rare event that more than one project registers with the "SharedMSBuildFileOwnerProject" 
    /// flag for the same shared MSBuild file, then if only one of these project is loaded (i.e. all of the 
    /// others are unloaded), then the single, LOADED project would be assigned as the OwnerProject.
    /// </remarks>
    HRESULT EnumAllAvailableSharedProjects(
        [in, unique] IVsHierarchy* referencingProject,
        [out, retval] IVsEnumSharedProjectReferences** ppEnumSharedProjectReferences);

    /// <summary>
    /// Returns an IVsSharedProjectReference object for a particular shared MSBuild file if it is 
    /// referenced/imported by the given referencingProject, client (aka "Head") project.
    /// </summary>
    /// <param name="sharedFileFullPath">full path of a (potential) shared project file</param>
    /// <param name="referencingProject">IVsHierarchy of a project that may be referencing a 
    /// Shared Project (i.e. importing the shared project file owned by the Shared Project).
    /// </param>
    /// <returns>an IVsSharedProjectReference object or null if the given sharedFileFullPath has 
    /// not been registered with the IVsSharedMSBuildFilesManagerHierarchy by the referencingProject.</returns>
    /// <remarks>
    /// All callers must be prepared to check for a null return value.
    /// </remarks>
    HRESULT GetSharedProjectReference(
        [in] LPCOLESTR sharedFileFullPath,
        [in] IVsHierarchy* referencingProject,
        [out, retval] IVsSharedProjectReference** ppSharedProjectReference);
}

//----------------------------------------------------------------------
// IVsSharedProjectReferencesHelper
// This is a helper service to help projects that support adding/removing
// SharedProject References via the ReferenceManager dialog. 
//----------------------------------------------------------------------
[
    uuid(BB0D419C-04CD-457A-BC3C-954F447EC806),
    version(1.0),
    pointer_default(unique),
]
interface IVsSharedProjectReferencesHelper : IUnknown
{
    /// <summary>
    /// Changes the set of Shared MSBuild files imported by a project.
    /// </summary>
    /// <param name="importingProject">project that is being modifyied.</param>
    /// <param name="importFullPathsToRemove">list of MSBuild project file full paths (e.g. *.projitems) that 
    /// should be removed from being imported</param>
    /// <param name="importFullPathsToAdd">list of MSBuild project file full paths (e.g. *.projitems) that 
    /// should be added as imports</param>
    /// <param name="szImportLabel">label used to identify the MSBuild import statements of interest 
    /// (e.g. Shared Project References use import statements with the label = "Shared").</param>
    /// <returns>VARIANT_BOOL -> true if project has been reloaded, false if not</returns>
    /// <remarks>This method may cause the pImportingProject to be reloaded as part of this 
    /// operation. If this method returns true that the project was reloaded, then the caller must refetch 
    /// the project by calling IVsSolution.GetProjectOfGuid or similar mechanism after this method returns. 
    /// If any errors occur then no changes will be committed to the project file on disk.
    /// </remarks>
    HRESULT ChangeSharedMSBuildFileImports(
        [in] IVsHierarchy* importingProject,
        [in] SAFEARRAY(BSTR) importFullPathsToRemove,
        [in] SAFEARRAY(BSTR) importFullPathsToAdd,
        [in] LPCOLESTR szImportLabel,
        [out, retval] VARIANT_BOOL* pfProjectWasReloaded
        );

    /// <summary>
    /// Changes the set of Shared Projects referenced by a project. 
    /// </summary>
    /// <param name="referencingProject">project that is using the AddReferenceManager
    /// dialog to add SharedProject references.</param>
    /// <param name="cReferencesToRemove">count of SharedProject References to be removed.</param>
    /// <param name="referencesToRemove">array of SharedProject references to be removed.
    /// Each element of the array is expected to support IVsSharedProjectReference or IVsHierarchy interface.
    /// May be null if there are no references to be removed.</param>
    /// <param name="cReferencesToAdd">count of SharedProject References to be added.</param>
    /// <param name="referencesToAdd">array of SharedProject references to be added.
    /// Each element of the array is expected to support IVsSharedProjectReference or IVsHierarchy interface.
    /// May be null if there are no references to be added.</param>
    /// <returns>VARIANT_BOOL -> true if project has been reloaded, false if not</returns>
    /// <remarks>
    /// This method is often used by projects as an implementation detail of their
    /// IVsReferenceManagerUserReloadRequired::ApplyReloadRequiredReferenceChanges implementation.
    /// This method may cause the referencingProject to be reloaded as part of this 
    /// operation. If this method returns true that the project was reloaded, then the caller must refetch 
    /// the project by calling IVsSolution.GetProjectOfGuid or similar mechanism after this method returns. 
    /// Shared Project References use MSBuild import statements that are tagged with the label "Shared".
    /// </remarks>
    HRESULT ChangeSharedProjectReferences(
        [in] IVsHierarchy* referencingProject,
        [in] int cReferencesToRemove,
        [in, size_is(cReferencesToRemove)] IUnknown* referencesToRemove[],
        [in] int cReferencesToAdd,
        [in, size_is(cReferencesToAdd)] IUnknown* referencesToAdd[],
        [out, retval] VARIANT_BOOL* pfProjectWasReloaded
        );
}

//----------------------------------------------------------------------
// IVsPlatformReferenceProviderContext2
// Extends IVsPlatformReferenceProviderContext to expose new platform SDK properties
//----------------------------------------------------------------------
[
    odl,
    uuid(65429265-78CC-4772-9826-5BF9E2295C62),
    version(1.0),
    oleautomation,
]
interface IVsPlatformReferenceProviderContext2 : IVsPlatformReferenceProviderContext
{
    // This points to the location on disk where extension SDKs live
    [propget] HRESULT SDKExtensionDirectoryRoot([out, retval] BSTR* pbstrSdkExtensionDirectoryRoot);
    [propput] HRESULT SDKExtensionDirectoryRoot([in] LPCOLESTR strSdkExtensionDirectoryRoot);
};

//----------------------------------------------------------------------
// IVsPlatformReferenceProviderContext3
// Extends IVsPlatformReferenceProviderContext2 to expose new platform SDK properties
//----------------------------------------------------------------------
[
    odl,
    uuid(2EE3C85D-04D8-461B-B7AC-8E4F9C59DC97),
    version(1.0),
    oleautomation,
]
interface IVsPlatformReferenceProviderContext3 : IVsPlatformReferenceProviderContext2
{
    // The SDK identifier for the platform
    [propget] HRESULT SDKIdentifier([out, retval] BSTR* pbstrSdkIdentifier);
    [propput] HRESULT SDKIdentifier([in] LPCOLESTR strSdkIdentifier);

    // This SDK version for the platform
    [propget] HRESULT SDKVersion([out, retval] BSTR* pbstrSdkVersion);
    [propput] HRESULT SDKVersion([in] LPCOLESTR strSdkVersion);
};

//----------------------------------------------------------------------
// IVsSccGlyphs2
// Allows SCC providers to provide ImageMoniker-based glyphs.
//----------------------------------------------------------------------
[
    uuid(B3C3F5E2-7460-4AD6-9581-3A24A3DFE417),
    version(1.0),
    pointer_default(unique),
]
interface IVsSccGlyphs2 : IUnknown
{
    // Gets a list of custom ImageMonikers for SCC state icons specific to an SCC provider.
    HRESULT GetCustomGlyphMonikerList(
        [in] ULONG baseIndex,                                               // The number of base icons in the central image list
        [out, retval] IVsImageMonikerImageList** imageMonikerImageList);    // The list of custom ImageMonikers from the SCC provider
};

#ifndef PROXYSTUB_BUILD

// SVsSharedProjectReferencesHelper service is a component to provide 
// support for project systems  that require reloading the project in order to change 
// Shared Project references (i.e. change the set of project imports) to implement 
// Add Shared Project Reference via the ReferenceManager dialog. 
[
    uuid(DB598271-AD61-4BB2-80BA-729AF83F0EE3)
]
interface SVsSharedProjectReferencesHelper : IUnknown
{
}
cpp_quote("#define SID_SVsSharedProjectReferencesHelper IID_SVsSharedProjectReferencesHelper")


// Guid for Shared Project Reference Tab in the Add Reference Manager dialog.
[
    uuid(88B47069-C019-4EEC-B69C-3C8630F83BA5)
]
interface SharedProjectReferenceProviderGuid : IUnknown
{
}
cpp_quote("#define GUID_SharedProjectReferenceProvider  IID_SharedProjectReferenceProviderGuid ")

#endif PROXYSTUB_BUILD

//------------------------------------------------------------------
// IVsSharedProjectQueryCanBeReferenced
// Gives a Shared Project a chance to veto the adding of
// a reference by a particular referencing project.
//------------------------------------------------------------------
[
    uuid(684863A4-BC6E-467C-8218-5C84CAB616DA),
    version(1.0),
    pointer_default(unique)
]
interface IVsSharedProjectQueryCanBeReferenced : IUnknown
{
    /// <summary>
    /// Called by IVsSharedMSBuildFilesManagerHierarchy2.EnumAllAvailableSharedProjects implementation in order 
    /// to filter the list of Shared Projects to only valid choices for the referencingProject. 
    /// </summary>
    /// <param name="referencingProject">project that wants to add a Shared Project Reference.</param>
    /// <returns>VSREFERENCEQUERYRESULT result value which indicates whether the reference is allowed or not.</returns>
    /// <remarks>
    /// The minimum expected implemenation of this method by a Shared Project is to enforce that the language 
    /// of the Shared Project is compatible with the language of the referencingProject. This check is 
    /// normally made by peforming an IsCapabilitiesMatch check. 
    /// e.g.:
    ///    return referencingProject.IsCapabilityMatch($(SharedProjectAppliesTo));
    /// where the $(SharedProjectAppliesTo) property of the Shared Project is a Capabilities expression that
    /// ensures that the referencingProject is of a compatible language (and possibly other criteria for 
    /// advanced Shared Project scenarios).
    /// For example the SharedProjectAppliesTo property defined in the Microsoft.CSharp.CodeSharing.targets file 
    /// is the following:
    ///      &lt;SharedProjectAppliesTo&gt;CSharp&lt;/ SharedProjectAppliesTo&gt;
    /// </remarks>
    HRESULT QueryCanSharedProjectBeReferenced(
        [in] IVsHierarchy *referencingProject,
        [out, retval] VSREFERENCEQUERYRESULT *pResult
        );
}

// END: Shared Project Support

//----------------------------------------------------------------------------
// Provides support for starting or stopping animations that are a sequence 
// of frames defined by image monikers.
//----------------------------------------------------------------------------
[
    uuid(5a257c4a-2eb3-4db7-83df-29f4a45b632c),
    version(1.0),
    pointer_default(unique)
]
interface IVsStatusbar3 : IUnknown
{
    /// <summary>
    /// Starts or stops a status bar animation.
    /// </summary>
    /// <param name="fOnOff">If true, starts the animation.  If false, stops the animation.</param>
    /// <param name="count">Number of Image Monikers for the animation.</param>
    /// <param name="monikers">An array of Image Monikers for the animation.</param>
    /// <returns>True if and only if the operation succeeded.</returns>
    HRESULT Animation2([in]VARIANT_BOOL  fOnOff,
        [in]int count,
        [in, size_is(count)]ImageMoniker * monikers,
        [out, retval] VARIANT_BOOL *succeeded
        );
}

// The CLSID for the BooleanSymbolExpressionEvaluator object, which implements 
//     IVsBooleanSymbolExpressionEvaluator {7C8306FC-AFBF-43FA-88FC-6FE4D7E16D74} and
//     IVsBooleanSymbolExpressionEvaluator2 {D02A169E-F096-48B0-9A1C-B6AC30FAE9AD}
// Call ILocalRegistry::CreateInstance to create an instance of this.
// Valid expression syntax is defined thus:
// The capability expression, such as "(VisualC | CSharp) + (MSTest | NUnit)".
// The '|' is the OR operator.
// The '&' and '+' characters are both AND operators.
// The '!' character is the NOT operator.
// Parentheses force evaluation precedence order.
// A null or empty expression is evaluated as a match.
// Project capabilities may be any character except these reserved characters:
// "'`:;,+-*/\!~|&%$@^()={}[]<>? \t\b\n\r
#ifndef PROXYSTUB_BUILD

[uuid(5DADF1EE-BCBE-46CE-BADF-271992C112A3)]
interface BooleanSymbolExpressionEvaluator : IUnknown
{
};

cpp_quote("#define CLSID_BooleanSymbolExpressionEvaluator IID_BooleanSymbolExpressionEvaluator")

#endif

//----------------------------------------------------------------------------
// IVsBooleanSymbolPresenceChecker
//----------------------------------------------------------------------------
// This interface provides a hit tester of boolean symbols used by
// IVsBooleanSymbolExpressionEvaluator2 when evaluating a boolean expression.
[uuid(416C706C-933E-4ACB-8D30-F02C28DD4874)]
interface IVsBooleanSymbolPresenceChecker : IUnknown
{
    // Checks whether the symbols defined may have changed since the last time
    // this method was called. Implementations that do not track versions may return true.
    HRESULT HasChangedSince(
        [in, unique, out] IUnknown **versionObject, // The response version object assigned at the last call.
                                                    // May be null to get the initial version.
                                                    // At the conclusion of this method call, the object
                                                    // or pointer may be changed so on a subsequent call
                                                    // we know what version was last observed.
                                                    // The caller should treat this value as an opaque object
                                                    // and should not assume any significance from whether the
                                                    // object pointer changed value or not.
        [out, retval] VARIANT_BOOL *hasChanged);    // Receives a value indicating whether the results may have
                                                    // changed since the last call to this method.

    // Checks for the presence of a given symbol.
    HRESULT IsSymbolPresent(
        [in] LPCOLESTR symbol,               // The symbol to check for
        [out, retval] VARIANT_BOOL* result); // true if the symbol is defined; false otherwise.
}

//----------------------------------------------------------------------------
// IVsBooleanSymbolPresenceBulkChecker
//----------------------------------------------------------------------------
// This interface provides a bulk hit tester of boolean symbols used by
// IVsBooleanSymbolExpressionEvaluator2 when evaluating a boolean expression.
[uuid(A37429BD-C5FE-4263-A8AD-D06D060B4632)]
interface IVsBooleanSymbolPresenceBulkChecker : IVsBooleanSymbolPresenceChecker
{
    // Checks for the presence of a collection of symbols.
    HRESULT AreSymbolsPresent(
        [in] SAFEARRAY(BSTR) symbols,                     // An array of symbols (BSTR) to check for.
        [out, retval] SAFEARRAY(VARIANT_BOOL) *results);  // Receives an array of equal length to symbols,
                                                          // where each element is set to true iff present.
}

//----------------------------------------------------------------------------
// IVsBooleanSymbolExpressionEvaluator2
//----------------------------------------------------------------------------
// This interface provides expression parsing and evaluation against a hit tester of boolean symbols
// in order to test whether a set of symbols cause the expression to evaluate to true.
// It is obtained by cocreating the BooleanSymbolExpressionEvaluator service GUID.
[uuid(D02A169E-F096-48B0-9A1C-B6AC30FAE9AD)]
interface IVsBooleanSymbolExpressionEvaluator2 : IUnknown
{
    HRESULT EvaluateExpression(
        [in, unique] LPCWSTR wszExpression,    // i.e. P1 & P2 & (!P3 | P4)   -- null and empty is allowed and results in a true return value.
        [in] IVsBooleanSymbolPresenceChecker * pSymbolChecker, // The object to check for presence of symbols encountered while parsing the expression. May NOT be null.
        [out, retval] VARIANT_BOOL* pfResult);
}

//----------------------------------------------------------------------------
// IVsStartupProjectsListService
//----------------------------------------------------------------------------
[uuid(DAEC2267-C961-44F3-96E2-3053E4EF550C)]
interface IVsStartupProjectsListService : IUnknown
{
    // Add the project specified by its GUID to the startup projects list
    HRESULT AddProject([in] REFGUID guidProject);

    // Removes the project specified by its GUID from the startup projects list
    HRESULT RemoveProject([in] REFGUID guidProject);
};

#ifndef PROXYSTUB_BUILD

// {C3DA54E0-794F-440C-8655-DA03CD0DD05E}
// Set when a Wizard begins loading and before it's open, and cleared once the Wizard completed (closed).
cpp_quote("extern const __declspec(selectany) GUID UICONTEXT_WizardOpen = { 0xc3da54e0, 0x794f, 0x440c, { 0x86, 0x55, 0xda, 0x3, 0xcd, 0xd, 0xd0, 0x5e } };")

//-----------------------------------------------------------------------------
// SVsStartupProjectsListService
// The service id for the IVsStartupProjectsListService service
//-----------------------------------------------------------------------------
[uuid(66B406DF-E206-47F6-A42B-CEE6B4201082)]
interface SVsStartupProjectsListService : IUnknown
{
}
cpp_quote("#define SID_SVsStartupProjectsListService IID_SVsStartupProjectsListService")

#endif

enum __VSHPROPID8
{
    // See previous version of vsshellXX.idl for previous enumeration values.

    VSHPROPID_SupportsIconMonikers = -2159,                 // VT_BOOL [optional] Gets whether or not the hierarchy supports icon monikers as an override of the VSHPROPID_IconImgList and VSHPROPID_IconHandle properties.  Aggregatable projects should only support this property if they're the outermost aggregate, even if they do support ImageMoniker-based images.
    VSHPROPID_IconMonikerGuid = -2160,                      // GUID [optional] Gets the Guid for an ImageMoniker associated with the item's icon
    VSHPROPID_IconMonikerId = -2161,                        // VT_I4 [optional] Gets the Id for an ImageMoniker associated with the item's icon
    VSHPROPID_OpenFolderIconMonikerGuid = -2162,            // GUID [optional] Gets the Guid for an ImageMoniker associated with the item's expanded icon
    VSHPROPID_OpenFolderIconMonikerId = -2163,              // VT_I4 [optional] Gets the Id for an ImageMoniker associated with the item's expanded icon
    VSHPROPID_IconMonikerImageList = -2164,                 // VT_UNKNOWN [optional] Gets the IVsImageMonikerImageList, which can be used to query for ImageMonikers for this item.

    VSHPROPID_SharedProjectReference = -2165,               // VT_UNKNOWN [optional] Returns an IVsSharedProjectReference object for a particular shared project reference item node.

    VSHPROPID_DiagHubPlatform = -2166,                      // BSTR [optional] Provides the Target Platform for the project type to the Diagnostics Hub. 
    // This is similar to VSHPROPID_TargetPlatformIdentifier but is Diagnostics Hub specific. Examples are 'Windows', 'Windows_Phone', 'XBox', 'iOS', 'Android'
    VSHPROPID_DiagHubPlatformVersion = -2167,               // BSTR [optional, required if VSHPROPID_DiagHubPlatform is provided] Provides the version of the target platform.
    // This is similar to VSHPROPID_TargetPlatformVersion but is Diagnostics Hub specific. This will be parsed as a .NET System.Version and should conform to its requirements
    VSHPROPID_DiagHubLanguage = -2168,                      // BSTR [optional, required if VSHPROPID_DiagHubPlatform is provided] Provides the language the project is 
    // targeting. Examples are 'CSharp', 'FSharp', 'VisualBasic', 'Cpp', 'CppCli', 'JavaScript', 'TypeScript'
    VSHPROPID_DiagHubProjectTargetFactory = -2169,          // BSTR [optional, required if VSHPROPID_DiagHubPlatform is provided] Provides the GUID for the target
    // factory within the Diagnostics Hub to use. The default value is '283ff32f-bc50-467c-a318-ee7015338ac0'
    VSHPROPID_DiagHubProjectTarget = -2170,                 // BSTR [optional, required if VSHPROPID_DiagHubPlatform is provided] Provides the GUID for the project
    // target within the specified VSHPROPID_DiagHubProjectTargetFactory.
    VSHPROPID_SolutionGuid = -2171,                         // GUID [optional] Reserved. Provides the Solution level ID. 

    VSHPROPID_ActiveIntellisenseProjectContext = -2172,     // BSTR [Optional] Gets/Sets the contextual intellisense project. It is used in shared scenarios where a single
                                                            // project is sharing files in more than one intellisense project.

    VSHPROPID_ProjectCapabilitiesChecker = -2173,           // VT_UNKNOWN [optional] Returns an IVsBooleanSymbolPresenceChecker, which can be passed to an
                                                            // instance of IVsBooleanSymbolExpressionEvaluator2 to evaluate project capabilities.
                                                            // This property obsoletes VSHPROPID_ProjectCapabilities and should be used when available.

    VSHPROPID_ContainsStartupTask = -2174,                  // VT_BOOL [optional] Gets whether or not the hierarchy contains StartupTasks.

    // !!!! NOTE !!!!   THIS MUST BE THE SAME AS THE LAST PROP DEFINED
    // when this is extended in the next version idl, uses of it must be changed to the new value
    VSHPROPID_FIRST8 = -2174
};

typedef[public] DWORD VSHPROPID8;

// this is an extension of VSSPROPID6, see vsshell120.idl, vsshell110.idl, vsshell100.idl, vsshell90.idl, vsshell80.idl, vsshell.idl
enum __VSSPROPID7
{
    VSSPROPID_SCCGlyphMonikerImageList = -9079,         // UNK, Read-Only.  The IVsImageMonikerImageList containing SCC state icon ImageMonikers.
    VSSPROPID_MainWindowInfoBarHost = -9080,            // UNK, Read-Only.  The IVsInfoBarHost for info bars hosted in the main window.
    VSSPROPID_UnlocalizedReleaseDescription = -9081,    // BSTR, Read-Only. What this release is branded as, e.g. CTP, Beta, RTM, etc. as an unlocalized string.
                                                        //                  If you need the localized version of this string, use the VSSPROPID_ReleaseDescription property.
    VSSPROPID_IsPrerelease = -9082,                     // BOOL, Read-Only. Indicates whether this is a pre-release version of Visual Studio
    VSSPROPID_FIRST7 = -9082
};
typedef LONG VSSPROPID7;

enum __VSFPROPID7
{
    // See previous version of vsshellXX.idl for previous enumeration values.

    VSFPROPID_InfoBarHost = -5033,                  // VT_UNKNOWN.  Gets the IVsInfoBarHost for the window frame, to which info bars can be added
                                                    // or removed.

    VSFPROPID_ToolboxUser = -5034,                   // IVsToolboxUser implementation attached to a window frame.
    // !!!! NOTE !!!!   THIS MUST BE THE SAME AS THE LAST PROP DEFINED
    // when this is extended in the next version idl, uses of it must be changed to the new value
    VSFPROPID7_FIRST = -5034,
};
typedef LONG VSFPROPID7;

enum __VSVPROPID2
{
    // See previous version of vsshellXX.idl for previous enumeration values.

    VSVPROPID_IconMonikerGuid = -6003,
    VSVPROPID_IconMonikerId = -6004,

    // !!!! NOTE !!!!   THIS MUST BE THE SAME AS THE LAST PROP DEFINED
    // when this is extended in the next version idl, uses of it must be changed to the new value
    VSVPROPID2_FIRST = -6004
};

typedef LONG VSVPROPID2;

enum __VSADDVPFLAGS3
{
    /********************************* defined in vsshell.idl

    ADDVP_AddToProjectWindow             = 0x00000001,
    ADDVP_ExcludeFromBuild               = 0x00000002,
    ADDVP_ExcludeFromDebugLaunch         = 0x00000004,
    ADDVP_ExcludeFromDeploy              = 0x00000008,
    ADDVP_ExcludeFromSCC                 = 0x00000010,
    ADDVP_ExcludeFromEnumOutputs         = 0x00000020,
    ADDVP_ExcludeFromCfgUI               = 0x00000040,

    *********************************/

    /********************************* defined in vsshell121.idl

    ADDVP_ReloadOnProjectFileChanged = 0x00000080,   // Enable Solution to watch for file changes to project file and reload on external change.

    *********************************/

    ADDVP_InvisibleInternalProject = 0x0000016E,    // Invisible project that never interferes with the user adding a project of the same name.
                                                    // Normally any newly added project has to have a unique name that does not clash with existing
                                                    // projects. ADDVP_InvisibleInternalProject projects are Virtual Projects that are either "place holder"
                                                    // projects which listen for SolutionEvents (e.g. OnBeforeProjectRegisteredInRunningDocumentTable 
                                                    // or OnAfterOpenProject) and auto remove themselves to not interfere with the user added project
                                                    // or they are non-traditional internal (e.g. files imported by projects only like MSBuild targets
                                                    // files, Shared.projitems files or VC .filters files) that are never opened as normal projects directly.
                                                    // NOTE: ADDVP_InvisibleInternalProject includes the following flags:
                                                    //     ADDVP_ExcludeFromBuild | ADDVP_ExcludeFromDeploy | ADDVP_ExcludeFromDebugLaunch | ADDVP_ExcludeFromEnumOutputs | ADDVP_ExcludeFromCfgUI
                                                    // and is not expected to be used in combination with ADDVP_AddToProjectWindow flag.
};
typedef DWORD VSADDVPFLAGSPRIVATE;

// Represents a span of text inside an IVsInfoBar.  Multiple spans of text can be concatenated together,
// much like in a rich text document.
[
    uuid(A513499A-A1D0-4C21-BDEE-16761BAFD930),
    version(1.0),
    pointer_default(unique)
]
interface IVsInfoBarTextSpan : IUnknown
{
    // the text for the span
    [propget] HRESULT Text([out, retval] BSTR* text);

    // formatting options for the text
    [propget] HRESULT Bold([out, retval] VARIANT_BOOL* bold);
    [propget] HRESULT Italic([out, retval] VARIANT_BOOL* italic);
    [propget] HRESULT Underline([out, retval] VARIANT_BOOL* underline);
}

// Represents a clickable action span inside an IVsInfoBar, rendered by default
// as a hyperlink.  Action items can have contextual data
// associated with them, and have a click callback on the IVsInfoBarUIEvents interface.
[
    uuid(25482DB2-7BBA-49DF-841B-55A01D067679),
    version(1.0),
    pointer_default(unique)
]
interface IVsInfoBarActionItem : IVsInfoBarTextSpan
{
    // Gets the user-provided context associated with the hyperlink.
    // This contextual data can be used to identify the hyperlink when it's clicked.
    [propget] HRESULT ActionContext([out, retval] VARIANT* context);

    // Gets whether or not this action item should be rendered as a button.
    // By default, action items are rendered as a hyperlink.
    [propget] HRESULT IsButton([out, retval] VARIANT_BOOL* isButton);
}

// Represents a document comprised of spans of text.
[
    uuid(186DD013-096E-4134-8DC2-A0861607DA50),
    version(1.0),
    pointer_default(unique)
]
interface IVsInfoBarTextSpanCollection : IUnknown
{
    // Gets the number of spans stored in the collection.
    [propget] HRESULT Count([out, retval] int* count);

    // Gets the span stored at a specific index in the collection.
    HRESULT GetSpan([in] int index, [out, retval] IVsInfoBarTextSpan** span);
}

// Represents a collection of action items
[
    uuid(A0E65F0E-DAEB-48B3-AA63-C274605B3EED),
    version(1.0),
    pointer_default(unique)
]
interface IVsInfoBarActionItemCollection : IUnknown
{
    // Gets the number of spans stored in the collection.
    [propget] HRESULT Count([out, retval] int* count);

    // Gets the span stored at a specific index in the collection.
    HRESULT GetItem([in] int index, [out, retval] IVsInfoBarActionItem** item);
}

// Represents the data needed to construct an IVsUIElement representing an info bar.
// Info bars can have an icon, a set of spans of text, and an optional close button.
[
    uuid(B8257FE8-9FF5-4F59-A613-02405B32A82A),
    version(1.0),
    pointer_default(unique)
]
interface IVsInfoBar : IUnknown
{
    // Gets the moniker for the image to display in the info bar
    [propget] HRESULT Image([out, retval] ImageMoniker* moniker);

    // Gets whether or not the InfoBar supports closing
    [propget] HRESULT IsCloseButtonVisible([out, retval] VARIANT_BOOL* closeButtonVisible);

    // Gets the collection of text spans displayed in the info bar.  Any
    // IVsInfoBarActionItem spans in this collection will be rendered as a hyperlink.
    [propget] HRESULT TextSpans([out, retval] IVsInfoBarTextSpanCollection** textSpans);

    // Gets the collection of action items displayed in the info bar
    [propget] HRESULT ActionItems([out, retval] IVsInfoBarActionItemCollection** actionItems);
}

interface IVsInfoBarUIElement;

// Event callback used for handling user gestures in an info bar.
[
    uuid(C115D9E6-DB96-42B1-AE1A-71A5E3835D53),
    version(1.0),
    pointer_default(unique)
]
interface IVsInfoBarUIEvents : IUnknown
{
    // Callback invoked when the close button on an info bar is clicked
    HRESULT OnClosed([in] IVsInfoBarUIElement* infoBarUIElement);

    // Callback invoked when an action item on an info bar is clicked
    HRESULT OnActionItemClicked([in] IVsInfoBarUIElement* infoBarUIElement, [in] IVsInfoBarActionItem* actionItem);
}

// Object representing an InfoBar UI element.  PreserveSig to derive from IVsUIElement,
// which is already PreserveSig.
[
    uuid(369C66D9-2A2B-49CF-9E17-83A1679475B6),
    version(1.0),
    pointer_default(unique),
    custom(uuid_VsPreserveSigAttribute, "preservesig")
]
interface IVsInfoBarUIElement : IVsUIElement
{
    // Requests that the InfoBar close itself by raising its OnClosed event.
    HRESULT Close();

    // Advises for UI events for the InfoBar
    HRESULT Advise([in] IVsInfoBarUIEvents* eventSink, [out] VSCOOKIE* cookie);

    // Unadvises from UI events for the InfOBar
    HRESULT Unadvise([in] VSCOOKIE cookie);
}

// Factory used to create a new info bar UI element from an input bar data source
[
    uuid(15C4AB06-6C7C-4ECB-85AB-FBC32801DA39),
    version(1.0),
    pointer_default(unique)
]
interface IVsInfoBarUIFactory : IUnknown
{
    // Creates a new info bar UI element
    HRESULT CreateInfoBar(
        [in] IVsInfoBar* infoBar,                       // The info bar's data
        [out, retval] IVsInfoBarUIElement** uiElement); // The UI element representing the info bar
}

// The service type implementing the IVsInfoBarUIFactory service
[uuid(8E223E35-68A4-4744-9140-C575682A66B4)]
interface SVsInfoBarUIFactory : IUnknown
{
}
cpp_quote("#define SID_SVsInfoBarUIFactory IID_SVsInfoBarUIFactory")

// A host control that knows how to lay out info bars.  For IVsWindowFrame, a host
// can be accessed via VSFPROPID_InfoBarHost.
[
    uuid(5580AE4B-C849-41F8-BC4C-FA7D8207F293),
    version(1.0),
    pointer_default(unique)
]
interface IVsInfoBarHost : IUnknown
{
    // Adds an info bar to be displayed by the info bar host.  Info bars are
    // displayed in the order in which they're added to the host.
    HRESULT AddInfoBar(
        [in] IVsUIElement* uiElement);  // the info bar to add

    // removes an info bar from the info bar host
    HRESULT RemoveInfoBar(
        [in] IVsUIElement* uiElement);  // the info bar to remove
}

[
    uuid(0461CF82-2583-4F9A-A1D6-7D61DE87B58B),
    version(1.0)
]
interface IVsWindowFrame5 : IUnknown
{
    // ImageMoniker property that allows you to set the icon of a WindowFrame. When using the 'get'
    // of this property, it will be return whatever this property was 'set' to directly. As there are other
    // ways to set the icon and this value can get overridden, if you want the ImageMoniker for the icon that is
    // actually being displayed on the frame, use DisplayedIconImageMoniker.
    [propget] HRESULT IconImageMoniker([out, retval] ImageMoniker* moniker);
    [propput] HRESULT IconImageMoniker([in] ImageMoniker moniker);

    // Readonly ImageMoniker property for the icon being displayed for the WindowFrame.
    [propget] HRESULT DisplayedIconImageMoniker([out, retval] ImageMoniker* moniker);
}

// Event sink used by IVsUIShell7.AdviseWindowFrameEvents
[
    uuid(15D6E42B-36AD-4AF9-A144-C6F07027A6ED),
    version(1.0),
    pointer_default(unique)
]
interface IVsWindowFrameEvents : IUnknown
{
    // Event called when a new IVsWindowFrame is created
    HRESULT OnFrameCreated([in] IVsWindowFrame* frame);

    // Event called when an IVsWindowFrame is permanently closed
    HRESULT OnFrameDestroyed([in] IVsWindowFrame* frame);

    // Event called when the IsVisible property of an IVsWindowFrame changes
    HRESULT OnFrameIsVisibleChanged([in] IVsWindowFrame* frame, [in] VARIANT_BOOL newIsVisible);

    // Event called when the IsOnScreen property of an IVsWindowFrame changes
    HRESULT OnFrameIsOnScreenChanged([in] IVsWindowFrame* frame, [in] VARIANT_BOOL newIsOnScreen);

    // Event called when the active IVsWindowFrame changes
    HRESULT OnActiveFrameChanged([in] IVsWindowFrame* oldFrame, [in] IVsWindowFrame* newFrame);
}

//----------------------------------------------------------------------------
// IVsDebugger5
//----------------------------------------------------------------------------
// Implemented by the Debugger, obtained via the SID_SVsShellDebugger service.
[
    uuid(uuid_IVsDebugger5),
    version(1.0),
    pointer_default(unique)
]
interface IVsDebugger5 : IUnknown
{
    // Indicate if the diagnostics tools should be bypassed in the next debugger session.
    HRESULT BypassDiagnosticsToolsOnNextSession([in] VARIANT_BOOL bypass);

    // Get a value indicating if the diagnostics tools should be bypassed in the next debugger session.
    HRESULT GetDiagnosticsToolsBypassState([retval, out] VARIANT_BOOL *willBypass);
}

[
    uuid(C5FFE6B0-C6E0-45A4-9FE2-DA5DEB84E59D),
    version(1.0),
    pointer_default(unique)
]
interface IVsUIShell7 : IUnknown
{
    // Called to advise for events affecting all IVsWindowFrames
    HRESULT AdviseWindowFrameEvents([in] IVsWindowFrameEvents* eventSink, [out, retval] VSCOOKIE* cookie);

    // Called to unadvise from events affecting all IVsWindowFrames
    HRESULT UnadviseWindowFrameEvents([in] VSCOOKIE cookie);
}

// enum __VSDBGLAUNCHFLAGS140 ADDED IN DEV14
// NOTE: USE OF THIS ENUM REQUIRES DEV14 OR ABOVE TO BE INSTALLED
enum __VSDBGLAUNCHFLAGS140
{
    /********************************************** defined in vsshell.idl
    DBGLAUNCH_Silent                = 0x00000001,
    DBGLAUNCH_LocalDeploy           = 0x00000002, // passed to IVsDebuggableProjectCfg::Launch to allow optimizations
    DBGLAUNCH_NoDebug               = 0x00000004, // launch without attaching a debugger
    DBGLAUNCH_DetachOnStop          = 0x00000008, // detach instead of terminate when debugging stopped.
    DBGLAUNCH_Selected              = 0x00000010, // launch selected project instead of startup project
    DBGLAUNCH_StopDebuggingOnEnd    = 0x00000020, // when this process ends, debugging is stopped.
    DBGLAUNCH_WaitForAttachComplete = 0x00000040, // when DLO_LaunchByWebServer, wait for the attach to finish before continuing to launch other targets
    **********************************************  defined in vsshell80.idl*/
    /*
    DBGLAUNCH_MergeEnv              = 0x00000080, // provided environment should be merged with system environment
    DBGLAUNCH_DesignTimeExprEval    = 0x00000100, // launched for design-time expression evaluation
    DBGLAUNCH_StopAtEntryPoint      = 0x00000200, // Stop at the entrypoint (step-into)
    DBGLAUNCH_CannotDebugAlone      = 0x00000400, // this process cannot be debugged alone -- stop debugging when only processes with this flag remain
    **********************************************/
    /********************************************** defined in vsshell90.idl
    DBGLAUNCH_WaitForEvent          = 0x00000800  // Debugger should wait for a named event to become signaled after launching the first debug target and before launching more targets
    **********************************************/
    /********************************************** defined in vsshell90.idl (SP1)
    DBGLAUNCH_UseDefaultBrowser     = 0x00001000  // Debugger should use the Default Web Browser; this flag used in conjunction with DLO_LaunchBrowser.
                                                  // The default browser is obtained via IVsUIShellOpenDocument:: GetFirstDefaultPreviewer().
                                                  // The bstrEXE in VsDebugTargetInfo2 points to the URL to be launched. Web Site projects will use
                                                  // this for Silverlight projects. This allows, for example, Firefox to be used which is single
                                                  // instance and so has to be handled differently on launch. Other project systems (e.g. C++) that
                                                  // currently use DLO_LaunchBrowser will continue to use that and IE will get launched as before.
    **********************************************/
    /********************************************* defined in vsshell100.idl (dev10)
    DBGLAUNCH_PrepForDebug          = 0x00002000, // We will eventually debug this process, so allow the debugger to perform additional setup
    DBGLAUNCH_TerminateOnStop       = 0x00004000, // Terminate the debuggee when debugging is stopped. It is an error to specify both this and DBGLAUNCH_DetachOnStop
    DBGLAUNCH_BreakOneProcess       = 0x00008000  // Disable 'Break all processes when one process breaks' debugger option for the debugging session; this option is ignoring if debugging has already started.
    
    DBGLAUNCH_BlockCredentialsDialog= 0x00010000, // Blocks the creditials dialog from being shown on authentication errors
    DBGLAUNCH_BlockWWSDialog        = 0x00020000, // Blocks the WWS install dialog from being shown
    DBGLAUNCH_StartInSimulator      = 0x00040000  // For DLO_AppPackageDebug, debugger should launch the application (or expect the application to start) in the simulator
    ********************************************** defined in vsshell110.idl (dev11)
    **********************************************/

    /********************************************* defined in vsshell100.idl (dev12)
    DBGLAUNCH_ALLOW_EVENTS_AFTER_STOPPED    = 0x00080000,  // Allows stopping events in break-mode
    DBGLAUNCH_FORCE_32BIT_DEBUG             = 0x00100000,  // Force use of the 32-bit debugger (currently used only for DLO_CreateProcess)
    DBGLAUNCH_FORCE_64BIT_DEBUG             = 0x00200000   // Force use of the 64-bit debugger (currently used only for DLO_CreateProcess)
    ********************************************** defined in vsshell110.idl (dev13)
    **********************************************/
    DBGLAUNCH_ContainsStartupTask           = 0x00400000,  // Use Startup Task activator (currently used only for DLO_AppPackageDebug)
    DBGLAUNCH_Profiling                     = 0x00800000   // Launch process for profiling
};
typedef DWORD VSDBGLAUNCHFLAGS140;

//----------------------------------------------------------------------------
// IVsToolsOptionsHelp
//----------------------------------------------------------------------------
[
    uuid(DDF4F502-C740-47B7-95CC-3FF4B765BA99),
    version(1.0),
    pointer_default(unique)
]
interface IVsToolsOptionsHelp : IUnknown
{
    // Called when F1 is invoked on a Tools/Options page
    HRESULT OnHelp();
}

// Message broadcast via IVsBroadcastMessageEvents::OnBroadcastMessage to indicate that the application is running
// low on available virtual memory. The wParam contains the available virtual memory in bytes. This message
// will be broadcast once per minute for as long as the low memory condition persists.
cpp_quote("#define VSM_VIRTUALMEMORYLOW          (WM_USER + 0x0C55)")

// Message broadcast via IVsBroadcastMessageEvents::OnBroadcastMessage to indicate that the application is running
// critically low on available virtual memory. The wParam contains the available virtual memory in bytes. This
// message will be broadcast once per minute for as long as the critical memory condition persists.
cpp_quote("#define VSM_VIRTUALMEMORYCRITICAL     (WM_USER + 0x0C56)")

// Message broadcast via IVsBroadcastMessageEvents::OnBroadcastMessage to indicate that a value for a Font or a
// Color in the Fonts and Colors page of the Tools->Options dialog has been changed.
cpp_quote("#define VSM_FONTORCOLORCHANGED     (WM_USER + 0x0C57)")

// The following interfaces are used by Roslyn's CodeModel to ensure their managed objects have COM STA semantics as well
// as classic QI semantics for interface transitions (not managed casting). In theory they are usable by any managed
// objects that want such functionality though their use is somewhat complicated.
[uuid(cbd71f2c-6bc5-4932-b851-b93eb3151386)]
interface IComWrapper : IUnknown
{
    [propget] HRESULT GCHandlePtr([out, retval] INT_PTR* pResult);
}

#ifndef PROXYSTUB_BUILD
// Factory class for creating COM wrappers around managed objects that have STA semantics.
[uuid(436b402a-a479-41a8-a093-9713ce3ad111)]
interface IComWrapperFactory : IUnknown
{
    HRESULT CreateAggregatedObject([in] IUnknown* managedObject, [out, retval] IUnknown** comWrapper);
}
#endif

//-----------------------------------------------------------------------------
// Enumerations for Settings Store
//-----------------------------------------------------------------------------

//-----------------------------------------------------------------------------
// Scope of the settings to retrieve from the IVsSettingsManager
// Note: Keep the values listed here synchronozed with the VSENCLOSINGSCOPES
// enumeration and keep them them bitwise exclusive.
// Note: This enumeration is being wrapped by the managed ones in MPF and Managed
// standalone library so update them as well whenever this enumeration changes.
//-----------------------------------------------------------------------------
enum __VsSettingsScope2
{           
    //SettingsScope_Configuration = 0x00000001,  // Read-only installation configuration scope             
    //SettingsScope_UserSettings  = 0x00000002,  // User settings scope
    SettingsScope_Remote  = 0x00000004,        // Settings from a remote store (aka Azure)
};
typedef DWORD VSSETTINGSSCOPE2;

//-----------------------------------------------------------------------------
// Returned as a result of querying the enclosed scopes that contain the provided
// property or collection.
// Note: This is a flagged enumeration meaning that more than one of those bits
// could be set as a result of the query.
// Note: This enumeration is being wrapped by the managed ones in MPF and Managed
// standalone library so update them as well whenever this enumeration changes.
//-----------------------------------------------------------------------------
enum __VsEnclosingScopes2
{       
    //EnclosingScopes_None =          0x00000000,                     // None of the valid scopes
    //EnclosingScopes_Configuration = SettingsScope_Configuration,    // Installation configuration scope
    //EnclosingScopes_UserSettings  = SettingsScope_UserSettings,     // User settings scope
    EnclosingScopes_Remote        = SettingsScope_Remote,           // Settings from a remote store (aka Azure)
};
typedef DWORD VSENCLOSINGSCOPES2;

//-----------------------------------------------------------------------------
// IVsOutputWindowPane3
//
// This interface is provided for the case where providers (e.g. build error provider) 
// want to write a text message associated with an identifier to output window
// so that later consumers (e.g. error list) can locate and navigate to that message based on the identifier.
// Note: A message identifier, which uniquely identifies a message text in output window, 
// is a combination of message provider GUID and a message ID.
// Note: Messages coming from the same provider cannot have same message ID.
// This is a collision condition and messages with duplicate message ID will not be sent to output window.
//-----------------------------------------------------------------------------
[
    uuid(D3D762D1-711A-4A4E-AF75-670F5160C38D),
    version(1.0),
    pointer_default(unique)
]
interface IVsOutputWindowPane3 : IUnknown
{
    // Called by client code to write a text message associated with a message identifier to the output window.
    // The combination of messageProvider and messageId must be unique.
    // Returns:
    //     S_OK         if succeeded.
    //     E_INVALIDARG if messageProvider is GUID_NULL or if the message identifier already exists and traces a message.
    //     Other failure HRESULTs if any other failures.
    HRESULT OutputStringWithId(
        [in] GUID messageProvider,              // The message provider GUID
        [in] DWORD messageId,                   // The message ID
        [in] LPCOLESTR message                  // The message text
        );

    // Called by client code to get the text message associated with the specified message identifier from the output window.
    // messageProvider and messageId combined together must uniquely identify a message.
    // Returns:
    //     S_OK         if succeeded or if a matching message does not exist (succeeded will differentiate these two cases).
    //     E_INVALIDARG if messageProvider is GUID_NULL.
    //     Other failure HRESULTs if any other failures.
    HRESULT TryGetStringWithId(
        [in] GUID messageProvider,              // The message provider GUID
        [in] DWORD messageId,                   // The message ID
        [out] BSTR *message,                    // The retrieved message text associated with the identifier.
                                                // NULL if a matching message does not exist (succeeded will be False as well in this case).
        [out, retval] VARIANT_BOOL *succeeded   // Indicates whether this call succeeded to get a valid message text
                                                // False if a matching message does not exist; True if otherwise successful.
        );

    // Called by client code to navigate to the text message associated with the specified message identifier in the output window.
    // If a navigation succeeded, the associated message in output pane will be selected and the caret in the pane will be moved to the beginning of the first line of the message.
    // messageProvider and messageId combined together must uniquely identify a message.
    // Returns:
    //     S_OK         if succeeded or if a matching message does not exist (succeeded will differentiate these two cases).
    //     E_INVALIDARG if messageProvider is GUID_NULL.
    //     Other failure HRESULTs if any other failures.
    HRESULT TryNavigateToMessageId(
        [in] GUID messageProvider,              // The message provider GUID.
        [in] DWORD messageId,                   // The message ID.
        [in] VARIANT_BOOL ensureVisible,        // Whether or not to ensure the output pane is visible.
        [in] VARIANT_BOOL ensureFocused,        // Whether or not to ensure the output pane is focused.
        [out, retval] VARIANT_BOOL *succeeded   // Indicates whether this call succeeded to navigate to the associated message in output pane.
                                                // False if a matching message does not exist; True if otherwise successful.
        );
}
