/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    VSDebugEng.h

Abstract:

    Master include file for extending the Visual Studio Debugger Engine
    (debugger back end).

--*/

#ifndef _INC_VSDEBUGENG_
#define _INC_VSDEBUGENG_

#if defined (_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

#ifndef __cplusplus
    #error This file requires C++ compilation (use a .cpp suffix)
#endif

#if defined(_MANAGED) || defined(__cplusplus_cli)
    #error This file should not be included in code compiled with /clr. Reference the managed assembly instead.
#endif

#ifndef VSDEBUGENG_NO_WINDOWS
    #include <windows.h>
    #include <ole2.h>
#endif

// By default, vsdebugeng.h defines helpers to make the API easier to use with the ATL.
// To disable these helpers, define VSDEBUGENG_NO_ATL prior to including this header file
#ifndef VSDEBUGENG_NO_ATL
    #include <atlbase.h>
    #include <atlstr.h>
#endif

// vsdebugeng.h defines helpers to make the API easier to use with the STL. However, these
// helpers are NOT included by default. To include these helpers, define VSDEBUGENG_USE_STL.
#ifdef VSDEBUGENG_USE_STL
    #include <string>
#endif

// For source compatibility, by default, we will not use C++ 11 scoped enums (enum class <identifier>),
// but 'VSDEBUGENG_USE_CPP11_SCOPED_ENUMS' can be enabled to use these
#if defined(VSDEBUGENG_USE_CPP11_SCOPED_ENUMS) || !defined(_MSC_VER)
#define FORWARD_DECLARE_SCOPED_ENUM(enum_name) enum class enum_name; typedef enum_name enum_name##_t
#define DEFINE_SCOPED_ENUM(enum_name) enum class enum_name
#define DEFINE_SCOPED_ENUM_FLAG_OPERATORS(enum_name) DEFINE_ENUM_FLAG_OPERATORS(enum_name) \
    inline bool operator==(enum_name value, std::nullptr_t zero) { return value == (enum_name)0; } \
    inline bool operator!=(enum_name value, std::nullptr_t zero) { return value != (enum_name)0; }
#else
#define FORWARD_DECLARE_SCOPED_ENUM(enum_name) struct enum_name { enum e; }; typedef enum_name::e enum_name##_t
#define DEFINE_SCOPED_ENUM(enum_name) enum enum_name::e
#define DEFINE_SCOPED_ENUM_FLAG_OPERATORS(enum_name) DEFINE_ENUM_FLAG_OPERATORS(enum_name)
#endif

#pragma pack(push, 8)
#pragma warning(push)
#pragma warning(disable:4324) // Disable 'structure was padded due to __declspec(align())' warning
#pragma warning(disable:4100) // Disable 'unreferenced formal parameter'

interface ICorDebugAppDomain;
interface ICorDebugThread;
interface ICorDebugProcess;
interface ICorDebugModule;
interface ICorDebugFunction;
interface ICorDebugEval;
interface IRemoteDebugApplication;
interface IServiceProvider;
#ifndef _MSC_VER
enum CV_HREG_e : unsigned int;
enum enum_TASKLOAD_FLAGS : unsigned int;
enum enum_TASKSTATE_TYPE : unsigned int;
enum enum_TASKPROPERTIES_FIELDS : unsigned int;
enum enum_TASKPROPERTIES_FLAGS : unsigned int;
enum _MINIDUMP_TYPE : unsigned int;
typedef _MINIDUMP_TYPE MINIDUMP_TYPE;
#else
// MSVC++ automatically gives a type for forward declared enums.  We can't use the above code because the idl files that
// define these enums don't understand the enum type syntax.
enum CV_HREG_e;
enum enum_TASKLOAD_FLAGS;
enum enum_TASKSTATE_TYPE;
enum enum_TASKPROPERTIES_FIELDS;
enum enum_TASKPROPERTIES_FLAGS;
typedef enum _MINIDUMP_TYPE MINIDUMP_TYPE;
#endif

#include <cor.h>
#include <cordebug.h>



namespace Microsoft { namespace VisualStudio { namespace Debugger {



// Forward definitions

FORWARD_DECLARE_SCOPED_ENUM(DkmApiVersion);
FORWARD_DECLARE_SCOPED_ENUM(DkmAsyncBreakStatus);
class DkmCustomMessage;
FORWARD_DECLARE_SCOPED_ENUM(DkmDataCreationDisposition);
FORWARD_DECLARE_SCOPED_ENUM(DkmDispatcherObjectFlags);
struct DkmDisplayUserMessagePromptAsyncResult;
FORWARD_DECLARE_SCOPED_ENUM(DkmDumpType);
FORWARD_DECLARE_SCOPED_ENUM(DkmEngineFlags);
class DkmEngineSettings;
FORWARD_DECLARE_SCOPED_ENUM(DkmEventCode);
class DkmEventDescriptor;
class DkmEventDescriptorS;
FORWARD_DECLARE_SCOPED_ENUM(DkmFuncEvalMode);
struct DkmGetCurrentCPUAddressAsyncResult;
struct DkmGetInstructionAddressAsyncResult;
class DkmInstructionAddress;
class DkmLanguageRegistrySetting;
FORWARD_DECLARE_SCOPED_ENUM(DkmModuleFlags);
class DkmModuleInstance;
FORWARD_DECLARE_SCOPED_ENUM(DkmModuleMemoryLayout);
class DkmModuleVersion;
class DkmPerformanceCounters;
struct DkmPerformanceCountersAsyncResult;
class DkmProcess;
class DkmProcessExecutionCounters;
FORWARD_DECLARE_SCOPED_ENUM(DkmReadMemoryFlags);
class DkmRegistryTweak;
struct DkmResolveCPUInstructionAddressAsyncResult;
FORWARD_DECLARE_SCOPED_ENUM(DkmRuntimeCapabilities);
class DkmRuntimeInstance;
struct DkmRuntimeInstanceId;
struct DkmSendLowerAsyncResult;
FORWARD_DECLARE_SCOPED_ENUM(DkmStoppingEventProcessingNextAction);
class DkmThread;
class DkmUnknownInstructionAddress;
class DkmUserMessage;
FORWARD_DECLARE_SCOPED_ENUM(DkmUserMessageOutputKind);

// Contains types related to expression evaluation.
namespace Evaluation {
    class DkmChildVisualizedExpression;
    FORWARD_DECLARE_SCOPED_ENUM(DkmClrCustomVisualizerAssemblyLocation);
    FORWARD_DECLARE_SCOPED_ENUM(DkmClrValueFlags);
    struct DkmCompileDisplayAttributeInternalAsyncResult;
    class DkmCompiledCustomInspectionQuery;
    class DkmCompiledInspectionQuery;
    class DkmCompiledVisualizationData;
    FORWARD_DECLARE_SCOPED_ENUM(DkmCompiledVisualizationDataPriority);
    struct DkmCompilerId;
    class DkmCustomDataContainer;
    class DkmCustomRawReturnValue;
    class DkmCustomUIVisualizerInfo;
    class DkmDataAddress;
    struct DkmEvaluateExpressionAsyncResult;
    struct DkmEvaluateReturnValueAsyncResult;
    struct DkmEvaluateReturnValueAsyncResult2;
    struct DkmEvaluationEnumAsyncResult;
    FORWARD_DECLARE_SCOPED_ENUM(DkmEvaluationFlags);
    class DkmEvaluationResult;
    FORWARD_DECLARE_SCOPED_ENUM(DkmEvaluationResultAccessType);
    FORWARD_DECLARE_SCOPED_ENUM(DkmEvaluationResultCategory);
    class DkmEvaluationResultEnumContext;
    FORWARD_DECLARE_SCOPED_ENUM(DkmEvaluationResultFlags);
    FORWARD_DECLARE_SCOPED_ENUM(DkmEvaluationResultStorageType);
    FORWARD_DECLARE_SCOPED_ENUM(DkmEvaluationResultTypeModifierFlags);
    struct DkmExecuteQueryAsyncResult;
    class DkmExpressionValueHome;
    class DkmFailedEvaluationResult;
    class DkmFakeValueHome;
    FORWARD_DECLARE_SCOPED_ENUM(DkmFuncEvalFlags);
    struct DkmGetChildrenAsyncResult;
    struct DkmGetFrameArgumentsAsyncResult;
    struct DkmGetFrameLocalsAsyncResult;
    struct DkmGetFrameNameAsyncResult;
    struct DkmGetFrameReturnTypeAsyncResult;
    struct DkmGetLanguageSettingsAsyncResult;
    class DkmILContext;
    class DkmInspectionContext;
    class DkmInspectionSession;
    class DkmIntermediateEvaluationResult;
    class DkmLanguage;
    class DkmLanguageExpression;
    class DkmLanguageInstructionAddress;
    class DkmNativeRawReturnValue;
    class DkmNativeReturnValueRegister;
    class DkmPointerValueHome;
    class DkmRawManagedReturnValue;
    class DkmRawReturnValue;
    class DkmRawReturnValueContainer;
    class DkmRootVisualizedExpression;
    FORWARD_DECLARE_SCOPED_ENUM(DkmRootVisualizedExpressionFlags);
    class DkmSuccessEvaluationResult;
    FORWARD_DECLARE_SCOPED_ENUM(DkmVariableInfoFlags);
    class DkmVisualizedExpression;
};

// Contains types used for evaluating expressions that are compiled into MSIL.
namespace Evaluation { namespace ClrCompilation {
    FORWARD_DECLARE_SCOPED_ENUM(DkmClrCompilationResultFlags);
    class DkmClrCustomTypeInfo;
    class DkmClrDebuggerBrowsableAttribute;
    FORWARD_DECLARE_SCOPED_ENUM(DkmClrDebuggerBrowsableAttributeState);
    class DkmClrDebuggerDisplayAttribute;
    class DkmClrDebuggerTypeProxyAttribute;
    class DkmClrDebuggerVisualizerAttribute;
    class DkmClrEvalAttribute;
    class DkmClrLocalVariableInfo;
    class DkmClrValue;
    class DkmCompiledClrInspectionQuery;
    class DkmCompiledClrLocalsQuery;
    struct DkmEvaluateDebuggerDisplayStringAsyncResult;
    struct DkmEvaluationAsyncResult;
    struct DkmExecuteClrInspectionQueryAsyncResult;
    struct DkmGetLocalValuesAsyncResult;
};};

// Contains the types used in the debugger's intermediate language (IL).
namespace Evaluation { namespace IL {
    class DkmCompiledILInspectionQuery;
    class DkmILAdd;
    class DkmILAmpAdjustBufferTag;
    class DkmILBeginTry;
    class DkmILBitAnd;
    class DkmILBitFieldRead;
    class DkmILBitFieldReadFromBytes;
    class DkmILBitFieldWrite;
    class DkmILBitFieldWriteToBytes;
    class DkmILBitNot;
    class DkmILBitOr;
    class DkmILBitShiftLeft;
    class DkmILBitShiftRight;
    class DkmILBitXor;
    FORWARD_DECLARE_SCOPED_ENUM(DkmILCallingConvention);
    class DkmILCatchBlock;
    class DkmILCheckTimeout;
    class DkmILCompareEqual;
    class DkmILCompareGreaterThan;
    class DkmILCompareGreaterThanOrEqual;
    class DkmILCompareLessThan;
    class DkmILCompareLessThanOrEqual;
    class DkmILCompareNotEqual;
    class DkmILConvert;
    class DkmILDivide;
    class DkmILDuplicateTop;
    class DkmILEndTry;
    class DkmILEvaluationResult;
    class DkmILExecuteFunction;
    class DkmILExecuteIntrinsic;
    class DkmILExtractBytes;
    class DkmILExtractBytesPopArguments;
    FORWARD_DECLARE_SCOPED_ENUM(DkmILFailureReason);
    FORWARD_DECLARE_SCOPED_ENUM(DkmILFunctionEvaluationArgumentFlags);
    FORWARD_DECLARE_SCOPED_ENUM(DkmILFunctionEvaluationFlags);
    class DkmILHlslBufferRead;
    class DkmILHlslGetGroupId;
    class DkmILHlslGetThreadId;
    class DkmILHlslIndexedRegisterRead;
    class DkmILHlslRegisterRead;
    class DkmILInstruction;
    class DkmILIsFalse;
    class DkmILIsTrue;
    class DkmILJump;
    class DkmILJumpIfFalse;
    class DkmILJumpIfTrue;
    class DkmILLoad;
    class DkmILMemoryRead;
    class DkmILMemoryStringRead;
    class DkmILMemoryWrite;
    class DkmILMultiply;
    class DkmILNop;
    class DkmILParameterValue;
    class DkmILPop;
    class DkmILPushConstant;
    class DkmILPushLocalVariablePseudoAddress;
    class DkmILRegisterRead;
    class DkmILRegisterWrite;
    class DkmILRemainder;
    class DkmILReturnTop;
    class DkmILSave;
    class DkmILSetBytesRegion;
    class DkmILSubtract;
    class DkmILThrow;
    class DkmILTlsGetValue;
    FORWARD_DECLARE_SCOPED_ENUM(DkmPrimitiveObjectType);
};};

// Contains the types used to evaluation the same expression across multiple threads.
namespace Evaluation { namespace Group {
    class DkmContextGroupEvaluationILResult;
    class DkmContextGroupEvaluationResult;
    struct DkmEvaluateExpressionOnThreadsAsyncResult;
    struct DkmExecuteQueryOnThreadsAsyncResult;
    class DkmFailedContextGroupEvaluationResult;
    class DkmILParameterValueCollection;
    class DkmSuccessContextGroupEvaluationResult;
    class DkmThreadEvaluationResultCollection;
};};

// Contains the types used for dealing with symbolic information in the debugger. This
// includes all types related to handling documents and text ranges. This namespace
// contains only the runtime environment agnostic types, with additional types found in
// the 'Native', 'Clr', 'Script' and 'CustomRuntimes' namespaces.
namespace Symbols {
    struct DkmCodeViewCompilerId;
    class DkmCustomSymbolFileId;
    FORWARD_DECLARE_SCOPED_ENUM(DkmDocumentMatchStrength);
    class DkmDynamicSymbolFileId;
    class DkmEngineSymbolSettings;
    struct DkmFindDocumentsAsyncResult;
    struct DkmFindSymbolsAsyncResult;
    struct DkmGetFunctionInfoAsyncResult;
    struct DkmGetMethodSymbolStoreDataAsyncResult;
    struct DkmGetMethodSymbolStoreDataPreRemapAsyncResult;
    struct DkmGetSourcePositionAsyncResult;
    struct DkmGetSourcePositionCallbackAsyncResult;
    struct DkmGetTokenSymbolStoreAttributeAsyncResult;
    struct DkmGetUserCodeSourcePositionCallbackAsyncResult;
    struct DkmHasLineInfoAsyncResult;
    struct DkmImageDebugDirectoryFormat;
    class DkmInstructionSymbol;
    struct DkmIsHiddenCodeAsyncResult;
    struct DkmIsUserCodeAsyncResult;
    struct DkmMD5HashValue;
    class DkmModule;
    struct DkmModuleId;
    class DkmPdbFileId;
    struct DkmRVASizePair;
    class DkmResolvedDocument;
    FORWARD_DECLARE_SCOPED_ENUM(DkmResolvedDocumentWarning);
    class DkmResolvedMappedDocument;
    struct DkmSHA1HashValue;
    class DkmSourceFileId;
    class DkmSourcePosition;
    FORWARD_DECLARE_SCOPED_ENUM(DkmSourcePositionFlags);
    struct DkmSteppingRange;
    FORWARD_DECLARE_SCOPED_ENUM(DkmSteppingRangeBoundary);
    class DkmSymbolFileId;
    struct DkmTextSpan;
};

// Contains types used for resolving function names to instruction addresses/symbols such
// as for setting function breakpoints.
namespace FunctionResolution {
    FORWARD_DECLARE_SCOPED_ENUM(DkmAddressSearchFlags);
    struct DkmOnFunctionResolvedAsyncResult;
    struct DkmOnResolverMessageAsyncResult;
    class DkmRuntimeFunctionResolutionRequest;
    class DkmSymbolFunctionResolutionRequest;
};

// Contains the types used for call stack walking and call stack frame formatting. This
// also includes types related to processor registers, as registers are tracked per-stack
// frame.
namespace CallStack {
    class DkmArmFrameRegisters;
    class DkmAsyncStackWalkContext;
    FORWARD_DECLARE_SCOPED_ENUM(DkmCallStackFilterOptions);
    struct DkmFrameFormatOptions;
    FORWARD_DECLARE_SCOPED_ENUM(DkmFrameNameFormatOptions);
    class DkmFrameRegisters;
    struct DkmGetAsyncCallStackAsyncResult;
    struct DkmGetClrGenericParametersAsyncResult;
    struct DkmGetContinuationFramesFromTaskObjectAsyncResult;
    struct DkmGetCurrentLocationAsyncResult;
    struct DkmGetManagedTaskContinuationFramesAsyncResult;
    struct DkmGetNextFramesAsyncResult;
    struct DkmGetTaskContinuationFramesAsyncResult;
    struct DkmGetTaskCreationStackAsyncResult;
    struct DkmHeuristicWalkFramesAsyncResult;
    class DkmMonitorStackWalkContext;
    struct DkmMonitorStackWalkResult;
    struct DkmRuntimeWalkNextFramesAndCheckCacheAsyncResult;
    struct DkmRuntimeWalkNextFramesAsyncResult;
    class DkmStackContext;
    class DkmStackFrame;
    class DkmStackHash;
    struct DkmStackMemoryRange;
    class DkmStackTraceContext;
    class DkmStackWalkContext;
    class DkmStackWalkFrame;
    class DkmStackWalkFrameAnnotation;
    class DkmStackWalkFrameData;
    FORWARD_DECLARE_SCOPED_ENUM(DkmStackWalkFrameFlags);
    FORWARD_DECLARE_SCOPED_ENUM(DkmStackWalkOperation);
    FORWARD_DECLARE_SCOPED_ENUM(DkmStackWalkStatus);
    class DkmSymbolStackWalkContext;
    class DkmUnwoundRegister;
    class DkmX64FrameRegisters;
    class DkmX86FrameRegisters;
};

// Contains types related to processing exceptions coming from the target process. This
// includes both setting triggers to be notified when specific exceptions are raised as
// well as describing exceptions coming out of the target. This namespace contains only
// the runtime environment agnostic types, with additional types found in the 'Native',
// 'Clr', 'Script' and 'CustomRuntimes' namespaces.
namespace Exceptions {
    struct DkmAddExceptionTriggerAsyncResult;
    class DkmExceptionCategoryTrigger;
    class DkmExceptionCodeTrigger;
    class DkmExceptionGlobalTrigger;
    class DkmExceptionInformation;
    FORWARD_DECLARE_SCOPED_ENUM(DkmExceptionInterceptActionFlags);
    class DkmExceptionNameTrigger;
    FORWARD_DECLARE_SCOPED_ENUM(DkmExceptionProcessingStage);
    class DkmExceptionTrigger;
    class DkmExceptionTriggerHit;
    struct DkmRemoveExceptionTriggerAsyncResult;
    class DkmStowedExceptionInformation;
    FORWARD_DECLARE_SCOPED_ENUM(DkmStowedExceptionNestedType);
};

// Contains the types related to setting breakpoints. This includes both the high-level
// breakpoint classes (DkmPendingBreakpoint, etc) that offer the same capabilities as
// user-set breakpoints, as well as the lower-level DkmRuntimeBreakpoint classes that the
// high-level breakpoints are implemented upon.
namespace Breakpoints {
    class DkmBoundBreakpoint;
    class DkmBreakpointCondition;
    FORWARD_DECLARE_SCOPED_ENUM(DkmBreakpointConditionOperator);
    class DkmBreakpointFileUpdateNotification;
    class DkmBreakpointHitCountCondition;
    FORWARD_DECLARE_SCOPED_ENUM(DkmBreakpointHitCountConditionOperator);
    FORWARD_DECLARE_SCOPED_ENUM(DkmBreakpointMessageLevel);
    FORWARD_DECLARE_SCOPED_ENUM(DkmBreakpointUnboundReason);
    struct DkmClearRuntimeBreakpointConditionsAsyncResult;
    struct DkmClearRuntimeBreakpointHitCountConditionAsyncResult;
    FORWARD_DECLARE_SCOPED_ENUM(DkmDataAccessStopMask);
    struct DkmDisableBoundBreakpointAsyncResult;
    struct DkmDisablePendingBreakpointAsyncResult;
    struct DkmDisableRuntimeBreakpointAsyncResult;
    struct DkmEnableBoundBreakpointAsyncResult;
    struct DkmEnablePendingBreakpointAsyncResult;
    struct DkmEnableRuntimeBreakpointAsyncResult;
    struct DkmEnrollPendingBreakpointAsyncResult;
    struct DkmEvaluateConditionAndSelectThreadAsyncResult;
    class DkmEvaluationBreakpointCondition;
    struct DkmGetBoundBreakpointHitCountValueAsyncResult;
    struct DkmGetRuntimeBreakpointHitCountConditionAsyncResult;
    class DkmPendingAddressBreakpoint;
    class DkmPendingAddressNameBreakpoint;
    class DkmPendingBreakpoint;
    class DkmPendingDataBreakpoint;
    class DkmPendingFileLineBreakpoint;
    class DkmPendingFunctionBreakpoint;
    struct DkmRequestBreakpointEventOnModifiedThreadAsyncResult;
    class DkmRuntimeBreakpoint;
    class DkmRuntimeHardwareDataBreakpoint;
    class DkmRuntimeInstructionBreakpoint;
    struct DkmSetCompiledConditionAsyncResult;
    struct DkmSetCompiledConditionPendingAsyncResult;
    struct DkmSetEvaluationConditionAsyncResult;
    struct DkmSetPendingBreakpointConditionAsyncResult;
    struct DkmSetPendingBreakpointHitCountConditionAsyncResult;
    struct DkmSetRuntimeBreakpointHitCountConditionAsyncResult;
    struct DkmTestRuntimeBreakpointAsyncResult;
    struct DkmTryClearConditionOnTargetDeviceAsyncResult;
    struct DkmTryPushConditionToTargetDeviceAsyncResult;
};

// Contains the types used to implement setting in the debugger.
namespace Stepping {
    FORWARD_DECLARE_SCOPED_ENUM(DkmLanguageStepIntoFlags);
    class DkmNativeSteppingCallSite;
    class DkmSingleStepRequest;
    FORWARD_DECLARE_SCOPED_ENUM(DkmStepArbitrationReason);
    FORWARD_DECLARE_SCOPED_ENUM(DkmStepKind);
    FORWARD_DECLARE_SCOPED_ENUM(DkmStepUnit);
    class DkmStepper;
    class DkmSteppingCodePath;
    class DkmSteppingCodePathSource;
};

// Contains types for start debugging and launching processes.
namespace Start {
    struct DkmActivateAppPackageAsyncResult;
    class DkmDebugLaunchSettings;
    class DkmDebugProcessRequest;
    struct DkmDebugProcessRequestAsyncResult;
    FORWARD_DECLARE_SCOPED_ENUM(DkmDebugProcessRequestFlags);
    struct DkmLaunchedProcessInfo;
    class DkmLoadCompleteEventDeferral;
    class DkmProcessAttachRequest;
    class DkmProcessLaunchEnvironmentFilterInputData;
    FORWARD_DECLARE_SCOPED_ENUM(DkmProcessLaunchEnvironmentFilterScenario);
    FORWARD_DECLARE_SCOPED_ENUM(DkmProcessLaunchFlags);
    FORWARD_DECLARE_SCOPED_ENUM(DkmProcessLaunchModeFlags);
    class DkmProcessLaunchRequest;
    class DkmProcessStartupInfo;
    FORWARD_DECLARE_SCOPED_ENUM(DkmStartMethod);
};

// Contains types used to perform the basic, generally pre-debugging, tasks on the target
// computer such as listing processes, deploying files, etc.
namespace DefaultPort {
    struct DkmActivateBackgroundTaskAsyncResult;
    class DkmAppPackageId;
    class DkmDeploymentCommand;
    FORWARD_DECLARE_SCOPED_ENUM(DkmDeploymentCommandFlags);
    class DkmDeviceInfo;
    struct DkmDownloadFileAsyncResult;
    struct DkmEnumerateBackgroundTasksAsyncResult;
    class DkmFileInfo;
    class DkmFileTransferStream;
    class DkmInstalledAppPackageInfo;
    class DkmInstalledApplicationInfo;
    FORWARD_DECLARE_SCOPED_ENUM(DkmPackageExecutionState);
    FORWARD_DECLARE_SCOPED_ENUM(DkmPackagedAppPlatform);
    FORWARD_DECLARE_SCOPED_ENUM(DkmProcessorFeatures);
    class DkmPublishedProgramInfo;
    FORWARD_DECLARE_SCOPED_ENUM(DkmRemoteAuthenticationMode);
    FORWARD_DECLARE_SCOPED_ENUM(DkmRunningProcessFlags);
    class DkmRunningProcessInfo;
    FORWARD_DECLARE_SCOPED_ENUM(DkmRunningProcessInfoPropertyMask);
    struct DkmShutDownAppPackageAsyncResult;
    class DkmStandardRemoteTransportConnection;
    struct DkmSuspendAppPackageAsyncResult;
    class DkmSystemInformation;
    FORWARD_DECLARE_SCOPED_ENUM(DkmSystemInformationFlags);
    class DkmTransportConnection;
    FORWARD_DECLARE_SCOPED_ENUM(DkmTransportConnectionFlags);
};

// Contains types specific to debugging code running under the Common Language Runtime
// (CLR).
namespace Clr {
    class DkmClrAlias;
    FORWARD_DECLARE_SCOPED_ENUM(DkmClrAliasKind);
    class DkmClrAppDomain;
    FORWARD_DECLARE_SCOPED_ENUM(DkmClrAsyncMethodLocation);
    struct DkmClrAwaitExpressionInfo;
    class DkmClrCaughtExceptionInformation;
    FORWARD_DECLARE_SCOPED_ENUM(DkmClrDebuggingServicesId);
    class DkmClrExceptionInformation;
    FORWARD_DECLARE_SCOPED_ENUM(DkmClrHeaderStatus);
    class DkmClrInstructionAddress;
    class DkmClrInstructionSymbol;
    class DkmClrLocalConstant;
    class DkmClrLocalVariable;
    struct DkmClrMethodId;
    struct DkmClrMethodScopeData;
    FORWARD_DECLARE_SCOPED_ENUM(DkmClrModuleFlags);
    class DkmClrModuleInstance;
    struct DkmClrNativeCodeMapEntry;
    class DkmClrRuntimeInstance;
    class DkmClrType;
    struct DkmGetAllAwaitExpressionInfoForStatementAsyncResult;
    struct DkmGetAsyncKickoffMethodAsyncResult;
    struct DkmGetAsyncMethodLocationAsyncResult;
    struct DkmGetMethodLocalSymbolsAsyncResult;
    struct DkmGetMethodSymbolStoreAttributeAsyncResult;
    struct DkmGetMethodTokensAsyncResult;
    struct DkmGetNextAwaitExpressionInfoAsyncResult;
    FORWARD_DECLARE_SCOPED_ENUM(DkmILInterpreterOptions);
    class DkmILInterpreterPrimitiveValue;
    class DkmILInterpreterReferenceValue;
    class DkmILInterpreterValue;
    struct DkmILRange;
    struct DkmManagedHeapObjectInfo;
    struct DkmManagedHeapRootInfo;
    class DkmManagedHeapSampler;
    struct DkmManagedHeapSegmentInfo;
    struct DkmManagedHeapTypeInfo;
    class DkmManagedHeapWalker;
    struct DkmManagedObjectReferenceInfo;
    class DkmManagedReturnStackFrame;
    class DkmManagedReturnValueContext;
    class DkmManagedReturnValueCopy;
    class DkmManagedReturnValueInfo;
    class DkmManagedReturnValueReference;
    struct DkmManagedTypeId;
    FORWARD_DECLARE_SCOPED_ENUM(DkmMetadataStatus);
    FORWARD_DECLARE_SCOPED_ENUM(DkmNonUserCodeFlags);
};

// Contains types specific to debugging code running under the native-compiled CLR.
namespace Clr { namespace NativeCompilation {
    class DkmClrNcContainerModuleInstance;
    class DkmClrNcInstanceFieldSymbol;
    class DkmClrNcInstructionAddress;
    class DkmClrNcInstructionSymbol;
    class DkmClrNcModuleInstance;
    class DkmClrNcRuntimeInstance;
    struct DkmCreateInstructionAddressFromRvaAsyncResult;
    struct DkmCreateInstructionAddressesFromILAddressAsyncResult;
};};

// Contains types specific to debugging native code.
namespace Native {
    class DkmCppExceptionInformation;
    class DkmCppWinRTExceptionInformation;
    struct DkmFindExportNameAsyncResult;
    struct DkmFindNearestExportAsyncResult;
    class DkmNativeAddressMetadata;
    FORWARD_DECLARE_SCOPED_ENUM(DkmNativeAddressStepType);
    FORWARD_DECLARE_SCOPED_ENUM(DkmNativeAddressType);
    class DkmNativeInstructionAddress;
    class DkmNativeInstructionSymbol;
    class DkmNativeModuleInstance;
    class DkmNativeRuntimeInstance;
    class DkmWin32ExceptionInformation;
};

// Contains types specific to debugging script code.
namespace Script {
    struct DkmOnScriptCriticalErrorAsyncResult;
    class DkmScriptBlockMappingInfo;
    class DkmScriptDocument;
    FORWARD_DECLARE_SCOPED_ENUM(DkmScriptDocumentContentType);
    FORWARD_DECLARE_SCOPED_ENUM(DkmScriptDocumentFlags);
    FORWARD_DECLARE_SCOPED_ENUM(DkmScriptDocumentJmcState);
    class DkmScriptDocumentTreeNode;
    FORWARD_DECLARE_SCOPED_ENUM(DkmScriptEmbeddedDocumentKind);
    class DkmScriptInstructionAddress;
    class DkmScriptInstructionSymbol;
    class DkmScriptRuntimeInstance;
    class DkmScriptSourceProjectItem;
    FORWARD_DECLARE_SCOPED_ENUM(DkmScriptSymbolNextSteppingAction);
    struct DkmSetRaiseSymbolEventsAsyncResult;
};

// Contains types specific to GPU debugging.
namespace GPU {
    FORWARD_DECLARE_SCOPED_ENUM(DkmComputeKernelModel);
    struct DkmComputeProperty;
    struct DkmComputeThreadInfo;
    FORWARD_DECLARE_SCOPED_ENUM(DkmComputeThreadState);
    FORWARD_DECLARE_SCOPED_ENUM(DkmGPUAddressType);
    FORWARD_DECLARE_SCOPED_ENUM(DkmGPUBreakpointBehaviorFlags);
    class DkmGPUComputeKernel;
    class DkmGPUComputeThread;
    class DkmGPUDataAddress;
    class DkmGPUMemoryAccessExceptionInformation;
    struct DkmGPURegisterDescription;
    FORWARD_DECLARE_SCOPED_ENUM(DkmHlslThreadIdComponents);
    FORWARD_DECLARE_SCOPED_ENUM(DkmQueryComputeThreadInfoFlags);
    struct DkmWhereClause;
};

// Contains types specific to extending the debugger to support a custom execution
// environment.
namespace CustomRuntimes {
    class DkmCustomExceptionInformation;
    class DkmCustomInstructionAddress;
    class DkmCustomInstructionSymbol;
    class DkmCustomModuleInstance;
    class DkmCustomRuntimeInstance;
};

// Contains types specific to runtime environment agnostic disassembly.
namespace Disassembly {
    class DkmDisassembledInstruction;
    struct DkmEffectiveAddress;
    FORWARD_DECLARE_SCOPED_ENUM(DkmEffectiveAddressFlags);
};

// Contains types used to describe properties of threads running in the target process.
namespace ThreadProperties {
    struct DkmGetManagedThreadPropertiesAsyncResult;
    struct DkmGetThreadDisplayPropertiesAsyncResult;
    struct DkmGetThreadNameAsyncResult;
    struct DkmGetVolatileFlagsAsyncResult;
    struct DkmGetVolatilePropertiesAsyncResult;
    FORWARD_DECLARE_SCOPED_ENUM(DkmVolatileThreadFlags);
};

// Contains types used to provide data to the 'Parallel Tasks' and 'Parallel Stacks'
// debugger windows. Types in this namespace are subject to change in future versions of
// Visual Studio.
namespace ParallelTasks {
    class DkmJsAsyncStackFrame;
    struct DkmManagedTaskInfo;
    class DkmTask;
    struct DkmTaskProperties;
    class DkmTaskProvider;
    FORWARD_DECLARE_SCOPED_ENUM(DkmTaskProviderCapabilityFlags);
    FORWARD_DECLARE_SCOPED_ENUM(DkmTaskReturnStatus);
    struct DkmTaskStackSegment;
    class DkmTaskSynchronizationObject;
};

// Contains types specific to edit and continue feature.
namespace Enc {
    FORWARD_DECLARE_SCOPED_ENUM(DkmNativeEncNotify);
};

// Contains types which are Microsoft-internal and subject to change.
namespace Internal {
    class DkmEELocalObject;
    class DkmPropertyProxy;
};

// Contains types which are related to telemetry.
namespace Telemetry {
    class DkmNameValuePair;
    struct DkmPostAsyncResult;
    class DkmTelemetryEvent;
};

// Include SAL 2.0 definition for compiling aganst older versions of sal.h
#ifndef SAL_VERSION_SAL2
#define _Field_size_opt_(size)
#endif

///<summary>
///Tuple of a pointer to a raw array, and the number of elements contained within the
///raw array.
///
///Memory Allocation:
///1. There are no requirements as to how the struct ITSELF is allocated.
///   Generally, it should be simply placed on the stack.
///2. If the DkmArray is being passed as input, or as a buffer which is allocated by the
///   caller, then there are no requirements on the way that 'Members' is allocated.
///3. When returned from a function as a callee-allocated buffer, this memory
///   should be allocated with DkmAllocBytes/DkmAllocArray and freed with DkmFreeMemory.
///</summary>
template <typename T>
struct DkmArray
{
    _Field_size_opt_(Length) T* Members; // Pointer to a raw array of 'Length' elements
    DWORD Length;
};

// Allocate zero-initialized memory from the Dispatcher's heap. This is primarily used for
// array memory.
DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE DkmAllocBytes(
    _In_ size_t bytes,
    _Out_bytecap_(bytes) void** ppMemory
    );

// Allocate a DkmArray of the specified size. On successful return, the
// count of elements will be set to the specified value, and the 'Members' field
// will point to a block of zero-initialized memory.
template <class T>
DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE DkmAllocArray(
    _In_ size_t elements,
    _Out_ DkmArray<T>* pArray
    );

// Free a DkmArray, releasing its elements.
template <class T>
DECLSPEC_NOTHROW void STDMETHODCALLTYPE DkmFreeArray(
    _In_ const DkmArray<T>& Array
    );

// Release an element from a DkmArray.
template <class T>
DECLSPEC_NOTHROW void STDMETHODCALLTYPE DkmReleaseElement(
    T& element
    );

// Free memory allocated with DkmAllocBytes
DECLSPEC_NOTHROW void STDMETHODCALLTYPE DkmFreeMemory(
    _Post_ptr_invalid_ void* pMemory
    );

DECLSPEC_NOTHROW void STDMETHODCALLTYPE DkmReleaseInterface(
    _In_opt_ IUnknown* pObject
    );

union ___ReferenceCount_t
{
    DWORD Value;
#ifdef __unix__
    void* Padding; // force alignment to match the cross-platform version of vsdebugeng.dll.
#endif
};



/* Class DkmDataContainer Description

DkmDataContainer is a building block which is used throughout this API. It allows many
of the objects in this API to contain 'virtual fields' which are added by any component
in the system. This is similar to a type-safe version of the 'expando' concept in
JScript.

Rules for DkmDataContainer:
1. All the 'reference' objects in the system inherit from DkmDataContainer. Reference
objects are tracked by the dispatcher component of this system, and at various
marshalling points (managed->native, native->managed, remoting) the object reference
identity is preserved. 'Value' objects do not inherit from DkmDataContainer because
the system does not track these objects, so at any marshalling transition, the value
of the object is copied.
2. The 'virtual fields' of these objects which inherit from DkmDataContainer are
called data items.
3. Data items are PRIVATE to the component that added them. This feature cannot be
used to share fields across component boundaries.
4. Data items are instances of a data item class. In managed code, data item classes
inherit from DkmDataItem to identify them as a data item. In native code, data items
inherit from IUnknown.
5. Usually, a component would never need to remove a data item. This is because data
items are automatically removed when the container object is closed.

Example:
//In native code, data items need to implement IUnknown and have a associated UUID.
//UUID should be randomly generated with a GUID generation tool.
class __declspec(uuid("{250266E5-99C0-4d4d-ABD4-39B53F1A59EA}")) CMyDataItem :
    // If the data item wishes to perform additional cleanup on container close, it may implement
    // IDkmDisposableDataItem in addition to IUnknown
    public IDkmDisposableDataItem
    // If the data item is passed as the 'DataItem' argument to a 'Create' method, it
    // may also wish to implement IDkmDataContainerCreateNotification
{
    // Object needs to declare the data that it wants to associate with the Dkm object
    int m_field1;

    // Object needs to implement IUnknown. Here is a very simple implementation
    volatile LONG m_refCount;

    ULONG __stdcall AddRef()
    {
        return (ULONG)InterlockedIncrement(&m_refCount);
    }
    ULONG __stdcall Release()
    {
        ULONG result = (ULONG)InterlockedDecrement(&m_refCount);
        if (result == 0)
        {
            delete this;
        }
        return result;
    }
    HRESULT __stdcall QueryInterface(REFIID riid, _Deref_out_ void** ppv)
    {
        if (riid == __uuidof(IUnknown))
        {
            *ppv = static_cast<IUnknown*>(this);
            AddRef();
            return S_OK;
        }
        // This example is implementing the optional interface IDkmDisposableDataItem
        else if (riid == __uuidof(IDkmDisposableDataItem))
        {
            *ppv = static_cast<IDkmDisposableDataItem*>(this);
            AddRef();
            return S_OK;
        }
        else
        {
            *ppv = NULL;
            return E_NOINTERFACE;
        }
    }

    // Data items can override the 'IDkmDisposableDataItem::OnClose' method to receive
    // notification when the data container object.
    HRESULT __stdcall OnClose()
    {
        printf("CMyDataItem is going away\n");

        return S_OK;
    }

public:
    CMyDataItem(int field1)
    {
        m_refCount = 1;
        m_field1 = field1;
    }
};

// create a new instance of the example data object
CComPtr<CMyDataItem> pMyDataItem;
pMyDataItem.Attach( new CMyDataItem(12) );

// data items can be passed to a create method...
CComPtr<DkmClrAlias> pNewObject;
DkmClrAlias::Create("ExampleName", pMyDataItem, &pNewObject);

// ...or then can be added using SetDataItem
pNewObject->SetDataItem(DkmDataCreationDisposition::CreateAlways, pMyDataItem);
*/
class DECLSPEC_NOVTABLE DECLSPEC_UUID("0DBABB2A-C342-49c9-B8A5-8764834CD78C") DkmDataContainer : public IUnknown
{
    private: ___ReferenceCount_t m_ReferenceCount;
    private: DkmDispatcherObjectFlags_t m_ObjectFlags;
    private: const GUID* m_pTypeId;
    private: size_t m_ObjectGCHandle;
    private: void* m_DataContainerCollection;
    private: void* m_pCreator;
    private: void* m_pCreateEventPosition;
    private: CRITICAL_SECTION m_ObjectCriticalSection;

    // DkmDataContainer is an abstract base class
    protected: DkmDataContainer();
    // This object is refcounted. It is deleted through Release
    protected: ~DkmDataContainer();
    // This object cannot be copied
    private: DkmDataContainer& operator=(const DkmDataContainer&);
    private: DkmDataContainer(const DkmDataContainer&);

    // Place a new item within this data container.
    // CreationDisposition: Action to be taken if there is already an item with the
    // same id.
    // item  : Item to add to the container. The DkmDataItem structure is usually
    // implicitly created from a pointer to a data item class. See DkmDataContainer for
    // more information.
    public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE SetDataItem(
        _In_ DkmDataCreationDisposition_t CreationDisposition,
        _In_ const struct DkmDataItem& item
        );

#if !defined(NO_DATA_CONTAINER_TEMPLATES)
    // Gets the instance of 'T' which has been added to this container instance.
    // T  : Type of a data item class. The compiler can determine 'T' from the 'ppObject'
    // argument. This method can be used with any data item class which uses
    // '__declspec(uuid(<value>))' to associate a UUID (GUID) with the class.
    // ppobject : Returns the 'T' object for this container instance.
    // Return value : S_OK is returned on success, and failure codes are used for any
    // error. E_XAPI_DATA_ITEM_NOT_FOUND indicates that there is no instance of 'T'
    // associated with this object.
    public: template <class T> DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetDataItem(
        _Deref_out_ T** ppObject
        );
#endif

    // Gets the value associated with 'ItemId'.
    // ItemId     : GUID Item key.
    // ppObject   : Value associated with 'ItemId'
    // Return value : S_OK is returned on success, and failure codes are used for any
    // error. E_XAPI_DATA_ITEM_NOT_FOUND indicates that the container does not have a
    // value for 'ItemId'.
    public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetDataItem(
        _In_ REFGUID ItemId,
        _Deref_out_ IUnknown** ppObject
        );

#if !defined(NO_DATA_CONTAINER_TEMPLATES)
    // Remove the instance of 'T' from this container. It is usually unnecessary to call
    // this method as a data container will automatically be emptied when the object is
    // closed.  If this contain does not have a 'T', this function will return S_FALSE.
    // T  : Type of a data item class.
    public: template <class T> DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE RemoveDataItem(
        );
#endif

    // Remove the value associated with 'ItemId' from this container. It is usually
    // unnecessary to call this method as a data container will automatically be emptied
    // when the object is closed.  If no value is associated, this function will return
    // S_FALSE.
    public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE RemoveDataItem(
        _In_ REFGUID ItemId
        );

    // Returns true if a 'unloaded' event has been raised for this object (example:
    // DkmThread::Unload is called) or if the object has been closed. Note that care
    // must be used when checking this status as, without synchronization, the returned
    // status may no longer be accurate the instruction after it is read.
    public: DECLSPEC_NOTHROW bool STDMETHODCALLTYPE IsUnloaded(
        );
}; // end of DkmDataContainer

// DkmDataItem is a pairing between a pointer to an instance of a data item class, and
// the associated GUID value used to identify this class. DkmDataItem is usually
// implicitly constructed, so code doesn't directly make use of it.
// See DkmDataContainer for more information.
struct DkmDataItem
{
    const LPUNKNOWN pValue;
    const GUID Id;

#if !defined(NO_DATA_CONTAINER_TEMPLATES) && !defined(VSDEBUGENG_NO_ATL)
    // Implicitly create a DkmDataItem. This overload is used when the pointer to the
    // data item class has been stored in a CComPtr.
    template <class T>
    DkmDataItem(_In_ const ATL::CComPtr<T>& pObject)
        : pValue(pObject.p), Id(__uuidof(T))
    {
    }
#endif

#if !defined(NO_DATA_CONTAINER_TEMPLATES)
    // Implicitly create a DkmDataItem from a pointer to a data item class.
    template <class T>
    DkmDataItem(_In_ T* pObject)
        : pValue(pObject), Id(__uuidof(T))
    {
    }
#endif

    // Explicitly construct a DkmDataItem. This overload is only necessary when it is
    // useful to calculate the ItemId instead of using the GUID associated with an item
    // class.
    DkmDataItem(_In_ IUnknown* pItemValue, _In_ const GUID& ItemId)
        : pValue(pItemValue), Id(ItemId)
    {
    }

    // Returns the empty DkmDataItem for passing to an object 'Create' method.
    static const DkmDataItem& STDMETHODCALLTYPE Null(
        );
};

// Optional interface which native data item classes may implement to receive
// notification when their container object is closed. This interface may be helpful to break AddRef cycles.
#define IID_IDkmDisposableDataItem __uuidof(Microsoft::VisualStudio::Debugger::IDkmDisposableDataItem)
interface DECLSPEC_NOVTABLE DECLSPEC_UUID("39738b1d-2e90-4164-a21c-749be02f9a96") IDkmDisposableDataItem : public IUnknown
{
    // 'OnClose' is invoked on all data items when a data container is closed.
    virtual HRESULT STDMETHODCALLTYPE OnClose(
        ) = 0;
};

// Optional interface which native data item classes may implement to obtain a pointer to
// a newly created data container that the item has been added to. This interface is only
// used when the data item is passed as the 'DataItem' argument to a 'Create' method.
// This allows the data item to obtain the newly created dispatcher object before this
// dispatcher object has been passed to any other component.
//
// Example:
// class CMyModuleDataItem : public IDkmDataContainerCreateNotification
// {
// public:
//     CComPtr<DkmModule> m_pModule;
//
//     HRESULT OnContainerCreated(DkmDataContainer* pContainer)
//     {
//         return pContainer->QueryInterface(&m_pModule);
//     }
//
//     ...
// };
//
// CMyModuleDataItem* pMyDataItem = new CMyModuleDataItem();
//
// CComPtr<DkmModule> pModule;
// hr = DkmModule::Create(..., pMyDataItem, &pModule);
// if (FAILED(hr))
//     return hr;
//
// ASSERT(pModule == pMyDataItem->m_pModule);
#define IID_IDkmDataContainerCreateNotification __uuidof(Microsoft::VisualStudio::Debugger::IDkmDataContainerCreateNotification)
interface DECLSPEC_NOVTABLE DECLSPEC_UUID("86c6f523-22af-46be-a4bc-a9e3b82fa5d9") IDkmDataContainerCreateNotification : public IUnknown
{
    // 'OnContainerCreated' is invoked when a 'Create' method succeeds in creating the object
    // and adding the initial data item to the collection
    virtual HRESULT STDMETHODCALLTYPE OnContainerCreated(
        _In_ DkmDataContainer* pContainer
        ) = 0;
};

// Callback interface which fires when an asynchronous request completes. This must be
// implemented by any component that appends work items to a work list.
//
// TResult: each async operation defines a 'Result' structure containing any returned
// data (including a status code). TResult is this struct.
template <class TResult>
interface DECLSPEC_NOVTABLE IDkmCompletionRoutine : public IUnknown
{
    // Function fired when results are complete.
    virtual void STDMETHODCALLTYPE OnComplete(
        _In_ const TResult& Result
        ) = 0;
};

// {F9A8DEDF-C104-495b-BA47-5C33364A3F6E}
__declspec(selectany) const extern IID IID_IDkmCompletionRoutine =
{ 0xf9a8dedf, 0xc104, 0x495b, { 0xba, 0x47, 0x5c, 0x33, 0x36, 0x4a, 0x3f, 0x6e } };

// Optional interface which is fired when the work list is complete, including firing
// all completion routines.
#define IID_IDkmWorkListCompletionRoutine __uuidof(Microsoft::VisualStudio::Debugger::IDkmWorkListCompletionRoutine)
interface DECLSPEC_NOVTABLE DECLSPEC_UUID("1CE48366-A05C-4955-BE03-8436A0662D8F") IDkmWorkListCompletionRoutine : public IUnknown
{
    // 'OnComplete' is called when processing for the work list has completed.
    virtual void STDMETHODCALLTYPE OnComplete(
        _In_ class DkmWorkList* pWorkList
        ) = 0;
};

// Internal flags indicating the current state of a work list.
FORWARD_DECLARE_SCOPED_ENUM(DkmWorkListFlags);
DEFINE_SCOPED_ENUM(DkmWorkListFlags)
{
    // No flags are currently set
    None = 0x0,
    // Critical Section has been initialized
    LockInitialized = 0x1,
    // The 'Create' method succeeded
    Created = 0x2,
    // Processing has begun for the work list
    Started = 0x4,
    // Processing started and all work items are complete (no new work items are allowed)
    ItemsComplete = 0x8,
    // The completion routine has finished executing
    CompleteInvoked = 0x10,
    // The work list was canceled before being marked as complete
    Canceled = 0x20,
    // We are currently invoking work items
    InvokingItems = 0x40,
    // The work items are executed on the thread that called 'Execute'
    InvokingOnExecuteThread = 0x80,
    // We added a task to the request thread to process requests/replies for this work list
    ScheduledNetProcessing = 0x100
};
DEFINE_SCOPED_ENUM_FLAG_OPERATORS(DkmWorkListFlags_t);

// Collection of asynchronous work items which are processed together. Work items
// are appended by calling any of the asynchronous methods throughout this API. Work
// items may be appended freely until the work list begins execution. Once execution has
// begun, additional work may only be appended from the implementation of a work item
// processing interface, or from a completion routine.
class DECLSPEC_NOVTABLE DECLSPEC_UUID("E33525D5-B5F4-4A7C-BF6B-4A5ED9D2646E") DkmWorkList : public IUnknown
{
    private: ___ReferenceCount_t m_ReferenceCount;
    private: size_t m_ObjectGCHandle;
    private: const GUID m_UniqueId;
    private: DkmWorkListFlags_t m_Flags;

    // Use DkmWorkList::Create to create this object
    private: DkmWorkList();
    // This object is refcounted. It is deleted through Release
    protected: ~DkmWorkList();
    // This object cannot be copied
    private: DkmWorkList& operator=(const DkmWorkList&);
    private: DkmWorkList(const DkmWorkList&);

    // Creates a new empty work list object. Callers should append operations to the
    // work list and then start execution ('BeginExecution' or 'Execute').
    //
    // Once created, a WorkList object will continue to exist until its execution is
    // completed, or until the request is canceled. So callers should ensure that
    // 'Cancel' is called in the case of failure.
    //
    // pCompletionRoutine: [In,Optional] Optional function which is fired when the work
    // list is complete, including firing all completion routines.
    // ppCreatedObject : [Out] Result of this method call.
    public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
        _In_opt_ IDkmWorkListCompletionRoutine* pCompletionRoutine,
        _Deref_out_ DkmWorkList** ppCreatedObject
        );

    // This function allows a component to determine if the current operation should be
    // canceled. This will return true when called from a thread which is currently
    // processing a work list, and when this work list has been canceled.
    //
    // This will fail if called from a completion routine or from a thread that is not
    // currently processing an interface call.
    //
    // Example:
    // for (DWORD c = 0; c < myFiles.GetCount(); c++)
    // {
    //     if (DkmWorkList::QueryIsCurrentInstanceCanceled() == S_OK)
    //         return COR_E_OPERATIONCANCELED;
    //
    //     ProcessFile(myFiles[c]);
    // }
    public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE QueryIsCurrentInstanceCanceled(
        );

    // This property allows a component processing a work item to determine if it is
    // canceled, or for a completion routine to determine if the operation was canceled.
    public: DECLSPEC_NOTHROW bool STDMETHODCALLTYPE IsCanceled(
        );

    // Begin execution of the items in this work list. This API will return immediately
    // and completion routines are fired to return results. Callbacks will fire as
    // results complete (unordered).
    //
    // This method may only be called by the component which created the object.
    public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE BeginExecution(
        );

    // Synchronously execute all items in the work list and return when processing is
    // complete or has been canceled, including firing all completion routines. Callbacks
    // will fire as results are complete (unordered).
    //
    // This method may only be called by the component which created the object. This
    // method will fail if execution is already in progress.
    public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Execute(
        );

    // Cancel execution of this work list. This API will return once all work on this
    // work queue has stopped (state reaches canceled or completed). The request is
    // ignored if the work list is already canceled. This method may only be called by
    // the component which created the object.
    //
    // Note for components declared as 'Synchronized' in the component configuration:
    // calling this API may implicitly release and then reacquire the lock around your
    // component. Be mindful of possible state changes.
    public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Cancel(
        );
}; // end of DkmWorkList

class DkmSourceString;
class DkmString;
template <class T> class DkmReadOnlyCollection;



//
// Macro to allocate a BSTR from a DkmString. This is done as a macro to avoid
// interfering with BSTR leak tracking macros
#define DkmSysAllocString(dkmString) \
    SysAllocStringLen(Microsoft::VisualStudio::Debugger::DkmString::Value(dkmString), Microsoft::VisualStudio::Debugger::DkmString::Length(dkmString))


class DECLSPEC_UUID("1c64ee50-f8e3-4554-b67c-c8f5c91fea3a") DkmString : public IUnknown
{
    public: static const DWORD MaxLength = 0x0fffffff;
    private: ___ReferenceCount_t m_ReferenceCount;
    private: const DWORD m_Length;
    private: const WCHAR m_Value[ANYSIZE_ARRAY];

    // DkmString's should never be directly allocated or copied
    private: DkmString();
    private: DkmString(const DkmString&);
    private: DkmString& operator=(const DkmString&);
    // This object is refcounted. It is deleted through Release
    protected: ~DkmString();

public:
    /// <summary>
    /// Accesses the underlying null terminated Unicode string in a DkmString. Note that
    /// a DkmString is immutable, so the returned value is a 'const' string and should
    /// NOT be written to.
    /// </summary>
    /// <example>
    /// MessageBox(NULL, pMessage->Value(), L"My message box", MB_OK);
    /// </example>
    _Ret_z_ inline const WCHAR* Value(
        ) const
    {
        return m_Value;
    }

    /// <summary>
    /// Returns the length of the string. For strings that do not contain embedded nulls,
    /// this value will match the length returned from wcslen.
    /// </summary>
    _Ret_range_(0,0x0fffffff) inline DWORD Length(
        ) const
    {
        return m_Length;
    }

    /// <summary>
    /// Accesses the underlying null terminated Unicode string in a DkmString. Note that
    /// a DkmString is immutable, so the returned value is a 'const' string and should
    /// NOT be written to.
    /// </summary>
    /// <example>
    /// SysAllocString(DkmString::Value(pString));
    /// </example>
    _Ret_opt_z_ static inline const WCHAR* Value(
        _In_opt_ DkmString* pString
        )
    {
        if (pString == NULL)
            return NULL;
        else
            return pString->Value();
    }

    /// <summary>
    /// Returns the length of the string. For strings that do not contain embedded nulls,
    /// this value will match the length returned from wcslen.
    /// </summary>
    _Ret_range_(0,0x0fffffff) static inline DWORD Length(
        _In_opt_ DkmString* pString
        )
    {
        if (pString == NULL)
            return 0;
        else
            return pString->Length();
    }

    /// <summary>
    /// Create a DkmString from a DkmStringSource. If the InputString is empty, the empty string will be returned.
    /// </summary>
    /// <example>
    /// DkmString::Create(L"Example String", &amp;pResult);
    /// </example>
    DECLSPEC_NOTHROW static HRESULT STDMETHODCALLTYPE Create(
        const DkmSourceString& InputString,
        _Deref_out_ DkmString** ppString
        );

    /// <summary>
    /// Create a DkmString from a multi-byte string (ANSI, UTF-8, etc). If the InputString is empty, the empty string will be returned.
    /// </summary>
    /// <example>
    /// DkmString::Create(CP_THREAD_ACP, "hi", 2, &amp;pResult);
    /// </example>
    DECLSPEC_NOTHROW static HRESULT STDMETHODCALLTYPE Create(
        _In_ DWORD CodePage,
        _In_bytecount_(cbMultiByte) const char* pMultiByteString,
        _In_ size_t cbMultiByte,
        _Deref_out_ DkmString** ppString
        );

    /// <summary>
    /// Returns true if the given string variable is a NULL pointer or if it is the empty
    /// string.
    /// </summary>
    static inline bool IsNullOrEmpty(
        _In_opt_ DkmString* pString
        )
    {
        return (pString == NULL || pString->Length() == 0);
    }

    /// <summary>
    /// Compares two strings by evaluating the numeric values of each character in the
    /// string. This is a binary comparison which will not ignore case.
    /// </summary>
    /// <param name="a">The first string to compare</param>
    /// <param name="b">The second string to compare</param>
    /// <returns>
    /// An integer indicating the lexical relationship between the two comparands. A
    /// negative return value if 'a' is less than 'b'. Zero if 'a' is equal to 'b'. A
    /// positive return value if 'a' is greater than 'b'.</returns>
    /// <example>
    /// if (DkmString::CompareOrdinal(L"A", L"A") == 0)
    /// {
    ///   ...
    /// }
    /// </example>
    DECLSPEC_NOTHROW static int STDMETHODCALLTYPE CompareOrdinal(
        const DkmSourceString& a,
        const DkmSourceString& b
        );

    /// <summary>
    /// Compare strings using ordinal sort rules and ignoring the case of the strings.
    /// This comparison is locale-invariant and will follow the same casing rules as the
    /// operating system, so it is appropriate for comparing file names, registery paths,
    /// etc.
    /// </summary>
    /// <param name="a">The first string to compare</param>
    /// <param name="b">The second string to compare</param>
    /// <returns>
    /// An integer indicating the lexical relationship between the two comparands. A
    /// negative return value if 'a' is less than 'b'. Zero if 'a' is equal to 'b'. A
    /// positive return value if 'a' is greater than 'b'.
    /// </returns>
    /// <example>
    /// if (DkmString::CompareOrdinalIgnoreCase(L"A", L"a") == 0)
    /// {
    ///   ...
    /// }
    /// </example>
    DECLSPEC_NOTHROW static int STDMETHODCALLTYPE CompareOrdinalIgnoreCase(
        const DkmSourceString& a,
        const DkmSourceString& b
        );

    /// <summary>
    /// Concatenate various strings together to create a DkmString.
    /// </summary>
    /// <example>
    /// DkmString::Concat(L"One", L" -and- ", L"Two", &amp;pResult);
    /// </example>
    DECLSPEC_NOTHROW static HRESULT STDMETHODCALLTYPE Concat(
        const DkmSourceString& item0,
        const DkmSourceString& item1,
        _Deref_out_ DkmString** ppString
        );
    DECLSPEC_NOTHROW static HRESULT STDMETHODCALLTYPE Concat(
        const DkmSourceString& item0,
        const DkmSourceString& item1,
        const DkmSourceString& item2,
        _Deref_out_ DkmString** ppString
        );
    DECLSPEC_NOTHROW static HRESULT STDMETHODCALLTYPE Concat(
        const DkmSourceString& item0,
        const DkmSourceString& item1,
        const DkmSourceString& item2,
        const DkmSourceString& item3,
        _Deref_out_ DkmString** ppString
        );
    DECLSPEC_NOTHROW static HRESULT STDMETHODCALLTYPE Concat(
        const DkmSourceString& item0,
        const DkmSourceString& item1,
        const DkmSourceString& item2,
        const DkmSourceString& item3,
        const DkmSourceString& item4,
        _Deref_out_ DkmString** ppString
        );
    DECLSPEC_NOTHROW static HRESULT STDMETHODCALLTYPE Concat(
        const DkmSourceString& item0,
        const DkmSourceString& item1,
        const DkmSourceString& item2,
        const DkmSourceString& item3,
        const DkmSourceString& item4,
        const DkmSourceString& item5,
        _Deref_out_ DkmString** ppString
        );
    DECLSPEC_NOTHROW static HRESULT STDMETHODCALLTYPE Concat(
        const DkmSourceString& item0,
        const DkmSourceString& item1,
        const DkmSourceString& item2,
        const DkmSourceString& item3,
        const DkmSourceString& item4,
        const DkmSourceString& item5,
        const DkmSourceString& item6,
        _Deref_out_ DkmString** ppString
        );
    DECLSPEC_NOTHROW static HRESULT STDMETHODCALLTYPE Concat(
        const DkmSourceString& item0,
        const DkmSourceString& item1,
        const DkmSourceString& item2,
        const DkmSourceString& item3,
        const DkmSourceString& item4,
        const DkmSourceString& item5,
        const DkmSourceString& item6,
        const DkmSourceString& item7,
        _Deref_out_ DkmString** ppString
        );
    DECLSPEC_NOTHROW static HRESULT STDMETHODCALLTYPE Concat(
        const DkmSourceString& item0,
        const DkmSourceString& item1,
        const DkmSourceString& item2,
        const DkmSourceString& item3,
        const DkmSourceString& item4,
        const DkmSourceString& item5,
        const DkmSourceString& item6,
        const DkmSourceString& item7,
        const DkmSourceString& item8,
        _Deref_out_ DkmString** ppString
        );
    DECLSPEC_NOTHROW static HRESULT STDMETHODCALLTYPE Concat(
        const DkmSourceString& item0,
        const DkmSourceString& item1,
        const DkmSourceString& item2,
        const DkmSourceString& item3,
        const DkmSourceString& item4,
        const DkmSourceString& item5,
        const DkmSourceString& item6,
        const DkmSourceString& item7,
        const DkmSourceString& item8,
        const DkmSourceString& item9,
        _Deref_out_ DkmString** ppString
        );

    /// <summary>
    /// Concatenate various strings together to create a DkmString.
    /// </summary>
    /// <example>
    /// DkmSourceString sources[2] = { DkmSourceString(L"one"), DkmSourceString(L"two") };
    /// DkmString::ConcatV(sources, _countof(sources), &amp;pResult);
    /// </example>
    DECLSPEC_NOTHROW static HRESULT STDMETHODCALLTYPE ConcatV(
        _In_count_(cSources) const DkmSourceString sources[],
        _In_ DWORD cSources,
        _Deref_out_ DkmString** ppString
        );

    /// <summary>
    /// Returns the empty string singleton object. Note that the empty string object is a
    /// singleton with infinite lifetime. So the caller does not need to monitor the
    /// reference count on this object.
    /// </summary>
    /// <example>
    /// DkmString::Empty()
    /// </example>
    _Ret_ DECLSPEC_NOTHROW static DkmString* STDMETHODCALLTYPE Empty(
        );

};

// DkmSourceString is used an input to functions which create a DkmString
// (DkmString::Create or DkmString::Concat).
//
// Generally this class is implicitly constructed by the compiler, so the consumer
// of these APIs does NOT need to explicitly create an instance.
//
// Example:
// DkmString::Create(L"My string", &pString);
//
// Here the compiler will automatically create a DkmSourceString from the string
// literal 'My string'.
class DkmSourceString
{
    LPCWSTR Text;
    DWORD Length;

    static DWORD LengthOf(_In_opt_z_ LPCWSTR text)
    {
        if (text == NULL)
            return 0;

        for (DWORD length = 0; true; length++)
        {
            if (text[length] == 0)
                return length;
            if (length > DkmString::MaxLength)
                return length;
        }
    }

public:
    DkmSourceString() : Text(NULL), Length(0)
    {
    }

    // DkmSourceString(LPCWSTR, DWORD) is used to explicitly define an input string
    // with its length. This is required when trying to create a DkmString that contains
    // embedded '\0' characters, or when trying to create a DkmString from data which may
    // not be null terminated.
    DkmSourceString(_In_opt_count_(length) LPCWSTR text, DWORD length) : Text(text), Length(length)
    {
    }

    // DkmSourceString(LPCWSTR) is used to implicitly convert from a null-terminated
    // Unicode string into a DkmSourceString
    DkmSourceString(_In_opt_z_ LPCWSTR text) : Text(text), Length(LengthOf(text))
    {
    }

    // DkmSourceString(DkmString*) is used to implicitly convert from a DkmString
    // into a DkmSourceString
    DkmSourceString(_In_opt_ DkmString* pString) :
        Text(DkmString::Value(pString)),
        Length(DkmString::Length(pString))
    {
    }

#ifndef VSDEBUGENG_NO_ATL
    // DkmSourceString(const ATL::CComPtr<DkmString>&) is used to implicitly convert
    // from a DkmString which is held in an ATL smart pointer into a DkmSourceString
    DkmSourceString(const ATL::CComPtr<DkmString>& pString) :
        Text(DkmString::Value(pString)),
        Length(DkmString::Length(pString))
    {
    }
#endif

#ifndef VSDEBUGENG_NO_ATL
    // DkmSourceString(const ATL::CComBSTR&) is used to implicitly convert from a BSTR
    // which is held in an ATL smart BSTR into a DkmSourceString
    DkmSourceString(const ATL::CComBSTR& bstr) : Text(bstr), Length(bstr.Length())
    {
    }
#endif

#ifndef VSDEBUGENG_NO_ATL
    // DkmSourceString(const ATL::CStringW&) is used to implicitly convert from an ATL
    // CString into a DkmSourceString
    DkmSourceString(const ATL::CStringW& str) : Text(str), Length((DWORD)str.GetLength())
    {
    }
#endif

#ifdef VSDEBUGENG_USE_STL
    // DkmSourceString(const std::wstring&) is used to implicitly convert from an STL
    // std::string into a DkmSourceString
    DkmSourceString(const std::wstring& string) : Text(string.c_str()), Length(string.length())
    {
    }
#endif
};

// Like DkmSourceString, DkmSourceBSTR is used an input to functions which create a
// DkmString (DkmString::Create or DkmString::Concat).
//
// This class is used to explicitly declare that an input string is a BSTR.
//
// Example:
// BSTR bstrResult;
// pExample->GetResult(&bstrResult);
//
// DkmString::Create(DkmSourceBSTR(bstrResult), &pString);
struct DkmSourceBSTR : public DkmSourceString
{
    // Constructs a new DkmSourceBSTR
    explicit DkmSourceBSTR(_In_opt_ BSTR bstr)
        : DkmSourceString(bstr, SysStringLen(bstr))
    {
    }
};

// Like DkmSourceString, DkmSourceStringLiteral is used an input to functions which
// create a DkmString (DkmString::Create or DkmString::Concat).
//
// This class is used to explicitly declare string literals such that the length of the
// literal can be assigned at compile time.
//
// Example:
// DkmString::Create(DkmSourceStringLiteral(L"My string"), &pString);
struct DkmSourceStringLiteral : public DkmSourceString
{
    // Constructs a new DkmSourceStringLiteral
    template <int CCH> explicit DkmSourceStringLiteral(const WCHAR (&string)[CCH])
        : DkmSourceString(string, CCH-1)
    {
    }
};

template <class T>
class DkmReadOnlyCollection : public IUnknown
{
    private: ___ReferenceCount_t m_ReferenceCount;
    private: const DWORD m_Count;
    private: const FARPROC m_pElementRelease;
    private: __declspec(align(16)) const T m_Items[ANYSIZE_ARRAY];

    // DkmReadOnlyCollection's should never be directly allocated or copied
    private: DkmReadOnlyCollection();
    private: DkmReadOnlyCollection(const DkmReadOnlyCollection<T>&);
    private: DkmReadOnlyCollection<T>& operator=(const DkmReadOnlyCollection<T>&);
    // This object is refcounted. It is deleted through Release
    protected: ~DkmReadOnlyCollection();

public:
    /// <summary>
    /// Provides access to the underlying array. Note that DkmReadOnlyCollection
    /// represents an immutable array, so the returned value is a 'const' array and
    /// should NOT be written to.
    /// </summary>
#if _MSC_VER >= 1700 // VS 2010 cannot handle this annotation
    _Ret_count_x_(Count())
#endif
    const T* Items(
        )
    {
        return m_Items;
    }

    /// <summary>
    /// Gets the number of elements contained in the ReadOnlyCollection instance.
    /// </summary>
    _Ret_range_(0,0x7FFFFFFF/sizeof(T)) inline DWORD Count(
        )
    {
        return m_Count;
    }

    /// <summary>
    /// Accesses an element in the collecion. Note that DkmReadOnlyCollection
    /// represents an immutable array, so the returned value is a 'const' element and
    /// should NOT be written to.
    /// </summary>
    /// DkmReadOnlyCollection<DkmString*>* pStringCollection;
    /// MyExampleFunction(&pStringCollection);
    /// printf("First returned string was '%S'\n", pStringCollection->Element(0));
    DECLSPEC_NOTHROW const T& STDMETHODCALLTYPE Element(
        size_t index
        );

    /// <summary>
    /// Create a DkmReadOnlyCollection<T> instance.
    /// </summary>
    /// <example>
    /// DkmReadOnlyCollection<DkmString*>* pStringCollection;
    /// DkmString* strings[2];
    /// DkmString::Create(L"String1", &strings[0]);
    /// DkmString::Create(L"String2", &strings[1]);
    /// DkmReadOnlyCollection<DkmString*>::Create(strings, _countof(strings), &pStringCollection);
    /// </example>
    DECLSPEC_NOTHROW static HRESULT STDMETHODCALLTYPE Create(
        _In_count_(Count) const T* pItemArray,
        _In_ DWORD Count,
        _Deref_out_ DkmReadOnlyCollection<T>** ppCollection
        );

    /// <summary>
    /// Create a DkmReadOnlyCollection<T> instance from a DkmArray<T>.
    /// </summary>
    DECLSPEC_NOTHROW static HRESULT STDMETHODCALLTYPE Create(
        _In_ const DkmArray<T>& input,
        _Deref_out_ DkmReadOnlyCollection<T>** ppCollection
        )
    {
        return Create(input.Members, input.Length, ppCollection);
    }

    /// <summary>
    /// Returns true if the given collection variable is a NULL pointer or if the
    /// collection contains no objects.
    /// </summary>
    static inline bool IsNullOrEmpty(
        _In_opt_ DkmReadOnlyCollection<T>* pCollection
        )
    {
        return (pCollection == NULL || pCollection->Count() == 0);
    }

    // Searches for the specified object and returns the zero-based index of the
    // first occurrence within the entire DkmReadOnlyCollection.
    // value           : [In,Optional] The value to search for in the collection,
    // the value can be nullptr if the collection is a pointer collection
    // Return value    : The index of the element if the element is found. MAXDWORD
    // if the element is not found.
    inline DWORD IndexOf(
        _In_opt_ const T& value
        )
    {
        const DWORD count = this->Count();
        for (DWORD c = 0; c < count; c++)
        {
            if (m_Items[c] == value)
            {
                return c;
            }
        }

        return MAXDWORD;
    }

    // Determines whether an element is in the DkmReadOnlyCollection.
    // value           : [In,Optional] The value to search for in the collection,
    // the value can be nullptr if the collection is a pointer collection
    // Return value    : true if value is found; otherwise, false.
    inline bool Contains(
        _In_opt_ const T& value
        )
    {
        return IndexOf(value) != MAXDWORD;
    }

    /// <summary>
    /// Returns the empty collection object. Note that the empty collection object is a
    /// singleton with infinite lifetime. So the caller does not need to monitor the
    /// reference count on this object.
    /// </summary>
    /// <example>
    /// DkmReadOnlyCollection::Empty()
    /// </example>
    _Ret_ static DkmReadOnlyCollection<T>* STDMETHODCALLTYPE Empty(
        );

};

/// <summary>
/// DkmXmm128 represents the content of a 128-bit XMM register on x64 systems
/// </summary>
union DkmXmm128
{
    float Single[4];
    double Double[2];
    UINT64 u64[2];
    UINT32 u32[4];
};
__declspec(selectany) const extern DkmXmm128 DkmXmm128_Zero = {0};

class DECLSPEC_UUID("030c428a-30e8-4e9d-9586-85e03b80e3d6") DkmVariant : public IUnknown
{
    private: ___ReferenceCount_t m_ReferenceCount;
#ifdef __clang__
    // To quiet a clang error about uninitialized m_Value (it's initialized through memcpy)
    private: const VARIANT m_Value = {0};
#else
    private: const VARIANT m_Value;
#endif

    // DkmVariant's should never be directly allocated or copied
    private: DkmVariant();
    private: DkmVariant(const DkmVariant&);
    private: DkmVariant& operator=(const DkmVariant&);
    // This object is refcounted. It is deleted through Release
    protected: ~DkmVariant();

public:
    /// <summary>
    /// Accesses the VARIANT stored within this object. Note that the variant will
    /// never be empty.
    /// </summary>
    inline const VARIANT& Value(
        )
    {
        return m_Value;
    }

    /// <summary>
    /// Returns the type of VARIANT stored in this object (ex: VT_BSTR for strings,
    //  VT_SAFEARRAY for arrays). Note that the type will never be VT_EMPTY.
    /// </summary>
    inline VARTYPE Type(
        )
    {
        return m_Value.vt;
    }

    /// <summary>
    /// Allocates a new DkmVariant. The value of this new DkmVariant comes from the source
    /// argument. On success, the source argument will be set to an empty variant.
    ///
    /// If pSource is an empty VARIANT (VT_EMPTY) a NULL DkmVariant will be returned, and
    /// the status code will be S_FALSE.
    /// </summary>
    /// <example>
    /// CComVariant helloWorld(L"Hello World");
    /// CComPtr&lt;DkmVariant&gt; pNewObject;
    /// DkmVariant::Convert(&amp;helloWorld, &amp;pNewObject);
    /// </example>
    DECLSPEC_NOTHROW static HRESULT STDMETHODCALLTYPE Convert(
        _Inout_ VARIANT* pSource,
        _Deref_out_opt_ DkmVariant** ppVariant
        );

    /// <summary>
    /// Allocates a new DkmVariant from a source BYTE array. This may be used to send
    /// serialized data from one component to another. The resulting variant will have
    /// a type of VT_ARRAY | VT_UI1, with:
    ///   size = DkmVariant::Value().parray->rgsabound->cElements
    ///   value = DkmVariant::Value().parray->pvData
    /// </summary>
    /// <example>
    /// CComPtr&lt;DkmVariant&gt; pNewObject;
    /// BYTE bytes[] = { 1, 2, 3, 4 };
    /// DkmVariant::Create(bytes, _countof(bytes), &amp;pNewObject);
    /// </example>
    DECLSPEC_NOTHROW static HRESULT STDMETHODCALLTYPE Create(
        _In_count_(size) const BYTE* pValue,
        DWORD size,
        _Deref_out_ DkmVariant** ppVariant
        );

};

// Static class containing settings which are global to the debugger process
/*static*/ class DkmGlobalSettings
{
public:
    // Language Identifier used by Visual Studio. For example, 1033 (MAKELANGID(LANG_ENGLISH,
    // SUBLANG_ENGLISH_US)) is used for English strings.
    static DECLSPEC_NOTHROW LCID STDMETHODCALLTYPE Locale(
        );
    // Obtain the registry root used by Visual Studio.
    // ppValue         : [Out,Optional] String object containing the current value (ex:
    // Software\Microsoft\VisualStudio\11.0). For components loaded into the remote debugger,
    // Registry root is NULL in remote debugging, and pseudo-remote (64-bit) scenarios.
    // Return value    : S_OK is returned if *ppValue is non-NULL, S_FALSE is returned
    // when *ppValue is NULL, and failure codes are used for any error.
    static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetRegistryRoot(
        _Deref_out_opt_ DkmString** ppValue
        );
    // Obtain paths for native visualizers using the visual studio extensibility mechanism
    // ppValue         : [Out,Optional] Read only collection of string objects containing
    // a list of paths to .natvis files.  VisualizerPaths is NULL in remote debugging scenarios.
    // It will be non-null in pseudo-remote, and local debugging scenarios.
    // Return value    : S_OK is returned if *ppValue is non-NULL, S_FALSE is returned
    // when *ppValue is NULL, and failure codes are used for any error.
    static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetVisualizerPaths(
        _Deref_out_opt_ DkmReadOnlyCollection<DkmString*>** ppVisualizerPaths
        );
    // Obtain paths for native step filters using the visual studio extensibility mechanism
    // ppValue         : [Out,Optional] Read only collection of string objects containing
    // a list of paths to .natstepfilter files.  *ppStepFilterPaths is NULL in remote debugging scenarios.
    // It will be non-null in pseudo-remote, and local debugging scenarios.
    // Return value    : S_OK is returned if *ppValue is non-NULL, S_FALSE is returned
    // when *ppValue is NULL, and failure codes are used for any error.
    static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetStepFilterPaths(
        _Deref_out_opt_ DkmReadOnlyCollection<DkmString*>** ppStepFilterPaths
        );
    // Obtain paths for native JustMyCode files using the visual studio extensibility mechanism.
    // ppValue         : [Out,Optional] Read only collection of string objects containing
    // a list of paths to .natjmc files.  *ppNativeJustMyCodePaths is NULL in remote debugging scenarios.
    // It will be non-null in pseudo-remote, and local debugging scenarios.
    // Return value    : S_OK is returned if *ppValue is non-NULL, S_FALSE is returned
    // when *ppValue is NULL, and failure codes are used for any error.
    static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetJustMyCodePaths(
        _Deref_out_opt_ DkmReadOnlyCollection<DkmString*>** ppNativeJustMyCodePaths
        );
    // Obtains the process id of the process which is logically the root process of the
    // Visual Studio or remote debugger instance. In Visual Studio scenarios, this will
    // be the process id of Visual Studio. In remote debugger scenarios, this is the
    // process id of the root msvsmon.exe instance.
    //
    // This API was introduced in Visual Studio 11 Feature Pack 1
    // (DkmApiVersion.VS11FeaturePack1).
    static DECLSPEC_NOTHROW DWORD STDMETHODCALLTYPE RootProcessId(
        );
    // Opens the specified subkey under the Visual Studio registry root for read acceess.
    // This function will work in all local debugging scenarios (including pseuo-remote).
    // It will return E_NOTIMPL in true-remote scenarios.
    //
    // This API was introduced in Visual Studio 12 Update 3 (DkmApiVersion.VS12Update3).
    // szSubKey        : [In,Optional] The subkey to open. If null or empty, the main
    // VS registry key will be opened.
    // phkResult       : [Out] Handle to the opened registry key. This should be closed
    // with RegCloseKey.
    // Return value    : S_OK on success, E_NOTIMPL if remote debugging, otherwise system
    // errors will be returned.
    static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE OpenVSSettingsKey(
        _In_opt_z_ LPCWSTR szSubKey,
        _Out_ HKEY* phkResult
        );
#ifndef EXCLUDE_IDE_ONLY_APIS
    // Retrieves the IVsTelemetryService for Visual Studio. This function should only be called from
    // client side components.
    //
    // This API was introduced in Visual Studio 14 RTM (DkmApiVersion.VS14RTM).
    // ppTelemetryService   : [Out,Optional] IUnknown pointer to the IVsTelemetryService.
    // Return Value         : S_OK is returned if *ppTelemetryService is non-NULL, S_FALSE is returned
    // otherwise.
    static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetVsTelemetryService(
        _Deref_out_opt_ IUnknown** ppTelemetryService
        );
#endif
};

#ifndef EXCLUDE_IDE_ONLY_APIS
// Static class which provides an API to execute code on the main thread of Visual Studio
/*static*/ class DkmMainVsThread
{
public:
    /// <summary>
    /// Invokes a routine on the main thread of Visual Studio, providing access to
    /// Visual Studio's global service provider. This API is only supported for
    /// components implemented in native code. Components implemented in managed code
    /// should use Microsoft.VisualStudio.Shell.ThreadHelper.Invoke instead.
    /// </summary>
    /// <param name="pMainThreadRoutine">
    /// [In] Interface to invoke on the UI thread.
    /// </param>
    /// <returns>
    /// E_NOTIMPL is returned when running in a host that doesn't support this, such
    /// as the debugger's test harness - glass2.exe.
    /// RPC_E_DISCONNECTED if there is no active session.
    /// Otherwise the result of invoking the routine is returned.
    /// </returns>
    static HRESULT STDMETHODCALLTYPE Invoke(
        _In_ interface IDkmMainThreadRoutine* pMainThreadRoutine
        );
};

#define IID_IDkmMainThreadRoutine __uuidof(Microsoft::VisualStudio::Debugger::IDkmMainThreadRoutine)

// Interface which is called on the main thread of Visual Studio. To execute some action
// that requires access to Visual Studio services.
interface DECLSPEC_NOVTABLE DECLSPEC_UUID("35C093B5-6E03-4DFE-8664-EEC20FFA4FD4") IDkmMainThreadRoutine : public IUnknown
{
    /// <summary>
    /// Method which will be called on Visual Studio's main thread. Note that code
    /// which runs within the implementation of this method will not have access to data
    /// items -- DkmDataContainer.GetDataItem will fail to find data items
    /// associated with the calling component, and DkmDataContainer.SetDataItem
    /// will incorrectly associate data items with the IDE rather than any particular
    /// component. Also note that any code that is called from this method must be
    /// prepared for apartment reentrancy as this handler will be run the next time
    /// the calling code pushes any sort of message pump (and not just when the UI
    /// thread isn't doing anything else).
    /// </summary>
    /// <param name="pVsGlobalServiceProvider">
    /// [In] Visual Studio's global service provider. This can be used to obtain Visual
    /// Studio services.
    /// </param>
    virtual HRESULT STDMETHODCALLTYPE Execute(
        _In_ IServiceProvider* pVsGlobalServiceProvider
        ) = 0;
};
#endif


// Describes the event being processed.
class DECLSPEC_UUID("1ff2acd1-b938-46ad-8eaa-422af78bc305") DkmEventDescriptor
{
    // This class cannot be created
    private: DkmEventDescriptor();
    // This class cannot be deleted
    protected: ~DkmEventDescriptor();
    // This class cannot be copied
    private: DkmEventDescriptor& operator=(const DkmEventDescriptor&);
    private: DkmEventDescriptor(const DkmEventDescriptor&);

    // Returns the timestamp from QueryPerformanceCounter that is taken as soon
    // as the event starts propogating. Note that if one event creates another
    // event, this value is passed from the first event to ensure the timing
    // matches relative to any other event that may occur.
    // This API was introduced in Visual Studio 14 RTM (DkmApiVersion.VS14RTM).
    public: DECLSPEC_NOTHROW UINT64 STDMETHODCALLTYPE GetTimeStamp();

private:
    const DkmEventCode_t m_Code;
    const DWORD m_Id;
public:
    // Returns an enumeration code to indicate the type of event. May be helpful
    // in diagnostic logging.
    DkmEventCode_t Code()
    {
        return m_Code;
    }

    // Returns an id for the event. May be helpful in diagnostic logging.
    DWORD Id()
    {
        return m_Id;
    }
};

// Describes the event being processed and provides the ability for a component to
// suppress this event.
class DECLSPEC_UUID("14bb75d0-1ab6-4a8a-a47b-7cd68e96c8bb") DkmEventDescriptorS : public DkmEventDescriptor
{
    // This class cannot be created
    private: DkmEventDescriptorS();
    // This class cannot be deleted
    protected: ~DkmEventDescriptorS();
    // This class cannot be copied
    private: DkmEventDescriptorS& operator=(const DkmEventDescriptorS&);
    private: DkmEventDescriptorS(const DkmEventDescriptorS&);

private:
    BOOL m_suppress;

public:
    // Returns true if the event has been supressed (Supress() was called).
    bool IsSuppressed()
    {
        return m_suppress != 0;
    }

public:
    // This method is used to suppress event processing for this event. When called,
    // the event will not be seen by components with a greater component level than the
    // suppressing component.
    DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Suppress(
        )
    {
        m_suppress = true;
        return S_OK;
    }
};


typedef struct {}* DkmComponentHandle;

/* static*/ class DkmComponentManager
{
private:
    // Class cannot be created
    DkmComponentManager();
    DkmComponentManager(const DkmComponentManager&);

public:
    // Initialize a thread with the component manager. This is necessary when a component
    // creates one or more worker threads. InitializeThread should only be called once,
    // it should be called after COM has been initialized, and must have a matching call
    // to UninitializeThread. InitializeThread will return S_FALSE if the same thread is
    // initialized multiple times with the same component id. Callers can use this
    // as a hint that UninitializeThread should not be called.
    // guidComponentId : Component ID of the thread.
    static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE InitializeThread(
        _In_ REFGUID guidComponentId
        );

    // Initialize a thread with the component manager. InitializeThreadByHandle will return
    // S_FALSE if the same thread is initialized multiple times with the same component handle.
    // Callers can use this as a hint that UninitializeThreadByHandle should not be called.
    // Unlike InitializeThread, this method uses a previously found component handle instead of a
    // guid. This allows faster thread initialization.
    // ComponentHandle : The component handle to initialize on the thread. This must be obtained
    // with FindComponentHandle.
    static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE InitializeThreadByHandle(
        _In_ DkmComponentHandle ComponentHandle
        );

    // Clean up a thread which was previously initialized with a call to
    // DkmComponentManager::InitializeThreadByHandle.
    // ComponentHandle : Component handle, obtained from FindComponentHandle.
    static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE UninitializeThreadByHandle(
        _In_ DkmComponentHandle ComponentHandle
        );

    // Clean up a thread which was previously initialized with a call to
    // DkmComponentManager::InitializeThread.
    // guidComponentId : Component ID of the thread.
    static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE UninitializeThread(
        _In_ REFGUID guidComponentId
        );
    // Obtain the component ID which is running on this thread. E_XAPI_NOT_INITIALIZED
    // is returned if the thread has not been initialized.
    static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetCurrentComponentId(
        _Out_ GUID* pComponentId
        );

    // Release the component lock for a synchronized component. This can be very
    // dangerous as it will allow component re-entrancy. The normal way to use this
    // is to release the lock on a call that exits a compoent and retake the lock
    // as soon as the call completes.
    static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE AllowComponentReentrancy(
        );

    // Relock a synchronized component after a call to ReleaseComponentLock.
    // This can be very dangerous as it will allow component re-entrancy.
    // The normal way to use this is to release the lock on a call that exits
    // a compoent and retake the lock
    // as soon as the call completes.
    static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE DisableComponentReentrancy(
        );

    // Returns true if the version of the Dispatcher is greater than or equal to
    // the specified API version.
    static DECLSPEC_NOTHROW bool STDMETHODCALLTYPE IsApiVersionSupported(
        _In_ DkmApiVersion_t apiVersion
        );

    // Returns a component handle, based on the component guid. The component handle
    // should only be used to call [Un]InitializeThreadByHandle or [Push]PopComponentHandle without
    // having to perform a search for the component every time based on its GUID
    static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE FindComponentHandle(
        _In_ REFGUID componentInfo,
        _Deref_out_ DkmComponentHandle* pComponentHandle
        );

    static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE PushComponentTransition(
        _In_ DkmComponentHandle ComponentHandle
        );

    static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE PopComponentTransition(
        _In_ DkmComponentHandle ComponentHandle
        );
};

// Identifies a DkmRuntimeInstance object within a process.
struct DECLSPEC_UUID("38ab90f5-dd83-b247-4d45-bd415c909b21") DkmRuntimeInstanceId
{
    // Indicates which type of runtime instance this is (ex: native code, CLR, etc).
    GUID RuntimeType;

    // Used along with the 'RuntimeType' to uniquely identify a particular runtime
    // instance within a given DkmProcess. If the 'RuntimeType' only supports a single
    // runtime instance per process (ex: DkmRuntimeId.Native), this value is typically
    // zero. For DkmRuntimeId.Clr, this value is the base address of the CLR dll.
    UINT64 InstanceId;

    // Compare an instance of the DkmRuntimeInstanceId struct to another instance.
    // Return value is as follows:
    // Less than zero:     This instance is less than 'other'.
    // Zero:               This instance is equal to 'other'.
    // Greater than zero:  This instance is greater than 'other'.
    DECLSPEC_NOTHROW int STDMETHODCALLTYPE CompareTo(
        const DkmRuntimeInstanceId& other
        ) const;

    bool operator==(const DkmRuntimeInstanceId& rhs) const     { return CompareTo(rhs) == 0; }
    bool operator!=(const DkmRuntimeInstanceId& rhs) const     { return CompareTo(rhs) != 0; }
    bool operator> (const DkmRuntimeInstanceId& rhs) const     { return CompareTo(rhs) > 0;  }
    bool operator< (const DkmRuntimeInstanceId& rhs) const     { return CompareTo(rhs) < 0;  }
    bool operator>=(const DkmRuntimeInstanceId& rhs) const     { return CompareTo(rhs) >= 0; }
    bool operator<=(const DkmRuntimeInstanceId& rhs) const     { return CompareTo(rhs) <= 0; }

    // Release all reference-counted fields within the DkmRuntimeInstanceId structure.
    static DECLSPEC_NOTHROW void STDMETHODCALLTYPE Release(
        _In_ DkmRuntimeInstanceId* pItem
        )
    {
        // structure requires no cleanup
    }
};

// Enumeration code of the various versions of this API.
DEFINE_SCOPED_ENUM(DkmApiVersion)
{
    // Visual Studio 11 Release to Manufacturing (RTM) version
    VS11RTM = 0xB000001,
    // Visual Studio 11 Update 1
    VS11FeaturePack1 = 0xB000002,
    // Visual Studio 11 Update 2
    VS11Update2 = 0xB000003,
    // Visual Studio 12 Release to Manufacturing (RTM) version
    VS12RTM = 0xC000000,
    // Visual Studio 12 Update 2
    VS12Update2 = 0xC000001,
    // Visual Studio 12 Update 3
    VS12Update3 = 0xC000003,
    // Visual Studio 14 Release to Manufacturing (RTM) version
    VS14RTM = 0xE000003
};

// Indicates the type of async-break that occurred.
DEFINE_SCOPED_ENUM(DkmAsyncBreakStatus)
{
    // An active thread was found inside the target process and the debugger used it to
    // break.
    ActiveBreak = 0,
    // The target process appears to be deadlocked and was frozen to emulate break mode.
    FrozenBreak = 1,
    // The caller of AsyncBreak requested an immediate break. The target process is
    // frozen to emulate break mode.
    ImmediateBreak = 2
};

// DkmBaseDebugMonitorId identifies the base debug monitor used to inspect and control
// the debugged process. For example, DkmBaseDebugMonitorId.WindowsProcess is used for
// processes debugged by the Win32 debugging API and DkmBaseDebugMonitorId.DumpFile is
// used for minidumps.
struct DkmBaseDebugMonitorId
{
    // DkmProcess is backed by a live Microsoft Windows process.
    // WindowsProcess is defined as {8ed4705e-401a-4f04-a0c9-5b7d7c679ec4}.
    static const GUID WindowsProcess;
    // DkmProcess is debugged using ONLY the ICorDebug API (the process is not being
    // debugging through the Win32 debugging API). This value is used when debugging with
    // the ICorDebug v2 pipeline. Scenarios include debugging a Win32 process running the
    // v2 CLR and debugging a managed process running on a Windows CE device.
    // ClrVirtualMachine is defined as {ff26db58-d56b-4420-a069-82b947de1ea0}.
    static const GUID ClrVirtualMachine;
    // DkmProcess is back by a minidump or crashdump file.
    // DumpFile is defined as {5283b2bd-0738-41fd-8a3c-8be6745cce3f}.
    static const GUID DumpFile;
    // DkmProcess is backed by a live Microsoft Windows ActiveScript process.
    // ActiveScript is defined as {9fb039e3-af4b-41ea-8b5f-c1e52138ffb8}.
    static const GUID ActiveScript;
    // DkmProcess is backed by a live Microsoft Windows D3D process that runs GPU code on
    // GPU hardware or reference rasterizer.
    // GpuVirtualMachine is defined as {72e62fa3-9001-40f1-9d75-ad1166a9ff41}.
    static const GUID GpuVirtualMachine;
    // DkmProcess is a live win32 process being debugged with the legacy in-process CLR
    // interop model. Both managed and native code can be debugged.
    // InProcessManagedNativeInterop is defined as {2a76521b-69f7-4919-b693-79f1dc5aee27}.
    static const GUID InProcessManagedNativeInterop;
    // Managed/native interop dump debugging.
    // DumpFileInterop is defined as {0d1e3537-15c6-4ba4-9c32-5e1c13197e19}.
    static const GUID DumpFileInterop;
};
__declspec(selectany) const GUID DkmBaseDebugMonitorId::WindowsProcess = { 0x8ed4705e, 0x401a, 0x4f04, { 0xa0, 0xc9, 0x5b, 0x7d, 0x7c, 0x67, 0x9e, 0xc4 } };
__declspec(selectany) const GUID DkmBaseDebugMonitorId::ClrVirtualMachine = { 0xff26db58, 0xd56b, 0x4420, { 0xa0, 0x69, 0x82, 0xb9, 0x47, 0xde, 0x1e, 0xa0 } };
__declspec(selectany) const GUID DkmBaseDebugMonitorId::DumpFile = { 0x5283b2bd, 0x738, 0x41fd, { 0x8a, 0x3c, 0x8b, 0xe6, 0x74, 0x5c, 0xce, 0x3f } };
__declspec(selectany) const GUID DkmBaseDebugMonitorId::ActiveScript = { 0x9fb039e3, 0xaf4b, 0x41ea, { 0x8b, 0x5f, 0xc1, 0xe5, 0x21, 0x38, 0xff, 0xb8 } };
__declspec(selectany) const GUID DkmBaseDebugMonitorId::GpuVirtualMachine = { 0x72e62fa3, 0x9001, 0x40f1, { 0x9d, 0x75, 0xad, 0x11, 0x66, 0xa9, 0xff, 0x41 } };
__declspec(selectany) const GUID DkmBaseDebugMonitorId::InProcessManagedNativeInterop = { 0x2a76521b, 0x69f7, 0x4919, { 0xb6, 0x93, 0x79, 0xf1, 0xdc, 0x5a, 0xee, 0x27 } };
__declspec(selectany) const GUID DkmBaseDebugMonitorId::DumpFileInterop = { 0xd1e3537, 0x15c6, 0x4ba4, { 0x9c, 0x32, 0x5e, 0x1c, 0x13, 0x19, 0x7e, 0x19 } };

// Message structure used to pass information between custom debugger backend components
// and custom visual studio UI components (packages, add-ins, etc).
class DECLSPEC_NOVTABLE DECLSPEC_UUID("d308a6ed-8e21-e7dd-abfa-9ae22434f9bc") DkmCustomMessage : public IUnknown
{
    private: ___ReferenceCount_t m_ReferenceCount;
    private: DkmDispatcherObjectFlags_t m_ObjectFlags;
    private: const GUID* m_pTypeId;
    private: size_t m_ObjectGCHandle;
    // Use DkmCustomMessage::Create to create this object
    private: DkmCustomMessage();
    // This object is refcounted. It is deleted through Release
    protected: ~DkmCustomMessage();
    // This object cannot be copied
    private: DkmCustomMessage& operator=(const DkmCustomMessage&);
    private: DkmCustomMessage(const DkmCustomMessage&);

    private: OPTIONAL DefaultPort::DkmTransportConnection* const m_pConnection;
    private: OPTIONAL DkmProcess* const m_pProcess;
    private: const GUID m_SourceId;
    private: const UINT32 m_MessageCode;
    private: OPTIONAL DkmVariant* const m_pParameter1;
    private: OPTIONAL DkmVariant* const m_pParameter2;
    private: void* m__pExtendedData;

    // [Optional] Transport connection used to send the message.
    public: _Ret_opt_ DECLSPEC_NOTHROW DefaultPort::DkmTransportConnection* STDMETHODCALLTYPE Connection(
        );

    // [Optional] DkmProcess represents a target process which is being debugged. The
    // debugger debugs processes, so this is the basic unit of debugging. A DkmProcess
    // can represent a system process or a virtual process such as minidumps.
    public: _Ret_opt_ DECLSPEC_NOTHROW DkmProcess* STDMETHODCALLTYPE Process(
        );

    // Identifies the source of an object. SourceIds are used to enable filtering in
    // scenarios when multiple components may be creating instances of a class. For
    // example, source ids can be used to determine if a breakpoint comes from the AD7 AL
    // (ex: user breakpoint, or other breakpoint visible at the SDM level) instead of a
    // breakpoint which may be created by another component (for example an internal
    // breakpoint used for stepping).
    public: DECLSPEC_NOTHROW const GUID& STDMETHODCALLTYPE SourceId(
        );

    // Identifies the type of custom event being sent. Partners are free to define any
    // set of values.
    public: DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE MessageCode(
        );

    // [Optional] Specifies additional message-specific information. Note that if this
    // message may need to travel over remoting boundaries, it is important to restrict
    // the type of this parameter to something which can be marshalled: strings,
    // primitives (ex: int), and arrays of primitives (ex: byte array).
    public: _Ret_opt_ DECLSPEC_NOTHROW DkmVariant* STDMETHODCALLTYPE Parameter1(
        );

    // [Optional] Specifies additional message-specific information. Note that if this
    // message may need to travel over remoting boundaries, it is important to restrict
    // the type of this parameter to something which can be marshalled: strings,
    // primitives (ex: int), and arrays of primitives (ex: byte array).
    public: _Ret_opt_ DECLSPEC_NOTHROW DkmVariant* STDMETHODCALLTYPE Parameter2(
        );

    /// <summary>
    /// Create a new DkmCustomMessage object instance.
    /// </summary>
    /// <param name="pConnection">
    /// [In,Optional] Transport connection used to send the message.
    /// </param>
    /// <param name="pProcess">
    /// [In,Optional] DkmProcess represents a target process which is being debugged. The
    /// debugger debugs processes, so this is the basic unit of debugging. A DkmProcess
    /// can represent a system process or a virtual process such as minidumps.
    /// </param>
    /// <param name="SourceId">
    /// [In] Identifies the source of an object. SourceIds are used to enable filtering
    /// in scenarios when multiple components may be creating instances of a class. For
    /// example, source ids can be used to determine if a breakpoint comes from the AD7
    /// AL (ex: user breakpoint, or other breakpoint visible at the SDM level) instead of
    /// a breakpoint which may be created by another component (for example an internal
    /// breakpoint used for stepping).
    /// </param>
    /// <param name="MessageCode">
    /// [In] Identifies the type of custom event being sent. Partners are free to define
    /// any set of values.
    /// </param>
    /// <param name="pParameter1">
    /// [In,Optional] Specifies additional message-specific information. Note that if
    /// this message may need to travel over remoting boundaries, it is important to
    /// restrict the type of this parameter to something which can be marshalled:
    /// strings, primitives (ex: int), and arrays of primitives (ex: byte array).
    /// </param>
    /// <param name="pParameter2">
    /// [In,Optional] Specifies additional message-specific information. Note that if
    /// this message may need to travel over remoting boundaries, it is important to
    /// restrict the type of this parameter to something which can be marshalled:
    /// strings, primitives (ex: int), and arrays of primitives (ex: byte array).
    /// </param>
    /// <param name="ppCreatedObject">
    /// [Out] Result of this method call.
    /// </param>
    /// <returns>
    /// S_OK is returned on success, and failure codes are used for any error.
    /// </returns>
    public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
        _In_opt_ DefaultPort::DkmTransportConnection* pConnection,
        _In_opt_ DkmProcess* pProcess,
        _In_ const GUID& SourceId,
        _In_ UINT32 MessageCode,
        _In_opt_ DkmVariant* pParameter1,
        _In_opt_ DkmVariant* pParameter2,
        _Deref_out_ DkmCustomMessage** ppCreatedObject
        );

    /// <summary>
    /// Raises a CustomStop event to a VS service which is expecting it. Note that there
    /// are restrictions on the type for parameters to this custom message. See
    /// DkmCustomMessage.SendToVsService for more information.
    /// </summary>
    /// <param name="pThread">
    /// [In] DkmThread represents a thread running in the target process.
    /// </param>
    /// <param name="VsService">
    /// [In] Visual Studio service that this event should be sent to. A VS package must
    /// register this service id (ex:
    /// Software\Microsoft\VisualStudio\$(ver)\Services\{VsService}) and this package
    /// must implement the IVsCustomDebuggerStoppingEventHandler110 interface.
    /// </param>
    /// <returns>
    /// S_OK is returned on success, and failure codes are used for any error.
    /// </returns>
    public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE OnCustomStop(
        _In_ DkmThread* pThread,
        _In_ const GUID& VsService
        );

    /// <summary>
    /// Sends a message to a listening component which is higher in the hierarchy.
    /// </summary>
    /// <param name="ppReplyMessage">
    /// [Out,Optional] Message sent back from the implementation.
    /// </param>
    /// <returns>
    /// S_OK is returned if *ppReplyMessage is non-NULL, S_FALSE is returned when
    /// *ppReplyMessage is NULL, and failure codes are used for any error.
    /// </returns>
    public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE SendHigher(
        _Deref_out_opt_ DkmCustomMessage** ppReplyMessage
        );

    /// <summary>
    /// Sends a message to a listening component which is lower in the hierarchy.
    /// </summary>
    /// <param name="ppReplyMessage">
    /// [Out,Optional] Message sent back from the implementation.
    /// </param>
    /// <returns>
    /// S_OK is returned if *ppReplyMessage is non-NULL, S_FALSE is returned when
    /// *ppReplyMessage is NULL, and failure codes are used for any error.
    /// </returns>
    public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE SendLower(
        _Deref_out_opt_ DkmCustomMessage** ppReplyMessage
        );

    /// <summary>
    /// Sends a message to a listening component which is lower in the hierarchy.
    ///
    /// This method will append a new work item to the specified work list, and return
    /// once the work item has been appended. The actual processing of the work item is
    /// asynchronous. The caller will be notified that the request is complete through
    /// the completion routine.
    /// </summary>
    /// <param name="pWorkList">
    /// WorkList to append the new work item to.
    /// </param>
    /// <param name="pCompletionRoutine">
    /// Routine to fire when the request is complete. If the request is successfully
    /// appended to the work list, this will always fire (including when the operation is
    /// canceled). This will never fire if appending the work item fails.
    /// </param>
    /// <returns>
    /// S_OK is returned on success, and failure codes are used for any error.
    /// </returns>
    public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE SendLower(
        _In_ DkmWorkList* pWorkList,
        _In_ IDkmCompletionRoutine<DkmSendLowerAsyncResult>* pCompletionRoutine
        );

    /// <summary>
    /// Sends a custom message to a Visual Studio package. This can be used, for example,
    /// to drive a custom UI or make a custom UI visible by enabling a command context
    /// (IVsMonitorSelection.SetCmdUIContext).
    ///
    /// For local 32-bit debugging, the custom message parameters
    /// (DkmCustomMessage.Parameter1/2), may contain any value (ex: object/IUnknown,
    /// string, etc), however, values are transferred between threads without
    /// marshalling, so in cases where this will not work, the sender is responsible for
    /// converting the parameter into a form which can be used from the VS service (ex:
    /// calling ole32!CoMarshalInterThreadInterfaceInStream).
    ///
    /// For remote debugging, and 64-bit debugging, the custom message parameters are
    /// marshalled across machines, and so the restrictions describe in the
    /// DkmCustomMessage.Parameter1 documentation applies.
    /// </summary>
    /// <param name="VsService">
    /// [In] Visual Studio service that this event should be sent to. A VS package must
    /// register this service id. The service class must implement the
    /// IVsCustomDebuggerEventHandler110 interface. Services can be registered in the
    /// registry ($RootKey$\Services\{VsService}), or through the VS shell
    /// IProfferService interface. Registry keys may be set through .pkgdef files. If the
    /// service should be called even if it is not already loaded, then the registry
    /// approach should be used. If the service should only be called if it has already
    /// been started, then IProfferService should be used.
    /// </param>
    /// <param name="IsBlocking">
    /// [In] True if SendToPackage should block waiting for the package to finish
    /// processing this message.
    ///
    /// Note that before Visual Studio 2015, when true, DkmCustomMessage.Process must be
    /// non-null. This requirement was dropped in Visual Studio 2015.
    /// </param>
    /// <returns>
    /// S_OK is returned on success, and failure codes are used for any error.
    /// </returns>
    public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE SendToVsService(
        _In_ const GUID& VsService,
        _In_ bool IsBlocking
        );
}; // end of DkmCustomMessage

// Action to be taken if the data item is already in the container.
DEFINE_SCOPED_ENUM(DkmDataCreationDisposition)
{
    // Add the data item only if there is no other data item with the same id.
    CreateNew = 0,
    // Always add the data item. If the data item is already present then overwrite it
    // with the new value.
    CreateAlways = 1
};

// Internal flags indicating the current state of a dispatcher object.
DEFINE_SCOPED_ENUM(DkmDispatcherObjectFlags)
{
    // No flags are currently set
    None = 0x0,
    // Object has been fully initialized and has not been closed
    ObjectAlive = 0x1,
    // Object has been unloaded
    ObjectUnloaded = 0x2,
    // Critical Section has been initialized
    LockInitialized = 0x4,
    // Object is hidden from components which are above the creation level.
    RestrictVisibilityAboveCreationLevel = 0x8,
    // Object is hidden from components which are below the creation level.
    RestrictVisibilityBelowCreationLevel = 0x10,
    // Reference object has been marshalled into its associated connection
    RemoteMarshalled = 0x20
};
DEFINE_SCOPED_ENUM_FLAG_OPERATORS(DkmDispatcherObjectFlags_t);

// Result of an asynchronous DkmUserMessage.DisplayPrompt call.
struct DkmDisplayUserMessagePromptAsyncResult
{
    // HRESULT code returned from the caller. This will be
    // DkmExceptionCode.COR_E_OPERATIONCANCELED (0x8013153B) if the operation was
    // canceled before processing was complete.
    HRESULT ErrorCode;

    // Win32 'ID' code from displaying the message box (ex: IDYES). These codes are
    // defined in winuser.h from the Windows SDK.
    UINT32 Result;
};

// Type of dump to save.
DEFINE_SCOPED_ENUM(DkmDumpType)
{
    // Save a basic minidump. Global memory, heap memory, and modules are not included.
    Minidump = 0,
    // Save a full minidump. Global memory, heap memory, and modules are included.
    MinidumpWithFullMemory = 1
};

// Flags that indicate immutable traits of this engine settings.
DEFINE_SCOPED_ENUM(DkmEngineFlags)
{
    // No process debug flags are set.
    None = 0x0,
    // This flag should no longer be read, instead use
    // DkmDebugLaunchSettings.IsNativeCodeSupported(). This flag may still be written and
    // indicates that this engine id supports native code debugging.
    NativeCodeSupported = 0x1,
    // Engine will use Just My Code when enabled from the IDE.
    JustMyCodeSupported = 0x2
};
DEFINE_SCOPED_ENUM_FLAG_OPERATORS(DkmEngineFlags_t);

// These are the 'standard' engine GUID values. It is expected that this list will grow
// over time, so where possible, it is recommended to query for a setting instead of
// comparing the EngineId.
struct DkmEngineId
{
    // Native-only debugging engine Guid.
    // NativeEng is defined as {3b476d35-a401-11d2-aad4-00c04f990171}.
    static const GUID NativeEng;
    // Debug engine for debugging all code within a Win32 process.
    // COMPlusNativeEng is defined as {92ef0900-2251-11d2-b72e-0000f87572ef}.
    static const GUID COMPlusNativeEng;
    // Debug engine for debugging CLR code within the desktop CLR v2.0. For example, a VB
    // application. When debugging in this mode, native debugging is not possible.
    // COMPlusOnlyEng2 is defined as {5fff7536-0c87-462d-8fd2-7971d948e6dc}.
    static const GUID COMPlusOnlyEng2;
    // Debug engine for debugging CLR code within CLR v4. When debugging in this mode,
    // native debugging is not possible.
    // COMPlusOnlyEng4 is defined as {fb0d4648-f776-4980-95f8-bb7f36ebc1ee}.
    static const GUID COMPlusOnlyEng4;
    // Debug engine for debugging only user CLR code inside the Microsoft SQL Server
    // process.
    // COMPlusSQLLocalEng is defined as {e04bde58-45ec-48db-9807-513f78865212}.
    static const GUID COMPlusSQLLocalEng;
    // Debug engine used for Silverlight debugging.
    // SilverlightEng is defined as {032f4b8c-7045-4b24-accf-d08c9da108fe}.
    static const GUID SilverlightEng;
    // Debug engine used for .NET Compact Framework v1 debugging.
    // EmbeddedClrEngV1 is defined as {123d150b-fa18-461c-b218-45b3e4589f9b}.
    static const GUID EmbeddedClrEngV1;
    // Debug engine used for .NET Compact Framework v2 debugging.
    // EmbeddedClrEngV2 is defined as {8c37b683-c921-4076-ac47-ec6da03fa658}.
    static const GUID EmbeddedClrEngV2;
    // Debug engine used for debugging Silverlight apps on Apple computers.
    // MacSilverlightEng is defined as {22189d02-cca4-40ae-a874-6c2a764fb071}.
    static const GUID MacSilverlightEng;
    // Debug engine used for active script debugging (ex: script in Microsoft Internet
    // Explorer).
    // Script is defined as {f200a7e7-dea5-11d0-b854-00a0244a1de2}.
    static const GUID Script;
    // Debug engine used for Core CLR debugging in Silverlight and XNA apps on Windows
    // Phone.
    // CoreSystemClr is defined as {2e36f1d4-b23c-435d-ab41-18e608940038}.
    static const GUID CoreSystemClr;
    // Debug engine used for Concord interop CLR v2. This GUID is used within Concord and
    // is not known above the AD7 layer.
    // InteropEngineV2 is defined as {1c23520a-8dba-4f3c-b228-8add24c0a1fe}.
    static const GUID InteropEngineV2;
    // Debug engine used for Concord interop CLR v4. This GUID is used within Concord and
    // is not known above the AD7 layer.
    // InteropEngineV4 is defined as {29c2639d-0c6f-4ae8-9b09-0cfb2f075fdf}.
    static const GUID InteropEngineV4;
    // Debug an application running under the native-compiled .NET Framework.
    // ClrNativeCompilation is defined as {47843766-18ee-4226-b2ee-0baa38e1e0d3}.
    static const GUID ClrNativeCompilation;
};
__declspec(selectany) const GUID DkmEngineId::NativeEng = { 0x3b476d35, 0xa401, 0x11d2, { 0xaa, 0xd4, 0x0, 0xc0, 0x4f, 0x99, 0x1, 0x71 } };
__declspec(selectany) const GUID DkmEngineId::COMPlusNativeEng = { 0x92ef0900, 0x2251, 0x11d2, { 0xb7, 0x2e, 0x0, 0x0, 0xf8, 0x75, 0x72, 0xef } };
__declspec(selectany) const GUID DkmEngineId::COMPlusOnlyEng2 = { 0x5fff7536, 0xc87, 0x462d, { 0x8f, 0xd2, 0x79, 0x71, 0xd9, 0x48, 0xe6, 0xdc } };
__declspec(selectany) const GUID DkmEngineId::COMPlusOnlyEng4 = { 0xfb0d4648, 0xf776, 0x4980, { 0x95, 0xf8, 0xbb, 0x7f, 0x36, 0xeb, 0xc1, 0xee } };
__declspec(selectany) const GUID DkmEngineId::COMPlusSQLLocalEng = { 0xe04bde58, 0x45ec, 0x48db, { 0x98, 0x7, 0x51, 0x3f, 0x78, 0x86, 0x52, 0x12 } };
__declspec(selectany) const GUID DkmEngineId::SilverlightEng = { 0x32f4b8c, 0x7045, 0x4b24, { 0xac, 0xcf, 0xd0, 0x8c, 0x9d, 0xa1, 0x8, 0xfe } };
__declspec(selectany) const GUID DkmEngineId::EmbeddedClrEngV1 = { 0x123d150b, 0xfa18, 0x461c, { 0xb2, 0x18, 0x45, 0xb3, 0xe4, 0x58, 0x9f, 0x9b } };
__declspec(selectany) const GUID DkmEngineId::EmbeddedClrEngV2 = { 0x8c37b683, 0xc921, 0x4076, { 0xac, 0x47, 0xec, 0x6d, 0xa0, 0x3f, 0xa6, 0x58 } };
__declspec(selectany) const GUID DkmEngineId::MacSilverlightEng = { 0x22189d02, 0xcca4, 0x40ae, { 0xa8, 0x74, 0x6c, 0x2a, 0x76, 0x4f, 0xb0, 0x71 } };
__declspec(selectany) const GUID DkmEngineId::Script = { 0xf200a7e7, 0xdea5, 0x11d0, { 0xb8, 0x54, 0x0, 0xa0, 0x24, 0x4a, 0x1d, 0xe2 } };
__declspec(selectany) const GUID DkmEngineId::CoreSystemClr = { 0x2e36f1d4, 0xb23c, 0x435d, { 0xab, 0x41, 0x18, 0xe6, 0x8, 0x94, 0x0, 0x38 } };
__declspec(selectany) const GUID DkmEngineId::InteropEngineV2 = { 0x1c23520a, 0x8dba, 0x4f3c, { 0xb2, 0x28, 0x8a, 0xdd, 0x24, 0xc0, 0xa1, 0xfe } };
__declspec(selectany) const GUID DkmEngineId::InteropEngineV4 = { 0x29c2639d, 0xc6f, 0x4ae8, { 0x9b, 0x9, 0xc, 0xfb, 0x2f, 0x7, 0x5f, 0xdf } };
__declspec(selectany) const GUID DkmEngineId::ClrNativeCompilation = { 0x47843766, 0x18ee, 0x4226, { 0xb2, 0xee, 0xb, 0xaa, 0x38, 0xe1, 0xe0, 0xd3 } };

// Contains the session-wide debug settings. There is one instance of this object per
// engine Guid (ex: one instance for COMPlusOnlyEng2, one instance for COMPlusNativeEng).
class DECLSPEC_NOVTABLE DECLSPEC_UUID("3c1f22df-556c-18bf-7584-c2c649777bfe") DkmEngineSettings : public DkmDataContainer
{
    // Use DkmEngineSettings::Create to create this object
    private: DkmEngineSettings();
    // This object is refcounted. It is deleted through Release
    protected: ~DkmEngineSettings();
    // This object cannot be copied
    private: DkmEngineSettings& operator=(const DkmEngineSettings&);
    private: DkmEngineSettings(const DkmEngineSettings&);

    // Contains additional fields of DkmEngineSettings which were added after the class
    // was initally introduced.
    private: struct ___ExtendedData
    {
        ___ExtendedData();

        // The maximum number of frames supported in the call stack window.
        const UINT32 MaxCallStackFrames;

        // Enables Edit and Continue.
        const bool IsEditAndContinue;

        // True if the debugger should validate the digital signatures of CLR debugging
        // libraries before loading them.
        const bool ValidateFilesForMinidumps;

        // [Optional] List of registry tweaks in the Visual Studio registry that
        // components may use to customize their behavior.  Registry tweaks are read from
        // the key [Visual Studio Registry Root]\Debugger\Engine at the start of each
        // debug session.
        OPTIONAL DkmReadOnlyCollection<DkmRegistryTweak*>* const pRegistryTweaks;

        // [Optional] Trace settings for WPF output.
        OPTIONAL DkmString* pTraceSettings;
    };

    private: const GUID m_EngineId;
    private: const DkmEngineFlags_t m_Flags;
    private: const Clr::DkmClrDebuggingServicesId_t m_ClrDebuggingServicesId;
    private: DkmReadOnlyCollection<Evaluation::DkmLanguage*>* const m_pLanguages;
    private: DkmReadOnlyCollection<Symbols::DkmImageDebugDirectoryFormat>* const m_pImageDebugDirectoryFormats;
    private: const bool m_EnableFuncEvalQuickAbort;
    private: DkmReadOnlyCollection<DkmString*>* const m_pFuncEvalQuickAbortExcludeList;
    private: const bool m_EnableAsyncDebugging;
    private: DkmReadOnlyCollection<DkmString*>* const m_pRemoteClrPdbNamePatterns;
    private: const GUID m_BaseDebugMonitorId;
    private: bool m_IsJustMyCodeEnabled;
    private: Symbols::DkmEngineSymbolSettings* m_pSymbolPaths;
    private: bool m_IsSuppressOptimizationsEnabled;
    private: bool m_IsStepOverPropertiesAndOperatorsEnabled;
    private: bool m_IsNativeExportsEnabled;
    private: bool m_IsGpuRaceHazardsAllowSameSettingEnabled;
    private: bool m_RequireFullTrustForSourceServer;
    private: ___ExtendedData* const m__pExtendedData;
    private: void* m_pProcessCollection2;

    // These are the 'standard' engine GUID values. It is expected that this list will
    // grow over time, so where possible, it is recommended to query for a setting
    // instead of comparing the EngineId.
    public: DECLSPEC_NOTHROW const GUID& STDMETHODCALLTYPE EngineId(
        );

    // Flags that indicate immutable traits of this engine settings.
    public: DECLSPEC_NOTHROW DkmEngineFlags_t STDMETHODCALLTYPE Flags(
        );

    // Indicates which version of the CLR debugging services (mscordbi.dll or other
    // implementation of the ICorDebug API) should be used when debugging this process.
    public: DECLSPEC_NOTHROW Clr::DkmClrDebuggingServicesId_t STDMETHODCALLTYPE ClrDebuggingServicesId(
        );

    // Collection of all programming languages supported while debugging this process.
    public: _Ret_ DECLSPEC_NOTHROW DkmReadOnlyCollection<Evaluation::DkmLanguage*>* STDMETHODCALLTYPE Languages(
        );

    // List of supported values for IMAGE_DEBUG_DIRECTORY.Type.
    public: _Ret_ DECLSPEC_NOTHROW DkmReadOnlyCollection<Symbols::DkmImageDebugDirectoryFormat>* STDMETHODCALLTYPE ImageDebugDirectoryFormats(
        );

    // Specifies whether FEQA is enabled for this engine for this debug session.
    public: DECLSPEC_NOTHROW bool STDMETHODCALLTYPE EnableFuncEvalQuickAbort(
        );

    // List of executables for whom FEQA isn't enabled even if FEQA DLLs are loaded.
    public: _Ret_ DECLSPEC_NOTHROW DkmReadOnlyCollection<DkmString*>* STDMETHODCALLTYPE FuncEvalQuickAbortExcludeList(
        );

    // Enables stepping over 'await' statements and stepping out of async methods. This
    // is on by default.
    public: DECLSPEC_NOTHROW bool STDMETHODCALLTYPE EnableAsyncDebugging(
        );

    // List of PDB name patterns used to determine if PDB will be loaded on remote side.
    public: _Ret_ DECLSPEC_NOTHROW DkmReadOnlyCollection<DkmString*>* STDMETHODCALLTYPE RemoteClrPdbNamePatterns(
        );

    // Base debug monitor used by this engine. This value may be Guid.Empty (GUID_NULL)
    // if the engine may use various base debug monitors depending on the process being
    // debugged.
    public: DECLSPEC_NOTHROW const GUID& STDMETHODCALLTYPE BaseDebugMonitorId(
        );

    // The maximum number of frames supported in the call stack window.
    //
    // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
    public: DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE MaxCallStackFrames(
        );

    // Enables Edit and Continue.
    //
    // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
    public: DECLSPEC_NOTHROW bool STDMETHODCALLTYPE IsEditAndContinue(
        );

    // True if the debugger should validate the digital signatures of CLR debugging
    // libraries before loading them.
    //
    // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
    public: DECLSPEC_NOTHROW bool STDMETHODCALLTYPE ValidateFilesForMinidumps(
        );

    // [Optional] List of registry tweaks in the Visual Studio registry that components
    // may use to customize their behavior.  Registry tweaks are read from the key
    // [Visual Studio Registry Root]\Debugger\Engine at the start of each debug session.
    //
    // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
    public: _Ret_opt_ DECLSPEC_NOTHROW DkmReadOnlyCollection<DkmRegistryTweak*>* STDMETHODCALLTYPE RegistryTweaks(
        );

    // When true, the debugger will enable JustMyCode features (stepping, call stack, and
    // exception filtering).
    public: DECLSPEC_NOTHROW bool STDMETHODCALLTYPE IsJustMyCodeEnabled(
        );

    // A collection of DkmStrings representing the symbol search paths and cache path.
    public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetSymbolPaths(
        _Deref_out_ Symbols::DkmEngineSymbolSettings** ppValue);

    // When true, the debugger will suppress Just-In-Time compiler optimizations for
    // newly-loaded modules.
    public: DECLSPEC_NOTHROW bool STDMETHODCALLTYPE IsSuppressOptimizationsEnabled(
        );

    // When true, the debugger will step over properties and operators when a step in is
    // done.
    public: DECLSPEC_NOTHROW bool STDMETHODCALLTYPE IsStepOverPropertiesAndOperatorsEnabled(
        );

    // When true, the debugger will will attempt to use the export tables from Win32 PE
    // files to resolve addresses.
    public: DECLSPEC_NOTHROW bool STDMETHODCALLTYPE IsNativeExportsEnabled(
        );

    // When true, the debugger will ignore GPU race hazards that didn't change the
    // previous data.
    public: DECLSPEC_NOTHROW bool STDMETHODCALLTYPE IsGpuRaceHazardsAllowSameSettingEnabled(
        );

    // When true, the debugger will require assemblies to be fully trusted before
    // executing source server commands from an assembly. The concept of fully trusted
    // only applies to CLR assemblies.
    public: DECLSPEC_NOTHROW bool STDMETHODCALLTYPE RequireFullTrustForSourceServer(
        );

    // [Optional] Trace settings for WPF output.
    //
    // This API was introduced in Visual Studio 14 RTM (DkmApiVersion.VS14RTM).
    public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetTraceSettings(
        _Deref_out_opt_ DkmString** ppValue);

    /// <summary>
    /// Find a DkmEngineSettings object. If no object with the given input key is
    /// present, FindSettings will fail.
    /// </summary>
    /// <param name="EngineId">
    /// [In] Search key used to find the element.
    /// </param>
    /// <param name="ppSettings">
    /// [Out] Result of the search.
    /// </param>
    /// <returns>
    /// S_OK is returned on success, and failure codes are used for any error.
    /// E_XAPI_OBJECT_NOT_FOUND indicates that the search key cannot be found.
    /// </returns>
    public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE FindSettings(
        _In_ const GUID& EngineId,
        _Deref_out_ DkmEngineSettings** ppSettings
        );

    /// <summary>
    /// GetSettings enumerates all the created DkmEngineSettings objects.
    /// </summary>
    /// <param name="pSettings">
    /// [Out] Array containing the enumerated elements.
    ///
    /// The memory for the DkmArray members is allocated by the method implementation
    /// using DkmAllocBytes/DkmAllocArray. It is freed by the caller using the
    /// CAutoDkmArray template or with DkmFreeMemory and manual element release.
    /// </param>
    /// <returns>
    /// S_OK is returned on success, and failure codes are used for any error.
    /// </returns>
    public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetSettings(
        _Out_ DkmArray<DkmEngineSettings*>* pSettings
        );

    /// <summary>
    /// Find a DkmProcess element within this DkmEngineSettings. If no element with the
    /// given input key is present, FindProcess will fail.
    /// </summary>
    /// <param name="UniqueId">
    /// [In] Search key used to find the element.
    /// </param>
    /// <param name="ppProcess">
    /// [Out] Result of the search.
    /// </param>
    /// <returns>
    /// S_OK is returned on success, and failure codes are used for any error.
    /// E_XAPI_OBJECT_NOT_FOUND indicates that the search key cannot be found.
    /// </returns>
    public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE FindProcess(
        _In_ const GUID& UniqueId,
        _Deref_out_ DkmProcess** ppProcess
        );

    /// <summary>
    /// GetProcesses enumerates the DkmProcess elements of this DkmEngineSettings object.
    /// </summary>
    /// <param name="pProcesses">
    /// [Out] Array containing the enumerated elements.
    ///
    /// The memory for the DkmArray members is allocated by the method implementation
    /// using DkmAllocBytes/DkmAllocArray. It is freed by the caller using the
    /// CAutoDkmArray template or with DkmFreeMemory and manual element release.
    /// </param>
    /// <returns>
    /// S_OK is returned on success, and failure codes are used for any error.
    /// </returns>
    public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetProcesses(
        _Out_ DkmArray<DkmProcess*>* pProcesses
        );

    /// <summary>
    /// Returns the DkmLanguage object which matches the given compiler id. If the
    /// language is unknown (not registered with the engine), then this method will
    /// return the default language object.
    /// </summary>
    /// <param name="CompilerId">
    /// [In] LanguageId/VendorId search key. Both values may be Guid.Empty to obtain the
    /// default language. Otherwise the vendor id must be non-zero or the default
    /// language object will be returned.
    /// </param>
    /// <param name="ppLanguage">
    /// [Out] Describes a programming language.
    /// </param>
    /// <returns>
    /// S_OK is returned on success, and failure codes are used for any error.
    /// </returns>
    public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetLanguage(
        _In_ const Evaluation::DkmCompilerId& CompilerId,
        _Deref_out_ Evaluation::DkmLanguage** ppLanguage
        );

    /// <summary>
    /// Returns the enumeration of DkmCodeViewCompilerId values. This enumeration may
    /// then be used by a symbol provider to map the information within a code view
    /// record to the DkmCompilerId structure.
    /// </summary>
    /// <param name="pCodeViewCompilers">
    /// [Out] DkmCodeViewCompilerId[] is used to translate information that is within the
    /// S_COMPILE* code view records into a DkmCompilerId. This allows the debugger to
    /// load an appropriate expression evaluator for a stack frame. Symbol providers may
    /// obtain this collection through DkmEngineSettings. Expression evaluators may add
    /// additional entries to this collection by having their setup add sub key(s) to the
    /// '%VSRegistryRoot%\Debugger\CodeView Compilers' registry key.
    ///
    /// The memory for the DkmArray members is allocated by the method implementation
    /// using DkmAllocBytes/DkmAllocArray. It is freed by the caller using the
    /// CAutoDkmArray template or with DkmFreeMemory and manual element release.
    /// </param>
    /// <returns>
    /// S_OK is returned on success, and failure codes are used for any error.
    /// </returns>
    public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetCodeViewCompilers(
        _Out_ DkmArray<Symbols::DkmCodeViewCompilerId>* pCodeViewCompilers
        );

    /// <summary>
    /// Get the user document visual studio folder path.
    /// </summary>
    /// <param name="ppUserDocumentPath">
    /// [Out] Returns the user document visual studio path.
    /// </param>
    /// <returns>
    /// S_OK is returned on success, and failure codes are used for any error.
    /// </returns>
    public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetUserDocumentPath(
        _Deref_out_ DkmString** ppUserDocumentPath
        );
}; // end of DkmEngineSettings

// Enumeration of all events which are currently defined in this API.
DEFINE_SCOPED_ENUM(DkmEventCode)
{
    AsyncBreakComplete = 0,
    BoundBreakpointHit = 1,
    ComputeKernelExit = 2,
    CustomStop = 3,
    DebugMonitorException = 4,
    EmbeddedBreakpointHit = 5,
    EntryPoint = 6,
    ExceptionContinued = 7,
    ExceptionTriggerHit = 8,
    FuncEvalCompleted = 9,
    FuncEvalStarting = 10,
    GPUSingleStepComplete = 11,
    InterceptExceptionCompleted = 12,
    LoadComplete = 13,
    ModuleCreate = 14,
    ModuleInstanceLoad = 15,
    ModuleInstanceUnload = 16,
    ModuleSymbolsLoaded = 17,
    ModuleSymbolsUpdated = 18,
    ProcessCreate = 19,
    ProcessExit = 20,
    ReturnValues = 21,
    RuntimeBreakpoint = 22,
    RuntimeInstanceLoad = 23,
    RuntimeInstanceUnload = 24,
    ScriptDocumentContentInsert = 25,
    ScriptDocumentContentRemove = 26,
    ScriptDocumentTreeNodeCreate = 27,
    ScriptDocumentTreeNodeUnload = 28,
    ScriptSymbolsUpdated = 29,
    SingleStepComplete = 30,
    StepComplete = 31,
    TaskProviderCreate = 32,
    ThreadCreate = 33,
    ThreadExit = 34,
    OutOfBandException = 35,
    BinaryLoaded = 36,
    ClrDebugMonitorExceptionCaught = 37,
    BinaryReloadOpportunity = 38,
    RuntimeInstanceLoadComplete = 39,
    HiddenEntryPoint = 40,
    ThreadNameChange = 41
};

// Indicates if there is a function evaluation occurring in the target process and if
// stopping events are allowed for this evaluation.
DEFINE_SCOPED_ENUM(DkmFuncEvalMode)
{
    // No function evaluation is currently in progress.
    NotEvaluating = 0,
    // A function evaluation is currently in progress. No stopping events are permitted
    // on the queried thread, so stopping events will be suppressed after the 'received'
    // phase of stopping event processing. This value is used when (1) the function
    // evaluation was started without the DkmFuncEvalFlags.AllowStoppingEvents flag -or-
    // (2) the queried thread is not the evaluating thread and
    // DkmFuncEvalFlags.RunAllThreads was not used.
    EvaluatingWithoutStoppingEvents = 1,
    // A function evaluation is currently in progress. Stopping events are permitted on
    // the queried thread, so if the queried thread hits a breakpoint, the debugger may
    // enter nested break state.
    EvaluatingWithStoppingEvents = 2
};

// Result of an asynchronous DkmInstructionAddress.GetCurrentCPUAddress call.
struct DkmGetCurrentCPUAddressAsyncResult
{
    // HRESULT code returned from the caller. This will be
    // DkmExceptionCode.COR_E_OPERATIONCANCELED (0x8013153B) if the operation was
    // canceled before processing was complete.
    HRESULT ErrorCode;

    // An array of the current CPU Instruction Addresses that map to this
    // DkmInstructionAddress.
    DkmArray<UINT64> InstructionPointers;
};

#ifndef EXCLUDE_IDE_ONLY_APIS
// Result of an asynchronous DkmProcess.GetInstructionAddress call.
struct DkmGetInstructionAddressAsyncResult
{
    // HRESULT code returned from the caller. This will be
    // DkmExceptionCode.COR_E_OPERATIONCANCELED (0x8013153B) if the operation was
    // canceled before processing was complete.
    HRESULT ErrorCode;

    // Abstract representation of an executable code location (ex: EIP value). If
    // resolved, an Instruction Address will be within a particular module instance. An
    // Instruction Address is always within a particular Runtime Instance.
    DkmInstructionAddress* pAddressObject;

    // True if this address is the first address in the line's range. False otherwise.
    bool FirstAddress;
};
#endif // #ifndef EXCLUDE_IDE_ONLY_APIS

// Abstract representation of an executable code location (ex: EIP value). If resolved,
// an Instruction Address will be within a particular module instance. An Instruction
// Address is always within a particular Runtime Instance.
//
// Derived classes: DkmClrInstructionAddress, DkmClrNcInstructionAddress,
// DkmCustomInstructionAddress, DkmNativeInstructionAddress, DkmScriptInstructionAddress,
// DkmUnknownInstructionAddress
class DECLSPEC_NOVTABLE DECLSPEC_UUID("6e2a219f-3a14-3410-e755-d00ce1f2f5e6") DkmInstructionAddress : public IUnknown
{
    private: ___ReferenceCount_t m_ReferenceCount;
    private: DkmDispatcherObjectFlags_t m_ObjectFlags;
    private: const GUID* m_pTypeId;
    private: size_t m_ObjectGCHandle;
    // Use DkmInstructionAddress::Create to create this object
    private: DkmInstructionAddress();
    // This object is refcounted. It is deleted through Release
    protected: ~DkmInstructionAddress();
    // This object cannot be copied
    private: DkmInstructionAddress& operator=(const DkmInstructionAddress&);
    private: DkmInstructionAddress(const DkmInstructionAddress&);

    // CPUInstruction provides the address that the CPU will execute. This is always
    // provided for native instructions. It may be provided for CLR or custom addresses
    // depending on how the address object was created.
    public: struct CPUInstruction
    {
        // The address of where the CPU instruction is located in the target process.
        UINT64 InstructionPointer;
    };

    // DkmInstructionAddress is an abstract base class. This enum indicates which derived
    // class this object is an instance of.
    public: FORWARD_DECLARE_SCOPED_ENUM(Tag);
    DEFINE_SCOPED_ENUM(Tag)
    {
    // Object is an instance of 'DkmNativeInstructionAddress'.
    NativeAddress = 0,
    // Object is an instance of 'DkmClrInstructionAddress'.
    ClrAddress = 1,
    // Object is an instance of 'DkmScriptInstructionAddress'.
    ScriptAddress = 2,
    // Object is an instance of 'DkmCustomInstructionAddress'.
    CustomAddress = 3,
    // Object is an instance of 'DkmUnknownInstructionAddress'.
    UnknownAddress = 4
    };

    private: OPTIONAL const DkmInstructionAddress::CPUInstruction* const m_pCPUInstruction;
    private: const Tag_t m_TagValue;
    private: DkmRuntimeInstance* const m_pRuntimeInstance;
    private: OPTIONAL DkmModuleInstance* const m_pModuleInstance;
    private: void* m__pExtendedData;

    // [Optional] CPUInstructionPart provides the address that the CPU will execute. This
    // is always provided for native instructions. It may be provided for CLR or custom
    // addresses depending on how the address object was created.
    public: _Ret_opt_ DECLSPEC_NOTHROW const DkmInstructionAddress::CPUInstruction* STDMETHODCALLTYPE CPUInstructionPart(
        );

    // DkmInstructionAddress is an abstract base class. This enum indicates which derived
    // class this object is an instance of.
    public: DECLSPEC_NOTHROW Tag_t STDMETHODCALLTYPE TagValue(
        );

    // The DkmRuntimeInstance class represents an execution environment which is loaded
    // into a DkmProcess and which contains code to be debugged.
    public: _Ret_ DECLSPEC_NOTHROW DkmRuntimeInstance* STDMETHODCALLTYPE RuntimeInstance(
        );

    // [Optional] The module containing this address. Addresses without a module cannot
    // have symbols (even for custom addresses). CLR addresses will always have a module.
    // Native addresses will not have a module if either the CPU jumped to an invalid
    // address (ex: NULL), or if the CPU is executing dynamically-emitted code.
    public: _Ret_opt_ DECLSPEC_NOTHROW DkmModuleInstance* STDMETHODCALLTYPE ModuleInstance(
        );

    // DkmProcess represents a target process which is being debugged. The debugger
    // debugs processes, so this is the basic unit of debugging. A DkmProcess can
    // represent a system process or a virtual process such as minidumps.
    public: _Ret_ DECLSPEC_NOTHROW DkmProcess* STDMETHODCALLTYPE Process(
        );

    /// <summary>
    /// Convert a DkmInstructionAddress into a DkmInstructionSymbol. If the
    /// DkmInstructionAddress is not in a DkmModule then GetSymbol will return null
    /// (S_FALSE in native code).
    /// </summary>
    /// <param name="ppSymbol">
    /// [Out,Optional] DkmInstructionSymbol represents a method in the target process.
    /// </param>
    /// <returns>
    /// S_OK is returned if *ppSymbol is non-NULL, S_FALSE is returned when *ppSymbol is
    /// NULL, and failure codes are used for any error.
    /// </returns>
    public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetSymbol(
        _Deref_out_opt_ Symbols::DkmInstructionSymbol** ppSymbol
        );

    /// <summary>
    /// Compares two instruction addresses and returns a value indicating whether one is
    /// less than, equal to, or greater than the other. The addresses must be from the
    /// same module.
    /// </summary>
    /// <param name="pOther">
    /// [In] An address to compare with this address.
    /// </param>
    /// <param name="pResult">
    /// [Out] A 32-bit signed integer that indicates the relative order of the objects
    /// being compared. The return value has the following meanings:
    ///
    /// Less than zero: This instance is less than 'other'. Zero: This instance is equal
    /// to 'other'. Greater than zero: This instance is greater than 'other'.
    /// </param>
    /// <returns>
    /// S_OK is returned on success, and failure codes are used for any error.
    /// </returns>
    public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE CompareTo(
        _In_ DkmInstructionAddress* pOther,
        _Out_ INT32* pResult
        );

    #ifndef EXCLUDE_IDE_ONLY_APIS
    /// <summary>
    /// Compares two instruction addresses and determines if they are within the same
    /// function.
    ///
    /// Location constraint: API must be called from an IDE component (component level
    /// &gt; 100,000).
    /// </summary>
    /// <param name="pOther">
    /// [In] An address to compare with this address.
    /// </param>
    /// <param name="pResult">
    /// [Out] True if the two addresses are from the same function.
    /// </param>
    /// <returns>
    /// S_OK is returned on success, and failure codes are used for any error.
    /// </returns>
    public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE IsInSameFunction(
        _In_ DkmInstructionAddress* pOther,
        _Out_ bool* pResult
        );
    #endif // #ifndef EXCLUDE_IDE_ONLY_APIS

    /// <summary>
    /// Resolves a DkmInstructionAddress to a CPU InstructionAddress. This is the reverse
    /// mapping of ResolveCPUInstructionAddress. This API is currently only supported by
    /// CLR DkmRuntimeInstance objects.
    ///
    /// Location constraint: This API should generally be called on the client, but it
    /// can be called on the server for translating CLR addresses (but not
    /// native-compiled).
    /// </summary>
    /// <param name="pInstructionPointers">
    /// [Out] An array of the current CPU Instruction Addresses that map to this
    /// DkmInstructionAddress.
    ///
    /// The memory for the DkmArray members is allocated by the method implementation
    /// using DkmAllocBytes/DkmAllocArray. It is freed by the caller using the
    /// CAutoDkmArray template or with DkmFreeMemory and manual element release.
    /// </param>
    /// <returns>
    /// S_OK is returned on success, and failure codes are used for any error.
    /// </returns>
    public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetCurrentCPUAddress(
        _Out_ DkmArray<UINT64>* pInstructionPointers
        );

    /// <summary>
    /// Resolves a DkmInstructionAddress to a CPU InstructionAddress. This is the reverse
    /// mapping of ResolveCPUInstructionAddress. This API is currently only supported by
    /// CLR DkmRuntimeInstance objects.
    ///
    /// This method will append a new work item to the specified work list, and return
    /// once the work item has been appended. The actual processing of the work item is
    /// asynchronous. The caller will be notified that the request is complete through
    /// the completion routine.
    ///
    /// Location constraint: This API should generally be called on the client, but it
    /// can be called on the server for translating CLR addresses (but not
    /// native-compiled).
    /// </summary>
    /// <param name="pWorkList">
    /// WorkList to append the new work item to.
    /// </param>
    /// <param name="pCompletionRoutine">
    /// Routine to fire when the request is complete. If the request is successfully
    /// appended to the work list, this will always fire (including when the operation is
    /// canceled). This will never fire if appending the work item fails.
    /// </param>
    /// <returns>
    /// S_OK is returned on success, and failure codes are used for any error.
    /// </returns>
    public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetCurrentCPUAddress(
        _In_ DkmWorkList* pWorkList,
        _In_ IDkmCompletionRoutine<DkmGetCurrentCPUAddressAsyncResult>* pCompletionRoutine
        );

    /// <summary>
    /// Determines if a given instruction address is user code or not.
    ///
    /// This method will append a new work item to the specified work list, and return
    /// once the work item has been appended. The actual processing of the work item is
    /// asynchronous. The caller will be notified that the request is complete through
    /// the completion routine.
    ///
    /// Location constraint: For managed, this can be called from any component.  For
    /// native, this can only be called from client-side components.
    ///
    /// This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
    /// </summary>
    /// <param name="pWorkList">
    /// WorkList to append the new work item to.
    /// </param>
    /// <param name="pCompletionRoutine">
    /// Routine to fire when the request is complete. If the request is successfully
    /// appended to the work list, this will always fire (including when the operation is
    /// canceled). This will never fire if appending the work item fails.
    /// </param>
    /// <returns>
    /// S_OK is returned on success, and failure codes are used for any error.
    /// </returns>
    public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE IsUserCode(
        _In_ DkmWorkList* pWorkList,
        _In_ IDkmCompletionRoutine<Symbols::DkmIsUserCodeAsyncResult>* pCompletionRoutine
        );
}; // end of DkmInstructionAddress

// Pairing between the name of a setting and its value.
class DECLSPEC_NOVTABLE DECLSPEC_UUID("e0271ff0-7cb5-6f49-e948-a82864f5744b") DkmLanguageRegistrySetting : public IUnknown
{
    private: ___ReferenceCount_t m_ReferenceCount;
    private: DkmDispatcherObjectFlags_t m_ObjectFlags;
    private: const GUID* m_pTypeId;
    private: size_t m_ObjectGCHandle;
    // Use DkmLanguageRegistrySetting::Create to create this object
    private: DkmLanguageRegistrySetting();
    // This object is refcounted. It is deleted through Release
    protected: ~DkmLanguageRegistrySetting();
    // This object cannot be copied
    private: DkmLanguageRegistrySetting& operator=(const DkmLanguageRegistrySetting&);
    private: DkmLanguageRegistrySetting(const DkmLanguageRegistrySetting&);

    private: DkmString* const m_pName;
    private: DkmVariant* const m_pValue;
    private: void* m__pExtendedData;

    // The name of the setting.
    public: _Ret_ DECLSPEC_NOTHROW DkmString* STDMETHODCALLTYPE Name(
        );

    // The value of the setting.  This can be either a DWORD or a string.
    public: _Ret_ DECLSPEC_NOTHROW DkmVariant* STDMETHODCALLTYPE Value(
        );

    /// <summary>
    /// Create a new DkmLanguageRegistrySetting object instance.
    /// </summary>
    /// <param name="pName">
    /// [In] The name of the setting.
    /// </param>
    /// <param name="pValue">
    /// [In] The value of the setting.  This can be either a DWORD or a string.
    /// </param>
    /// <param name="ppCreatedObject">
    /// [Out] Result of this method call.
    /// </param>
    /// <returns>
    /// S_OK is returned on success, and failure codes are used for any error.
    /// </returns>
    public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
        _In_ DkmString* pName,
        _In_ DkmVariant* pValue,
        _Deref_out_ DkmLanguageRegistrySetting** ppCreatedObject
        );
}; // end of DkmLanguageRegistrySetting

// Flags which indicate traits of a DkmModuleInstance.
DEFINE_SCOPED_ENUM(DkmModuleFlags)
{
    // No module flags are set.
    None = 0x0,
    // Module is backed by a file. Note that this is set even in cases where the module
    // could not be resolved (dll is missing, binary could not be found while examining a
    // minidump, etc).
    FileBacked = 0x1,
    // Module is backed by a file and the debug monitor was able to open this file.
    FileResolved = 0x2,
    // Neither the module's file or memory content could be found. Debugging will be
    // impaired.
    MissingBinary = 0x4,
    // Module was relocated because it could not load at its preferred base address.
    Relocated = 0x8,
    // Optimization status for the module could be detected and the module was determined
    // to be optimized.
    Optimized = 0x10,
    // Optimization status for the module could be detected and the module was determined
    // to be unoptimized.
    Unoptimized = 0x20,
    // The module can be edited during debugging. For .NET modules this implies that the
    // CORDEBUG_JIT_ENABLE_ENC is set.
    Editable = 0x40
};
DEFINE_SCOPED_ENUM_FLAG_OPERATORS(DkmModuleFlags_t);

// The Module Instance class represent a code bundle (ex: dll or exe) which is loaded
// into a particular process at a particular location. Module Instance objects are 1:1
// with the execution environment's notion of a code bundle. For example, in native code,
// Module Instance objects are 1:1 with base address.
//
// Derived classes: DkmClrModuleInstance, DkmClrNcModuleInstance,
// DkmCustomModuleInstance, DkmNativeModuleInstance, DkmClrNcContainerModuleInstance
class DECLSPEC_NOVTABLE DECLSPEC_UUID("74857b6f-618d-66e3-149e-6cebf4c4123e") DkmModuleInstance : public DkmDataContainer
{
    // Use DkmModuleInstance::Create to create this object
    private: DkmModuleInstance();
    // This object is refcounted. It is deleted through Release
    protected: ~DkmModuleInstance();
    // This object cannot be copied
    private: DkmModuleInstance& operator=(const DkmModuleInstance&);
    private: DkmModuleInstance(const DkmModuleInstance&);

    // 'MinidumpInfo' is used to convey additional information about modules in a
    // DkmProcess for a minidump.
    public: struct MinidumpInfo
    {
        // Path where the module was loaded on the computer where the dump was taken.
        DkmString* pOriginalPath;
    };

    // DkmModuleInstance is an abstract base class. This enum indicates which derived
    // class this object is an instance of.
    public: FORWARD_DECLARE_SCOPED_ENUM(Tag);
    DEFINE_SCOPED_ENUM(Tag)
    {
    // Object is an instance of 'DkmNativeModuleInstance'.
    NativeModuleInstance = 0,
    // Object is an instance of 'DkmClrModuleInstance'.
    ClrModuleInstance = 1,
    // Object is an instance of 'DkmCustomModuleInstance'.
    CustomModuleInstance = 2,
    // Object is an instance of 'DkmClrNcContainerModuleInstance'.
    ClrNcContainerModuleInstance = 3
    };

    private: OPTIONAL const DkmModuleInstance::MinidumpInfo* const m_pMinidumpInfo;
    private: const Tag_t m_TagValue;
    private: const GUID m_UniqueId;
    private: DkmString* const m_pName;
    private: DkmString* const m_pFullName;
    private: const UINT64 m_TimeDateStamp;
    private: DkmRuntimeInstance* const m_pRuntimeInstance;
    private: OPTIONAL DkmModuleVersion* const m_pVersion;
    private: OPTIONAL Symbols::DkmSymbolFileId* const m_pSymbolFileId;
    private: const DkmModuleFlags_t m_Flags;
    private: const DkmModuleMemoryLayout_t m_MemoryLayout;
    private: const UINT64 m_BaseAddress;
    private: const UINT32 m_LoadOrder;
    private: const UINT32 m_Size;
    private: DkmString* const m_pLoadContext;
    private: bool m_IsDisabled;
    private: OPTIONAL Symbols::DkmModule* m_pModule;
    private: void* m__pExtendedData;

    // [Optional] 'MinidumpInfoPart' is used to convey additional information about
    // modules in a DkmProcess for a minidump.
    public: _Ret_opt_ DECLSPEC_NOTHROW const DkmModuleInstance::MinidumpInfo* STDMETHODCALLTYPE MinidumpInfoPart(
        );

    // DkmModuleInstance is an abstract base class. This enum indicates which derived
    // class this object is an instance of.
    public: DECLSPEC_NOTHROW Tag_t STDMETHODCALLTYPE TagValue(
        );

    // Uniquely identifies the DkmModuleInstance object.
    public: DECLSPEC_NOTHROW const GUID& STDMETHODCALLTYPE UniqueId(
        );

    // Short representation of the module name. For file-based modules, this  is the file
    // name and extension (ex: kernel32.dll).
    public: _Ret_ DECLSPEC_NOTHROW DkmString* STDMETHODCALLTYPE Name(
        );

    // Fully qualified module name. For file-based modules, this is the full path to the
    // module (ex: c:\windows\system32\kernel32.dll.
    public: _Ret_ DECLSPEC_NOTHROW DkmString* STDMETHODCALLTYPE FullName(
        );

    // Date/Time of when the loaded module was built. This value is obtained from the
    // IMAGE_NT_HEADERS of the loaded module. The unit of measurement is a  FILETIME
    // value, which is a 64-bit value representing the number of 100-nanosecond intervals
    // since January 1, 1601 (UTC).
    public: DECLSPEC_NOTHROW UINT64 STDMETHODCALLTYPE TimeDateStamp(
        );

    // The DkmRuntimeInstance class represents an execution environment which is loaded
    // into a DkmProcess and which contains code to be debugged.
    public: _Ret_ DECLSPEC_NOTHROW DkmRuntimeInstance* STDMETHODCALLTYPE RuntimeInstance(
        );

    // [Optional] File version information.
    public: _Ret_opt_ DECLSPEC_NOTHROW DkmModuleVersion* STDMETHODCALLTYPE Version(
        );

    // [Optional] Contains information needed to locate symbols for this module. On
    // Win32, this information is contained within the IMAGE_DEBUG_DIRECTORY.
    public: _Ret_opt_ DECLSPEC_NOTHROW Symbols::DkmSymbolFileId* STDMETHODCALLTYPE SymbolFileId(
        );

    // Flags which indicate traits of a DkmModuleInstance.
    public: DECLSPEC_NOTHROW DkmModuleFlags_t STDMETHODCALLTYPE Flags(
        );

    // Enumeration that indicates how a module is laid out in memory.
    public: DECLSPEC_NOTHROW DkmModuleMemoryLayout_t STDMETHODCALLTYPE MemoryLayout(
        );

    // [Optional] The starting memory address of where the module loaded. This value will
    // be zero if the module did not load in a contiguous block of memory.
    public: DECLSPEC_NOTHROW UINT64 STDMETHODCALLTYPE BaseAddress(
        );

    // The integer count of the number of module instances that have loaded up to and
    // including this module. Each runtime instance keeps track of its own load order
    // count.
    public: DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE LoadOrder(
        );

    // [Optional] The number of bytes in the module's memory region. This value will be
    // zero if the module did not load in a contiguous block of memory.
    public: DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE Size(
        );

    // String description of the context under which this module has been loaded. ex:
    // 'Win32' or 'CLR v2.0.50727: Default Domain'.
    public: _Ret_ DECLSPEC_NOTHROW DkmString* STDMETHODCALLTYPE LoadContext(
        );

    // DkmProcess represents a target process which is being debugged. The debugger
    // debugs processes, so this is the basic unit of debugging. A DkmProcess can
    // represent a system process or a virtual process such as minidumps.
    public: _Ret_ DECLSPEC_NOTHROW DkmProcess* STDMETHODCALLTYPE Process(
        );

    // This represents a connection between the monitor and the IDE. It can either be a
    // local connection if the monitor is running in the same process as the IDE, or it
    // can be a remote connection. In the monitor process, there is only one connection.
    public: _Ret_ DECLSPEC_NOTHROW DefaultPort::DkmTransportConnection* STDMETHODCALLTYPE Connection(
        );

    // Indicates if this module instance has been disabled. Disabled modules are largely
    // ignored by the debugger. For native modules, the address range of the disabled
    // module is treated as if it is unmapped. For CLR modules, any frames from these
    // modules is hidden from the call stack.
    public: DECLSPEC_NOTHROW bool STDMETHODCALLTYPE IsDisabled(
        );

    // [Optional] The symbol handler's representation of a module (DkmModule) which is
    // associated with this module instance. This value is initially null, and is
    // assigned if and when symbols are associated with this module instance.
    public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetModule(
        _Deref_out_opt_ Symbols::DkmModule** ppValue);

    /// <summary>
    /// Updates the disabled status on a module. This method may only be called from a
    /// ModuleInstanceLoad event. When disabling a module, it is common to also suppress
    /// the module load event.
    /// </summary>
    /// <param name="IsDisabled">
    /// [In] Indicates if this module instance has been disabled. Disabled modules are
    /// largely ignored by the debugger. For native modules, the address range of the
    /// disabled module is treated as if it is unmapped. For CLR modules, any frames from
    /// these modules is hidden from the call stack.
    /// </param>
    /// <returns>
    /// S_OK is returned on success, and failure codes are used for any error.
    /// </returns>
    public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE SetDisabled(
        _In_ bool IsDisabled
        );

    /// <summary>
    /// Obtain the disassembly of the address range in the debuggee module instance.
    /// </summary>
    /// <param name="Address">
    /// [In] The address where disassembly should start.
    /// </param>
    /// <param name="Count">
    /// [In] The number of instructions to disassemble.
    /// </param>
    /// <param name="IsForward">
    /// [In] True if this is forward disassembling, otherwise this is reverse
    /// disassembling.
    /// </param>
    /// <param name="pDisassembly">
    /// [Out] The results of disassembly read from the debuggee byte code.
    ///
    /// The memory for the DkmArray members is allocated by the method implementation
    /// using DkmAllocBytes/DkmAllocArray. It is freed by the caller using the
    /// CAutoDkmArray template or with DkmFreeMemory and manual element release.
    /// </param>
    /// <param name="pIsEnd">
    /// [Out] True if the disassembly has reached the end of byte code, false otherwise.
    /// </param>
    /// <returns>
    /// S_OK is returned on success, and failure codes are used for any error.
    /// </returns>
    public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetGPUDisassembly(
        _In_ UINT64 Address,
        _In_ UINT32 Count,
        _In_ bool IsForward,
        _Out_ DkmArray<BYTE>* pDisassembly,
        _Out_ bool* pIsEnd
        );

    /// <summary>
    /// Returns the disassembly size in the debuggee module instance.
    /// </summary>
    /// <param name="pSize">
    /// [Out] The disassembly size.
    /// </param>
    /// <returns>
    /// S_OK is returned on success, and failure codes are used for any error.
    /// </returns>
    public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetGPUDisassemblySize(
        _Out_ UINT64* pSize
        );

    /// <summary>
    /// Returns the address of the next instruction relative to a starting address.
    /// </summary>
    /// <param name="StartAddress">
    /// [In] The address of the current instruction.
    /// </param>
    /// <param name="pNextAddress">
    /// [Out] The address of the next instruction from StartAddress.
    /// </param>
    /// <returns>
    /// S_OK is returned on success, and failure codes are used for any error.
    /// </returns>
    public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetNextGPUInstructionAddress(
        _In_ UINT64 StartAddress,
        _Out_ UINT64* pNextAddress
        );

    #ifndef EXCLUDE_MONITOR_ONLY_APIS
    /// <summary>
    /// This method is invoked by base debug monitors in response to a call to
    /// IDkmModuleSymbolsLoaded.RaiseSymbolsLoadedEvent. This method must be invoked from
    /// the event thread, or from the request thread as part of a reload. Base debug
    /// monitors should synchronously switch to the event thread, pause the target
    /// process, and invoke OnSymbolsLoaded.
    ///
    /// Location constraint: API must be called from a Monitor component (component level
    /// &lt; 100,000).
    /// </summary>
    /// <param name="pModule">
    /// [In] The DkmModule class represents a code bundle (ex: dll or exe) which is or
    /// once was loaded into one or more processes. The DkmModule class is the central
    /// object to the symbol APIs, and is 1:1 with the symbol handler's notation of what
    /// is loaded. If a code bundle loads into three different processes (or the same
    /// process but with three different base addresses or three different app domains)
    /// but the symbol handler thinks of all of these as being identical, there will be
    /// only one module object.
    /// </param>
    /// <param name="IsReload">
    /// [In] True if symbols are being reloaded for an existing module, False if this is
    /// happening as part of module load processing.
    /// </param>
    /// <returns>
    /// S_OK is returned on success, and failure codes are used for any error.
    /// </returns>
    public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE OnSymbolsLoaded(
        _In_ Symbols::DkmModule* pModule,
        _In_ bool IsReload
        );
    #endif // #ifndef EXCLUDE_MONITOR_ONLY_APIS

    /// <summary>
    /// This method is invoked by a symbol provider to associate a DkmModule with a
    /// DkmModuleInstance and to trigger a ModuleSymbolsLoaded event. It may be called
    /// only once for a DkmModuleInstance object. Calling this API will both establish
    /// the DkmModule&lt;-&gt;DkmModuleInstance association, as well as cause a
    /// ModuleSymbolsLoaded event to be raised.
    /// </summary>
    /// <param name="pModule">
    /// [In] The DkmModule that is associated with the DkmModuleInstance.
    /// </param>
    /// <param name="IsReload">
    /// [In] True if symbols are being reloaded for an existing module, False if this is
    /// happening as part of module load processing.
    /// </param>
    /// <returns>
    /// S_OK is returned on success, and failure codes are used for any error.
    /// </returns>
    public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE SetModule(
        _In_ Symbols::DkmModule* pModule,
        _In_ bool IsReload
        );

    #ifndef EXCLUDE_MONITOR_ONLY_APIS
    /// <summary>
    /// Runtime instances call this method to mark a module as a boundary module. When
    /// stepping, runtimes should check if the step has hit a boundary module and start
    /// stepping arbitration if they have. Note that some runtimes may not be able to
    /// honor this request. The dispatcher will keep a count of the number of times this
    /// has been called. Only when a matching number of calls to
    /// ClearTransitionModuleFlag have been made will the module no longer be considered
    /// a transition module.
    ///
    /// Location constraint: API must be called from a Monitor component (component level
    /// &lt; 100,000).
    /// </summary>
    /// <returns>
    /// S_OK is returned on success, and failure codes are used for any error.
    /// </returns>
    public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE FlagAsTransitionModule(
        );
    #endif // #ifndef EXCLUDE_MONITOR_ONLY_APIS

    #ifndef EXCLUDE_MONITOR_ONLY_APIS
    /// <summary>
    /// Runtime instances call this method to mark a module as a boundary module. When
    /// stepping, runtimes should check if the step has hit a boundary module and start
    /// stepping arbitration if they have. Note that some runtimes may not be able to
    /// honor this request. The dispatcher will keep a count of the number of times
    /// FlagAsTransitionModule has been called. Only when a matching number of calls to
    /// ClearTransitionModuleFlag will the module no longer be considered a transition
    /// module.
    ///
    /// Location constraint: API must be called from a Monitor component (component level
    /// &lt; 100,000).
    /// </summary>
    /// <returns>
    /// S_OK is returned on success, and failure codes are used for any error.
    /// </returns>
    public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ClearTransitionModuleFlag(
        );
    #endif // #ifndef EXCLUDE_MONITOR_ONLY_APIS

    #ifndef EXCLUDE_MONITOR_ONLY_APIS
    /// <summary>
    /// Returns true if any runtime instance has flagged this module as a transition
    /// module.
    ///
    /// Location constraint: API must be called from a Monitor component (component level
    /// &lt; 100,000).
    /// </summary>
    /// <param name="pResult">
    /// [Out] Boolean return value. True if the module is a transition module. False
    /// otherwise.
    /// </param>
    /// <returns>
    /// S_OK is returned on success, and failure codes are used for any error.
    /// </returns>
    public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE IsTransitionModule(
        _Out_ bool* pResult
        );
    #endif // #ifndef EXCLUDE_MONITOR_ONLY_APIS

    #ifndef EXCLUDE_IDE_ONLY_APIS
    /// <summary>
    /// Attempt to load a binary that previously failed to load using updated symbol
    /// paths.
    ///
    /// Location constraint: API must be called from an IDE component (component level
    /// &gt; 100,000).
    /// </summary>
    /// <returns>
    /// S_OK is returned on success, and failure codes are used for any error.
    /// </returns>
    public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE TryLoadBinary(
        );
    #endif // #ifndef EXCLUDE_IDE_ONLY_APIS

    #ifndef EXCLUDE_IDE_ONLY_APIS
    /// <summary>
    /// Called to initiate loading of symbols for DkmModuleInstances whose symbols were
    /// not found when the module loaded.
    ///
    /// Location constraint: API must be called from an IDE component (component level
    /// &gt; 100,000).
    /// </summary>
    /// <returns>
    /// S_OK is returned on success, and failure codes are used for any error.
    /// </returns>
    public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE TryLoadSymbols(
        );
    #endif // #ifndef EXCLUDE_IDE_ONLY_APIS

    #ifndef EXCLUDE_IDE_ONLY_APIS
    /// <summary>
    /// Obtain a localized a string description of the current symbol status.
    ///
    /// Location constraint: API must be called from an IDE component (component level
    /// &gt; 100,000).
    /// </summary>
    /// <param name="ExcludeCommonErrors">
    /// [In] This value will be true for creating the initial load output message, and
    /// false for obtaining the output window text.
    /// </param>
    /// <param name="ppStatus">
    /// [Out] Localized status string (ex: 'Symbols Loaded', 'No symbols loaded', etc.).
    /// </param>
    /// <returns>
    /// S_OK is returned on success, and failure codes are used for any error.
    /// </returns>
    public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetSymbolStatusMessage(
        _In_ bool ExcludeCommonErrors,
        _Deref_out_ DkmString** ppStatus
        );
    #endif // #ifndef EXCLUDE_IDE_ONLY_APIS

    #ifndef EXCLUDE_IDE_ONLY_APIS
    /// <summary>
    /// Returns a string describing the various locations in which symbols were searched
    /// for, and the result of checking that location. This information is used to
    /// populate the 'Symbol Load Information' in the modules window.
    ///
    /// Location constraint: API must be called from an IDE component (component level
    /// &gt; 100,000).
    /// </summary>
    /// <param name="ppDescription">
    /// [Out] String containing information about the symbol search. The typical format
    /// is 'location1:result1\r\nlocation2:result2...'.
    /// </param>
    /// <returns>
    /// S_OK is returned on success, and failure codes are used for any error.
    /// </returns>
    public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetSymbolLoadInformation(
        _Deref_out_ DkmString** ppDescription
        );
    #endif // #ifndef EXCLUDE_IDE_ONLY_APIS

    /// <summary>
    /// This method is invoked by symbol handlers to read symbols for DkmModuleInstances
    /// whose symbols reside in debuggee's memory.
    /// </summary>
    /// <param name="ppSymbolBuffer">
    /// [Out,Optional] The symbol buffer that is read from debuggee's memory at runtime.
    /// </param>
    /// <returns>
    /// S_OK is returned if *ppSymbolBuffer is non-NULL, S_FALSE is returned when
    /// *ppSymbolBuffer is NULL, and failure codes are used for any error.
    /// </returns>
    public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ReadSymbols(
        _Deref_out_opt_ DkmReadOnlyCollection<BYTE>** ppSymbolBuffer
        );

    /// <summary>
    /// Mark the Unload object as unloaded and notify components which implement the
    /// event sync interface. Control will return once all components have been notified.
    ///
    /// This method may only be called by the component which created the object.
    /// </summary>
    /// <returns>
    /// S_OK is returned on success, and failure codes are used for any error.
    /// </returns>
    public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Unload(
        );

    /// <summary>
    /// Raise a ModuleSymbolsUpdated event. Components which implement the event sync
    /// interface will receive the event notification. Control will return once all
    /// components have been notified.
    /// </summary>
    /// <param name="pModule">
    /// [In] The DkmModule class represents a code bundle (ex: dll or exe) which is or
    /// once was loaded into one or more processes. The DkmModule class is the central
    /// object to the symbol APIs, and is 1:1 with the symbol handler's notation of what
    /// is loaded. If a code bundle loads into three different processes (or the same
    /// process but with three different base addresses or three different app domains)
    /// but the symbol handler thinks of all of these as being identical, there will be
    /// only one module object.
    /// </param>
    /// <returns>
    /// S_OK is returned on success, and failure codes are used for any error.
    /// </returns>
    public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE OnSymbolsUpdated(
        _In_ Symbols::DkmModule* pModule
        );

    /// <summary>
    /// Raise a BinaryLoaded event. Components which implement the event sync interface
    /// will receive the event notification. Control will return once all components have
    /// been notified.
    ///
    /// This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
    /// </summary>
    /// <param name="pPath">
    /// [In] The full path, relative to the computer running Visual Studio to open the
    /// minidump, of the matching binary we were able to find.
    /// </param>
    /// <returns>
    /// S_OK is returned on success, and failure codes are used for any error.
    /// </returns>
    public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE OnBinaryLoaded(
        _In_ DkmString* pPath
        );

    /// <summary>
    /// Determines if a module is considered user code.
    ///
    /// Location constraint: This method can be called from an IDE component. Starting in
    /// Visual Studio 2013 Update 2, it is also possible to call this from a monitor
    /// component for managed code.
    ///
    /// This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
    /// </summary>
    /// <param name="pIsUserCode">
    /// [Out] True if some or all of the module is user code.  False if the entire module
    /// is nonuser code.
    /// </param>
    /// <returns>
    /// S_OK is returned on success, and failure codes are used for any error.
    /// </returns>
    public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE IsUserCode(
        _Out_ bool* pIsUserCode
        );

    #ifndef EXCLUDE_MONITOR_ONLY_APIS
    /// <summary>
    /// Raise a BinaryReloadOpportunity event. Components which implement the event sync
    /// interface will receive the event notification. Control will return once all
    /// components have been notified.
    ///
    /// Location constraint: API must be called from a Monitor component (component level
    /// &lt; 100,000).
    ///
    /// This API was introduced in Visual Studio 12 Update 2 (DkmApiVersion.VS12Update2).
    /// </summary>
    /// <returns>
    /// S_OK is returned on success, and failure codes are used for any error.
    /// </returns>
    public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE OnBinaryReloadOpportunity(
        );
    #endif // #ifndef EXCLUDE_MONITOR_ONLY_APIS

    /// <summary>
    /// This method allows a component to determine if module load event for a module was
    /// suppressed.
    ///
    /// This API was introduced in Visual Studio 12 Update 3 (DkmApiVersion.VS12Update3).
    /// </summary>
    /// <param name="pResult">
    /// [Out] Returns true if module load event was suppressed.
    /// </param>
    /// <returns>
    /// S_OK is returned on success, and failure codes are used for any error.
    /// </returns>
    public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE IsSuppressed(
        _Out_ bool* pResult
        );

    #ifndef EXCLUDE_MONITOR_ONLY_APIS
    /// <summary>
    /// This method is called when a module changes due to EnC or dynamically emitted
    /// code.
    ///
    /// Location constraint: API must be called from a Monitor component (component level
    /// &lt; 100,000).
    ///
    /// This API was introduced in Visual Studio 14 RTM (DkmApiVersion.VS14RTM).
    /// </summary>
    /// <returns>
    /// S_OK is returned on success, and failure codes are used for any error.
    /// </returns>
    public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE OnModuleModified(
        );
    #endif // #ifndef EXCLUDE_MONITOR_ONLY_APIS
}; // end of DkmModuleInstance

// Enumeration that indicates how a module is laid out in memory.
DEFINE_SCOPED_ENUM(DkmModuleMemoryLayout)
{
    // The memory layout of this module is unknown or not defined. This is used for CLR
    // dynamic modules.
    Unknown = 0,
    // Dll is loaded using the 'in memory' layout for a PE. This is the result from
    // LoadLibrary or CreateFileMapping(..SEC_IMAGE...).
    MemoryPE = 1,
    // Dll is loaded using the disk layout for a PE. This is the result of a PE file
    // being directly blitted into a memory buffer using ReadFile.
    DiskPE = 2
};

// File version information.
class DECLSPEC_NOVTABLE DECLSPEC_UUID("c7094fad-97e0-e3eb-4337-60cbb394aa35") DkmModuleVersion : public IUnknown
{
    private: ___ReferenceCount_t m_ReferenceCount;
    private: DkmDispatcherObjectFlags_t m_ObjectFlags;
    private: const GUID* m_pTypeId;
    private: size_t m_ObjectGCHandle;
    // Use DkmModuleVersion::Create to create this object
    private: DkmModuleVersion();
    // This object is refcounted. It is deleted through Release
    protected: ~DkmModuleVersion();
    // This object cannot be copied
    private: DkmModuleVersion& operator=(const DkmModuleVersion&);
    private: DkmModuleVersion(const DkmModuleVersion&);

    private: OPTIONAL DkmString* const m_pFileVersionString;
    private: OPTIONAL DkmString* const m_pCompanyName;
    private: const UINT32 m_FileVersionMS;
    private: const UINT32 m_FileVersionLS;
    private: const UINT32 m_ProductVersionMS;
    private: const UINT32 m_ProductVersionLS;
    private: const UINT32 m_VersionFlags;
    private: void* m__pExtendedData;

    // [Optional] 'FileVersion' field from the variable-sized version data (ex:
    // '6.0.6000.16386 (vista_rtm.061101-2205)').
    public: _Ret_opt_ DECLSPEC_NOTHROW DkmString* STDMETHODCALLTYPE FileVersionString(
        );

    // [Optional] 'CompanyName' field from the variable-sized version data (ex:
    // 'Microsoft Corporation').
    public: _Ret_opt_ DECLSPEC_NOTHROW DkmString* STDMETHODCALLTYPE CompanyName(
        );

    // Most significant 32-bits of the file version (e.g. 0x00030010 = 3.10).
    public: DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE FileVersionMS(
        );

    // Least significant 32 bits of the file's binary version number (e.g. 0x00000031 =
    // 0.31).
    public: DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE FileVersionLS(
        );

    // Most significant 32 bits of the binary version number of the product with which
    // this file was distributed (e.g. 0x00030010 = 3.10).
    public: DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE ProductVersionMS(
        );

    // Least significant 32 bits of the binary version number of the product with which
    // this file was distributed (e.g. 0x00000031 = 0.31).
    public: DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE ProductVersionLS(
        );

    // VS_FF_* flags from winver.h of the Platform SDK.
    public: DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE VersionFlags(
        );

    /// <summary>
    /// Create a new DkmModuleVersion object instance.
    /// </summary>
    /// <param name="pFileVersionString">
    /// [In,Optional] 'FileVersion' field from the variable-sized version data (ex:
    /// '6.0.6000.16386 (vista_rtm.061101-2205)').
    /// </param>
    /// <param name="pCompanyName">
    /// [In,Optional] 'CompanyName' field from the variable-sized version data (ex:
    /// 'Microsoft Corporation').
    /// </param>
    /// <param name="FileVersionMS">
    /// [In] Most significant 32-bits of the file version (e.g. 0x00030010 = 3.10).
    /// </param>
    /// <param name="FileVersionLS">
    /// [In] Least significant 32 bits of the file's binary version number (e.g.
    /// 0x00000031 = 0.31).
    /// </param>
    /// <param name="ProductVersionMS">
    /// [In] Most significant 32 bits of the binary version number of the product with
    /// which this file was distributed (e.g. 0x00030010 = 3.10).
    /// </param>
    /// <param name="ProductVersionLS">
    /// [In] Least significant 32 bits of the binary version number of the product with
    /// which this file was distributed (e.g. 0x00000031 = 0.31).
    /// </param>
    /// <param name="VersionFlags">
    /// [In] VS_FF_* flags from winver.h of the Platform SDK.
    /// </param>
    /// <param name="ppCreatedObject">
    /// [Out] Result of this method call.
    /// </param>
    /// <returns>
    /// S_OK is returned on success, and failure codes are used for any error.
    /// </returns>
    public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
        _In_opt_ DkmString* pFileVersionString,
        _In_opt_ DkmString* pCompanyName,
        _In_ UINT32 FileVersionMS,
        _In_ UINT32 FileVersionLS,
        _In_ UINT32 ProductVersionMS,
        _In_ UINT32 ProductVersionLS,
        _In_ UINT32 VersionFlags,
        _Deref_out_ DkmModuleVersion** ppCreatedObject
        );
}; // end of DkmModuleVersion

// Process execution counters collection.
//
// This API was introduced in Visual Studio 14 RTM (DkmApiVersion.VS14RTM).
class DECLSPEC_NOVTABLE DECLSPEC_UUID("c00029d1-55bb-5536-c725-a7a2bcf07481") DkmPerformanceCounters : public IUnknown
{
    private: ___ReferenceCount_t m_ReferenceCount;
    private: DkmDispatcherObjectFlags_t m_ObjectFlags;
    private: const GUID* m_pTypeId;
    private: size_t m_ObjectGCHandle;
    // Use DkmPerformanceCounters::Create to create this object
    private: DkmPerformanceCounters();
    // This object is refcounted. It is deleted through Release
    protected: ~DkmPerformanceCounters();
    // This object cannot be copied
    private: DkmPerformanceCounters& operator=(const DkmPerformanceCounters&);
    private: DkmPerformanceCounters(const DkmPerformanceCounters&);

    private: const UINT32 m_StartStopCounter;
    private: const UINT64 m_SystemTime;
    private: const UINT64 m_UserTime;
    private: const UINT64 m_KernelTime;
    private: const UINT64 m_RuntimeOverhead;
    private: const UINT64 m_OSOverhead;
    private: const UINT64 m_TotalOverhead;
    private: const UINT64 m_Id;
    private: void* m__pExtendedData;

    // Number of performance watch start/stop iterations. If this number is high then
    // performance data is not reliable.
    //
    // This API was introduced in Visual Studio 14 RTM (DkmApiVersion.VS14RTM).
    public: DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE StartStopCounter(
        );

    // System time (in milliseconds) consumed by debuggee process during debugger step.
    //
    // This API was introduced in Visual Studio 14 RTM (DkmApiVersion.VS14RTM).
    public: DECLSPEC_NOTHROW UINT64 STDMETHODCALLTYPE SystemTime(
        );

    // User time (in milliseconds) consumed by debuggee process during debugger step.
    //
    // This API was introduced in Visual Studio 14 RTM (DkmApiVersion.VS14RTM).
    public: DECLSPEC_NOTHROW UINT64 STDMETHODCALLTYPE UserTime(
        );

    // Kernel time (in milliseconds) consumed by debuggee process during debugger step.
    //
    // This API was introduced in Visual Studio 14 RTM (DkmApiVersion.VS14RTM).
    public: DECLSPEC_NOTHROW UINT64 STDMETHODCALLTYPE KernelTime(
        );

    // System time (in milliseconds) considered to be the runtime overhead during
    // debugger step. SystemTime value does not contain this overhead.
    //
    // This API was introduced in Visual Studio 14 RTM (DkmApiVersion.VS14RTM).
    public: DECLSPEC_NOTHROW UINT64 STDMETHODCALLTYPE RuntimeOverhead(
        );

    // System time (in milliseconds) considered to be the OS overhead during debugger
    // step. SystemTime value does not contain this overhead.
    //
    // This API was introduced in Visual Studio 14 RTM (DkmApiVersion.VS14RTM).
    public: DECLSPEC_NOTHROW UINT64 STDMETHODCALLTYPE OSOverhead(
        );

    // System time (in milliseconds) considered to be the total overhead during debugger
    // step. SystemTime value does not contain this overhead. Runtime overhead + OS
    // overhead value might be greater than TotalOverhead if they are overlapping.
    //
    // This API was introduced in Visual Studio 14 RTM (DkmApiVersion.VS14RTM).
    public: DECLSPEC_NOTHROW UINT64 STDMETHODCALLTYPE TotalOverhead(
        );

    // Id based on the QPC time to co-relate debugger events in the Concord and package.
    //
    // This API was introduced in Visual Studio 14 RTM (DkmApiVersion.VS14RTM).
    public: DECLSPEC_NOTHROW UINT64 STDMETHODCALLTYPE Id(
        );

    /// <summary>
    /// Create a new DkmPerformanceCounters object instance.
    ///
    /// This API was introduced in Visual Studio 14 RTM (DkmApiVersion.VS14RTM).
    /// </summary>
    /// <param name="StartStopCounter">
    /// [In] Number of performance watch start/stop iterations. If this number is high
    /// then performance data is not reliable.
    /// </param>
    /// <param name="SystemTime">
    /// [In] System time (in milliseconds) consumed by debuggee process during debugger
    /// step.
    /// </param>
    /// <param name="UserTime">
    /// [In] User time (in milliseconds) consumed by debuggee process during debugger
    /// step.
    /// </param>
    /// <param name="KernelTime">
    /// [In] Kernel time (in milliseconds) consumed by debuggee process during debugger
    /// step.
    /// </param>
    /// <param name="RuntimeOverhead">
    /// [In] System time (in milliseconds) considered to be the runtime overhead during
    /// debugger step. SystemTime value does not contain this overhead.
    /// </param>
    /// <param name="OSOverhead">
    /// [In] System time (in milliseconds) considered to be the OS overhead during
    /// debugger step. SystemTime value does not contain this overhead.
    /// </param>
    /// <param name="TotalOverhead">
    /// [In] System time (in milliseconds) considered to be the total overhead during
    /// debugger step. SystemTime value does not contain this overhead. Runtime overhead
    /// + OS overhead value might be greater than TotalOverhead if they are overlapping.
    /// </param>
    /// <param name="Id">
    /// [In] Id based on the QPC time to co-relate debugger events in the Concord and
    /// package.
    /// </param>
    /// <param name="ppCreatedObject">
    /// [Out] Result of this method call.
    /// </param>
    /// <returns>
    /// S_OK is returned on success, and failure codes are used for any error.
    /// </returns>
    public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
        _In_ UINT32 StartStopCounter,
        _In_ UINT64 SystemTime,
        _In_ UINT64 UserTime,
        _In_ UINT64 KernelTime,
        _In_ UINT64 RuntimeOverhead,
        _In_ UINT64 OSOverhead,
        _In_ UINT64 TotalOverhead,
        _In_ UINT64 Id,
        _Deref_out_ DkmPerformanceCounters** ppCreatedObject
        );
}; // end of DkmPerformanceCounters

// Result of an asynchronous DkmProcess.QueryPerformanceCounters call.
struct DkmPerformanceCountersAsyncResult
{
    // HRESULT code returned from the caller. This will be
    // DkmExceptionCode.COR_E_OPERATIONCANCELED (0x8013153B) if the operation was
    // canceled before processing was complete.
    HRESULT ErrorCode;

    // Collected performance counters.
    DkmPerformanceCounters* pCounters;
};

// DkmProcess represents a target process which is being debugged. The debugger debugs
// processes, so this is the basic unit of debugging. A DkmProcess can represent a system
// process or a virtual process such as minidumps.
class DECLSPEC_NOVTABLE DECLSPEC_UUID("a6eaf62b-6db1-4f38-6359-46e9262d7a0a") DkmProcess : public DkmDataContainer
{
    // Use DkmProcess::Create to create this object
    private: DkmProcess();
    // This object is refcounted. It is deleted through Release
    protected: ~DkmProcess();
    // This object cannot be copied
    private: DkmProcess& operator=(const DkmProcess&);
    private: DkmProcess(const DkmProcess&);

    // Information relevant to a running process. For example, this Part will NOT be
    // present for minidumps.
    public: struct Live
    {
        // Process Id (PID) assigned by the operating system. As the same process id may
        // be used by multiple computers, and as process ids may be recycled, it is
        // recommended to use 'UniqueId' for identity purposes.
        UINT32 Id;

        // 64-bit date time value indicating when the process was started. The start time
        // along with the id and the machine where the process was started can uniquely
        // identify a process.
        UINT64 StartTime;
    };

    // Contains additional fields of DkmProcess which were added after the class was
    // initally introduced.
    private: struct ___ExtendedData
    {
        ___ExtendedData();

        // True if the process belongs to a Windows Store app package or Windows Phone
        // app package.
        const bool IsAppPackage;
    };

    private: OPTIONAL const DkmProcess::Live* const m_pLive;
    private: DefaultPort::DkmTransportConnection* const m_pConnection;
    private: DkmString* const m_pPath;
    private: const GUID m_UniqueId;
    private: const Start::DkmStartMethod_t m_StartMethod;
    private: DkmEngineSettings* const m_pEngineSettings;
    private: Start::DkmDebugLaunchSettings* const m_pDebugLaunchSettings;
    private: DefaultPort::DkmSystemInformation* const m_pSystemInformation;
    private: const GUID m_BaseDebugMonitorId;
    private: bool m_IsNativeDebuggingEnabled;
    private: ___ExtendedData* const m__pExtendedData;
    private: void* m_pComputeKernelCollection0;
    private: void* m_pEELocalObjectCollection0;
    private: void* m_pInspectionSessionCollection0;
    private: void* m_pPendingBreakpointCollection0;
    private: void* m_pRuntimeFunctionResolutionRequestCollection0;
    private: void* m_pRuntimeInstanceCollection0;
    private: void* m_pSystemThreadCollection1;
    private: void* m_pThreadCollection0;

    // [Optional] Information relevant to a running process. For example, this Part will
    // NOT be present for minidumps.
    public: _Ret_opt_ DECLSPEC_NOTHROW const DkmProcess::Live* STDMETHODCALLTYPE LivePart(
        );

    // This represents a connection between the monitor and the IDE. It can either be a
    // local connection if the monitor is running in the same process as the IDE, or it
    // can be a remote connection. In the monitor process, there is only one connection.
    public: _Ret_ DECLSPEC_NOTHROW DefaultPort::DkmTransportConnection* STDMETHODCALLTYPE Connection(
        );

    // Full path to the starting executable of the process.
    public: _Ret_ DECLSPEC_NOTHROW DkmString* STDMETHODCALLTYPE Path(
        );

    // Guid which uniquely identifies this process object. This Guid value is the same as
    // the Guid exposed at the SDM layer (IDebugProcess2::GetProcessId) and at the
    // automation layer.
    public: DECLSPEC_NOTHROW const GUID& STDMETHODCALLTYPE UniqueId(
        );

    // StartMethod describes how the debug engine started debugging this process.
    public: DECLSPEC_NOTHROW Start::DkmStartMethod_t STDMETHODCALLTYPE StartMethod(
        );

    // Contains the session-wide debug settings. There is one instance of this object per
    // engine Guid (ex: one instance for COMPlusOnlyEng2, one instance for
    // COMPlusNativeEng).
    public: _Ret_ DECLSPEC_NOTHROW DkmEngineSettings* STDMETHODCALLTYPE EngineSettings(
        );

    // Settings supplied during a start debugging operation from a project system or
    // other caller of LaunchDebugTargets (or various other start debugging APIs).
    public: _Ret_ DECLSPEC_NOTHROW Start::DkmDebugLaunchSettings* STDMETHODCALLTYPE DebugLaunchSettings(
        );

    // Contains information about the computer system that this process is running under.
    // If this process is running under WOW (32-bit emulation on a 64-bit OS) this
    // information will be for the 32-bit subsystem rather than the 64-bit subsystem.
    public: _Ret_ DECLSPEC_NOTHROW DefaultPort::DkmSystemInformation* STDMETHODCALLTYPE SystemInformation(
        );

    // DkmBaseDebugMonitorId identifies the base debug monitor used to inspect and
    // control the debugged process. For example, DkmBaseDebugMonitorId.WindowsProcess is
    // used for processes debugged by the Win32 debugging API and
    // DkmBaseDebugMonitorId.DumpFile is used for minidumps.
    public: DECLSPEC_NOTHROW const GUID& STDMETHODCALLTYPE BaseDebugMonitorId(
        );

    // True if the process belongs to a Windows Store app package or Windows Phone app
    // package.
    //
    // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
    public: DECLSPEC_NOTHROW bool STDMETHODCALLTYPE IsAppPackage(
        );

    // When true, the debugger will attempt to debug native code - it will stop on native
    // exceptions, load symbols, display native frames on the call stack, bind and hit
    // breakpoints, and leave native threads stopped while in break state.
    public: DECLSPEC_NOTHROW bool STDMETHODCALLTYPE IsNativeDebuggingEnabled(
        );

    /// <summary>
    /// Find a DkmProcess object. If no object with the given input key is present,
    /// FindProcess will fail.
    /// </summary>
    /// <param name="UniqueId">
    /// [In] Search key used to find the element.
    /// </param>
    /// <param name="ppProcess">
    /// [Out] Result of the search.
    /// </param>
    /// <returns>
    /// S_OK is returned on success, and failure codes are used for any error.
    /// E_XAPI_OBJECT_NOT_FOUND indicates that the search key cannot be found.
    /// </returns>
    public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE FindProcess(
        _In_ const GUID& UniqueId,
        _Deref_out_ DkmProcess** ppProcess
        );

    /// <summary>
    /// GetProcesses enumerates all the created DkmProcess objects.
    /// </summary>
    /// <param name="pProcesses">
    /// [Out] Array containing the enumerated elements.
    ///
    /// The memory for the DkmArray members is allocated by the method implementation
    /// using DkmAllocBytes/DkmAllocArray. It is freed by the caller using the
    /// CAutoDkmArray template or with DkmFreeMemory and manual element release.
    /// </param>
    /// <returns>
    /// S_OK is returned on success, and failure codes are used for any error.
    /// </returns>
    public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetProcesses(
        _Out_ DkmArray<DkmProcess*>* pProcesses
        );

    /// <summary>
    /// Creates a new process object. This method is called from the base debug monitor
    /// on the event thread as part of the processing of
    /// IDkmStartDebuggingOperations.AttachToProcess or
    /// IDkmStartDebuggingOperations.ResumeDebuggedProcess.
    ///
    /// This method will send a ProcessCreate event.
    /// </summary>
    /// <param name="pConnection">
    /// [In] This represents a connection between the monitor and the IDE. It can either
    /// be a local connection if the monitor is running in the same process as the IDE,
    /// or it can be a remote connection. In the monitor process, there is only one
    /// connection.
    /// </param>
    /// <param name="pPath">
    /// [In] Full path to the starting executable of the process.
    /// </param>
    /// <param name="UniqueId">
    /// [In] Guid which uniquely identifies this process object. This Guid value is the
    /// same as the Guid exposed at the SDM layer (IDebugProcess2::GetProcessId) and at
    /// the automation layer.
    /// </param>
    /// <param name="StartMethod">
    /// [In] StartMethod describes how the debug engine started debugging this process.
    /// </param>
    /// <param name="pEngineSettings">
    /// [In] Contains the session-wide debug settings. There is one instance of this
    /// object per engine Guid (ex: one instance for COMPlusOnlyEng2, one instance for
    /// COMPlusNativeEng).
    /// </param>
    /// <param name="pDebugLaunchSettings">
    /// [In] Settings supplied during a start debugging operation from a project system
    /// or other caller of LaunchDebugTargets (or various other start debugging APIs).
    /// </param>
    /// <param name="pSystemInformation">
    /// [In] Contains information about the computer system that this process is running
    /// under. If this process is running under WOW (32-bit emulation on a 64-bit OS)
    /// this information will be for the 32-bit subsystem rather than the 64-bit
    /// subsystem.
    /// </param>
    /// <param name="BaseDebugMonitorId">
    /// [In] DkmBaseDebugMonitorId identifies the base debug monitor used to inspect and
    /// control the debugged process. For example, DkmBaseDebugMonitorId.WindowsProcess
    /// is used for processes debugged by the Win32 debugging API and
    /// DkmBaseDebugMonitorId.DumpFile is used for minidumps.
    /// </param>
    /// <param name="IsNativeDebuggingEnabled">
    /// [In] When true, the debugger will attempt to debug native code - it will stop on
    /// native exceptions, load symbols, display native frames on the call stack, bind
    /// and hit breakpoints, and leave native threads stopped while in break state.
    /// </param>
    /// <param name="pLive">
    /// [In,Optional] Information relevant to a running process. For example, this Part
    /// will NOT be present for minidumps.
    /// </param>
    /// <param name="DataItem">
    /// [In] Data object to add to the new DkmProcess instance. DkmDataItem::Null() in
    /// the case that the caller doesn't need to add a data item.
    /// </param>
    /// <param name="ppCreatedObject">
    /// [Out] Result of this method call.
    /// </param>
    /// <returns>
    /// S_OK is returned on success, and failure codes are used for any error.
    /// </returns>
    public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
        _In_ DefaultPort::DkmTransportConnection* pConnection,
        _In_ DkmString* pPath,
        _In_ const GUID& UniqueId,
        _In_ Start::DkmStartMethod_t StartMethod,
        _In_ DkmEngineSettings* pEngineSettings,
        _In_ Start::DkmDebugLaunchSettings* pDebugLaunchSettings,
        _In_ DefaultPort::DkmSystemInformation* pSystemInformation,
        _In_ const GUID& BaseDebugMonitorId,
        _In_ bool IsNativeDebuggingEnabled,
        _In_opt_ const DkmProcess::Live* pLive,
        _In_ const DkmDataItem& DataItem,
        _Deref_out_ DkmProcess** ppCreatedObject
        );

    /// <summary>
    /// Creates a new process object. This method is called from the base debug monitor
    /// on the event thread as part of the processing of
    /// IDkmStartDebuggingOperations.AttachToProcess or
    /// IDkmStartDebuggingOperations.ResumeDebuggedProcess.
    ///
    /// This method will send a ProcessCreate event.
    ///
    /// This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
    /// </summary>
    /// <param name="pConnection">
    /// [In] This represents a connection between the monitor and the IDE. It can either
    /// be a local connection if the monitor is running in the same process as the IDE,
    /// or it can be a remote connection. In the monitor process, there is only one
    /// connection.
    /// </param>
    /// <param name="pPath">
    /// [In] Full path to the starting executable of the process.
    /// </param>
    /// <param name="UniqueId">
    /// [In] Guid which uniquely identifies this process object. This Guid value is the
    /// same as the Guid exposed at the SDM layer (IDebugProcess2::GetProcessId) and at
    /// the automation layer.
    /// </param>
    /// <param name="StartMethod">
    /// [In] StartMethod describes how the debug engine started debugging this process.
    /// </param>
    /// <param name="pEngineSettings">
    /// [In] Contains the session-wide debug settings. There is one instance of this
    /// object per engine Guid (ex: one instance for COMPlusOnlyEng2, one instance for
    /// COMPlusNativeEng).
    /// </param>
    /// <param name="pDebugLaunchSettings">
    /// [In] Settings supplied during a start debugging operation from a project system
    /// or other caller of LaunchDebugTargets (or various other start debugging APIs).
    /// </param>
    /// <param name="pSystemInformation">
    /// [In] Contains information about the computer system that this process is running
    /// under. If this process is running under WOW (32-bit emulation on a 64-bit OS)
    /// this information will be for the 32-bit subsystem rather than the 64-bit
    /// subsystem.
    /// </param>
    /// <param name="BaseDebugMonitorId">
    /// [In] DkmBaseDebugMonitorId identifies the base debug monitor used to inspect and
    /// control the debugged process. For example, DkmBaseDebugMonitorId.WindowsProcess
    /// is used for processes debugged by the Win32 debugging API and
    /// DkmBaseDebugMonitorId.DumpFile is used for minidumps.
    /// </param>
    /// <param name="IsAppPackage">
    /// [In] True if the process belongs to a Windows Store app package or Windows Phone
    /// app package.
    /// </param>
    /// <param name="IsNativeDebuggingEnabled">
    /// [In] When true, the debugger will attempt to debug native code - it will stop on
    /// native exceptions, load symbols, display native frames on the call stack, bind
    /// and hit breakpoints, and leave native threads stopped while in break state.
    /// </param>
    /// <param name="pLive">
    /// [In,Optional] Information relevant to a running process. For example, this Part
    /// will NOT be present for minidumps.
    /// </param>
    /// <param name="DataItem">
    /// [In] Data object to add to the new DkmProcess instance. DkmDataItem::Null() in
    /// the case that the caller doesn't need to add a data item.
    /// </param>
    /// <param name="ppCreatedObject">
    /// [Out] Result of this method call.
    /// </param>
    /// <returns>
    /// S_OK is returned on success, and failure codes are used for any error.
    /// </returns>
    public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
        _In_ DefaultPort::DkmTransportConnection* pConnection,
        _In_ DkmString* pPath,
        _In_ const GUID& UniqueId,
        _In_ Start::DkmStartMethod_t StartMethod,
        _In_ DkmEngineSettings* pEngineSettings,
        _In_ Start::DkmDebugLaunchSettings* pDebugLaunchSettings,
        _In_ DefaultPort::DkmSystemInformation* pSystemInformation,
        _In_ const GUID& BaseDebugMonitorId,
        _In_ bool IsAppPackage,
        _In_ bool IsNativeDebuggingEnabled,
        _In_opt_ const DkmProcess::Live* pLive,
        _In_ const DkmDataItem& DataItem,
        _Deref_out_ DkmProcess** ppCreatedObject
        );

    /// <summary>
    /// GetThreads enumerates the DkmThread elements of this DkmProcess object.
    /// </summary>
    /// <param name="pThreads">
    /// [Out] Array containing the enumerated elements.
    ///
    /// The memory for the DkmArray members is allocated by the method implementation
    /// using DkmAllocBytes/DkmAllocArray. It is freed by the caller using the
    /// CAutoDkmArray template or with DkmFreeMemory and manual element release.
    /// </param>
    /// <returns>
    /// S_OK is returned on success, and failure codes are used for any error.
    /// </returns>
    public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetThreads(
        _Out_ DkmArray<DkmThread*>* pThreads
        );

    /// <summary>
    /// Find a DkmThread element within this DkmProcess. If no element with the given
    /// input key is present, FindSystemThread will fail. If an object is found, it will
    /// always contain the 'System' Part.
    /// </summary>
    /// <param name="Id">
    /// [In] Search key used to find the element.
    /// </param>
    /// <param name="ppThread">
    /// [Out] Result of the search.
    /// </param>
    /// <returns>
    /// S_OK is returned on success, and failure codes are used for any error.
    /// E_XAPI_OBJECT_NOT_FOUND indicates that the search key cannot be found.
    /// </returns>
    public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE FindSystemThread(
        _In_ UINT32 Id,
        _Deref_out_ DkmThread** ppThread
        );

    /// <summary>
    /// Raise a AsyncBreakComplete event. Components which implement the event sync
    /// interface will receive the event notification. This method will enqueue the event
    /// and control will immediately return to the caller.
    /// </summary>
    /// <param name="Status">
    /// [In] Indicates the type of async-break that occurred.
    /// </param>
    /// <param name="pThread">
    /// [In] DkmThread represents a thread running in the target process.
    /// </param>
    /// <returns>
    /// S_OK is returned on success, and failure codes are used for any error.
    /// </returns>
    public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE OnAsyncBreakComplete(
        _In_ DkmAsyncBreakStatus_t Status,
        _In_ DkmThread* pThread
        );

    /// <summary>
    /// GetPendingBreakpoints enumerates the DkmPendingBreakpoint elements of this
    /// DkmProcess object.
    /// </summary>
    /// <param name="pPendingBreakpoints">
    /// [Out] Array containing the enumerated elements.
    ///
    /// The memory for the DkmArray members is allocated by the method implementation
    /// using DkmAllocBytes/DkmAllocArray. It is freed by the caller using the
    /// CAutoDkmArray template or with DkmFreeMemory and manual element release.
    /// </param>
    /// <returns>
    /// S_OK is returned on success, and failure codes are used for any error.
    /// </returns>
    public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetPendingBreakpoints(
        _Out_ DkmArray<Breakpoints::DkmPendingBreakpoint*>* pPendingBreakpoints
        );

    /// <summary>
    /// Find a DkmRuntimeInstance element within this DkmProcess. If no element with the
    /// given input key is present, FindRuntimeInstance will fail.
    /// </summary>
    /// <param name="Id">
    /// [In] Search key used to find the element.
    /// </param>
    /// <param name="ppRuntimeInstance">
    /// [Out] Result of the search.
    /// </param>
    /// <returns>
    /// S_OK is returned on success, and failure codes are used for any error.
    /// E_XAPI_OBJECT_NOT_FOUND indicates that the search key cannot be found.
    /// </returns>
    public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE FindRuntimeInstance(
        _In_ const DkmRuntimeInstanceId& Id,
        _Deref_out_ DkmRuntimeInstance** ppRuntimeInstance
        );

    /// <summary>
    /// GetRuntimeInstances enumerates the DkmRuntimeInstance elements of this DkmProcess
    /// object.
    /// </summary>
    /// <param name="pRuntimeInstances">
    /// [Out] Array containing the enumerated elements.
    ///
    /// The memory for the DkmArray members is allocated by the method implementation
    /// using DkmAllocBytes/DkmAllocArray. It is freed by the caller using the
    /// CAutoDkmArray template or with DkmFreeMemory and manual element release.
    /// </param>
    /// <returns>
    /// S_OK is returned on success, and failure codes are used for any error.
    /// </returns>
    public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetRuntimeInstances(
        _Out_ DkmArray<DkmRuntimeInstance*>* pRuntimeInstances
        );

    /// <summary>
    /// GetComputeKernels enumerates the DkmGPUComputeKernel elements of this DkmProcess
    /// object.
    /// </summary>
    /// <param name="pComputeKernels">
    /// [Out] Array containing the enumerated elements.
    ///
    /// The memory for the DkmArray members is allocated by the method implementation
    /// using DkmAllocBytes/DkmAllocArray. It is freed by the caller using the
    /// CAutoDkmArray template or with DkmFreeMemory and manual element release.
    /// </param>
    /// <returns>
    /// S_OK is returned on success, and failure codes are used for any error.
    /// </returns>
    public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetComputeKernels(
        _Out_ DkmArray<GPU::DkmGPUComputeKernel*>* pComputeKernels
        );

    /// <summary>
    /// GetRuntimeFunctionResolutionRequests enumerates the
    /// DkmRuntimeFunctionResolutionRequest elements of this DkmProcess object.
    /// </summary>
    /// <param name="pRuntimeFunctionResolutionRequests">
    /// [Out] Array containing the enumerated elements.
    ///
    /// The memory for the DkmArray members is allocated by the method implementation
    /// using DkmAllocBytes/DkmAllocArray. It is freed by the caller using the
    /// CAutoDkmArray template or with DkmFreeMemory and manual element release.
    /// </param>
    /// <returns>
    /// S_OK is returned on success, and failure codes are used for any error.
    /// </returns>
    public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetRuntimeFunctionResolutionRequests(
        _Out_ DkmArray<FunctionResolution::DkmRuntimeFunctionResolutionRequest*>* pRuntimeFunctionResolutionRequests
        );

    /// <summary>
    /// Raise a EntryPoint event. Components which implement the event sync interface
    /// will receive the event notification. This method will enqueue the event and
    /// control will immediately return to the caller.
    /// </summary>
    /// <param name="pThread">
    /// [In] DkmThread represents a thread running in the target process.
    /// </param>
    /// <returns>
    /// S_OK is returned on success, and failure codes are used for any error.
    /// </returns>
    public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE OnEntryPoint(
        _In_ DkmThread* pThread
        );

    /// <summary>
    /// Resolves a CPU instruction to a native module, and returns a
    /// DkmNativeInstructionAddress to represent this CPU instruction. If the instruction
    /// pointer is not within a module, a DkmUnknownInstructionAddress object is returned
    /// instead.
    /// </summary>
    /// <param name="InstructionPointer">
    /// [In] Memory address where the native instruction is located.
    /// </param>
    /// <param name="ppAddressObject">
    /// [Out] Abstract representation of an executable code location (ex: EIP value). If
    /// resolved, an Instruction Address will be within a particular module instance. An
    /// Instruction Address is always within a particular Runtime Instance.
    /// </param>
    /// <returns>
    /// S_OK is returned on success, and failure codes are used for any error.
    /// </returns>
    public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE CreateNativeInstructionAddress(
        _In_ UINT64 InstructionPointer,
        _Deref_out_ DkmInstructionAddress** ppAddressObject
        );

    /// <summary>
    /// Resolves a virtual address to a native module. If the virtual address is not
    /// within a module, null is returned (S_FALSE return code in native). Disabled
    /// modules will not be returned.
    /// </summary>
    /// <param name="Address">
    /// [In] Memory address to use as a search key.
    /// </param>
    /// <param name="ppModuleInstance">
    /// [Out,Optional] 'DkmNativeModuleInstance' is used for modules which contain CPU
    /// code and/or are loaded by the Win32 loader.
    /// </param>
    /// <returns>
    /// S_OK is returned if *ppModuleInstance is non-NULL, S_FALSE is returned when
    /// *ppModuleInstance is NULL, and failure codes are used for any error.
    /// </returns>
    public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE FindNativeModule(
        _In_ UINT64 Address,
        _Deref_out_opt_ Native::DkmNativeModuleInstance** ppModuleInstance
        );

    /// <summary>
    /// Resolves a virtual address to a native module. If the virtual address is not
    /// within a module, null is returned (S_FALSE return code in native).
    /// </summary>
    /// <param name="Address">
    /// [In] Memory address to use as a search key.
    /// </param>
    /// <param name="IncludeDisabledModules">
    /// [In] When true, the search will include module instances that have 'IsDisabled'
    /// set to 'true'.
    /// </param>
    /// <param name="ppModuleInstance">
    /// [Out,Optional] 'DkmNativeModuleInstance' is used for modules which contain CPU
    /// code and/or are loaded by the Win32 loader.
    /// </param>
    /// <returns>
    /// S_OK is returned if *ppModuleInstance is non-NULL, S_FALSE is returned when
    /// *ppModuleInstance is NULL, and failure codes are used for any error.
    /// </returns>
    public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE FindNativeModule(
        _In_ UINT64 Address,
        _In_ bool IncludeDisabledModules,
        _Deref_out_opt_ Native::DkmNativeModuleInstance** ppModuleInstance
        );

    /// <summary>
    /// This method will tell the debug monitors to asynchronously break execution of the
    /// debuggee process. An AsyncBreakComplete event is sent after the operation is
    /// complete.
    /// </summary>
    /// <param name="StopImmediately">
    /// [In] If this is set to true, implementers should immediately enter break rather
    /// than trying to find a thread inside the process that is executing code.
    /// </param>
    /// <returns>
    /// S_OK is returned on success, and failure codes are used for any error.
    /// </returns>
    public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE AsyncBreak(
        _In_ bool StopImmediately
        );

    /// <summary>
    /// This method will search the local disk and any configured symbol servers for a
    /// binary that matches the parameters. The path to this file on the local disk is
    /// returned. If the file was on a symbol server, it is downloaded to a cache and the
    /// local path is returned.
    /// </summary>
    /// <param name="pApplicationPath">
    /// [In] The original path to the exe stored in the minidump.
    /// </param>
    /// <param name="pDumpPath">
    /// [In] The path to the dump file.
    /// </param>
    /// <param name="pOriginalPath">
    /// [In] The original path to the binary stored in the minidump.
    /// </param>
    /// <param name="TimeDateStamp">
    /// [In] The time date stamp of the binary in the time_t format.
    /// </param>
    /// <param name="ImageSize">
    /// [In] The size of the image.
    /// </param>
    /// <param name="ppFoundPath">
    /// [Out,Optional] The path on the local disk of the local (or downloaded) binary.
    /// </param>
    /// <returns>
    /// S_OK is returned if *ppFoundPath is non-NULL, S_FALSE is returned when
    /// *ppFoundPath is NULL, and failure codes are used for any error.
    /// </returns>
    public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE LocateBinary(
        _In_ DkmString* pApplicationPath,
        _In_ DkmString* pDumpPath,
        _In_ DkmString* pOriginalPath,
        _In_ UINT32 TimeDateStamp,
        _In_ UINT32 ImageSize,
        _Deref_out_opt_ DkmString** ppFoundPath
        );

    #ifndef EXCLUDE_IDE_ONLY_APIS
    /// <summary>
    /// Disassemble an address range in the debuggee process.
    ///
    /// Location constraint: API must be called from an IDE component (component level
    /// &gt; 100,000).
    /// </summary>
    /// <param name="pAddress">
    /// [In] The address where disassembly should start.
    /// </param>
    /// <param name="Count">
    /// [In] The number of instructions to disassemble.
    /// </param>
    /// <param name="pDisassembledInstructions">
    /// [Out] The results of disassembling the address range.
    ///
    /// The memory for the DkmArray members is allocated by the method implementation
    /// using DkmAllocBytes/DkmAllocArray. It is freed by the caller using the
    /// CAutoDkmArray template or with DkmFreeMemory and manual element release.
    /// </param>
    /// <returns>
    /// S_OK is returned on success, and failure codes are used for any error.
    /// </returns>
    public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Disassemble(
        _In_ DkmInstructionAddress* pAddress,
        _In_ UINT32 Count,
        _Out_ DkmArray<Disassembly::DkmDisassembledInstruction*>* pDisassembledInstructions
        );
    #endif // #ifndef EXCLUDE_IDE_ONLY_APIS

    #ifndef EXCLUDE_IDE_ONLY_APIS
    /// <summary>
    /// Returns the address of the kth instruction relative to a starting address. For
    /// constant length instruction sets, this is simple arithmetic. For variable length
    /// instruction sets, reverse-disassembly is required to obtain this address.
    ///
    /// Location constraint: API must be called from an IDE component (component level
    /// &gt; 100,000).
    /// </summary>
    /// <param name="pStartAddress">
    /// [In] The address of the current instruction where the offset should begin.
    /// </param>
    /// <param name="InstructionOffset">
    /// [In] The number of instructions relative to StartAddress to find the desired
    /// address. This value can be negative.
    /// </param>
    /// <param name="ppAddress">
    /// [Out] The address of the instruction InstructionOffset instructions from
    /// StartAddress.
    /// </param>
    /// <returns>
    /// S_OK is returned on success, and failure codes are used for any error.
    /// </returns>
    public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetInstructionAddress(
        _In_ DkmInstructionAddress* pStartAddress,
        _In_ INT32 InstructionOffset,
        _Deref_out_ DkmInstructionAddress** ppAddress
        );
    #endif // #ifndef EXCLUDE_IDE_ONLY_APIS

    /// <summary>
    /// This method will write out a memory dump of the process to the path specified.
    /// </summary>
    /// <param name="DumpType">
    /// [In] The type of dump to write. Either minidump or full-memory minidump.
    /// </param>
    /// <param name="pPath">
    /// [In] The full path to where the minidump should be saved. In remote scenarios,
    /// this path is relative to the remote machine.
    /// </param>
    /// <param name="pTargetThread">
    /// [In,Optional] The thread to use for the minidump if there is no current
    /// exception.
    /// </param>
    /// <returns>
    /// S_OK is returned on success, and failure codes are used for any error.
    /// </returns>
    public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE WriteDump(
        _In_ DkmDumpType_t DumpType,
        _In_ DkmString* pPath,
        _In_opt_ DkmThread* pTargetThread
        );

    /// <summary>
    /// Adds an exception trigger so that ExceptionTriggerHit events will be sent when
    /// the exception trigger has been met.
    ///
    /// If there is already an exception triggered defined for this {SourceId,
    /// DkmExceptionTrigger} tuple then the existing trigger will be modified with the
    /// new settings. For example, if a component defines a trigger to stop when an
    /// access violation exception is thrown and later sets a trigger to fire when any
    /// Win32 exception goes unhandled, then the access violation trigger will be
    /// removed.
    /// </summary>
    /// <param name="SourceId">
    /// [In] Identifies the source of an object. SourceIds are used to enable filtering
    /// in scenarios when multiple components may be creating instances of a class. For
    /// example, source ids can be used to determine if a breakpoint comes from the AD7
    /// AL (ex: user breakpoint, or other breakpoint visible at the SDM level) instead of
    /// a breakpoint which may be created by another component (for example an internal
    /// breakpoint used for stepping).
    /// </param>
    /// <param name="pTrigger">
    /// [In] Describes an exception or collection of exceptions which a component wants
    /// to break on. When a higher level components wants to be notified about certain
    /// exceptions, it should create one or more exception triggers, and then enable
    /// these triggers (DkmProcess.EnableExceptionTriggers). After this, when the
    /// exception occurs, a ExceptionTriggerHit exception will be fired whenever this
    /// trigger is met.
    /// </param>
    /// <returns>
    /// S_OK is returned on success, and failure codes are used for any error.
    /// </returns>
    public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE AddExceptionTrigger(
        _In_ const GUID& SourceId,
        _In_ Exceptions::DkmExceptionTrigger* pTrigger
        );

    /// <summary>
    /// Adds an exception trigger so that ExceptionTriggerHit events will be sent when
    /// the exception trigger has been met.
    ///
    /// If there is already an exception triggered defined for this {SourceId,
    /// DkmExceptionTrigger} tuple then the existing trigger will be modified with the
    /// new settings. For example, if a component defines a trigger to stop when an
    /// access violation exception is thrown and later sets a trigger to fire when any
    /// Win32 exception goes unhandled, then the access violation trigger will be
    /// removed.
    ///
    /// This method will append a new work item to the specified work list, and return
    /// once the work item has been appended. The actual processing of the work item is
    /// asynchronous. The caller will be notified that the request is complete through
    /// the completion routine.
    /// </summary>
    /// <param name="pWorkList">
    /// WorkList to append the new work item to.
    /// </param>
    /// <param name="SourceId">
    /// [In] Identifies the source of an object. SourceIds are used to enable filtering
    /// in scenarios when multiple components may be creating instances of a class. For
    /// example, source ids can be used to determine if a breakpoint comes from the AD7
    /// AL (ex: user breakpoint, or other breakpoint visible at the SDM level) instead of
    /// a breakpoint which may be created by another component (for example an internal
    /// breakpoint used for stepping).
    /// </param>
    /// <param name="pTrigger">
    /// [In] Describes an exception or collection of exceptions which a component wants
    /// to break on. When a higher level components wants to be notified about certain
    /// exceptions, it should create one or more exception triggers, and then enable
    /// these triggers (DkmProcess.EnableExceptionTriggers). After this, when the
    /// exception occurs, a ExceptionTriggerHit exception will be fired whenever this
    /// trigger is met.
    /// </param>
    /// <param name="pCompletionRoutine">
    /// Routine to fire when the request is complete. If the request is successfully
    /// appended to the work list, this will always fire (including when the operation is
    /// canceled). This will never fire if appending the work item fails.
    /// </param>
    /// <returns>
    /// S_OK is returned on success, and failure codes are used for any error.
    /// </returns>
    public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE AddExceptionTrigger(
        _In_ DkmWorkList* pWorkList,
        _In_ const GUID& SourceId,
        _In_ Exceptions::DkmExceptionTrigger* pTrigger,
        _In_ IDkmCompletionRoutine<Exceptions::DkmAddExceptionTriggerAsyncResult>* pCompletionRoutine
        );

    /// <summary>
    /// Removes all the exception triggers which have been set with a particular
    /// SourceId. After this method returns, the exception triggers will no longer raise
    /// ExceptionTriggerHit events. Exception triggers are automatically cleared when the
    /// DkmProcess object is closed.
    /// </summary>
    /// <param name="SourceId">
    /// [In] Identifies the source of an object. SourceIds are used to enable filtering
    /// in scenarios when multiple components may be creating instances of a class. For
    /// example, source ids can be used to determine if a breakpoint comes from the AD7
    /// AL (ex: user breakpoint, or other breakpoint visible at the SDM level) instead of
    /// a breakpoint which may be created by another component (for example an internal
    /// breakpoint used for stepping).
    /// </param>
    /// <returns>
    /// S_OK is returned on success, and failure codes are used for any error.
    /// </returns>
    public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ClearExceptionTriggers(
        _In_ const GUID& SourceId
        );

    /// <summary>
    /// The method will return the contents of the IMAGE_RUNTIME_FUNCTION_ENTRY for an
    /// address if possible. For searching static entries, callers should call the
    /// equivalent method on DkmNativeModuleInstance.
    /// </summary>
    /// <param name="Address">
    /// [In] The virtual address for which to find a function table entry for.
    /// </param>
    /// <param name="pBaseAddress">
    /// [Out] The base address for the runtime function table entry.
    /// </param>
    /// <param name="ppFunctionTableEntry">
    /// [Out,Optional] The runtime function table entry for this address if found.
    /// </param>
    /// <returns>
    /// S_OK is returned if *ppFunctionTableEntry is non-NULL, S_FALSE is returned when
    /// *ppFunctionTableEntry is NULL, and failure codes are used for any error.
    /// </returns>
    public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE SearchRuntimeFunctionTable(
        _In_ UINT64 Address,
        _Out_ UINT64* pBaseAddress,
        _Deref_out_opt_ DkmReadOnlyCollection<BYTE>** ppFunctionTableEntry
        );

    /// <summary>
    /// Get the breakpoint behavior of the process.
    /// </summary>
    /// <param name="pBreakpointBehavior">
    /// [Out] The breakpoint behavior of the process.
    /// </param>
    /// <returns>
    /// S_OK is returned on success, and failure codes are used for any error.
    /// </returns>
    public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetGPUBreakpointBehavior(
        _Out_ GPU::DkmGPUBreakpointBehaviorFlags_t* pBreakpointBehavior
        );

    /// <summary>
    /// Enables / disables a particular GPU memory access warning.
    /// </summary>
    /// <param name="WarningCode">
    /// [In] Warning code to set.
    /// </param>
    /// <param name="Enable">
    /// [In] True to set the warning, false to clear it.
    /// </param>
    /// <returns>
    /// S_OK is returned on success, and failure codes are used for any error.
    /// </returns>
    public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE SetGPUMemoryAccessWarning(
        _In_ UINT32 WarningCode,
        _In_ bool Enable
        );

    /// <summary>
    /// Disables all active GPU memory access warnings.
    /// </summary>
    /// <returns>
    /// S_OK is returned on success, and failure codes are used for any error.
    /// </returns>
    public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ClearAllGPUMemoryAccessWarnings(
        );

    #ifndef EXCLUDE_IDE_ONLY_APIS
    /// <summary>
    /// Resolves a CPU InstructionAddress to a DkmInstructionAddress.
    ///
    /// This method will append a new work item to the specified work list, and return
    /// once the work item has been appended. The actual processing of the work item is
    /// asynchronous. The caller will be notified that the request is complete through
    /// the completion routine.
    ///
    /// Location constraint: API must be called from an IDE component (component level
    /// &gt; 100,000).
    /// </summary>
    /// <param name="pWorkList">
    /// WorkList to append the new work item to.
    /// </param>
    /// <param name="InstructionPointer">
    /// [In] Memory address where the native instruction is located.
    /// </param>
    /// <param name="pCompletionRoutine">
    /// Routine to fire when the request is complete. If the request is successfully
    /// appended to the work list, this will always fire (including when the operation is
    /// canceled). This will never fire if appending the work item fails.
    /// </param>
    /// <returns>
    /// S_OK is returned on success, and failure codes are used for any error.
    /// </returns>
    public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetInstructionAddress(
        _In_ DkmWorkList* pWorkList,
        _In_ UINT64 InstructionPointer,
        _In_ IDkmCompletionRoutine<DkmGetInstructionAddressAsyncResult>* pCompletionRoutine
        );
    #endif // #ifndef EXCLUDE_IDE_ONLY_APIS

    #ifndef EXCLUDE_MONITOR_ONLY_APIS
    /// <summary>
    /// Method called by the base debug monitor to inform other components that the
    /// instruction memory of the target process was modified. Currently, this is only
    /// used for breakpoint insertion.
    ///
    /// Location constraint: API must be called from a Monitor component (component level
    /// &lt; 100,000).
    /// </summary>
    /// <param name="Address">
    /// [In] The base address from which to write the target process's memory.
    /// </param>
    /// <param name="OriginalMemory">
    /// [In] The original code bytes which were replaced in the target process.
    ///
    /// The memory for the DkmArray members is allocated by the caller, and can be from
    /// any source (stack memory, static buffer, heap, etc). The implementation should
    /// not modify the members.
    /// </param>
    /// <returns>
    /// S_OK is returned on success, and failure codes are used for any error.
    /// </returns>
    public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE OnInstructionPatchInserted(
        _In_ UINT64 Address,
        _In_ const DkmArray<BYTE>& OriginalMemory
        );
    #endif // #ifndef EXCLUDE_MONITOR_ONLY_APIS

    #ifndef EXCLUDE_MONITOR_ONLY_APIS
    /// <summary>
    /// Method called by the base debug monitor to inform other components that the
    /// instruction memory of the target process was restored to its original state.
    /// Currently, this is only used for breakpoint removal.
    ///
    /// Location constraint: API must be called from a Monitor component (component level
    /// &lt; 100,000).
    /// </summary>
    /// <param name="Address">
    /// [In] The base address from which to write the target process's memory.
    /// </param>
    /// <param name="OriginalMemory">
    /// [In] The original code bytes which were restored in the target process.
    ///
    /// The memory for the DkmArray members is allocated by the caller, and can be from
    /// any source (stack memory, static buffer, heap, etc). The implementation should
    /// not modify the members.
    /// </param>
    /// <returns>
    /// S_OK is returned on success, and failure codes are used for any error.
    /// </returns>
    public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE OnInstructionPatchRemoved(
        _In_ UINT64 Address,
        _In_ const DkmArray<BYTE>& OriginalMemory
        );
    #endif // #ifndef EXCLUDE_MONITOR_ONLY_APIS

    /// <summary>
    /// Read the memory of the target process.
    /// </summary>
    /// <param name="Address">
    /// [In] The base address from which to read the target process's memory.
    /// </param>
    /// <param name="Flags">
    /// [In] Flags controlling the behavior of DkmProcess.ReadMemory and
    /// DkmProcess.ReadMemoryString.
    /// </param>
    /// <param name="pBuffer">
    /// [In,Out] A buffer that receives the contents from the address space of the target
    /// process. On failure, the content of this buffer is unspecified.
    /// </param>
    /// <param name="Size">
    /// [In] The number of bytes to be read from the process. In scenarios where the call
    /// is marshalled to the remote debugger from the IDE, this must be less than 25 MBs.
    /// </param>
    /// <param name="pBytesRead">
    /// [Out,Optional] Indicates the number of bytes read from the target process. If
    /// DkmReadMemoryFlags.AllowPartialRead is clear, on success this value will always
    /// be exactly equal to the input size. If DkmReadMemoryFlags.AllowPartialRead is
    /// specified, on success, this value will be greater than zero.
    /// </param>
    /// <returns>
    /// S_OK is returned on success, and failure codes are used for any error.
    /// E_INVALID_MEMORY_ADDRESS indicates that the address is not valid. See
    /// 'DkmReadMemoryFlags.AllowPartialRead' documentation for more information.
    /// </returns>
    public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ReadMemory(
        _In_ UINT64 Address,
        _In_ DkmReadMemoryFlags_t Flags,
        _Out_capcount_(Size) void* pBuffer,
        _In_ UINT32 Size,
        _Out_ UINT32* pBytesRead
        );

    /// <summary>
    /// Reads a null-terminated string from the target process process's memory. This can
    /// be used to read an ANSI or Unicode (UTF-8, UTF-16 or UTF-32) strings.
    /// </summary>
    /// <param name="Address">
    /// [In] The base address from which to read the target process's memory.
    /// </param>
    /// <param name="Flags">
    /// [In] Flags controlling the behavior of DkmProcess.ReadMemory and
    /// DkmProcess.ReadMemoryString.
    /// </param>
    /// <param name="CharacterSize">
    /// [In] Number of bytes in each character. This should be set to 1 (ANSI/UTF-8), 2
    /// (UTF-16) or 4 (UTF-32).
    /// </param>
    /// <param name="MaxCharacters">
    /// [In] The maximum number of characters to read from the target process. When
    /// DkmReadMemoryFlags.AllowPartialRead is false, the request will fail if a null
    /// terminator isn't found within this range. This value should be reasonable. The
    /// Microsoft implementation will fail any request for more than 25 MBs of string
    /// memory.
    /// </param>
    /// <param name="pStringMemory">
    /// [Out] The value of the string which was read from the target process. If
    /// DkmReadMemoryFlags.AllowPartialRead is clear, this memory will always include the
    /// null termination character. If DkmReadMemoryFlags.AllowPartialRead is specified,
    /// this buffer will not contain the null termination character if the read was
    /// truncated.
    ///
    /// The memory for the DkmArray members is allocated by the method implementation
    /// using DkmAllocBytes/DkmAllocArray. It is freed by the caller using the
    /// CAutoDkmArray template or with DkmFreeMemory and manual element release.
    /// </param>
    /// <returns>
    /// S_OK is returned on success, and failure codes are used for any error.
    /// E_INVALID_MEMORY_ADDRESS indicates that the address is not valid. See
    /// 'DkmReadMemoryFlags.AllowPartialRead' documentation for more information.
    /// E_STRING_TOO_LONG indicates that the string could not be read within the
    /// specified maximum number of characters.
    /// </returns>
    public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ReadMemoryString(
        _In_ UINT64 Address,
        _In_ DkmReadMemoryFlags_t Flags,
        _In_ UINT16 CharacterSize,
        _In_ UINT32 MaxCharacters,
        _Out_ DkmArray<BYTE>* pStringMemory
        );

    /// <summary>
    /// Writes memory to the target process. Before data transfer occurs, the system
    /// verifies that all data in the base address and memory of the specified size is
    /// accessible for write access, and if it is not accessible, the function raises an
    /// E_INVALID_MEMORY_ADDRESS error.
    /// </summary>
    /// <param name="Address">
    /// [In] The base address from which to write the target process's memory.
    /// </param>
    /// <param name="Data">
    /// [In] Data to be written in the address space of the specified process.
    ///
    /// The memory for the DkmArray members is allocated by the caller, and can be from
    /// any source (stack memory, static buffer, heap, etc). The implementation should
    /// not modify the members.
    /// </param>
    /// <returns>
    /// S_OK is returned on success, and failure codes are used for any error.
    /// </returns>
    public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE WriteMemory(
        _In_ UINT64 Address,
        _In_ const DkmArray<BYTE>& Data
        );

    /// <summary>
    /// Write memory to the target process, but hide the write from calls to ReadMemory.
    /// This API may be used to patch instructions or data within the target process to
    /// implement debugger features. Before data transfer occurs, the system verifies
    /// that all data in the base address and memory of the specified size is accessible
    /// for write access, and if it is not accessible, the function raises an
    /// E_INVALID_MEMORY_ADDRESS error.
    /// </summary>
    /// <param name="Address">
    /// [In] The base address from which to write the target process's memory.
    /// </param>
    /// <param name="Data">
    /// [In] Data to be written in the address space of the specified process.
    ///
    /// The memory for the DkmArray members is allocated by the caller, and can be from
    /// any source (stack memory, static buffer, heap, etc). The implementation should
    /// not modify the members.
    /// </param>
    /// <returns>
    /// S_OK is returned on success, and failure codes are used for any error.
    /// </returns>
    public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE InvisibleWriteMemory(
        _In_ UINT64 Address,
        _In_ const DkmArray<BYTE>& Data
        );

    /// <summary>
    /// Obtains the number of active handles in the process.
    /// </summary>
    /// <param name="pHandleCount">
    /// [Out] The number of handles in the debuggee process.
    /// </param>
    /// <returns>
    /// S_OK is returned on success, and failure codes are used for any error.
    /// </returns>
    public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetHandleCount(
        _Out_ UINT32* pHandleCount
        );

    /// <summary>
    /// Obtains the number of clock cycles that the debuggee has been running since
    /// ResetRunningTime() was last called.
    /// </summary>
    /// <param name="pRunningTime">
    /// [Out] The time the debuggee has been running.
    /// </param>
    /// <returns>
    /// S_OK is returned on success, and failure codes are used for any error.
    /// </returns>
    public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetRunningTime(
        _Out_ UINT64* pRunningTime
        );

    /// <summary>
    /// Sets the running time counter to the specified value.
    /// </summary>
    /// <param name="RunningTime">
    /// [In] The value to set the clock to.
    /// </param>
    /// <returns>
    /// S_OK is returned on success, and failure codes are used for any error.
    /// </returns>
    public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE SetRunningTime(
        _In_ UINT64 RunningTime
        );

    /// <summary>
    /// Provides access to the DkmRuntimeInstance which is for the naive code within a
    /// process. There is exactly one DkmRuntimeInstance for a process.
    /// </summary>
    /// <param name="ppRuntimeInstance">
    /// [Out] Represents the native code executing in a target process.
    /// </param>
    /// <returns>
    /// S_OK is returned on success, and failure codes are used for any error.
    /// </returns>
    public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetNativeRuntimeInstance(
        _Deref_out_ Native::DkmNativeRuntimeInstance** ppRuntimeInstance
        );

    /// <summary>
    /// This method is called to tell the monitor to detach from the target process. This
    /// will trigger a ProcessExit event to be sent on the event thread.
    /// </summary>
    /// <returns>
    /// S_OK is returned on success, and failure codes are used for any error.
    /// </returns>
    public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Detach(
        );

    /// <summary>
    /// This method is called to tell the monitor to terminate the target process. This
    /// will trigger a ProcessExit event to be sent on the event thread.
    /// </summary>
    /// <param name="ExitCode">
    /// [In] The exit code to be used by the process and threads terminated as a result
    /// of this call. Use the GetExitCodeProcess function to retrieve a process's exit
    /// value. Use the GetExitCodeThread function to retrieve a thread's exit value.
    /// </param>
    /// <returns>
    /// S_OK is returned on success, and failure codes are used for any error.
    /// </returns>
    public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Terminate(
        _In_ UINT32 ExitCode
        );

    /// <summary>
    /// StoppingEventProcessingBegin is called by the base debug monitor on the event
    /// thread. It notifies the Dispatcher that the target process is stopped and may
    /// have reached a stopping event. For example, the Win32 base debug monitor calls
    /// this whenever it receives an EXCEPTION_DEBUG_EVENT from the operating system.
    /// This method updates the internal state of the DkmProcess object so that stopping
    /// events are allowed to be sent.
    /// </summary>
    /// <param name="ForceQueue">
    /// [In] Normally, the dispatcher will reject (return E_TARGET_ALREADY_STOPPED)
    /// attempts to send additional stopping events after the target process has received
    /// its initial batch of stopping events (StoppingEventProcessingContinue has been
    /// called). By passing 'true' for this argument, the base debug monitor causes these
    /// events to be queued rather than rejected. This is used by the Win32 debug monitor
    /// when it fully drains the Win32 debugging event queue prior to the start of a
    /// function evaluation.
    /// </param>
    /// <returns>
    /// S_OK is returned on success, and failure codes are used for any error.
    /// </returns>
    public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE StoppingEventProcessingBegin(
        _In_ bool ForceQueue
        );

    /// <summary>
    /// StoppingEventProcessingContinue is called by the base debug monitor on the event
    /// thread. This method is called after all stopping events within the current batch
    /// have been issued (ex: called DkmRuntimeBreakpoint.OnHit). This method will notify
    /// components which have implemented a stopping event notification interface and
    /// will call into the execution manager to slip the process to a safe point. The
    /// base debug monitor must call StoppingEventProcessingContinue after any successful
    /// call to StoppingEventProcessingBegin. the base debug monitor after it has issued
    /// all stopping events.
    ///
    /// A base debug monitor should expect to be reentrantly called while it is in this
    /// method.
    /// </summary>
    /// <param name="pNextAction">
    /// [Out] Status code returned to the base debug monitor to indicate the next action
    /// to take in stopping event processing.
    /// </param>
    /// <returns>
    /// S_OK is returned on success, and failure codes are used for any error.
    /// </returns>
    public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE StoppingEventProcessingContinue(
        _Out_ DkmStoppingEventProcessingNextAction_t* pNextAction
        );

    /// <summary>
    /// AbortingFuncEvalExecution is called by the runtime debug monitor when aborting a
    /// function evaluation. AbortingFuncEvalExecution will update the internal state of
    /// the DkmProcess object so the stopping event manager will allow two stopping
    /// events through: a function evaluation complete breakpoint or an async break.
    /// </summary>
    /// <param name="Flags">
    /// [In] Flags impacting how function evaluation requests are performed.
    /// </param>
    /// <returns>
    /// S_OK is returned on success, and failure codes are used for any error.
    /// </returns>
    public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE AbortingFuncEvalExecution(
        _In_ Evaluation::DkmFuncEvalFlags_t Flags
        );

    /// <summary>
    /// This method allows a component to determined if the process is considered stopped
    /// by the Dispatcher. This method does not need to be called from within an
    /// interface method which requires the target process to be stopped, but it may be
    /// helpful during operations which may be called from run mode.
    /// </summary>
    /// <param name="pResult">
    /// [Out] Returns true if the process is considered stopped. This will return true on
    /// request threads after the debugger has sent a stopping event (ex: breakpoint hit)
    /// to the IDE and before the process has been resumed. It will return true on event
    /// threads if a pausing event (ex: module load) or stopping event (ex: breakpoint
    /// hit) is being processed.
    /// </param>
    /// <returns>
    /// S_OK is returned on success, and failure codes are used for any error.
    /// </returns>
    public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE IsStopped(
        _Out_ bool* pResult
        );

    /// <summary>
    /// Provides the list of active system threads in the process. Threads which are not
    /// system threads (DkmThread::System is null) or have been unloaded, will not be
    /// present in this collection.
    /// </summary>
    /// <param name="pSystemThreads">
    /// [Out] Returned array of system threads.
    ///
    /// The memory for the DkmArray members is allocated by the method implementation
    /// using DkmAllocBytes/DkmAllocArray. It is freed by the caller using the
    /// CAutoDkmArray template or with DkmFreeMemory and manual element release.
    /// </param>
    /// <returns>
    /// S_OK is returned on success, and failure codes are used for any error.
    /// </returns>
    public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetSystemThreads(
        _Out_ DkmArray<DkmThread*>* pSystemThreads
        );

    /// <summary>
    /// Reserves and/or commits a region of memory within the virtual address space of
    /// the target process. The function initializes the memory it allocates to zero,
    /// unless MEM_RESET is used. For additional information, see the VirtualAlloc Win32
    /// API in MSDN.
    /// </summary>
    /// <param name="Address">
    /// [In] Address within the target process where the memory should be committed or
    /// reserved. This value is typically zero, in which case the system chooses an
    /// address.
    /// </param>
    /// <param name="Size">
    /// [In] The size of the region of memory to allocate, in bytes. The system will
    /// automatically round up to the next page boundary.
    /// </param>
    /// <param name="AllocationType">
    /// [In] Indicates the type of allocation to perform. This is typically MEM_COMMIT |
    /// MEM_RESERVE (0x3000) which reserves and commits an allocation in one step.
    /// </param>
    /// <param name="PageProtection">
    /// [In] The memory protection for the region of pages to be allocated. If the pages
    /// are being committed, you can specify any one of the memory protection constants
    /// (ex: PAGE_READWRITE, PAGE_EXECUTE).
    /// </param>
    /// <param name="pAllocatedAddress">
    /// [Out] Base address of the allocated region of pages.
    /// </param>
    /// <returns>
    /// S_OK is returned on success, and failure codes are used for any error.
    /// </returns>
    public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE AllocateVirtualMemory(
        _In_ UINT64 Address,
        _In_ UINT32 Size,
        _In_ UINT32 AllocationType,
        _In_ UINT32 PageProtection,
        _Out_ UINT64* pAllocatedAddress
        );

    /// <summary>
    /// Releases and/or decommits a region of memory within the virtual address space of
    /// the target process. For additional information, see the VirtualFree Win32 API in
    /// MSDN.
    /// </summary>
    /// <param name="Address">
    /// [In] Address within the target process where the memory should be freed.
    /// </param>
    /// <param name="Size">
    /// [In] Number of bytes to decommit. To release a region of memory, this value must
    /// be zero.
    /// </param>
    /// <param name="FreeType">
    /// [In] Indicates the type of free operation to perform. This is typically
    /// MEM_RELEASE (0x8000), which releases the specified region of pages. After the
    /// operation, the pages are in the free state. MEM_DECOMMIT (0x4000) can be used
    /// instead to decommit the pages without releasing them.
    /// </param>
    /// <returns>
    /// S_OK is returned on success, and failure codes are used for any error.
    /// </returns>
    public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE FreeVirtualMemory(
        _In_ UINT64 Address,
        _In_ UINT32 Size,
        _In_ UINT32 FreeType
        );

    /// <summary>
    /// Read memory from the target process. This method differs from 'ReadMemory' in
    /// that this method can be called at any time (not just when the target is stopped)
    /// and the debugger will not try to cache the result of this operation.
    /// </summary>
    /// <param name="Address">
    /// [In] The base address from which to read the target process's memory.
    /// </param>
    /// <param name="pBuffer">
    /// [In,Out] A buffer that receives the contents from the address space of the target
    /// process. On failure, the content of this buffer is unspecified.
    /// </param>
    /// <param name="Size">
    /// [In] The number of bytes to be read from the process. In scenarios where the call
    /// is marshalled to the remote debugger from the IDE, this must be less than 25 MBs.
    /// </param>
    /// <returns>
    /// S_OK is returned on success, and failure codes are used for any error.
    /// E_INVALID_MEMORY_ADDRESS indicates that one or more bytes of the request could
    /// not be read.
    /// </returns>
    public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE VolatileReadMemory(
        _In_ UINT64 Address,
        _Out_capcount_(Size) void* pBuffer,
        _In_ UINT32 Size
        );

    /// <summary>
    /// Write to the memory of the target process. This method differs from 'WriteMemory'
    /// in that this method can be called at any time (not just when the target is
    /// stopped) and the debugger will not try to cache the result of this operation. If
    /// any memory cannot be written to, an E_INVALID_MEMORY_ADDRESS error will be
    /// raised. Because the memory write may occur from run mode, this failure may happen
    /// after the copy operation has already begun, and thus may lead to memory
    /// corruption in the target process. For this reason, this function must be used
    /// with care, and failures may be fatal.
    /// </summary>
    /// <param name="Address">
    /// [In] The base address from which to write the target process's memory.
    /// </param>
    /// <param name="Data">
    /// [In] Data to be written in the address space of the specified process.
    ///
    /// The memory for the DkmArray members is allocated by the caller, and can be from
    /// any source (stack memory, static buffer, heap, etc). The implementation should
    /// not modify the members.
    /// </param>
    /// <returns>
    /// S_OK is returned on success, and failure codes are used for any error.
    /// </returns>
    public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE VolatileWriteMemory(
        _In_ UINT64 Address,
        _In_ const DkmArray<BYTE>& Data
        );

    /// <summary>
    /// This method is called by the process's base debug monitor to raise a LoadComplete
    /// event. LoadComplete is issued after DkmModuleInstance objects have been created
    /// for the initial set of modules in the process, and generally the initial set of
    /// threads have also been created.
    ///
    /// The load complete event may be deferred by a runtime debug monitor using
    /// DkmLoadCompleteEventDeferral.Add, in which case this method will immediately
    /// complete. Otherwise, this method will send the event to all components which
    /// implement the event sync interface. Control will return once all components have
    /// been notified.
    ///
    /// This method may only be called by the component which created the object.
    /// </summary>
    /// <returns>
    /// S_OK is returned on success, and failure codes are used for any error.
    /// </returns>
    public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE OnLoadComplete(
        );

    /// <summary>
    /// ProcessExit is sent by the dispatcher when DkmProcess::Unload is invoked by the
    /// monitor.
    ///
    /// This method may only be called by the component which created the object.
    /// </summary>
    /// <param name="ExitCode">
    /// [In] 32-bit value which the processed returned on exit. This is the same value
    /// that would be reported from the kernel32!GetExitCodeProcess.
    /// </param>
    /// <returns>
    /// S_OK is returned on success, and failure codes are used for any error.
    /// </returns>
    public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Unload(
        _In_ UINT32 ExitCode
        );

    /// <summary>
    /// Called to initiate locating of binaries whose images might not have previously
    /// found or attempted to be loaded. This method will search the local disk and any
    /// configured symbol servers for a binary that matches the parameters. The path to
    /// this file on the local disk is returned. If the file was on a symbol server, it
    /// is downloaded to a cache and the local path is returned.
    ///
    /// This API was introduced in Visual Studio 11 Update 1
    /// (DkmApiVersion.VS11FeaturePack1).
    /// </summary>
    /// <param name="pApplicationPath">
    /// [In] The original path to the exe stored in the minidump.
    /// </param>
    /// <param name="pDumpPath">
    /// [In] The path to the dump file.
    /// </param>
    /// <param name="pOriginalPath">
    /// [In] The original path to the binary stored in the minidump.
    /// </param>
    /// <param name="TimeDateStamp">
    /// [In] The time date stamp of the binary in the time_t format.
    /// </param>
    /// <param name="ImageSize">
    /// [In] The size of the image.
    /// </param>
    /// <param name="ppFoundPath">
    /// [Out,Optional] The path on the local disk of the local (or downloaded) binary.
    /// </param>
    /// <returns>
    /// S_OK is returned if *ppFoundPath is non-NULL, S_FALSE is returned when
    /// *ppFoundPath is NULL, and failure codes are used for any error.
    /// </returns>
    public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE TryLocateBinary(
        _In_ DkmString* pApplicationPath,
        _In_ DkmString* pDumpPath,
        _In_ DkmString* pOriginalPath,
        _In_ UINT32 TimeDateStamp,
        _In_ UINT32 ImageSize,
        _Deref_out_opt_ DkmString** ppFoundPath
        );

    /// <summary>
    /// Returns the path to the primary executable in the minidump being debugged.
    ///
    /// This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
    /// </summary>
    /// <param name="ppExePath">
    /// [Out] Path to the debuggee's primary executable file.
    /// </param>
    /// <returns>
    /// S_OK is returned on success, and failure codes are used for any error.
    /// </returns>
    public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetDumpExePath(
        _Deref_out_ DkmString** ppExePath
        );

    /// <summary>
    /// Returns true if once all the initial module loads/thread creates have been sent
    /// for all the runtimes present when we started debugging the process. Note that
    /// this definition may be different from the Win32 Debug API definition of load
    /// complete since other runtime instances may need additional time to load.
    ///
    /// This API was introduced in Visual Studio 12 Update 2 (DkmApiVersion.VS12Update2).
    /// </summary>
    /// <param name="pResult">
    /// [Out] True if the process has reached load complete.
    /// </param>
    /// <returns>
    /// S_OK is returned on success, and failure codes are used for any error.
    /// </returns>
    public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE IsLoadComplete(
        _Out_ bool* pResult
        );

    /// <summary>
    /// Get the stowed exceptions from a dump.
    ///
    /// This API was introduced in Visual Studio 12 Update 3 (DkmApiVersion.VS12Update3).
    /// </summary>
    /// <param name="pStowedExceptions">
    /// [Out] An array of stowed exception records contained in the dump.
    ///
    /// The memory for the DkmArray members is allocated by the method implementation
    /// using DkmAllocBytes/DkmAllocArray. It is freed by the caller using the
    /// CAutoDkmArray template or with DkmFreeMemory and manual element release.
    /// </param>
    /// <returns>
    /// S_OK is returned on success, and failure codes are used for any error.
    /// </returns>
    public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetStowedExceptions(
        _Out_ DkmArray<Exceptions::DkmStowedExceptionInformation*>* pStowedExceptions
        );

    /// <summary>
    /// Get the native stowed exception from a dump. This will return S_FALSE if there is
    /// no native stowed exception.
    ///
    /// This API was introduced in Visual Studio 12 Update 3 (DkmApiVersion.VS12Update3).
    /// </summary>
    /// <param name="ppNativeStowedException">
    /// [Out,Optional] The native stowed exception from the dump, or NULL if there is no
    /// native stowed exception.
    /// </param>
    /// <returns>
    /// S_OK is returned if *ppNativeStowedException is non-NULL, S_FALSE is returned
    /// when *ppNativeStowedException is NULL, and failure codes are used for any error.
    /// </returns>
    public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetNativeStowedException(
        _Deref_out_opt_ Exceptions::DkmStowedExceptionInformation** ppNativeStowedException
        );

    /// <summary>
    /// Get the managed stowed exception from a dump. This will return S_FALSE if there
    /// is no managed stowed exception.
    ///
    /// This API was introduced in Visual Studio 12 Update 3 (DkmApiVersion.VS12Update3).
    /// </summary>
    /// <param name="ppManagedStowedException">
    /// [Out,Optional] The managed stowed exception from the dump, or NULL if there is no
    /// managed stowed exception.
    /// </param>
    /// <returns>
    /// S_OK is returned if *ppManagedStowedException is non-NULL, S_FALSE is returned
    /// when *ppManagedStowedException is NULL, and failure codes are used for any error.
    /// </returns>
    public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetManagedStowedException(
        _Deref_out_opt_ Exceptions::DkmStowedExceptionInformation** ppManagedStowedException
        );

    /// <summary>
    /// Raise a HiddenEntryPoint event. Components which implement the event sync
    /// interface will receive the event notification. This method will enqueue the event
    /// and control will immediately return to the caller.
    ///
    /// This API was introduced in Visual Studio 14 RTM (DkmApiVersion.VS14RTM).
    /// </summary>
    /// <param name="pThread">
    /// [In] DkmThread represents a thread running in the target process.
    /// </param>
    /// <returns>
    /// S_OK is returned on success, and failure codes are used for any error.
    /// </returns>
    public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE OnHiddenEntryPoint(
        _In_ DkmThread* pThread
        );

    #ifndef EXCLUDE_IDE_ONLY_APIS
    /// <summary>
    /// Handler which is notified before the target process is terminated or detached.
    ///
    /// Location constraint: API must be called from an IDE component (component level
    /// &gt; 100,000).
    ///
    /// This API was introduced in Visual Studio 14 RTM (DkmApiVersion.VS14RTM).
    /// </summary>
    /// <returns>
    /// S_OK is returned on success, and failure codes are used for any error.
    /// </returns>
    public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE BeforeStopDebugging(
        );
    #endif // #ifndef EXCLUDE_IDE_ONLY_APIS

    /// <summary>
    /// Called by a component to indicate that detach is not allowed on the process.
    ///
    /// This API was introduced in Visual Studio 14 RTM (DkmApiVersion.VS14RTM).
    /// </summary>
    /// <param name="ReasonCode">
    /// [In] HRESULT indicating why detach is not available. This should be a failed
    /// HRESULT value (value less than zero).
    /// </param>
    /// <returns>
    /// S_OK is returned on success, and failure codes are used for any error.
    /// </returns>
    public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE SetDetachUnavailable(
        _In_ HRESULT ReasonCode
        );

    /// <summary>
    /// Removes an exception trigger previously set. Note that the processing stage is
    /// ignored and does not need to match the value originally provided.
    ///
    /// This API was introduced in Visual Studio 14 RTM (DkmApiVersion.VS14RTM).
    /// </summary>
    /// <param name="SourceId">
    /// [In] Identifies the source of an object. SourceIds are used to enable filtering
    /// in scenarios when multiple components may be creating instances of a class. For
    /// example, source ids can be used to determine if a breakpoint comes from the AD7
    /// AL (ex: user breakpoint, or other breakpoint visible at the SDM level) instead of
    /// a breakpoint which may be created by another component (for example an internal
    /// breakpoint used for stepping).
    /// </param>
    /// <param name="pTrigger">
    /// [In] Describes an exception or collection of exceptions which a component wants
    /// to break on. When a higher level components wants to be notified about certain
    /// exceptions, it should create one or more exception triggers, and then enable
    /// these triggers (DkmProcess.EnableExceptionTriggers). After this, when the
    /// exception occurs, a ExceptionTriggerHit exception will be fired whenever this
    /// trigger is met.
    /// </param>
    /// <returns>
    /// S_OK is returned on success, and failure codes are used for any error.
    /// </returns>
    public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE RemoveExceptionTrigger(
        _In_ const GUID& SourceId,
        _In_ Exceptions::DkmExceptionTrigger* pTrigger
        );

    /// <summary>
    /// Removes an exception trigger previously set. Note that the processing stage is
    /// ignored and does not need to match the value originally provided.
    ///
    /// This method will append a new work item to the specified work list, and return
    /// once the work item has been appended. The actual processing of the work item is
    /// asynchronous. The caller will be notified that the request is complete through
    /// the completion routine.
    ///
    /// This API was introduced in Visual Studio 14 RTM (DkmApiVersion.VS14RTM).
    /// </summary>
    /// <param name="pWorkList">
    /// WorkList to append the new work item to.
    /// </param>
    /// <param name="SourceId">
    /// [In] Identifies the source of an object. SourceIds are used to enable filtering
    /// in scenarios when multiple components may be creating instances of a class. For
    /// example, source ids can be used to determine if a breakpoint comes from the AD7
    /// AL (ex: user breakpoint, or other breakpoint visible at the SDM level) instead of
    /// a breakpoint which may be created by another component (for example an internal
    /// breakpoint used for stepping).
    /// </param>
    /// <param name="pTrigger">
    /// [In] Describes an exception or collection of exceptions which a component wants
    /// to break on. When a higher level components wants to be notified about certain
    /// exceptions, it should create one or more exception triggers, and then enable
    /// these triggers (DkmProcess.EnableExceptionTriggers). After this, when the
    /// exception occurs, a ExceptionTriggerHit exception will be fired whenever this
    /// trigger is met.
    /// </param>
    /// <param name="pCompletionRoutine">
    /// Routine to fire when the request is complete. If the request is successfully
    /// appended to the work list, this will always fire (including when the operation is
    /// canceled). This will never fire if appending the work item fails.
    /// </param>
    /// <returns>
    /// S_OK is returned on success, and failure codes are used for any error.
    /// </returns>
    public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE RemoveExceptionTrigger(
        _In_ DkmWorkList* pWorkList,
        _In_ const GUID& SourceId,
        _In_ Exceptions::DkmExceptionTrigger* pTrigger,
        _In_ IDkmCompletionRoutine<Exceptions::DkmRemoveExceptionTriggerAsyncResult>* pCompletionRoutine
        );

    /// <summary>
    /// Asynchronous Method to obtain the timing data from the
    /// IDkmPerformanceMeasurementDispatcherService gathered from events emitted by the
    /// runtimes in the process. This is called asynchronously because obtaining the
    /// debugger overhead can be very expensive.
    ///
    /// This method will append a new work item to the specified work list, and return
    /// once the work item has been appended. The actual processing of the work item is
    /// asynchronous. The caller will be notified that the request is complete through
    /// the completion routine.
    ///
    /// This API was introduced in Visual Studio 14 RTM (DkmApiVersion.VS14RTM).
    /// </summary>
    /// <param name="pWorkList">
    /// WorkList to append the new work item to.
    /// </param>
    /// <param name="pCompletionRoutine">
    /// Routine to fire when the request is complete. If the request is successfully
    /// appended to the work list, this will always fire (including when the operation is
    /// canceled). This will never fire if appending the work item fails.
    /// </param>
    /// <returns>
    /// S_OK is returned on success, and failure codes are used for any error.
    /// </returns>
    public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE QueryPerformanceCounters(
        _In_ DkmWorkList* pWorkList,
        _In_ IDkmCompletionRoutine<DkmPerformanceCountersAsyncResult>* pCompletionRoutine
        );
}; // end of DkmProcess

// Stores a QPC timestamp for a process stop/resume event.
//
// This API was introduced in Visual Studio 14 RTM (DkmApiVersion.VS14RTM).
class DECLSPEC_NOVTABLE DECLSPEC_UUID("ed71c47f-dc09-2abb-d61b-b55a74bdb710") DkmProcessExecutionCounters : public IUnknown
{
    private: ___ReferenceCount_t m_ReferenceCount;
    private: DkmDispatcherObjectFlags_t m_ObjectFlags;
    private: const GUID* m_pTypeId;
    private: size_t m_ObjectGCHandle;
    // Use DkmProcessExecutionCounters::Create to create this object
    private: DkmProcessExecutionCounters();
    // This object is refcounted. It is deleted through Release
    protected: ~DkmProcessExecutionCounters();
    // This object cannot be copied
    private: DkmProcessExecutionCounters& operator=(const DkmProcessExecutionCounters&);
    private: DkmProcessExecutionCounters(const DkmProcessExecutionCounters&);

    private: const UINT64 m_QueryPerformanceCounterTime;
    private: void* m__pExtendedData;

    // QPC time for this event.
    //
    // This API was introduced in Visual Studio 14 RTM (DkmApiVersion.VS14RTM).
    public: DECLSPEC_NOTHROW UINT64 STDMETHODCALLTYPE QueryPerformanceCounterTime(
        );

    /// <summary>
    /// Create a new DkmProcessExecutionCounters object instance.
    ///
    /// This API was introduced in Visual Studio 14 RTM (DkmApiVersion.VS14RTM).
    /// </summary>
    /// <param name="QueryPerformanceCounterTime">
    /// [In] QPC time for this event.
    /// </param>
    /// <param name="ppCreatedObject">
    /// [Out] Result of this method call.
    /// </param>
    /// <returns>
    /// S_OK is returned on success, and failure codes are used for any error.
    /// </returns>
    public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
        _In_ UINT64 QueryPerformanceCounterTime,
        _Deref_out_ DkmProcessExecutionCounters** ppCreatedObject
        );
}; // end of DkmProcessExecutionCounters

// Flags controlling the behavior of DkmProcess.ReadMemory and
// DkmProcess.ReadMemoryString.
DEFINE_SCOPED_ENUM(DkmReadMemoryFlags)
{
    // Indicates that the caller wants the default behavior for ReadMemory.
    None = 0x0,
    // Indicates that the caller wants the read operation to succeed if only part of the
    // memory read succeeded. If this is set, an E_INVALID_MEMORY_ADDRESS error will only
    // be raised if 'Address' is invalid. If this flag is clear, a
    // E_INVALID_MEMORY_ADDRESS error will be raised if any portion of the requested
    // memory was unreadable.
    AllowPartialRead = 0x1,
    // Indicates that the read should only succeed if the memory pages in question have
    // one of the the execute flags set (PAGE_EXECUTE, PAGE_EXECUTE_READONLY, etc.). If
    // combined with AllowPartialRead, this will return all memory between the starting
    // address and the end of the executable region. If no executable code is found, the
    // read fails with E_INVALID_MEMORY_PROTECT.
    ExecutableOnly = 0x2,
    // Indicates that the read is a GPU C++ AMP pointer and that the high bits should be
    // read from the tag memory.
    ReadGPUPointer = 0x4
};
DEFINE_SCOPED_ENUM_FLAG_OPERATORS(DkmReadMemoryFlags_t);

// A key/value pair read from the registry.
//
// This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
class DECLSPEC_NOVTABLE DECLSPEC_UUID("cc23b95f-53fb-bc5a-454c-9345558fa0fe") DkmRegistryTweak : public IUnknown
{
    private: ___ReferenceCount_t m_ReferenceCount;
    private: DkmDispatcherObjectFlags_t m_ObjectFlags;
    private: const GUID* m_pTypeId;
    private: size_t m_ObjectGCHandle;
    // Use DkmRegistryTweak::Create to create this object
    private: DkmRegistryTweak();
    // This object is refcounted. It is deleted through Release
    protected: ~DkmRegistryTweak();
    // This object cannot be copied
    private: DkmRegistryTweak& operator=(const DkmRegistryTweak&);
    private: DkmRegistryTweak(const DkmRegistryTweak&);

    private: DkmString* const m_pValueName;
    private: const UINT32 m_Data;
    private: void* m__pExtendedData;

    // The name of the registry value that specifies this tweak.
    //
    // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
    public: _Ret_ DECLSPEC_NOTHROW DkmString* STDMETHODCALLTYPE ValueName(
        );

    // The value of this tweak in the registry.
    //
    // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
    public: DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE Data(
        );

    /// <summary>
    /// Create a new DkmRegistryTweak object instance.
    ///
    /// This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
    /// </summary>
    /// <param name="pValueName">
    /// [In] The name of the registry value that specifies this tweak.
    /// </param>
    /// <param name="Data">
    /// [In] The value of this tweak in the registry.
    /// </param>
    /// <param name="ppCreatedObject">
    /// [Out] Result of this method call.
    /// </param>
    /// <returns>
    /// S_OK is returned on success, and failure codes are used for any error.
    /// </returns>
    public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
        _In_ DkmString* pValueName,
        _In_ UINT32 Data,
        _Deref_out_ DkmRegistryTweak** ppCreatedObject
        );
}; // end of DkmRegistryTweak

// Result of an asynchronous DkmRuntimeInstance.ResolveCPUInstructionAddress call.
struct DkmResolveCPUInstructionAddressAsyncResult
{
    // HRESULT code returned from the caller. This will be
    // DkmExceptionCode.COR_E_OPERATIONCANCELED (0x8013153B) if the operation was
    // canceled before processing was complete.
    HRESULT ErrorCode;

    // Abstract representation of an executable code location (ex: EIP value). If
    // resolved, an Instruction Address will be within a particular module instance. An
    // Instruction Address is always within a particular Runtime Instance.
    DkmInstructionAddress* pAddressObject;

    // True if this address is the first address in the line's range. False otherwise.
    bool FirstAddress;
};

// Enumeration of runtime capabilities.
//
// This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
DEFINE_SCOPED_ENUM(DkmRuntimeCapabilities)
{
    // No capabilities specified.
    None = 0x0,
    // Allow stack caching for when this runtime has a stack frame at the top of the
    // stack.
    AllowStackCaching = 0x1,
    // Prevent detaching the debugger.  Detach will be disabled if any of the runtime
    // instances have this capability set.
    PreventDetach = 0x2,
    // Indicates that the runtime supports the Just-My-Code feature.
    SupportsJustMyCode = 0x4,
    // Indicates that the runtime does not allow stopping in non-user code.  This is
    // currently used to disable breakpoints in non-user code for runtimes with this
    // capability.  When stack frames for runtimes with this capability set are at the
    // top of the stack, any non-user frames will be collapsed to [External Code]. This
    // capability flag should only be set when SupportJustMyCode is also set.
    ProhibitsStoppingInNonUserCode = 0x8
};
DEFINE_SCOPED_ENUM_FLAG_OPERATORS(DkmRuntimeCapabilities_t);

// The Runtime Id identifies the execution environment for a particular piece of code.
// Runtime Ids are used by the dispatcher to decide which monitor to dispatch to. Note
// that the ordering of the runtime ID Guids is somewhat significant as this dictates
// which runtime gets the first shot during arbitration. Thus, if one wants to declare a
// new runtime instance which is built on the CLR, the runtime id should be less than
// DkmRuntimeId.Clr.
struct DkmRuntimeId
{
    // Identifies native code. Since all code executed by the CPU is native, this is the
    // default runtime and any code address unclaimed by other runtimes will be treated
    // as native.
    // Native is defined as {acec4df9-31f4-46fd-946d-2194f653fd26}.
    static const GUID Native;
    // Identifies code running under the CLR runtime.
    // Clr is defined as {390763e5-34af-483b-a7ba-e5e0235da888}.
    static const GUID Clr;
    // Identifies code running under the GPU D3D runtime.
    // Gpu is defined as {9e1b75f6-2088-4494-98bf-90985386bd85}.
    static const GUID Gpu;
    // Identifies code running under Microsoft ActiveScript based runtimes.
    // ActiveScript is defined as {4e602173-b073-4a20-b20e-1d7d6b9b075b}.
    static const GUID ActiveScript;
    // Identifies code running under Microsoft ActiveScript based runtimes that can
    // interop with other debug code types.
    // ActiveScriptInterop is defined as {0edd4525-c3ca-48e4-bd11-8eb5ae3ef6f5}.
    static const GUID ActiveScriptInterop;
    // Identifies code running under the native-compiled CLR.
    // ClrNativeCompilation is defined as {5c4f3253-8682-4aba-8fe7-dfd44e6de5bc}.
    static const GUID ClrNativeCompilation;
    // Identifies code running under the GPU Interop D3D runtime.
    // GpuInterop is defined as {a5099208-2f13-4d71-bcf6-846bc83f211f}.
    static const GUID GpuInterop;
};
__declspec(selectany) const GUID DkmRuntimeId::Native = { 0xacec4df9, 0x31f4, 0x46fd, { 0x94, 0x6d, 0x21, 0x94, 0xf6, 0x53, 0xfd, 0x26 } };
__declspec(selectany) const GUID DkmRuntimeId::Clr = { 0x390763e5, 0x34af, 0x483b, { 0xa7, 0xba, 0xe5, 0xe0, 0x23, 0x5d, 0xa8, 0x88 } };
__declspec(selectany) const GUID DkmRuntimeId::Gpu = { 0x9e1b75f6, 0x2088, 0x4494, { 0x98, 0xbf, 0x90, 0x98, 0x53, 0x86, 0xbd, 0x85 } };
__declspec(selectany) const GUID DkmRuntimeId::ActiveScript = { 0x4e602173, 0xb073, 0x4a20, { 0xb2, 0xe, 0x1d, 0x7d, 0x6b, 0x9b, 0x7, 0x5b } };
__declspec(selectany) const GUID DkmRuntimeId::ActiveScriptInterop = { 0xedd4525, 0xc3ca, 0x48e4, { 0xbd, 0x11, 0x8e, 0xb5, 0xae, 0x3e, 0xf6, 0xf5 } };
__declspec(selectany) const GUID DkmRuntimeId::ClrNativeCompilation = { 0x5c4f3253, 0x8682, 0x4aba, { 0x8f, 0xe7, 0xdf, 0xd4, 0x4e, 0x6d, 0xe5, 0xbc } };
__declspec(selectany) const GUID DkmRuntimeId::GpuInterop = { 0xa5099208, 0x2f13, 0x4d71, { 0xbc, 0xf6, 0x84, 0x6b, 0xc8, 0x3f, 0x21, 0x1f } };

// The DkmRuntimeInstance class represents an execution environment which is loaded into
// a DkmProcess and which contains code to be debugged.
//
// Derived classes: DkmClrRuntimeInstance, DkmClrNcRuntimeInstance,
// DkmCustomRuntimeInstance, DkmNativeRuntimeInstance, DkmScriptRuntimeInstance
class DECLSPEC_NOVTABLE DECLSPEC_UUID("9b32a175-6e35-1ae5-1498-c93ab323e2c8") DkmRuntimeInstance : public DkmDataContainer
{
    // Use DkmRuntimeInstance::Create to create this object
    private: DkmRuntimeInstance();
    // This object is refcounted. It is deleted through Release
    protected: ~DkmRuntimeInstance();
    // This object cannot be copied
    private: DkmRuntimeInstance& operator=(const DkmRuntimeInstance&);
    private: DkmRuntimeInstance(const DkmRuntimeInstance&);

    // DkmRuntimeInstance is an abstract base class. This enum indicates which derived
    // class this object is an instance of.
    public: FORWARD_DECLARE_SCOPED_ENUM(Tag);
    DEFINE_SCOPED_ENUM(Tag)
    {
    // Object is an instance of 'DkmNativeRuntimeInstance'.
    NativeRuntimeInstance = 0,
    // Object is an instance of 'DkmClrRuntimeInstance'.
    ClrRuntimeInstance = 1,
    // Object is an instance of 'DkmScriptRuntimeInstance'.
    ScriptRuntimeInstance = 2,
    // Object is an instance of 'DkmCustomRuntimeInstance'.
    CustomRuntimeInstance = 3
    };

    // Contains additional fields of DkmRuntimeInstance which were added after the class
    // was initally introduced.
    private: struct ___ExtendedData
    {
        ___ExtendedData();

        // Enumeration of runtime capabilities.
        const DkmRuntimeCapabilities_t Capabilities;

        // [Optional] For runtimes that are implemented on top of another runtime, this
        // can optionally be used to indicant the logical parent. This can then be used
        // to request services from the parent when the child runtime doesn't implement
        // the service. This is currently used only for obtaining the top stack frame to
        // evaluate a conditional breakpoint when the child runtime doesn't walk stacks
        // itself.
        OPTIONAL DkmRuntimeInstance* const pParentRuntime;
    };

    private: const Tag_t m_TagValue;
    private: DkmProcess* const m_pProcess;
    private: const DkmRuntimeInstanceId m_Id;
    private: ___ExtendedData* const m__pExtendedData;
    private: void* m_pContextGroupEvalResultCollection0;
    private: void* m_pModuleInstanceCollection0;
    private: void* m_pRuntimeBreakpointCollection0;
    private: void* m_pScriptDocumentTreeNodeCollection0;
    private: void* m_pTaskProviderCollection0;

    // DkmRuntimeInstance is an abstract base class. This enum indicates which derived
    // class this object is an instance of.
    public: DECLSPEC_NOTHROW Tag_t STDMETHODCALLTYPE TagValue(
        );

    // DkmProcess represents a target process which is being debugged. The debugger
    // debugs processes, so this is the basic unit of debugging. A DkmProcess can
    // represent a system process or a virtual process such as minidumps.
    public: _Ret_ DECLSPEC_NOTHROW DkmProcess* STDMETHODCALLTYPE Process(
        );

    // Identifies a DkmRuntimeInstance object within a process.
    public: DECLSPEC_NOTHROW const DkmRuntimeInstanceId& STDMETHODCALLTYPE Id(
        );

    // Enumeration of runtime capabilities.
    //
    // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
    public: DECLSPEC_NOTHROW DkmRuntimeCapabilities_t STDMETHODCALLTYPE Capabilities(
        );

    // [Optional] For runtimes that are implemented on top of another runtime, this can
    // optionally be used to indicant the logical parent. This can then be used to
    // request services from the parent when the child runtime doesn't implement the
    // service. This is currently used only for obtaining the top stack frame to evaluate
    // a conditional breakpoint when the child runtime doesn't walk stacks itself.
    //
    // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
    public: _Ret_opt_ DECLSPEC_NOTHROW DkmRuntimeInstance* STDMETHODCALLTYPE ParentRuntime(
        );

    // This represents a connection between the monitor and the IDE. It can either be a
    // local connection if the monitor is running in the same process as the IDE, or it
    // can be a remote connection. In the monitor process, there is only one connection.
    public: _Ret_ DECLSPEC_NOTHROW DefaultPort::DkmTransportConnection* STDMETHODCALLTYPE Connection(
        );

    /// <summary>
    /// GetScriptDocumentTreeNodes enumerates the DkmScriptDocumentTreeNode elements of
    /// this DkmRuntimeInstance object.
    /// </summary>
    /// <param name="pScriptDocumentTreeNodes">
    /// [Out] Array containing the enumerated elements.
    ///
    /// The memory for the DkmArray members is allocated by the method implementation
    /// using DkmAllocBytes/DkmAllocArray. It is freed by the caller using the
    /// CAutoDkmArray template or with DkmFreeMemory and manual element release.
    /// </param>
    /// <returns>
    /// S_OK is returned on success, and failure codes are used for any error.
    /// </returns>
    public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetScriptDocumentTreeNodes(
        _Out_ DkmArray<Script::DkmScriptDocumentTreeNode*>* pScriptDocumentTreeNodes
        );

    /// <summary>
    /// GetModuleInstances enumerates the DkmModuleInstance elements of this
    /// DkmRuntimeInstance object.
    /// </summary>
    /// <param name="pModuleInstances">
    /// [Out] Array containing the enumerated elements.
    ///
    /// The memory for the DkmArray members is allocated by the method implementation
    /// using DkmAllocBytes/DkmAllocArray. It is freed by the caller using the
    /// CAutoDkmArray template or with DkmFreeMemory and manual element release.
    /// </param>
    /// <returns>
    /// S_OK is returned on success, and failure codes are used for any error.
    /// </returns>
    public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetModuleInstances(
        _Out_ DkmArray<DkmModuleInstance*>* pModuleInstances
        );

    /// <summary>
    /// GetTaskProviders enumerates the DkmTaskProvider elements of this
    /// DkmRuntimeInstance object.
    /// </summary>
    /// <param name="pTaskProviders">
    /// [Out] Array containing the enumerated elements.
    ///
    /// The memory for the DkmArray members is allocated by the method implementation
    /// using DkmAllocBytes/DkmAllocArray. It is freed by the caller using the
    /// CAutoDkmArray template or with DkmFreeMemory and manual element release.
    /// </param>
    /// <returns>
    /// S_OK is returned on success, and failure codes are used for any error.
    /// </returns>
    public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetTaskProviders(
        _Out_ DkmArray<ParallelTasks::DkmTaskProvider*>* pTaskProviders
        );

    /// <summary>
    /// Resolves a CPU InstructionAddress to a runtime-specific DkmInstructionAddress
    /// object.
    ///
    /// This API is currently only supported by CLR DkmRuntimeInstance objects, and the
    /// CLR runtime instance can currently only find instruction addresses which are in a
    /// method that is currently on the call stack of one of the threads in the target
    /// process.
    ///
    /// Location constraint: This API should generally be called on the client, but it
    /// can be called on the server for translating CLR addresses (but not
    /// native-compiled).
    /// </summary>
    /// <param name="InstructionPointer">
    /// [In] Memory address where the native instruction is located.
    /// </param>
    /// <param name="ppAddressObject">
    /// [Out] Abstract representation of an executable code location (ex: EIP value). If
    /// resolved, an Instruction Address will be within a particular module instance. An
    /// Instruction Address is always within a particular Runtime Instance.
    /// </param>
    /// <param name="pFirstAddress">
    /// [Out] True if this address is the first address in the line's range. False
    /// otherwise.
    /// </param>
    /// <returns>
    /// S_OK is returned on success, and failure codes are used for any error.
    /// </returns>
    public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ResolveCPUInstructionAddress(
        _In_ UINT64 InstructionPointer,
        _Deref_out_ DkmInstructionAddress** ppAddressObject,
        _Out_ bool* pFirstAddress
        );

    /// <summary>
    /// Resolves a CPU InstructionAddress to a runtime-specific DkmInstructionAddress
    /// object.
    ///
    /// This API is currently only supported by CLR DkmRuntimeInstance objects, and the
    /// CLR runtime instance can currently only find instruction addresses which are in a
    /// method that is currently on the call stack of one of the threads in the target
    /// process.
    ///
    /// This method will append a new work item to the specified work list, and return
    /// once the work item has been appended. The actual processing of the work item is
    /// asynchronous. The caller will be notified that the request is complete through
    /// the completion routine.
    ///
    /// Location constraint: This API should generally be called on the client, but it
    /// can be called on the server for translating CLR addresses (but not
    /// native-compiled).
    /// </summary>
    /// <param name="pWorkList">
    /// WorkList to append the new work item to.
    /// </param>
    /// <param name="InstructionPointer">
    /// [In] Memory address where the native instruction is located.
    /// </param>
    /// <param name="pCompletionRoutine">
    /// Routine to fire when the request is complete. If the request is successfully
    /// appended to the work list, this will always fire (including when the operation is
    /// canceled). This will never fire if appending the work item fails.
    /// </param>
    /// <returns>
    /// S_OK is returned on success, and failure codes are used for any error.
    /// </returns>
    public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ResolveCPUInstructionAddress(
        _In_ DkmWorkList* pWorkList,
        _In_ UINT64 InstructionPointer,
        _In_ IDkmCompletionRoutine<DkmResolveCPUInstructionAddressAsyncResult>* pCompletionRoutine
        );

    /// <summary>
    /// This method returns all modules that match the specified name.
    /// </summary>
    /// <param name="pSearchKey">
    /// [In] Name of the module to search for. This string may or may not contain the
    /// file extension (ex: 'kernel32' or 'kernel32.dll').
    /// </param>
    /// <param name="pMatches">
    /// [Out] Returns any modules that match the specified search key. Only currently
    /// loaded dlls will be returned. Modules are returned in load-order.
    ///
    /// The memory for the DkmArray members is allocated by the method implementation
    /// using DkmAllocBytes/DkmAllocArray. It is freed by the caller using the
    /// CAutoDkmArray template or with DkmFreeMemory and manual element release.
    /// </param>
    /// <returns>
    /// S_OK is returned on success, and failure codes are used for any error.
    /// </returns>
    public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE FindModulesByName(
        _In_ DkmString* pSearchKey,
        _Out_ DkmArray<DkmModuleInstance*>* pMatches
        );

    /// <summary>
    /// Sets the value of the register in the thread's context. Sub registers that are
    /// made up of larger registers are supported.
    /// </summary>
    /// <param name="pStackWalkFrame">
    /// [In] The stack frame the register is being set in. For most runtime instances,
    /// this is used to verify the stack frame is the top of the stack and stop the write
    /// if it isn't.
    /// </param>
    /// <param name="RegisterIndex">
    /// [In] The CV constant of the register to set.
    /// </param>
    /// <param name="pValue">
    /// [In] The value to set the register to. The size of the byte array must match the
    /// width of the register being set.
    /// </param>
    /// <returns>
    /// S_OK is returned on success, and failure codes are used for any error.
    /// </returns>
    public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE SetRegisterValue(
        _In_ CallStack::DkmStackWalkFrame* pStackWalkFrame,
        _In_ CV_HREG_e RegisterIndex,
        _In_ DkmReadOnlyCollection<BYTE>* pValue
        );

    #ifndef EXCLUDE_MONITOR_ONLY_APIS
    /// <summary>
    /// BeforeEnableNewStepper is called by the stepping manager before a new stepper is
    /// enabled. This gives runtimes the ability to do any initialization that might be
    /// required such as performing pre-step function evaluations.
    ///
    /// Location constraint: API must be called from a Monitor component (component level
    /// &lt; 100,000).
    /// </summary>
    /// <param name="pStepper">
    /// [In] DkmStepper represents a request to step a thread. It facilitates shared
    /// object lifetime between the various runtime debug monitors that participate in
    /// stepping.
    /// </param>
    /// <returns>
    /// S_OK is returned on success, and failure codes are used for any error.
    /// </returns>
    public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE BeforeEnableNewStepper(
        _In_ Stepping::DkmStepper* pStepper
        );
    #endif // #ifndef EXCLUDE_MONITOR_ONLY_APIS

    #ifndef EXCLUDE_MONITOR_ONLY_APIS
    /// <summary>
    /// OwnsCurrentExecutionLocation is called by the stepping manager while it is
    /// searching for monitors to perform a step. If the current location in the debuggee
    /// is understood by this monitor it can return true here to take control of the
    /// step.
    ///
    /// Location constraint: API must be called from a Monitor component (component level
    /// &lt; 100,000).
    /// </summary>
    /// <param name="pStepper">
    /// [In] DkmStepper represents a request to step a thread. It facilitates shared
    /// object lifetime between the various runtime debug monitors that participate in
    /// stepping.
    /// </param>
    /// <param name="Reason">
    /// [In] DkmStepArbitrationReason the reason step arbitration is occurring.
    /// </param>
    /// <param name="pOwnsFrame">
    /// [Out] If the runtime instance wants control of the step, it should set this to
    /// true. It should be set to false to not take control.
    /// </param>
    /// <returns>
    /// S_OK is returned on success, and failure codes are used for any error.
    /// </returns>
    public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE OwnsCurrentExecutionLocation(
        _In_ Stepping::DkmStepper* pStepper,
        _In_ Stepping::DkmStepArbitrationReason_t Reason,
        _Out_ bool* pOwnsFrame
        );
    #endif // #ifndef EXCLUDE_MONITOR_ONLY_APIS

    #ifndef EXCLUDE_MONITOR_ONLY_APIS
    /// <summary>
    /// Step is called by the stepping manager after it determines this monitor is the
    /// correct monitor to perform the step.
    ///
    /// Location constraint: API must be called from a Monitor component (component level
    /// &lt; 100,000).
    /// </summary>
    /// <param name="pStepper">
    /// [In] DkmStepper represents a request to step a thread. It facilitates shared
    /// object lifetime between the various runtime debug monitors that participate in
    /// stepping.
    /// </param>
    /// <param name="Reason">
    /// [In] DkmStepArbitrationReason the reason step arbitration is occurring.
    /// </param>
    /// <returns>
    /// S_OK is returned on success, and failure codes are used for any error.
    /// </returns>
    public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Step(
        _In_ Stepping::DkmStepper* pStepper,
        _In_ Stepping::DkmStepArbitrationReason_t Reason
        );
    #endif // #ifndef EXCLUDE_MONITOR_ONLY_APIS

    #ifndef EXCLUDE_MONITOR_ONLY_APIS
    /// <summary>
    /// StopStep is called by the stepping manager when the process is being continued to
    /// clear out any remaining stepping state for a stepper.
    ///
    /// Location constraint: API must be called from a Monitor component (component level
    /// &lt; 100,000).
    /// </summary>
    /// <param name="pStepper">
    /// [In] DkmStepper represents a request to step a thread. It facilitates shared
    /// object lifetime between the various runtime debug monitors that participate in
    /// stepping.
    /// </param>
    /// <returns>
    /// S_OK is returned on success, and failure codes are used for any error.
    /// </returns>
    public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE StopStep(
        _In_ Stepping::DkmStepper* pStepper
        );
    #endif // #ifndef EXCLUDE_MONITOR_ONLY_APIS

    #ifndef EXCLUDE_MONITOR_ONLY_APIS
    /// <summary>
    /// AfterSteppingArbitration is called by the stepping manager on the old controlling
    /// runtime instance after stepping arbitration is complete but before the next
    /// runtime instance starts stepping. This allows runtimes to clear any stepping
    /// state if another runtime took control. If no other runtime monitor claimed the
    /// current location, the original monitor should finish the step. This is indicated
    /// by NewControllingRuntimeInstance being null. For instance, a runtime instance may
    /// choose to step back out if a step-in landed in a location without symbols and no
    /// other runtime took control.
    ///
    /// Location constraint: API must be called from a Monitor component (component level
    /// &lt; 100,000).
    /// </summary>
    /// <param name="pStepper">
    /// [In] DkmStepper represents a request to step a thread. It facilitates shared
    /// object lifetime between the various runtime debug monitors that participate in
    /// stepping.
    /// </param>
    /// <param name="Reason">
    /// [In] DkmStepArbitrationReason the reason step arbitration is occurring.
    /// </param>
    /// <param name="pNewControllingRuntimeInstance">
    /// [In,Optional] The DkmRuntimeInstance class represents an execution environment
    /// which is loaded into a DkmProcess and which contains code to be debugged.
    /// </param>
    /// <returns>
    /// S_OK is returned on success, and failure codes are used for any error.
    /// </returns>
    public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE AfterSteppingArbitration(
        _In_ Stepping::DkmStepper* pStepper,
        _In_ Stepping::DkmStepArbitrationReason_t Reason,
        _In_opt_ DkmRuntimeInstance* pNewControllingRuntimeInstance
        );
    #endif // #ifndef EXCLUDE_MONITOR_ONLY_APIS

    #ifndef EXCLUDE_MONITOR_ONLY_APIS
    /// <summary>
    /// OnNewControllingRuntimeInstance is called by the stepping manager on all
    /// non-controlling runtime instances after step arbitration has selected a new
    /// controlling runtime instance.
    ///
    /// Location constraint: API must be called from a Monitor component (component level
    /// &lt; 100,000).
    /// </summary>
    /// <param name="pStepper">
    /// [In] DkmStepper represents a request to step a thread. It facilitates shared
    /// object lifetime between the various runtime debug monitors that participate in
    /// stepping.
    /// </param>
    /// <param name="Reason">
    /// [In] DkmStepArbitrationReason the reason step arbitration is occurring.
    /// </param>
    /// <param name="pControllingRuntimeInstance">
    /// [In] The DkmRuntimeInstance class represents an execution environment which is
    /// loaded into a DkmProcess and which contains code to be debugged.
    /// </param>
    /// <returns>
    /// S_OK is returned on success, and failure codes are used for any error.
    /// </returns>
    public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE OnNewControllingRuntimeInstance(
        _In_ Stepping::DkmStepper* pStepper,
        _In_ Stepping::DkmStepArbitrationReason_t Reason,
        _In_ DkmRuntimeInstance* pControllingRuntimeInstance
        );
    #endif // #ifndef EXCLUDE_MONITOR_ONLY_APIS

    #ifndef EXCLUDE_MONITOR_ONLY_APIS
    /// <summary>
    /// StepControlRequested is called by the stepping manager when a non-controlling
    /// runtime instance detects that the thread has hit a transition into its runtime.
    /// If the current controlling runtime instance can stop stepping, it should set
    /// Granted to true. Actual control is not given until the requesting runtime calls
    /// DkmStepper.TakeStepControl. This two part process allows callers to request
    /// control of multiple steppers at the same time.
    ///
    /// Location constraint: API must be called from a Monitor component (component level
    /// &lt; 100,000).
    /// </summary>
    /// <param name="pStepper">
    /// [In] DkmStepper represents a request to step a thread. It facilitates shared
    /// object lifetime between the various runtime debug monitors that participate in
    /// stepping.
    /// </param>
    /// <param name="Reason">
    /// [In] DkmStepArbitrationReason the reason step arbitration is occurring.
    /// </param>
    /// <param name="pCallingRuntimeInstance">
    /// [In] The calling runtime instance that wishes to take control of the step.
    /// </param>
    /// <param name="pGranted">
    /// [Out] The controlling runtime can stop the step and give control to the caller,
    /// then it should set this to true.
    /// </param>
    /// <returns>
    /// S_OK is returned on success, and failure codes are used for any error.
    /// </returns>
    public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE StepControlRequested(
        _In_ Stepping::DkmStepper* pStepper,
        _In_ Stepping::DkmStepArbitrationReason_t Reason,
        _In_ DkmRuntimeInstance* pCallingRuntimeInstance,
        _Out_ bool* pGranted
        );
    #endif // #ifndef EXCLUDE_MONITOR_ONLY_APIS

    #ifndef EXCLUDE_MONITOR_ONLY_APIS
    /// <summary>
    /// TakeStepControl is called by the stepping manager when a non-controlling runtime
    /// instance detects that the thread has hit a transition into its runtime. The
    /// stepping manager will forward the call to the current controlling runtime
    /// instance. The runtime instance requesting control should first call
    /// StepControlRequested on all steppers it wants control of. If they all set Granted
    /// to true, the runtime instance should then call this method on each stepper it is
    /// taking control of.
    ///
    /// Location constraint: API must be called from a Monitor component (component level
    /// &lt; 100,000).
    /// </summary>
    /// <param name="pStepper">
    /// [In] DkmStepper represents a request to step a thread. It facilitates shared
    /// object lifetime between the various runtime debug monitors that participate in
    /// stepping.
    /// </param>
    /// <param name="LeaveGuardsInPlace">
    /// [In] Set to true by the caller if it would like the current controlling runtime
    /// instance to leave guards in place to stop the step if necessary. For instance,
    /// this can be used to leave guard breakpoints after a call instruction so another
    /// runtime can step back out if the target of the call doesn't have source. However,
    /// any stepping state that affects the immediate step, such as trap flags, should be
    /// removed by the controlling runtime instance.
    /// </param>
    /// <param name="Reason">
    /// [In] DkmStepArbitrationReason the reason step arbitration is occurring.
    /// </param>
    /// <param name="pCallingRuntimeInstance">
    /// [In] The calling runtime instance that wishes to take control of the step.
    /// </param>
    /// <returns>
    /// S_OK is returned on success, and failure codes are used for any error.
    /// </returns>
    public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE TakeStepControl(
        _In_ Stepping::DkmStepper* pStepper,
        _In_ bool LeaveGuardsInPlace,
        _In_ Stepping::DkmStepArbitrationReason_t Reason,
        _In_ DkmRuntimeInstance* pCallingRuntimeInstance
        );
    #endif // #ifndef EXCLUDE_MONITOR_ONLY_APIS

    #ifndef EXCLUDE_MONITOR_ONLY_APIS
    /// <summary>
    /// NotifyStepComplete is called by the stepping manager on all non-controlling
    /// runtime instances when a step is complete.
    ///
    /// Location constraint: API must be called from a Monitor component (component level
    /// &lt; 100,000).
    /// </summary>
    /// <param name="pStepper">
    /// [In] DkmStepper represents a request to step a thread. It facilitates shared
    /// object lifetime between the various runtime debug monitors that participate in
    /// stepping.
    /// </param>
    /// <returns>
    /// S_OK is returned on success, and failure codes are used for any error.
    /// </returns>
    public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE NotifyStepComplete(
        _In_ Stepping::DkmStepper* pStepper
        );
    #endif // #ifndef EXCLUDE_MONITOR_ONLY_APIS

    #ifndef EXCLUDE_IDE_ONLY_APIS
    /// <summary>
    /// Gets the Display Properties of the Thread including the Display Name and Thread
    /// Category.
    ///
    /// This method will append a new work item to the specified work list, and return
    /// once the work item has been appended. The actual processing of the work item is
    /// asynchronous. The caller will be notified that the request is complete through
    /// the completion routine.
    ///
    /// Location constraint: API must be called from an IDE component (component level
    /// &gt; 100,000).
    /// </summary>
    /// <param name="pWorkList">
    /// WorkList to append the new work item to.
    /// </param>
    /// <param name="pThread">
    /// [In] The Thread.
    /// </param>
    /// <param name="pCompletionRoutine">
    /// Routine to fire when the request is complete. If the request is successfully
    /// appended to the work list, this will always fire (including when the operation is
    /// canceled). This will never fire if appending the work item fails.
    /// </param>
    /// <returns>
    /// S_OK is returned on success, and failure codes are used for any error.
    /// </returns>
    public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetThreadDisplayProperties(
        _In_ DkmWorkList* pWorkList,
        _In_ DkmThread* pThread,
        _In_ IDkmCompletionRoutine<ThreadProperties::DkmGetThreadDisplayPropertiesAsyncResult>* pCompletionRoutine
        );
    #endif // #ifndef EXCLUDE_IDE_ONLY_APIS

    /// <summary>
    /// Compute the name of a thread.
    /// </summary>
    /// <param name="pThread">
    /// [In] The Thread.
    /// </param>
    /// <param name="ppName">
    /// [Out,Optional] The Thread Name.
    /// </param>
    /// <returns>
    /// S_OK is returned if *ppName is non-NULL, S_FALSE is returned when *ppName is
    /// NULL, and failure codes are used for any error.
    /// </returns>
    public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetThreadName(
        _In_ DkmThread* pThread,
        _Deref_out_opt_ DkmString** ppName
        );

    /// <summary>
    /// Compute the name of a thread.
    ///
    /// This method will append a new work item to the specified work list, and return
    /// once the work item has been appended. The actual processing of the work item is
    /// asynchronous. The caller will be notified that the request is complete through
    /// the completion routine.
    /// </summary>
    /// <param name="pWorkList">
    /// WorkList to append the new work item to.
    /// </param>
    /// <param name="pThread">
    /// [In] The Thread.
    /// </param>
    /// <param name="pCompletionRoutine">
    /// Routine to fire when the request is complete. If the request is successfully
    /// appended to the work list, this will always fire (including when the operation is
    /// canceled). This will never fire if appending the work item fails.
    /// </param>
    /// <returns>
    /// S_OK is returned on success, and failure codes are used for any error.
    /// </returns>
    public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetThreadName(
        _In_ DkmWorkList* pWorkList,
        _In_ DkmThread* pThread,
        _In_ IDkmCompletionRoutine<ThreadProperties::DkmGetThreadNameAsyncResult>* pCompletionRoutine
        );

    /// <summary>
    /// RuntimeInstanceUnload is sent by the dispatcher when DkmRuntimeInstance::Unload
    /// is invoked by the monitor.
    ///
    /// This method may only be called by the component which created the object.
    /// </summary>
    /// <returns>
    /// S_OK is returned on success, and failure codes are used for any error.
    /// </returns>
    public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Unload(
        );

    /// <summary>
    /// GetManagedHeapSamplers enumerates the DkmManagedHeapSampler elements of this
    /// DkmRuntimeInstance object.
    ///
    /// This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
    /// </summary>
    /// <param name="pManagedHeapSamplers">
    /// [Out] Array containing the enumerated elements.
    ///
    /// The memory for the DkmArray members is allocated by the method implementation
    /// using DkmAllocBytes/DkmAllocArray. It is freed by the caller using the
    /// CAutoDkmArray template or with DkmFreeMemory and manual element release.
    /// </param>
    /// <returns>
    /// S_OK is returned on success, and failure codes are used for any error.
    /// </returns>
    public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetManagedHeapSamplers(
        _Out_ DkmArray<Clr::DkmManagedHeapSampler*>* pManagedHeapSamplers
        );

    /// <summary>
    /// GetManagedHeapWalkers enumerates the DkmManagedHeapWalker elements of this
    /// DkmRuntimeInstance object.
    ///
    /// This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
    /// </summary>
    /// <param name="pManagedHeapWalkers">
    /// [Out] Array containing the enumerated elements.
    ///
    /// The memory for the DkmArray members is allocated by the method implementation
    /// using DkmAllocBytes/DkmAllocArray. It is freed by the caller using the
    /// CAutoDkmArray template or with DkmFreeMemory and manual element release.
    /// </param>
    /// <returns>
    /// S_OK is returned on success, and failure codes are used for any error.
    /// </returns>
    public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetManagedHeapWalkers(
        _Out_ DkmArray<Clr::DkmManagedHeapWalker*>* pManagedHeapWalkers
        );

    #ifndef EXCLUDE_MONITOR_ONLY_APIS
    /// <summary>
    /// GetCodePathsInRange is called to get code paths in specific IL range.
    ///
    /// Location constraint: It should only be called on server side.
    ///
    /// This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
    /// </summary>
    /// <param name="pCorFrame">
    /// [In] The ICorDebugFrame to query for code paths.
    /// </param>
    /// <param name="StartILOffset">
    /// [In] Specifies the query start IL offset, inclusively.
    /// </param>
    /// <param name="EndILOffset">
    /// [In] Specifies the query end IL offset, inclusively.
    /// </param>
    /// <param name="pCodePaths">
    /// [Out] DkmSteppingCodePath[] represents a location that user can step to from
    /// current location.
    ///
    /// The memory for the DkmArray members is allocated by the method implementation
    /// using DkmAllocBytes/DkmAllocArray. It is freed by the caller using the
    /// CAutoDkmArray template or with DkmFreeMemory and manual element release.
    /// </param>
    /// <returns>
    /// S_OK is returned on success, and failure codes are used for any error.
    /// </returns>
    public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetCodePathsInRange(
        _In_ ICorDebugFrame* pCorFrame,
        _In_ UINT32 StartILOffset,
        _In_ UINT32 EndILOffset,
        _Out_ DkmArray<Stepping::DkmSteppingCodePath*>* pCodePaths
        );
    #endif // #ifndef EXCLUDE_MONITOR_ONLY_APIS

    #ifndef EXCLUDE_IDE_ONLY_APIS
    /// <summary>
    /// Disassemble an address range in the debuggee runtime.
    ///
    /// Location constraint: API must be called from an IDE component (component level
    /// &gt; 100,000).
    ///
    /// This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
    /// </summary>
    /// <param name="pAddress">
    /// [In] The address where disassembly should start.
    /// </param>
    /// <param name="Count">
    /// [In] The number of instructions to disassemble.
    /// </param>
    /// <param name="pDisassembledInstructions">
    /// [Out] The results of disassembling the address range.
    ///
    /// The memory for the DkmArray members is allocated by the method implementation
    /// using DkmAllocBytes/DkmAllocArray. It is freed by the caller using the
    /// CAutoDkmArray template or with DkmFreeMemory and manual element release.
    /// </param>
    /// <returns>
    /// S_OK is returned on success, and failure codes are used for any error.
    /// </returns>
    public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Disassemble(
        _In_ DkmInstructionAddress* pAddress,
        _In_ UINT32 Count,
        _Out_ DkmArray<Disassembly::DkmDisassembledInstruction*>* pDisassembledInstructions
        );
    #endif // #ifndef EXCLUDE_IDE_ONLY_APIS

    #ifndef EXCLUDE_IDE_ONLY_APIS
    /// <summary>
    /// Returns the address of the kth instruction relative to a starting address. For
    /// constant length instruction sets, this is simple arithmetic. For variable length
    /// instruction sets, reverse-disassembly is required to obtain this address.
    ///
    /// Location constraint: API must be called from an IDE component (component level
    /// &gt; 100,000).
    ///
    /// This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
    /// </summary>
    /// <param name="pStartAddress">
    /// [In] The address of the current instruction where the offset should begin.
    /// </param>
    /// <param name="InstructionOffset">
    /// [In] The number of instructions relative to StartAddress to find the desired
    /// address. This value can be negative.
    /// </param>
    /// <param name="ppAddress">
    /// [Out] The address of the instruction InstructionOffset instructions from
    /// StartAddress.
    /// </param>
    /// <returns>
    /// S_OK is returned on success, and failure codes are used for any error.
    /// </returns>
    public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetInstructionAddress(
        _In_ DkmInstructionAddress* pStartAddress,
        _In_ INT32 InstructionOffset,
        _Deref_out_ DkmInstructionAddress** ppAddress
        );
    #endif // #ifndef EXCLUDE_IDE_ONLY_APIS

    /// <summary>
    /// This method is called by a debug monitor to raise a RuntimeInstanceLoadComplete
    /// event. RuntimeInstanceLoadComplete is currently only sent for the native runtime
    /// instance, though this may change in the future. The event is issued after
    /// DkmModuleInstance objects have been created for the initial set of modules in the
    /// runtime instance.
    ///
    /// This method may only be called by the component which created the object.
    ///
    /// This API was introduced in Visual Studio 12 Update 2 (DkmApiVersion.VS12Update2).
    /// </summary>
    /// <returns>
    /// S_OK is returned on success, and failure codes are used for any error.
    /// </returns>
    public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE OnLoadComplete(
        );
}; // end of DkmRuntimeInstance

// Result of an asynchronous DkmCustomMessage.SendLower call.
struct DkmSendLowerAsyncResult
{
    // HRESULT code returned from the caller. This will be
    // DkmExceptionCode.COR_E_OPERATIONCANCELED (0x8013153B) if the operation was
    // canceled before processing was complete.
    HRESULT ErrorCode;

    // [Optional] Message sent back from the implementation.
    OPTIONAL DkmCustomMessage* pReplyMessage;
};

// Identifies the source of an object. SourceIds are used to enable filtering in
// scenarios when multiple components may be creating instances of a class. For example,
// source ids can be used to determine if a breakpoint comes from the AD7 AL (ex: user
// breakpoint, or other breakpoint visible at the SDM level) instead of a breakpoint
// which may be created by another component (for example an internal breakpoint used for
// stepping).
struct DkmSourceId
{
    // Object was created in response to a breakpoint request from the IDE.
    // AD7BreakpointId is defined as {f7a1b1d1-d4ee-4e0e-9bac-bdaa38c83fe3}.
    static const GUID AD7BreakpointId;
    // Object was created for a source-level breakpoint by the Microsoft breakpoint
    // manager.
    // MSBreakpointManagerId is defined as {86d0cdce-288c-46df-b9b2-e888a699c4b2}.
    static const GUID MSBreakpointManagerId;
    // Filtered events sent to the Native DM filter on this Source ID.
    // NativeBaseDmRequest is defined as {c9516daf-4af3-4e0d-8f37-8f97463f2dc1}.
    static const GUID NativeBaseDmRequest;
    // DkmExceptionTrigger was created in response to exception settings from the IDE.
    // AD7ExceptionSetting is defined as {aa9327a2-5b63-42d2-aa69-9b62bbfef726}.
    static const GUID AD7ExceptionSetting;
    // DkmExceptionTrigger was created in response to the 'Break when exceptions cross
    // AppDomain or managed/native boundaries (Managed only)' debugger option.
    // AD7ExceptionBoundary is defined as {58ee2076-d444-44c6-9d2a-4a92870ecc6b}.
    static const GUID AD7ExceptionBoundary;
    // DkmStepper created in response to a step request from the IDE.
    // AD7Stepper is defined as {d7647ea0-e55c-4413-aade-bc7b6a8c3db3}.
    static const GUID AD7Stepper;
    // SymbolsUpdate event generated by Managed DM.
    // ManagedDmSymbolsUpdateId is defined as {e24ae1c1-6f67-49ac-8c27-1403c9d4979c}.
    static const GUID ManagedDmSymbolsUpdateId;
    // DkmStepper created by Managed DM.
    // ManagedDmStepper is defined as {931d08be-5b80-41c2-be46-ffe84502c2e8}.
    static const GUID ManagedDmStepper;
    // Filtered events sent to the GPU Debug Monitor filter on this Source ID.
    // GpuDebugMonitorRequest is defined as {c1ddbd10-6bfc-4adb-9ce8-2f0324b1d657}.
    static const GUID GpuDebugMonitorRequest;
    // Object was created at the AD7 layer to execute a command.
    // AD7DeploymentId is defined as {b0e66140-065d-4ef2-a899-497540228bdd}.
    static const GUID AD7DeploymentId;
    // Object was created at the AD7 layer to execute a command.
    // BaseDMServicesId is defined as {c293512f-1105-4ea7-885e-93aad05137b8}.
    static const GUID BaseDMServicesId;
    // DkmStepper created by the Stepping Manager.
    // SteppingManagerStepper is defined as {911ce3c5-0620-42bc-b814-4135728cf174}.
    static const GUID SteppingManagerStepper;
    // Object created for local CPP EE.
    // ClientCppEE is defined as {67b95d8d-0c6b-46ff-b3d2-fa011f3b610b}.
    static const GUID ClientCppEE;
    // Object created for server CPP EE.
    // ServerCppEE is defined as {61785163-5f87-4c6d-8322-04f6ce664d31}.
    static const GUID ServerCppEE;
};
__declspec(selectany) const GUID DkmSourceId::AD7BreakpointId = { 0xf7a1b1d1, 0xd4ee, 0x4e0e, { 0x9b, 0xac, 0xbd, 0xaa, 0x38, 0xc8, 0x3f, 0xe3 } };
__declspec(selectany) const GUID DkmSourceId::MSBreakpointManagerId = { 0x86d0cdce, 0x288c, 0x46df, { 0xb9, 0xb2, 0xe8, 0x88, 0xa6, 0x99, 0xc4, 0xb2 } };
__declspec(selectany) const GUID DkmSourceId::NativeBaseDmRequest = { 0xc9516daf, 0x4af3, 0x4e0d, { 0x8f, 0x37, 0x8f, 0x97, 0x46, 0x3f, 0x2d, 0xc1 } };
__declspec(selectany) const GUID DkmSourceId::AD7ExceptionSetting = { 0xaa9327a2, 0x5b63, 0x42d2, { 0xaa, 0x69, 0x9b, 0x62, 0xbb, 0xfe, 0xf7, 0x26 } };
__declspec(selectany) const GUID DkmSourceId::AD7ExceptionBoundary = { 0x58ee2076, 0xd444, 0x44c6, { 0x9d, 0x2a, 0x4a, 0x92, 0x87, 0xe, 0xcc, 0x6b } };
__declspec(selectany) const GUID DkmSourceId::AD7Stepper = { 0xd7647ea0, 0xe55c, 0x4413, { 0xaa, 0xde, 0xbc, 0x7b, 0x6a, 0x8c, 0x3d, 0xb3 } };
__declspec(selectany) const GUID DkmSourceId::ManagedDmSymbolsUpdateId = { 0xe24ae1c1, 0x6f67, 0x49ac, { 0x8c, 0x27, 0x14, 0x3, 0xc9, 0xd4, 0x97, 0x9c } };
__declspec(selectany) const GUID DkmSourceId::ManagedDmStepper = { 0x931d08be, 0x5b80, 0x41c2, { 0xbe, 0x46, 0xff, 0xe8, 0x45, 0x2, 0xc2, 0xe8 } };
__declspec(selectany) const GUID DkmSourceId::GpuDebugMonitorRequest = { 0xc1ddbd10, 0x6bfc, 0x4adb, { 0x9c, 0xe8, 0x2f, 0x3, 0x24, 0xb1, 0xd6, 0x57 } };
__declspec(selectany) const GUID DkmSourceId::AD7DeploymentId = { 0xb0e66140, 0x65d, 0x4ef2, { 0xa8, 0x99, 0x49, 0x75, 0x40, 0x22, 0x8b, 0xdd } };
__declspec(selectany) const GUID DkmSourceId::BaseDMServicesId = { 0xc293512f, 0x1105, 0x4ea7, { 0x88, 0x5e, 0x93, 0xaa, 0xd0, 0x51, 0x37, 0xb8 } };
__declspec(selectany) const GUID DkmSourceId::SteppingManagerStepper = { 0x911ce3c5, 0x620, 0x42bc, { 0xb8, 0x14, 0x41, 0x35, 0x72, 0x8c, 0xf1, 0x74 } };
__declspec(selectany) const GUID DkmSourceId::ClientCppEE = { 0x67b95d8d, 0xc6b, 0x46ff, { 0xb3, 0xd2, 0xfa, 0x1, 0x1f, 0x3b, 0x61, 0xb } };
__declspec(selectany) const GUID DkmSourceId::ServerCppEE = { 0x61785163, 0x5f87, 0x4c6d, { 0x83, 0x22, 0x4, 0xf6, 0xce, 0x66, 0x4d, 0x31 } };

// Status code returned to the base debug monitor to indicate the next action to take in
// stopping event processing.
DEFINE_SCOPED_ENUM(DkmStoppingEventProcessingNextAction)
{
    // The base debug monitor should resume execution of the target processes normally.
    // If an exception event was raised, standard exception processing (ex: handler
    // search, stack unwinding) should continue in the target process unless
    // DkmExceptionInformation.SquashProcessing() was successfully called.
    //
    // This status value is returned when the base debug monitor didn't issue any
    // stopping events, or when all stopping events were suppressed.
    ResumeTarget = 0,
    // The base debug monitor should resume execution of non-suspended threads in the
    // target process. Standard exception processing on suspended thread should be held
    // up so that the decision as to if it should be allowed to continue normally or be
    // squashed may be made at a later time.
    //
    // This status value is used when one or more threads are not at a safe point, so the
    // target process must be slipped. The target process is expected to hit one or more
    // stopping events (breakpoint or exception) in order to indicate that a safe point
    // has been reached. The base debug monitor may also choose to eventually time out
    // and proceed without reaching a safe point. The timeout value is specified in
    // DkmEngineSettings.SlipTimeout.
    SlipTarget = 1,
    // The base debug monitor should resume execution of non-suspended threads in the
    // target process. Standard exception processing on suspended thread should be held
    // up so that the decision as to if it should be allowed to continue normally or be
    // squashed may be made at a later time. After resuming execution, the base debug
    // monitor should immediately call StoppingEventProcessingContinue again.
    //
    // This status value is used when all threads are in the target process are at a safe
    // point, but one or more threads in the target process should run free while in
    // break mode. This is used when managed-only debugging certain host applications.
    ResumeUnclaimedThreads = 2,
    // Stopping event processing has completed and a stopping event has been sent to the
    // IDE. Execution of the target process should stay halted until the IDE resumes
    // execution.
    EnterStoppedState = 3,
    // This value is returned if StoppingEventProcessingBegin was called with
    // ForceQueueMode set to true.
    ForceQueueModeComplete = 4
};

// DkmThread represents a thread running in the target process.
//
// Derived classes: DkmGPUComputeThread
class DECLSPEC_NOVTABLE DECLSPEC_UUID("ac420a23-b721-57c1-375d-a5053f90f94c") DkmThread : public DkmDataContainer
{
    // Use DkmThread::Create to create this object
    private: DkmThread();
    // This object is refcounted. It is deleted through Release
    protected: ~DkmThread();
    // This object cannot be copied
    private: DkmThread& operator=(const DkmThread&);
    private: DkmThread(const DkmThread&);

    // Describes traits of the thread which are relevant to a full Win32 thread.
    // Currently, this value is required, and all threads will have a 'System' block. In
    // the future, this value may be NULL if the DkmThread represents something other
    // than a full Win32 thread.
    public: struct System
    {
        // Thread Id (TID) assigned by the operating system. While running, this uniquely
        // identifies the thread within a particular DkmProcess.
        UINT32 Id;
    };

    private: OPTIONAL const DkmThread::System* const m_pSystem;
    private: const GUID m_UniqueId;
    private: DkmProcess* const m_pProcess;
    private: const UINT64 m_NativeStartAddress;
    private: const UINT64 m_TebAddress;
    private: const bool m_IsMainThread;
    private: void* m__pExtendedData;
    private: void* m_pMonitorStackWalkContextCollection0;
    private: void* m_pStackWalkContextCollection0;
    private: void* m_pStepperCollection0;

    // [Optional] Describes traits of the thread which are relevant to a full Win32
    // thread. Currently, this value is required, and all threads will have a 'System'
    // block. In the future, this value may be NULL if the DkmThread represents something
    // other than a full Win32 thread.
    public: _Ret_opt_ DECLSPEC_NOTHROW const DkmThread::System* STDMETHODCALLTYPE SystemPart(
        );

    // Guid which uniquely identifies this thread object.
    public: DECLSPEC_NOTHROW const GUID& STDMETHODCALLTYPE UniqueId(
        );

    // DkmProcess represents a target process which is being debugged. The debugger
    // debugs processes, so this is the basic unit of debugging. A DkmProcess can
    // represent a system process or a virtual process such as minidumps.
    public: _Ret_ DECLSPEC_NOTHROW DkmProcess* STDMETHODCALLTYPE Process(
        );

    // If available, this is the Win32 start address of this thread (value passed to the
    // CreateThread API). The value will not always be available, for example, it is
    // generally not available in scenarios where the thread was started after the
    // debugger attached, or in minidumps.
    public: DECLSPEC_NOTHROW UINT64 STDMETHODCALLTYPE NativeStartAddress(
        );

    // Address within the target process, where the Win32 thread environment block is
    // stored. See documentation on the TEB structure in MSDN for more information.
    public: DECLSPEC_NOTHROW UINT64 STDMETHODCALLTYPE TebAddress(
        );

    // True if this is the main thread of this process. The main thread is the first
    // thread to start.
    public: DECLSPEC_NOTHROW bool STDMETHODCALLTYPE IsMainThread(
        );

    // This represents a connection between the monitor and the IDE. It can either be a
    // local connection if the monitor is running in the same process as the IDE, or it
    // can be a remote connection. In the monitor process, there is only one connection.
    public: _Ret_ DECLSPEC_NOTHROW DefaultPort::DkmTransportConnection* STDMETHODCALLTYPE Connection(
        );

    // Contains information about the computer system that this thread is running under.
    // If this thread is running under WOW (32-bit emulation on a 64-bit OS) this
    // information will be for the 32-bit subsystem rather than the 64-bit subsystem.
    public: _Ret_ DECLSPEC_NOTHROW DefaultPort::DkmSystemInformation* STDMETHODCALLTYPE SystemInformation(
        );

    /// <summary>
    /// DkmThread is called by a debug monitor to create a new DkmThread instance.
    /// DkmThread objects for system threads are created by the base debug monitor. This
    /// method must be called on the event thread.
    ///
    /// This method will send a ThreadCreate event.
    /// </summary>
    /// <param name="pProcess">
    /// [In] DkmProcess represents a target process which is being debugged. The debugger
    /// debugs processes, so this is the basic unit of debugging. A DkmProcess can
    /// represent a system process or a virtual process such as minidumps.
    /// </param>
    /// <param name="NativeStartAddress">
    /// [In] If available, this is the Win32 start address of this thread (value passed
    /// to the CreateThread API). The value will not always be available, for example, it
    /// is generally not available in scenarios where the thread was started after the
    /// debugger attached, or in minidumps.
    /// </param>
    /// <param name="TebAddress">
    /// [In] Address within the target process, where the Win32 thread environment block
    /// is stored. See documentation on the TEB structure in MSDN for more information.
    /// </param>
    /// <param name="IsMainThread">
    /// [In] True if this is the main thread of this process. The main thread is the
    /// first thread to start.
    /// </param>
    /// <param name="pSystem">
    /// [In,Optional] Describes traits of the thread which are relevant to a full Win32
    /// thread. Currently, this value is required, and all threads will have a 'System'
    /// block. In the future, this value may be NULL if the DkmThread represents
    /// something other than a full Win32 thread.
    /// </param>
    /// <param name="DataItem">
    /// [In] Data object to add to the new DkmThread instance. DkmDataItem::Null() in the
    /// case that the caller doesn't need to add a data item.
    /// </param>
    /// <param name="ppCreatedObject">
    /// [Out] Result of this method call.
    /// </param>
    /// <returns>
    /// S_OK is returned on success, and failure codes are used for any error.
    /// </returns>
    public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
        _In_ DkmProcess* pProcess,
        _In_ UINT64 NativeStartAddress,
        _In_ UINT64 TebAddress,
        _In_ bool IsMainThread,
        _In_opt_ const DkmThread::System* pSystem,
        _In_ const DkmDataItem& DataItem,
        _Deref_out_ DkmThread** ppCreatedObject
        );

    /// <summary>
    /// GetSteppers enumerates the DkmStepper elements of this DkmThread object.
    /// </summary>
    /// <param name="pSteppers">
    /// [Out] Array containing the enumerated elements.
    ///
    /// The memory for the DkmArray members is allocated by the method implementation
    /// using DkmAllocBytes/DkmAllocArray. It is freed by the caller using the
    /// CAutoDkmArray template or with DkmFreeMemory and manual element release.
    /// </param>
    /// <returns>
    /// S_OK is returned on success, and failure codes are used for any error.
    /// </returns>
    public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetSteppers(
        _Out_ DkmArray<Stepping::DkmStepper*>* pSteppers
        );

    /// <summary>
    /// Raise a EmbeddedBreakpointHit event. Components which implement the event sync
    /// interface will receive the event notification. This method will enqueue the event
    /// and control will immediately return to the caller.
    /// </summary>
    /// <param name="pInstructionAddress">
    /// [In,Optional] The address where the embedded breakpoint was hit.
    /// </param>
    /// <param name="ShowAsException">
    /// [In] If true, the UI will display an exception hit dialog for a breakpoint
    /// exception. If false, UI will simply break and the DkmInstructionAddress is not
    /// used.
    /// </param>
    /// <returns>
    /// S_OK is returned on success, and failure codes are used for any error.
    /// </returns>
    public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE OnEmbeddedBreakpointHit(
        _In_opt_ DkmInstructionAddress* pInstructionAddress,
        _In_ bool ShowAsException
        );

    /// <summary>
    /// This method is used to resume the target process so that a function evaluation
    /// may occur. This function is called by a runtime debug monitor after it has setup
    /// a function evaluation in order to make the target process run. The runtime
    /// monitor will first update the thread context, update any necessary memory in the
    /// target process, and setup any detection that the function evaluation is
    /// completed.
    ///
    /// Callers of this method MUST always call EndFuncEvalExecution before returning
    /// from the operation that triggered the function evaluation. The behavior is
    /// undefined if a caller fails to do so.
    ///
    /// This method is implemented in the base debug monitor by first updating the target
    /// process to be in function evaluation mode (DkmThread.OnBeginFuncEvalExecution),
    /// then suspending and/or resuming threads as specified by the function evaluation
    /// flags and finally continuing the target process.
    ///
    /// This method may be called from any thread, however OnBeginFuncEvalExecution must
    /// be called from the stopping event thread, so the base debug monitor may need to
    /// perform as thread switch as part of the implementation of this method. The base
    /// debug monitor should not return from BeginFuncEvalExecution until after the
    /// target has been resumed.
    /// </summary>
    /// <param name="Flags">
    /// [In] Flags impacting how function evaluation requests are performed.
    /// </param>
    /// <returns>
    /// S_OK is returned on success, and failure codes are used for any error.
    /// </returns>
    public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE BeginFuncEvalExecution(
        _In_ Evaluation::DkmFuncEvalFlags_t Flags
        );

    #ifndef EXCLUDE_MONITOR_ONLY_APIS
    /// <summary>
    /// API which may be called from a IDkmSingleStepCompleteReceived or
    /// IDkmRuntimeBreakpointReceived implementation to force the base DM to fire the
    /// EXCEPTION_BREAKPOINT or EXCEPTION_SINGLE_STEP exception in the target process
    /// when execution is resumed. Normally, the breakpoint or single step exception is
    /// implicitly suppressed. This allows the EXCEPTION_BREAKPOINT/EXCEPTION_SINGLE_STEP
    /// to be handled by exception handlers within the target process. This API will fail
    /// if the thread is not currently sitting at a step complete or breakpoint event.
    ///
    /// Location constraint: API must be called from a Monitor component (component level
    /// &lt; 100,000).
    /// </summary>
    /// <param name="ExceptionCode">
    /// [In] Win32 exception code to raise. Currently, this must be EXCEPTION_BREAKPOINT
    /// or EXCEPTION_SINGLE_STEP.
    /// </param>
    /// <returns>
    /// S_OK is returned on success, and failure codes are used for any error.
    /// </returns>
    public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE RaiseExecutionControlException(
        _In_ UINT32 ExceptionCode
        );
    #endif // #ifndef EXCLUDE_MONITOR_ONLY_APIS

    /// <summary>
    /// Gets the extended registers from the thread context.
    /// </summary>
    /// <param name="pExtendedRegisters">
    /// [Out] An array of extended registers.
    ///
    /// The memory for the DkmArray members is allocated by the method implementation
    /// using DkmAllocBytes/DkmAllocArray. It is freed by the caller using the
    /// CAutoDkmArray template or with DkmFreeMemory and manual element release.
    /// </param>
    /// <returns>
    /// S_OK is returned on success, and failure codes are used for any error.
    /// </returns>
    public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetExtendedRegisters(
        _Out_ DkmArray<CallStack::DkmUnwoundRegister*>* pExtendedRegisters
        );

    /// <summary>
    /// Sets the value of the extended register in the thread's context.
    /// </summary>
    /// <param name="RegisterIndex">
    /// [In] The CV constant of the register to set. For AVX, this can be any of the YMM
    /// register enumeration codes. The caller is expected to set the full YMM register
    /// (including the portions which are aliased on XMM registers).
    /// </param>
    /// <param name="pValue">
    /// [In] The value to set the register to. The size of the byte array must match the
    /// width of the register being set.
    /// </param>
    /// <returns>
    /// S_OK is returned on success, and failure codes are used for any error.
    /// </returns>
    public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE SetExtendedRegisterValue(
        _In_ CV_HREG_e RegisterIndex,
        _In_ DkmReadOnlyCollection<BYTE>* pValue
        );

    /// <summary>
    /// Convert an array of DkmUnwoundRegisters into an instance of DkmFrameRegisters
    /// containing a sorted DkmReadOnlyCollection of DkmUnwoundRegisters.
    /// </summary>
    /// <param name="UnwoundRegisters">
    /// [In] The unwound register collection to use as the source of the collection.
    ///
    /// The memory for the DkmArray members is allocated by the caller, and can be from
    /// any source (stack memory, static buffer, heap, etc). The implementation should
    /// not modify the members.
    /// </param>
    /// <param name="VFrame">
    /// [In] The vframe for this register set. This is only used on x86.
    /// </param>
    /// <param name="ppCreatedObject">
    /// [Out] DkmFrameRegisters represents the registers of a stack frame.
    /// </param>
    /// <returns>
    /// S_OK is returned on success, and failure codes are used for any error.
    /// </returns>
    public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE CreateFrameRegisters(
        _In_ const DkmArray<CallStack::DkmUnwoundRegister*>& UnwoundRegisters,
        _In_ UINT32 VFrame,
        _Deref_out_ CallStack::DkmFrameRegisters** ppCreatedObject
        );

    /// <summary>
    /// Get a managed thread's properties.
    /// </summary>
    /// <param name="pManagedThreadId">
    /// [Out] The managed thread id of the thread.
    /// </param>
    /// <returns>
    /// S_OK is returned on success, and failure codes are used for any error.
    /// </returns>
    public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetManagedThreadProperties(
        _Out_ INT32* pManagedThreadId
        );

    /// <summary>
    /// Get a managed thread's properties.
    ///
    /// This method will append a new work item to the specified work list, and return
    /// once the work item has been appended. The actual processing of the work item is
    /// asynchronous. The caller will be notified that the request is complete through
    /// the completion routine.
    /// </summary>
    /// <param name="pWorkList">
    /// WorkList to append the new work item to.
    /// </param>
    /// <param name="pCompletionRoutine">
    /// Routine to fire when the request is complete. If the request is successfully
    /// appended to the work list, this will always fire (including when the operation is
    /// canceled). This will never fire if appending the work item fails.
    /// </param>
    /// <returns>
    /// S_OK is returned on success, and failure codes are used for any error.
    /// </returns>
    public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetManagedThreadProperties(
        _In_ DkmWorkList* pWorkList,
        _In_ IDkmCompletionRoutine<ThreadProperties::DkmGetManagedThreadPropertiesAsyncResult>* pCompletionRoutine
        );

    #ifndef EXCLUDE_MONITOR_ONLY_APIS
    /// <summary>
    /// Return the top stack frame for a thread. This frame can come from a runtime
    /// instance, or a monitor unwinder. This can only be called from the server process.
    /// To obtain the top frame in the client process, use GetTopStackFrame.
    ///
    /// Location constraint: API must be called from a Monitor component (component level
    /// &lt; 100,000).
    /// </summary>
    /// <param name="pRuntimeInstance">
    /// [In] The runtime instance of the frame.
    /// </param>
    /// <param name="ppFrame">
    /// [Out] The top stack frame.
    /// </param>
    /// <returns>
    /// S_OK is returned on success, and failure codes are used for any error. E_NO_FRAME
    /// is returned if no native runtime is present and there are no frames on the stack.
    /// </returns>
    public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetTopStackWalkFrame(
        _In_ DkmRuntimeInstance* pRuntimeInstance,
        _Deref_out_ CallStack::DkmStackWalkFrame** ppFrame
        );
    #endif // #ifndef EXCLUDE_MONITOR_ONLY_APIS

    #ifndef EXCLUDE_MONITOR_ONLY_APIS
    /// <summary>
    /// GetCurrentFrameInfo is used to obtain the frame base and return address for the
    /// current context of the thread. This takes into account Frame Pointer Omission and
    /// if the current instruction pointer is in a prolog, epilog etc... NOTE: In some
    /// cases this will get it wrong if the frame has Frame Pointer Omission and there
    /// are no symbols loaded.
    ///
    /// Location constraint: API must be called from a Monitor component (component level
    /// &lt; 100,000).
    /// </summary>
    /// <param name="pReturnAddress">
    /// [Out] The return address of the frame.
    /// </param>
    /// <param name="pFrameBase">
    /// [Out] The frame base of the frame.
    /// </param>
    /// <param name="pVFrame">
    /// [Out] The vframe of the current frame. Only valid on x86.
    /// </param>
    /// <returns>
    /// S_OK is returned on success, and failure codes are used for any error.
    /// </returns>
    public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetCurrentFrameInfo(
        _Out_ UINT64* pReturnAddress,
        _Out_ UINT64* pFrameBase,
        _Out_ UINT64* pVFrame
        );
    #endif // #ifndef EXCLUDE_MONITOR_ONLY_APIS

    #ifndef EXCLUDE_IDE_ONLY_APIS
    /// <summary>
    /// Returns the top call stack frame for a thread. This value is normally cached
    /// after the first stack walk and cleared on continue. This is only callable above
    /// the stack provider in the client process. To obtain the top frame in the server
    /// process, call GetTopStackWalkFrame.
    ///
    /// Location constraint: API must be called from an IDE component (component level
    /// &gt; 100,000).
    /// </summary>
    /// <param name="ppTopFrame">
    /// [Out] DkmStackWalkFrame represents a frame on a call stack which has been walked,
    /// but may not have been formatted or filtered. Formatted frames are represented by
    /// DkmStackFrame instead.
    /// </param>
    /// <returns>
    /// S_OK is returned on success, and failure codes are used for any error.
    /// </returns>
    public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetTopStackFrame(
        _Deref_out_ CallStack::DkmStackWalkFrame** ppTopFrame
        );
    #endif // #ifndef EXCLUDE_IDE_ONLY_APIS

    /// <summary>
    /// Returns a DkmFrameRegisters object containing the thread's current register
    /// values.
    /// </summary>
    /// <param name="PseudoRegisters">
    /// [In] An array of cvconst/value pairs to add to the collection of register values
    /// coming from the context. This is generally used to add the vframe pseudo-register
    /// on x86.
    ///
    /// The memory for the DkmArray members is allocated by the caller, and can be from
    /// any source (stack memory, static buffer, heap, etc). The implementation should
    /// not modify the members.
    /// </param>
    /// <param name="ppCreatedObject">
    /// [Out] DkmFrameRegisters represents the registers of a stack frame.
    /// </param>
    /// <returns>
    /// S_OK is returned on success, and failure codes are used for any error.
    /// </returns>
    public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetCurrentRegisters(
        _In_ const DkmArray<CallStack::DkmUnwoundRegister*>& PseudoRegisters,
        _Deref_out_ CallStack::DkmFrameRegisters** ppCreatedObject
        );

    /// <summary>
    /// Creates a DkmFrameRegisters object from the supplied byte array containing a
    /// Win32 CONTEXT structure.
    /// </summary>
    /// <param name="ThreadContext">
    /// [In] Win32 CONTEXT to obtain the registers for.
    ///
    /// The memory for the DkmArray members is allocated by the caller, and can be from
    /// any source (stack memory, static buffer, heap, etc). The implementation should
    /// not modify the members.
    /// </param>
    /// <param name="PseudoRegisters">
    /// [In] An array of cvconst/value pairs to add to the collection of register values
    /// coming from the context. This is generally used to add the vframe pseudo-register
    /// on x86.
    ///
    /// The memory for the DkmArray members is allocated by the caller, and can be from
    /// any source (stack memory, static buffer, heap, etc). The implementation should
    /// not modify the members.
    /// </param>
    /// <param name="ExtendedRegisters">
    /// [In] An array of extended registers.
    ///
    /// The memory for the DkmArray members is allocated by the caller, and can be from
    /// any source (stack memory, static buffer, heap, etc). The implementation should
    /// not modify the members.
    /// </param>
    /// <param name="ppCreatedObject">
    /// [Out] DkmFrameRegisters represents the registers of a stack frame.
    /// </param>
    /// <returns>
    /// S_OK is returned on success, and failure codes are used for any error.
    /// </returns>
    public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE CreateRegistersObject(
        _In_ const DkmArray<BYTE>& ThreadContext,
        _In_ const DkmArray<CallStack::DkmUnwoundRegister*>& PseudoRegisters,
        _In_ const DkmArray<CallStack::DkmUnwoundRegister*>& ExtendedRegisters,
        _Deref_out_ CallStack::DkmFrameRegisters** ppCreatedObject
        );

    /// <summary>
    /// OnContinueExecution is called by the base debug monitor on the event thread. This
    /// method is called as part of the implementation of
    /// IDkmContinueExecution.ContinueExecution, which is what is used by the IDE to
    /// continue the target process. This method is used by the Dispatcher to either
    /// dispatch stopping events which could not be processed earlier, or to update the
    /// internal state of the DkmProcess object to indicate that the target process is
    /// now running. Before marking the process as running, the Dispatcher will send a
    /// Continue event.
    ///
    /// A base debug monitor should expect to be reentrantly called while it is in this
    /// method.
    /// </summary>
    /// <param name="pContinueTargetProcess">
    /// [Out] True if the base debug monitor should resume execution of the target
    /// process.
    /// </param>
    /// <returns>
    /// S_OK is returned on success, and failure codes are used for any error.
    /// </returns>
    public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE OnContinueExecution(
        _Out_ bool* pContinueTargetProcess
        );

    /// <summary>
    /// OnBeginFuncEvalExecution is called by the base debug monitor on the event thread.
    /// This method is called as part of the implementation of
    /// IDkmBaseFuncEvalService.BeginFuncEvalExecution, which is called to resume the
    /// process for a function evaluation. OnBeginFuncEvalExecution will update the
    /// internal state of the DkmProcess object to indicate that a function evaluation is
    /// in progress. This will also send a FuncEvalStarting event and it will mark the
    /// process as running, so that no operations which require a stopped process will be
    /// allowed.
    /// </summary>
    /// <param name="Flags">
    /// [In] Flags impacting how function evaluation requests are performed.
    /// </param>
    /// <param name="pContinueTargetProcess">
    /// [Out] True if the base debug monitor should resume execution of the target
    /// process. This will be true unless both DkmFuncEvalFlags.AllowStoppingEvents and
    /// DkmFuncEvalFlags.RunAllThreads are set -and- there are events waiting to be
    /// processed.
    /// </param>
    /// <returns>
    /// S_OK is returned on success, and failure codes are used for any error.
    /// </returns>
    public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE OnBeginFuncEvalExecution(
        _In_ Evaluation::DkmFuncEvalFlags_t Flags,
        _Out_ bool* pContinueTargetProcess
        );

    /// <summary>
    /// EndFuncEvalExecution is called by the runtime debug monitor on the event thread
    /// to exit function evaluation mode. EndFuncEvalExecution will update the internal
    /// state of the DkmProcess object to indicate that the function evaluation has
    /// ended. This will also send a FuncEvalEnded event and it will mark the process as
    /// stopped.
    ///
    /// This method may be called (1) while processing a 'received' stopping event
    /// notification -or- (2) while processing a non-stopping event such as thread exit,
    /// -or- (3) while the target is still stopped, for example if the function
    /// evaluation setup failed.
    /// </summary>
    /// <param name="Flags">
    /// [In] Flags impacting how function evaluation requests are performed.
    /// </param>
    /// <returns>
    /// S_OK is returned on success, and failure codes are used for any error.
    /// </returns>
    public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE EndFuncEvalExecution(
        _In_ Evaluation::DkmFuncEvalFlags_t Flags
        );

    /// <summary>
    /// Indicates if the given thread has a stopping event in the queue. This information
    /// is used by the execution manager to decide if a thread may be slipped.
    /// </summary>
    /// <param name="IgnoreAsyncBreakEvents">
    /// [In] If true, the dispatcher will ignore async break events when searching for
    /// stopping events.
    /// </param>
    /// <param name="pResult">
    /// [Out] True if the thread has a queued stopping event.
    /// </param>
    /// <returns>
    /// S_OK is returned on success, and failure codes are used for any error.
    /// </returns>
    public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE IsStoppingEventQueued(
        _In_ bool IgnoreAsyncBreakEvents,
        _Out_ bool* pResult
        );

    /// <summary>
    /// GetCurrentFuncEvalMode may be called by components as part of event processing to
    /// determine if function evaluation is enabled. This function may only be called as
    /// part of event processing.
    /// </summary>
    /// <param name="pCurrentMode">
    /// [Out] Indicates if there is a function evaluation occurring in the target process
    /// and if stopping events are allowed for this evaluation.
    /// </param>
    /// <returns>
    /// S_OK is returned on success, and failure codes are used for any error.
    /// </returns>
    public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetCurrentFuncEvalMode(
        _Out_ DkmFuncEvalMode_t* pCurrentMode
        );

    /// <summary>
    /// Update the context (register values) of a thread.
    /// </summary>
    /// <param name="Context">
    /// [In] A CONTEXT structure that contains the context to be set in the specified
    /// thread. The value of the ContextFlags member of this structure specifies which
    /// portions of a thread's context to set. Some values in the CONTEXT structure that
    /// cannot be specified are silently set to the correct value. This includes bits in
    /// the CPU status register that specify the privileged processor mode, global
    /// enabling bits in the debugging register, and other states that must be controlled
    /// by the operating system.
    ///
    /// The memory for the DkmArray members is allocated by the caller, and can be from
    /// any source (stack memory, static buffer, heap, etc). The implementation should
    /// not modify the members.
    /// </param>
    /// <returns>
    /// S_OK is returned on success, and failure codes are used for any error.
    /// </returns>
    public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE SetContext(
        _In_ const DkmArray<BYTE>& Context
        );

    /// <summary>
    /// Obtain the current context (register values) of a thread.
    /// </summary>
    /// <param name="ContextFlags">
    /// [In] Win32 flags indicating which portion of the CONTEXT object to obtain (ex:
    /// CONTEXT_FULL, CONTEXT_CONTROL, CONTEXT_INTEGER).
    /// </param>
    /// <param name="pContext">
    /// [In,Out] A Win32 CONTEXT structure that contains the context of the specified
    /// thread. The value of the ContextFlags member of this structure specifies which
    /// portions of a thread's context to obtained.
    /// </param>
    /// <param name="ContextSize">
    /// [In] Size of the context structure to read in bytes. This must exactly match the
    /// size required to read the context.
    /// </param>
    /// <returns>
    /// S_OK is returned on success, and failure codes are used for any error.
    /// </returns>
    public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetContext(
        _In_ UINT32 ContextFlags,
        _Out_capcount_(ContextSize) void* pContext,
        _In_ UINT32 ContextSize
        );

    #ifndef EXCLUDE_IDE_ONLY_APIS
    /// <summary>
    /// Provides the location of a thread, as visible in the threads window, or threads
    /// drop down in the debug location toolbar.
    ///
    /// This method will append a new work item to the specified work list, and return
    /// once the work item has been appended. The actual processing of the work item is
    /// asynchronous. The caller will be notified that the request is complete through
    /// the completion routine.
    ///
    /// Location constraint: API must be called from an IDE component (component level
    /// &gt; 100,000).
    /// </summary>
    /// <param name="pWorkList">
    /// WorkList to append the new work item to.
    /// </param>
    /// <param name="pCompletionRoutine">
    /// Routine to fire when the request is complete. If the request is successfully
    /// appended to the work list, this will always fire (including when the operation is
    /// canceled). This will never fire if appending the work item fails.
    /// </param>
    /// <returns>
    /// S_OK is returned on success, and failure codes are used for any error.
    /// </returns>
    public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetCurrentLocation(
        _In_ DkmWorkList* pWorkList,
        _In_ IDkmCompletionRoutine<CallStack::DkmGetCurrentLocationAsyncResult>* pCompletionRoutine
        );
    #endif // #ifndef EXCLUDE_IDE_ONLY_APIS

    /// <summary>
    /// Retrieves the stack limit/stack base of the given thread. Note that its possible
    /// for this value to change over time, for example, in the case of fibers.
    /// </summary>
    /// <param name="pMemoryRange">
    /// [Out] The limit/base address for the memory containing a thread's stack.
    /// </param>
    /// <returns>
    /// S_OK is returned on success, and failure codes are used for any error.
    /// E_INVALID_MEMORY_ADDRESS indicates that the address containing the TEB structure
    /// could not be read from the target process. This may be returned for minidumps
    /// without heap.
    /// </returns>
    public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetStackAddressRange(
        _Out_ CallStack::DkmStackMemoryRange* pMemoryRange
        );

    /// <summary>
    /// Suspend this thread.
    /// </summary>
    /// <param name="InternalSuspension">
    /// [In] Pass true if this suspension should be hidden in calls to
    /// GetSuspensionCount. This is useful for internal suspensions that should not be
    /// reported to the user such as thread slippage suspensions.
    /// </param>
    /// <param name="pExternalSuspensionCount">
    /// [Out,Optional] The previous number of suspensions for this thread minus the ones
    /// internal to the debugger.
    /// </param>
    /// <returns>
    /// S_OK is returned on success, and failure codes are used for any error.
    /// </returns>
    public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Suspend(
        _In_ bool InternalSuspension,
        _Out_ UINT32* pExternalSuspensionCount
        );

    /// <summary>
    /// Resume this thread.
    /// </summary>
    /// <param name="InternalSuspension">
    /// [In] Pass true if this suspension should be hidden in calls to
    /// GetSuspensionCount. This is useful for internal suspensions that should not be
    /// reported to the user such as thread slippage suspensions.
    /// </param>
    /// <param name="pExternalSuspensionCount">
    /// [Out,Optional] The previous number of suspensions for this thread minus the ones
    /// internal to the debugger before this resume is applied.
    /// </param>
    /// <returns>
    /// S_OK is returned on success, and failure codes are used for any error.
    /// </returns>
    public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Resume(
        _In_ bool InternalSuspension,
        _Out_ UINT32* pExternalSuspensionCount
        );

    /// <summary>
    /// Return the current suspension count of this thread.
    /// </summary>
    /// <param name="ShowInternal">
    /// [In] Pass true to return the true suspension count for the thread. Return false
    /// to only see the suspensions that occurred in the debuggee process or the one's
    /// that passed true for InternalSuspension to Suspend.
    /// </param>
    /// <param name="pSuspensionCount">
    /// [Out] The suspension count of thread. The internal thread suspension count is
    /// subtracted from this value if ShowInternal is false.
    /// </param>
    /// <returns>
    /// S_OK is returned on success, and failure codes are used for any error.
    /// </returns>
    public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetSuspensionCount(
        _In_ bool ShowInternal,
        _Out_ UINT32* pSuspensionCount
        );

    /// <summary>
    /// Return the total number of suspensions caused by the debugger (i.e. calls to
    /// DkmThread::Suspend without a call to DkmThread::Resume). This excludes any
    /// suspensions external to the debugger.
    /// </summary>
    /// <param name="pSuspensionCount">
    /// [Out] The total number of suspensions caused by the debugger (i.e. calls to
    /// DkmThread::Suspend without a call to DkmThread::Resume). This excludes any
    /// suspensions external to the debugger.
    /// </param>
    /// <returns>
    /// S_OK is returned on success, and failure codes are used for any error.
    /// </returns>
    public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetDebuggerSuspensionCount(
        _Out_ UINT32* pSuspensionCount
        );

    /// <summary>
    /// Retrieves the value in the debuggee thread's thread local storage (TLS) slot for
    /// the specified TLS index. Each thread of a process has its own slot for each TLS
    /// index.
    /// </summary>
    /// <param name="TlsIndex">
    /// [In] The TLS index that was allocated when the target process called the TlsAlloc
    /// function.
    /// </param>
    /// <param name="pValue">
    /// [Out] The pointer-sized value which was stored in the thread's TLS slot. If the
    /// target thread is 32-bit, the upper 32-bits of this value will be zero.
    /// </param>
    /// <returns>
    /// S_OK is returned on success, and failure codes are used for any error.
    /// </returns>
    public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetTlsValue(
        _In_ UINT32 TlsIndex,
        _Out_ UINT64* pValue
        );

    /// <summary>
    /// Stores a value in the debuggee thread's thread local storage (TLS) slot for the
    /// specified TLS index. Each thread of a process has its own slot for each TLS
    /// index.
    /// </summary>
    /// <param name="TlsIndex">
    /// [In] The TLS index that was allocated when the target process called the TlsAlloc
    /// function.
    /// </param>
    /// <param name="Value">
    /// [In] The pointer-sized value to store in the thread's TLS slot. If the target
    /// thread is 32-bit, the upper 32-bits of this value will be ignored.
    /// </param>
    /// <returns>
    /// S_OK is returned on success, and failure codes are used for any error.
    /// </returns>
    public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE SetTlsValue(
        _In_ UINT32 TlsIndex,
        _In_ UINT64 Value
        );

    /// <summary>
    /// Get a thread's dynamic properties.
    /// </summary>
    /// <param name="pPriority">
    /// [Out] The priority of the thread. The values returned correspond directly to the
    /// values defined for kernel32!GetThreadPriority.
    /// </param>
    /// <param name="pAffinityMask">
    /// [Out] The affinity mask of the thread. The values returned correspond directly to
    /// the values defined for kernel32!SetThreadAffinityMask.
    /// </param>
    /// <returns>
    /// S_OK is returned on success, and failure codes are used for any error.
    /// </returns>
    public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetVolatileProperties(
        _Out_ INT32* pPriority,
        _Out_ UINT64* pAffinityMask
        );

    /// <summary>
    /// Get a thread's dynamic properties.
    ///
    /// This method will append a new work item to the specified work list, and return
    /// once the work item has been appended. The actual processing of the work item is
    /// asynchronous. The caller will be notified that the request is complete through
    /// the completion routine.
    /// </summary>
    /// <param name="pWorkList">
    /// WorkList to append the new work item to.
    /// </param>
    /// <param name="pCompletionRoutine">
    /// Routine to fire when the request is complete. If the request is successfully
    /// appended to the work list, this will always fire (including when the operation is
    /// canceled). This will never fire if appending the work item fails.
    /// </param>
    /// <returns>
    /// S_OK is returned on success, and failure codes are used for any error.
    /// </returns>
    public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetVolatileProperties(
        _In_ DkmWorkList* pWorkList,
        _In_ IDkmCompletionRoutine<ThreadProperties::DkmGetVolatilePropertiesAsyncResult>* pCompletionRoutine
        );

    /// <summary>
    /// Get volatile flags about a thread. For instance, return if a thread is a
    /// user-mode scheduled thread.
    /// </summary>
    /// <param name="pFlags">
    /// [Out] Volatile flags that apply to a thread. These values are expected to change
    /// over time and should not be cached by callers.
    /// </param>
    /// <returns>
    /// S_OK is returned on success, and failure codes are used for any error.
    /// </returns>
    public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetVolatileFlags(
        _Out_ ThreadProperties::DkmVolatileThreadFlags_t* pFlags
        );

    /// <summary>
    /// Get volatile flags about a thread. For instance, return if a thread is a
    /// user-mode scheduled thread.
    ///
    /// This method will append a new work item to the specified work list, and return
    /// once the work item has been appended. The actual processing of the work item is
    /// asynchronous. The caller will be notified that the request is complete through
    /// the completion routine.
    /// </summary>
    /// <param name="pWorkList">
    /// WorkList to append the new work item to.
    /// </param>
    /// <param name="pCompletionRoutine">
    /// Routine to fire when the request is complete. If the request is successfully
    /// appended to the work list, this will always fire (including when the operation is
    /// canceled). This will never fire if appending the work item fails.
    /// </param>
    /// <returns>
    /// S_OK is returned on success, and failure codes are used for any error.
    /// </returns>
    public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetVolatileFlags(
        _In_ DkmWorkList* pWorkList,
        _In_ IDkmCompletionRoutine<ThreadProperties::DkmGetVolatileFlagsAsyncResult>* pCompletionRoutine
        );

    /// <summary>
    /// Raise a InterceptExceptionCompleted event. Components which implement the event
    /// sync interface will receive the event notification. This method will enqueue the
    /// event and control will immediately return to the caller.
    /// </summary>
    /// <param name="Cookie">
    /// [In] Cookie that was handed out when intercept exception request came in.
    /// </param>
    /// <returns>
    /// S_OK is returned on success, and failure codes are used for any error.
    /// </returns>
    public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE OnInterceptExceptionCompleted(
        _In_ UINT64 Cookie
        );

    /// <summary>
    /// ThreadExit is sent by the dispatcher when DkmThread::Unload is invoked by the
    /// monitor.
    ///
    /// This method may only be called by the component which created the object.
    /// </summary>
    /// <param name="ExitCode">
    /// [In] 32-bit value that the process returned on exit. This is the same value that
    /// would be reported from the kernel32!GetExitCodeThread.
    /// </param>
    /// <returns>
    /// S_OK is returned on success, and failure codes are used for any error.
    /// </returns>
    public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Unload(
        _In_ UINT32 ExitCode
        );

    /// <summary>
    /// GetThreadCurrentWinRtErrorInfo is used to get the address of the current
    /// IErrorInfo object for this thread.
    ///
    /// This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
    /// </summary>
    /// <param name="pWinRTErrorInfo">
    /// [Out,Optional] Address of the current IErrorInfo object on this thread.
    /// </param>
    /// <returns>
    /// S_OK is returned on success, and failure codes are used for any error.
    /// </returns>
    public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetThreadCurrentWinRtErrorInfo(
        _Out_ UINT64* pWinRTErrorInfo
        );

    /// <summary>
    /// ThreadNameChange is sent by the dispatcher when DkmThread::NameChange is invoked
    /// by the monitor.
    ///
    /// This API was introduced in Visual Studio 14 RTM (DkmApiVersion.VS14RTM).
    /// </summary>
    /// <returns>
    /// S_OK is returned on success, and failure codes are used for any error.
    /// </returns>
    public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE OnThreadNameChange(
        );
}; // end of DkmThread

// Contains information about a message that is to be displayed to the user.
class DECLSPEC_NOVTABLE DECLSPEC_UUID("1a166c7c-4ae6-0992-82e2-c75555ed8055") DkmUserMessage : public IUnknown
{
    private: ___ReferenceCount_t m_ReferenceCount;
    private: DkmDispatcherObjectFlags_t m_ObjectFlags;
    private: const GUID* m_pTypeId;
    private: size_t m_ObjectGCHandle;
    // Use DkmUserMessage::Create to create this object
    private: DkmUserMessage();
    // This object is refcounted. It is deleted through Release
    protected: ~DkmUserMessage();
    // This object cannot be copied
    private: DkmUserMessage& operator=(const DkmUserMessage&);
    private: DkmUserMessage(const DkmUserMessage&);

    // Contains additional fields of DkmUserMessage which were added after the class was
    // initally introduced.
    private: struct ___ExtendedData
    {
        ___ExtendedData();

        // An optional timestamp value. Typically, obtained via QueryPerformanceCounter
        // when the object is created. Note that if the object is created on the local
        // side of the remoting layer, no timestamp will be available.
        const UINT64 TimeStamp;
    };

    private: DefaultPort::DkmTransportConnection* const m_pConnection;
    private: OPTIONAL DkmProcess* const m_pProcess;
    private: const DkmUserMessageOutputKind_t m_OutputKind;
    private: DkmString* const m_pMessageText;
    private: const UINT32 m_MessageBoxFlags;
    private: const HRESULT m_ErrorCode;
    private: ___ExtendedData* const m__pExtendedData;

    // Connection used to send the message to the debugger. This will value is usually
    // obtained from DkmProcess.Connection unless the message needs to be sent before the
    // DkmProcess is created.
    public: _Ret_ DECLSPEC_NOTHROW DefaultPort::DkmTransportConnection* STDMETHODCALLTYPE Connection(
        );

    // [Optional] Process that this message is in reference to.
    public: _Ret_opt_ DECLSPEC_NOTHROW DkmProcess* STDMETHODCALLTYPE Process(
        );

    // Indicates where a DkmUserMessage should be output within the debugger IDE.
    public: DECLSPEC_NOTHROW DkmUserMessageOutputKind_t STDMETHODCALLTYPE OutputKind(
        );

    // Text to display inside the message box or inside the output window. If an error
    // code is provided, '%1' will be replaced with the text for the error message. For
    // example: 'Unable to stand on my head. %1'.
    public: _Ret_ DECLSPEC_NOTHROW DkmString* STDMETHODCALLTYPE MessageText(
        );

    // Win32 message box flags from winuser.h (ex: MB_OK). These flags are ignored if
    // OutputKind is not set to 'MessageBox'.
    public: DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE MessageBoxFlags(
        );

    // Error code to display a message for. This value should be S_OK (0) if the message
    // is not for an error.
    public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ErrorCode(
        );

    // An optional timestamp value. Typically, obtained via QueryPerformanceCounter when
    // the object is created. Note that if the object is created on the local side of the
    // remoting layer, no timestamp will be available.
    //
    // This API was introduced in Visual Studio 14 RTM (DkmApiVersion.VS14RTM).
    public: DECLSPEC_NOTHROW UINT64 STDMETHODCALLTYPE TimeStamp(
        );

    /// <summary>
    /// Create a new DkmUserMessage object instance.
    /// </summary>
    /// <param name="pConnection">
    /// [In] Connection used to send the message to the debugger. This will value is
    /// usually obtained from DkmProcess.Connection unless the message needs to be sent
    /// before the DkmProcess is created.
    /// </param>
    /// <param name="pProcess">
    /// [In,Optional] Process that this message is in reference to.
    /// </param>
    /// <param name="OutputKind">
    /// [In] Indicates where a DkmUserMessage should be output within the debugger IDE.
    /// </param>
    /// <param name="pMessageText">
    /// [In] Text to display inside the message box or inside the output window. If an
    /// error code is provided, '%1' will be replaced with the text for the error
    /// message. For example: 'Unable to stand on my head. %1'.
    /// </param>
    /// <param name="MessageBoxFlags">
    /// [In] Win32 message box flags from winuser.h (ex: MB_OK). These flags are ignored
    /// if OutputKind is not set to 'MessageBox'.
    /// </param>
    /// <param name="ErrorCode">
    /// [In] Error code to display a message for. This value should be S_OK (0) if the
    /// message is not for an error.
    /// </param>
    /// <param name="ppCreatedObject">
    /// [Out] Result of this method call.
    /// </param>
    /// <returns>
    /// S_OK is returned on success, and failure codes are used for any error.
    /// </returns>
    public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
        _In_ DefaultPort::DkmTransportConnection* pConnection,
        _In_opt_ DkmProcess* pProcess,
        _In_ DkmUserMessageOutputKind_t OutputKind,
        _In_ DkmString* pMessageText,
        _In_ UINT32 MessageBoxFlags,
        _In_ HRESULT ErrorCode,
        _Deref_out_ DkmUserMessage** ppCreatedObject
        );

    /// <summary>
    /// Create a new DkmUserMessage object instance.
    ///
    /// This API was introduced in Visual Studio 14 RTM (DkmApiVersion.VS14RTM).
    /// </summary>
    /// <param name="pConnection">
    /// [In] Connection used to send the message to the debugger. This will value is
    /// usually obtained from DkmProcess.Connection unless the message needs to be sent
    /// before the DkmProcess is created.
    /// </param>
    /// <param name="pProcess">
    /// [In,Optional] Process that this message is in reference to.
    /// </param>
    /// <param name="OutputKind">
    /// [In] Indicates where a DkmUserMessage should be output within the debugger IDE.
    /// </param>
    /// <param name="pMessageText">
    /// [In] Text to display inside the message box or inside the output window. If an
    /// error code is provided, '%1' will be replaced with the text for the error
    /// message. For example: 'Unable to stand on my head. %1'.
    /// </param>
    /// <param name="MessageBoxFlags">
    /// [In] Win32 message box flags from winuser.h (ex: MB_OK). These flags are ignored
    /// if OutputKind is not set to 'MessageBox'.
    /// </param>
    /// <param name="ErrorCode">
    /// [In] Error code to display a message for. This value should be S_OK (0) if the
    /// message is not for an error.
    /// </param>
    /// <param name="TimeStamp">
    /// [In] An optional timestamp value. Typically, obtained via QueryPerformanceCounter
    /// when the object is created. Note that if the object is created on the local side
    /// of the remoting layer, no timestamp will be available.
    /// </param>
    /// <param name="ppCreatedObject">
    /// [Out] Result of this method call.
    /// </param>
    /// <returns>
    /// S_OK is returned on success, and failure codes are used for any error.
    /// </returns>
    public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
        _In_ DefaultPort::DkmTransportConnection* pConnection,
        _In_opt_ DkmProcess* pProcess,
        _In_ DkmUserMessageOutputKind_t OutputKind,
        _In_ DkmString* pMessageText,
        _In_ UINT32 MessageBoxFlags,
        _In_ HRESULT ErrorCode,
        _In_ UINT64 TimeStamp,
        _Deref_out_ DkmUserMessage** ppCreatedObject
        );

    /// <summary>
    /// Displays a message to the user inside the Visual Studio debugger IDE. This
    /// function does not block waiting for the user to dismiss the error message.
    /// </summary>
    /// <returns>
    /// S_OK is returned on success, and failure codes are used for any error.
    /// </returns>
    public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Post(
        );

    /// <summary>
    /// Displays a message to the user inside the Visual Studio debugger IDE. This
    /// function waits for the Visual Studio IDE to complete processing this message.
    /// This method may not be called from code that runs as part of UI event processing.
    /// Doing so will cause a deadlock. This method requires DkmUserMessage.Process to be
    /// non-null.
    /// </summary>
    /// <param name="pResult">
    /// [Out] Win32 'ID' code from displaying the message box (ex: IDYES). These codes
    /// are defined in winuser.h from the Windows SDK.
    /// </param>
    /// <returns>
    /// S_OK is returned on success, and failure codes are used for any error.
    /// </returns>
    public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE DisplayPrompt(
        _Out_ UINT32* pResult
        );

    /// <summary>
    /// Displays a message to the user inside the Visual Studio debugger IDE. This method
    /// is the Async implementation.  Once it is executed the completion routine will be
    /// called with the DkmProcess and the user response (Yes/No).  This method requires
    /// DkmUserMessage.Process to be non-null.
    ///
    /// This method will append a new work item to the specified work list, and return
    /// once the work item has been appended. The actual processing of the work item is
    /// asynchronous. The caller will be notified that the request is complete through
    /// the completion routine.
    ///
    /// This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
    /// </summary>
    /// <param name="pWorkList">
    /// WorkList to append the new work item to.
    /// </param>
    /// <param name="pCompletionRoutine">
    /// Routine to fire when the request is complete. If the request is successfully
    /// appended to the work list, this will always fire (including when the operation is
    /// canceled). This will never fire if appending the work item fails.
    /// </param>
    /// <returns>
    /// S_OK is returned on success, and failure codes are used for any error.
    /// </returns>
    public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE DisplayPrompt(
        _In_ DkmWorkList* pWorkList,
        _In_ IDkmCompletionRoutine<DkmDisplayUserMessagePromptAsyncResult>* pCompletionRoutine
        );
}; // end of DkmUserMessage

// Indicates where a DkmUserMessage should be output within the debugger IDE.
DEFINE_SCOPED_ENUM(DkmUserMessageOutputKind)
{
    // Message should be displayed in the output window.  It will always appear and
    // cannot be filtered by the user.
    UnfilteredOutputWindowMessage = 0,
    // Message should be displayed in the output window.  If the user has chosen to hide
    // exception message, the message will not be displayed. Typically, messages of this
    // kind inform the user that an exception has occurred in the debuggee.
    ExceptionOutputWindowMessage = 1,
    // Message should be displayed in the output window.  If the user has chosen to hide
    // program output, the message will not be displayed. Typically, messages of this
    // kind are sent from the debuggee using API's such as OutputDebugString() or
    // System.Diagnostics.Debugger.WriteLine().
    ProgramOutput = 2,
    // Message should be displayed in a message box.
    MessageBox = 3,
    // Message displayed in message box prompts to enable/disable JustMyCode.
    JustMyCodePrompt = 4,
    // Step filtering-related message.  Will go to output window, unless the user chooses
    // to turn off step-filtering messages.
    StepFilterOutputWindowMessage = 5,
    // Message box informing user that we stepped over a property or operator.  UI layer
    // will handle the logic of suppressing the dialog if it was already shown before.
    StepFilterPrompt = 6,
    // Message is displayed in a message box and the debugger UI will attempt a
    // detach/terminate to stop debugging this process. If the FatalError is being
    // generated from a debug event, the component sending the fatal error may want to
    // suspend the threads of the process so that it doesn't execute further until
    // debugging stops.
    FatalError = 7,
    // This message kind is used when the user aborts an operation that is required in
    // order to debug. Like a FatalError message, the debugger UI the debugger UI will
    // attempt a detach/terminate to stop debugging this process when the event is
    // received.
    FatalOperationAbortOutputMessage = 8,
    // Message is displayed when a user is using the new debugger (Concord) and has hit a
    // breakpoint in a language that not supported.
    NewDebuggerCompatibilityWarning = 9
};

// Represents an address which could not be resolved to a module.
class DECLSPEC_NOVTABLE DECLSPEC_UUID("a36f3140-bcdd-fcdf-a363-869fbaea9906") DkmUnknownInstructionAddress : public DkmInstructionAddress
{
    // Use DkmUnknownInstructionAddress::Create to create this object
    private: DkmUnknownInstructionAddress();
    // This object is refcounted. It is deleted through Release
    protected: ~DkmUnknownInstructionAddress();
    // This object cannot be copied
    private: DkmUnknownInstructionAddress& operator=(const DkmUnknownInstructionAddress&);
    private: DkmUnknownInstructionAddress(const DkmUnknownInstructionAddress&);

    private: void* m__pExtendedData;

    // Attempt to cast a 'DkmInstructionAddress' to a 'DkmUnknownInstructionAddress'. Return
    // NULL if the path object is not a 'DkmUnknownInstructionAddress'.
    // pUnknownAddress : [In,Optional] Object to attempt to cast
    // Return Value : [Optional] Result of the cast.
    public: static DECLSPEC_NOTHROW DkmUnknownInstructionAddress* TryCast(
        DkmInstructionAddress* pInstructionAddress
        )
    {
        if (pInstructionAddress == NULL || pInstructionAddress->TagValue() != Tag::UnknownAddress)
            return NULL;

        return static_cast<DkmUnknownInstructionAddress*>(pInstructionAddress);
    }

    /// <summary>
    /// Create a new DkmUnknownInstructionAddress object instance.
    /// </summary>
    /// <param name="pRuntimeInstance">
    /// [In] The DkmRuntimeInstance class represents an execution environment which is
    /// loaded into a DkmProcess and which contains code to be debugged.
    /// </param>
    /// <param name="pCPUInstruction">
    /// [In,Optional] CPUInstruction provides the address that the CPU will execute. This
    /// is always provided for native instructions. It may be provided for CLR or custom
    /// addresses depending on how the address object was created.
    /// </param>
    /// <param name="ppCreatedObject">
    /// [Out] Result of this method call.
    /// </param>
    /// <returns>
    /// S_OK is returned on success, and failure codes are used for any error.
    /// </returns>
    public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
        _In_ DkmRuntimeInstance* pRuntimeInstance,
        _In_opt_ const DkmInstructionAddress::CPUInstruction* pCPUInstruction,
        _Deref_out_ DkmUnknownInstructionAddress** ppCreatedObject
        );
}; // end of DkmUnknownInstructionAddress


// Contains types related to expression evaluation.
namespace Evaluation {
    // Identifies the compiler (language and vendor) that a method comes from. This is used
    // to select an expression evaluator.
    struct DECLSPEC_UUID("b0873194-c47f-a65a-5def-16644ebe23b8") DkmCompilerId
    {
        // Vendor for the compiler. In some contexts this may be Guid.Empty to indicate that
        // the vendor is unknown.
        GUID VendorId;

        // Language that the code was written in. In some contexts, this may be Guid.Empty to
        // indicate that the language is unknown.
        GUID LanguageId;

        // Compare an instance of the DkmCompilerId struct to another instance.
        // Return value is as follows:
        // Less than zero:     This instance is less than 'other'.
        // Zero:               This instance is equal to 'other'.
        // Greater than zero:  This instance is greater than 'other'.
        DECLSPEC_NOTHROW int STDMETHODCALLTYPE CompareTo(
            const DkmCompilerId& other
            ) const;

        bool operator==(const DkmCompilerId& rhs) const     { return CompareTo(rhs) == 0; }
        bool operator!=(const DkmCompilerId& rhs) const     { return CompareTo(rhs) != 0; }
        bool operator> (const DkmCompilerId& rhs) const     { return CompareTo(rhs) > 0;  }
        bool operator< (const DkmCompilerId& rhs) const     { return CompareTo(rhs) < 0;  }
        bool operator>=(const DkmCompilerId& rhs) const     { return CompareTo(rhs) >= 0; }
        bool operator<=(const DkmCompilerId& rhs) const     { return CompareTo(rhs) <= 0; }

        // Release all reference-counted fields within the DkmCompilerId structure.
        static DECLSPEC_NOTHROW void STDMETHODCALLTYPE Release(
            _In_ DkmCompilerId* pItem
            )
        {
            // structure requires no cleanup
        }
    };

    // Enum that describes the location of the visualizer assembly.
    //
    // This API was introduced in Visual Studio 14 RTM (DkmApiVersion.VS14RTM).
    DEFINE_SCOPED_ENUM(DkmClrCustomVisualizerAssemblyLocation)
    {
        // Location unknown.
        Unknown = 0,
        // The ...\Documents\...\Visual Studio X\Visualizers directory.
        UserDirectory = 1,
        // The ...\Common7\Packages\Debugger\Visualizers directory.
        SharedDirectory = 2,
        // Present on an assembly loaded by the debuggee.
        Debuggee = 3
    };

    // Flags which indicate attributes of a CLR value.
    //
    // This API was introduced in Visual Studio 14 RTM (DkmApiVersion.VS14RTM).
    DEFINE_SCOPED_ENUM(DkmClrValueFlags)
    {
        // No value flags set.
        None = 0x0,
        // Indicates that the evaluation did not succeed and has returned an error message.
        Error = 0x1,
        // Indicates that the value exists only in the debugger and is not backed by a real
        // value in the process being debugged.
        Synthetic = 0x2,
        // Indicates that the evaluation returned a void value.
        Void = 0x4
    };
    DEFINE_SCOPED_ENUM_FLAG_OPERATORS(DkmClrValueFlags_t);

    // Result of an asynchronous DkmLanguageExpression.CompileDisplayAttributeInternal call.
    struct DkmCompileDisplayAttributeInternalAsyncResult
    {
        // HRESULT code returned from the caller. This will be
        // DkmExceptionCode.COR_E_OPERATIONCANCELED (0x8013153B) if the operation was
        // canceled before processing was complete.
        HRESULT ErrorCode;

        // [Optional] Indicates any error compiling the expression.  If the code compiles
        // successfully, this value should be null. In error cases, this value indicates the
        // reason for the compile error and the caller should return S_OK.
        OPTIONAL DkmString* pError;

        // [Optional] The compiled display attribute.  If Result is null, and Error is not
        // null, there was a compile error.
        OPTIONAL Evaluation::ClrCompilation::DkmCompiledClrInspectionQuery* pResult;
    };

    // Represents a query which is produced by an expression evaluator or similar component
    // and set to the target computer to obtain information about the dynamic state of the
    // program (ex: the current value of a register).  Consumers of inspection queries should
    // call Close() once it is known that the inspection query will no longer execute.
    //
    // Derived classes: DkmCompiledCustomInspectionQuery, DkmCompiledILInspectionQuery,
    // DkmCompiledClrInspectionQuery, DkmCompiledClrLocalsQuery
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("47a09cc9-e122-16e1-9132-beda4e7b8025") DkmCompiledInspectionQuery : public IUnknown
    {
        private: ___ReferenceCount_t m_ReferenceCount;
        private: DkmDispatcherObjectFlags_t m_ObjectFlags;
        private: const GUID* m_pTypeId;
        private: size_t m_ObjectGCHandle;
        // Use DkmCompiledInspectionQuery::Create to create this object
        private: DkmCompiledInspectionQuery();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmCompiledInspectionQuery();
        // This object cannot be copied
        private: DkmCompiledInspectionQuery& operator=(const DkmCompiledInspectionQuery&);
        private: DkmCompiledInspectionQuery(const DkmCompiledInspectionQuery&);

        // DkmCompiledInspectionQuery is an abstract base class. This enum indicates which
        // derived class this object is an instance of.
        public: FORWARD_DECLARE_SCOPED_ENUM(Tag);
        DEFINE_SCOPED_ENUM(Tag)
        {
        // Object is an instance of 'DkmCompiledILInspectionQuery'.
        DkmILQuery = 0,
        // Object is an instance of 'DkmCompiledCustomInspectionQuery'.
        CustomQuery = 1,
        // Object is an instance of 'DkmCompiledClrInspectionQuery'.
        CompiledClrInspectionQuery = 2,
        // Object is an instance of 'DkmCompiledClrLocalsQuery'.
        CompiledClrLocalsQuery = 3
        };

        // Contains additional fields of DkmCompiledInspectionQuery which were added after
        // the class was initally introduced.
        private: struct ___ExtendedData
        {
            ___ExtendedData();

            // [Optional] Custom Data to associate with this inspection query.  It will
            // persist as long as the query has the potential to execute.
            OPTIONAL Evaluation::DkmCustomDataContainer* const pDataContainer;

            // The language of the expression evaluator that created this query.
            const Evaluation::DkmCompilerId LanguageId;
        };

        private: const Tag_t m_TagValue;
        private: DkmRuntimeInstance* const m_pRuntimeInstance;
        private: const GUID m_QueryKind;
        private: ___ExtendedData* const m__pExtendedData;

        // DkmCompiledInspectionQuery is an abstract base class. This enum indicates which
        // derived class this object is an instance of.
        public: DECLSPEC_NOTHROW Tag_t STDMETHODCALLTYPE TagValue(
            );

        // The DkmRuntimeInstance class represents an execution environment which is loaded
        // into a DkmProcess and which contains code to be debugged.
        public: _Ret_ DECLSPEC_NOTHROW DkmRuntimeInstance* STDMETHODCALLTYPE RuntimeInstance(
            );

        // Indicates the type of inspection query. This is used to select a component to
        // process the query.
        public: DECLSPEC_NOTHROW const GUID& STDMETHODCALLTYPE QueryKind(
            );

        // [Optional] Custom Data to associate with this inspection query.  It will persist
        // as long as the query has the potential to execute.
        //
        // This API was introduced in Visual Studio 14 RTM (DkmApiVersion.VS14RTM).
        public: _Ret_opt_ DECLSPEC_NOTHROW Evaluation::DkmCustomDataContainer* STDMETHODCALLTYPE DataContainer(
            );

        // The language of the expression evaluator that created this query.
        //
        // This API was introduced in Visual Studio 14 RTM (DkmApiVersion.VS14RTM).
        public: DECLSPEC_NOTHROW const Evaluation::DkmCompilerId& STDMETHODCALLTYPE LanguageId(
            );

        /// <summary>
        /// Executes a compiled inspection query and returns any results.
        /// </summary>
        /// <param name="pParameters">
        /// [In,Optional] Optional array of parameter values to pass to the IL stream.
        /// </param>
        /// <param name="pILContext">
        /// [In] The stack frame context we are evaluating on.
        /// </param>
        /// <param name="Timeout">
        /// [In] This is the timeout to be used for potentially slow operations such as a
        /// function evaluation. This value is in milliseconds.
        /// </param>
        /// <param name="FuncEvalFlags">
        /// [In] Flags impacting how function evaluation requests are performed.
        /// </param>
        /// <param name="pResults">
        /// [Out] Results of the evaluations. Each ILEvaluationResult object contains an
        /// index that indicates which DkmILInstruction in the instructions parameter this
        /// result came from. NOTE: some instructions will not return a result.
        ///
        /// The memory for the DkmArray members is allocated by the method implementation
        /// using DkmAllocBytes/DkmAllocArray. It is freed by the caller using the
        /// CAutoDkmArray template or with DkmFreeMemory and manual element release.
        /// </param>
        /// <param name="pFailureReason">
        /// [Out] If an expected error occurs evaluating the DkmIL, indicates the reason for
        /// the failure.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Execute(
            _In_opt_ DkmReadOnlyCollection<Evaluation::IL::DkmILParameterValue*>* pParameters,
            _In_ Evaluation::DkmILContext* pILContext,
            _In_ UINT32 Timeout,
            _In_ Evaluation::DkmFuncEvalFlags_t FuncEvalFlags,
            _Out_ DkmArray<Evaluation::IL::DkmILEvaluationResult*>* pResults,
            _Out_ Evaluation::IL::DkmILFailureReason_t* pFailureReason
            );

        /// <summary>
        /// Executes a compiled inspection query and returns any results.
        ///
        /// This method will append a new work item to the specified work list, and return
        /// once the work item has been appended. The actual processing of the work item is
        /// asynchronous. The caller will be notified that the request is complete through
        /// the completion routine.
        /// </summary>
        /// <param name="pWorkList">
        /// WorkList to append the new work item to.
        /// </param>
        /// <param name="pParameters">
        /// [In,Optional] Optional array of parameter values to pass to the IL stream.
        /// </param>
        /// <param name="pILContext">
        /// [In] The stack frame context we are evaluating on.
        /// </param>
        /// <param name="Timeout">
        /// [In] This is the timeout to be used for potentially slow operations such as a
        /// function evaluation. This value is in milliseconds.
        /// </param>
        /// <param name="FuncEvalFlags">
        /// [In] Flags impacting how function evaluation requests are performed.
        /// </param>
        /// <param name="pCompletionRoutine">
        /// Routine to fire when the request is complete. If the request is successfully
        /// appended to the work list, this will always fire (including when the operation is
        /// canceled). This will never fire if appending the work item fails.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Execute(
            _In_ DkmWorkList* pWorkList,
            _In_opt_ DkmReadOnlyCollection<Evaluation::IL::DkmILParameterValue*>* pParameters,
            _In_ Evaluation::DkmILContext* pILContext,
            _In_ UINT32 Timeout,
            _In_ Evaluation::DkmFuncEvalFlags_t FuncEvalFlags,
            _In_ IDkmCompletionRoutine<Evaluation::DkmExecuteQueryAsyncResult>* pCompletionRoutine
            );

        /// <summary>
        /// Closes this compiled inspection query.  This should be called at the point in
        /// which the query will no longer execute.
        ///
        /// This API was introduced in Visual Studio 14 RTM (DkmApiVersion.VS14RTM).
        /// </summary>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Close(
            );

        #ifndef EXCLUDE_IDE_ONLY_APIS
        /// <summary>
        /// Resolves a DkmILFailureReason into an error message.  This is used to produce the
        /// error message for a condition breakpoint.
        ///
        /// Location constraint: API must be called from an IDE component (component level
        /// &gt; 100,000).
        ///
        /// This API was introduced in Visual Studio 14 RTM (DkmApiVersion.VS14RTM).
        /// </summary>
        /// <param name="ErrorCode">
        /// [In] Error code returned from execution of the IL stream.
        /// </param>
        /// <param name="ppErrorMessage">
        /// [Out] Human-readable error message describing the error.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ResolveILFailureReason(
            _In_ Evaluation::IL::DkmILFailureReason_t ErrorCode,
            _Deref_out_ DkmString** ppErrorMessage
            );
        #endif // #ifndef EXCLUDE_IDE_ONLY_APIS
    }; // end of DkmCompiledInspectionQuery

    // Indicates the type of inspection query. This is used to select a component to process
    // the query.
    struct DkmCompiledInspectionQueryKind
    {
        // Query is a DkmCompiledILInspectionQuery object.
        // DkmIL is defined as {7e76111e-089f-4ca9-baeb-7b5028eae246}.
        static const GUID DkmIL;
        // Query is a DkmCompiledClrInspectionQuery.
        // DkmClrIL is defined as {fec9d92e-b98a-42ef-b324-dc7a035dbcfd}.
        static const GUID DkmClrIL;
    };
    __declspec(selectany) const GUID DkmCompiledInspectionQueryKind::DkmIL = { 0x7e76111e, 0x89f, 0x4ca9, { 0xba, 0xeb, 0x7b, 0x50, 0x28, 0xea, 0xe2, 0x46 } };
    __declspec(selectany) const GUID DkmCompiledInspectionQueryKind::DkmClrIL = { 0xfec9d92e, 0xb98a, 0x42ef, { 0xb3, 0x24, 0xdc, 0x7a, 0x3, 0x5d, 0xbc, 0xfd } };

    // Represents the results of parsing one or more visualization files.
    //
    // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("3347c534-533c-275b-1828-d1dd73ba2fc0") DkmCompiledVisualizationData : public DkmDataContainer
    {
        // Use DkmCompiledVisualizationData::Create to create this object
        private: DkmCompiledVisualizationData();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmCompiledVisualizationData();
        // This object cannot be copied
        private: DkmCompiledVisualizationData& operator=(const DkmCompiledVisualizationData&);
        private: DkmCompiledVisualizationData(const DkmCompiledVisualizationData&);

        private: Evaluation::DkmLanguage* const m_pLanguage;
        private: Evaluation::DkmInspectionSession* const m_pInspectionSession;
        private: const GUID m_UniqueId;
        private: void* m__pExtendedData;

        // The language for which this visualization data applies to.
        //
        // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
        public: _Ret_ DECLSPEC_NOTHROW Evaluation::DkmLanguage* STDMETHODCALLTYPE Language(
            );

        // The inspection session which owns the lifetime of this object.
        //
        // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
        public: _Ret_ DECLSPEC_NOTHROW Evaluation::DkmInspectionSession* STDMETHODCALLTYPE InspectionSession(
            );

        // Guid which uniquely identifies this inspection session.
        //
        // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
        public: DECLSPEC_NOTHROW const GUID& STDMETHODCALLTYPE UniqueId(
            );

        /// <summary>
        /// Closes a DkmCompiledVisualizationData object instance. This will release any
        /// resources associated with this object across all components. This includes
        /// resources across computer or managed/native marshalling boundaries.
        ///
        /// DkmCompiledVisualizationData objects are automatically closed when their
        /// associated DkmInspectionSession object is closed.
        ///
        /// This method may only be called by the component which created the object.
        ///
        /// This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
        /// </summary>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Close(
            );

        /// <summary>
        /// Create a new DkmCompiledVisualizationData object instance. The caller is
        /// responsible for closing the created object after they are done.
        ///
        /// This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
        /// </summary>
        /// <param name="pLanguage">
        /// [In] The language for which this visualization data applies to.
        /// </param>
        /// <param name="pInspectionSession">
        /// [In] The inspection session which owns the lifetime of this object.
        /// </param>
        /// <param name="DataItem">
        /// [In] Data object to add to the new DkmCompiledVisualizationData instance.
        /// DkmDataItem::Null() in the case that the caller doesn't need to add a data item.
        /// </param>
        /// <param name="ppCreatedObject">
        /// [Out] Result of this method call.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ Evaluation::DkmLanguage* pLanguage,
            _In_ Evaluation::DkmInspectionSession* pInspectionSession,
            _In_ const DkmDataItem& DataItem,
            _Deref_out_ Evaluation::DkmCompiledVisualizationData** ppCreatedObject
            );

        #ifndef EXCLUDE_IDE_ONLY_APIS
        /// <summary>
        /// Compiles object visualization data from a human-readable form into a
        /// DkmCompiledVisualizationData object.
        ///
        /// Location constraint: API must be called from an IDE component (component level
        /// &gt; 100,000).
        ///
        /// This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
        /// </summary>
        /// <param name="VisualizationFiles">
        /// [In] List of full paths, on to the Visual Studio computer, that describe
        /// information to be used for object visualization. For C++, each item in the array
        /// should be the full path to a .natvis file you wish to use when formatting the
        /// results of the expression.
        ///
        /// The memory for the DkmArray members is allocated by the caller, and can be from
        /// any source (stack memory, static buffer, heap, etc). The implementation should
        /// not modify the members.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Initialize(
            _In_ const DkmArray<DkmString*>& VisualizationFiles
            );
        #endif // #ifndef EXCLUDE_IDE_ONLY_APIS
    }; // end of DkmCompiledVisualizationData

    // Specifies the relative priority of context-specific visualization data, relative to
    // the default visualization data.
    //
    // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
    DEFINE_SCOPED_ENUM(DkmCompiledVisualizationDataPriority)
    {
        // Indicates that context-specific visualization data will not be used.
        None = 0,
        // Indicates that context-specific visualization data will be used only as a fallback
        // when regular visualization data is not available.
        Low = 1,
        // Indicates that context-specific visualization data will be prioritized ahead of
        // default visualization data and that default visualization data will only be used
        // as a fallback when context-specific data is not available for the object being
        // visualized.
        High = 2,
        // Indicates that context-specific visualization data will be used exclusively and
        // that default visualization data will not be used at all.
        Exclusive = 3
    };

    // Data container used to hold custom data about an object that does not directly support
    // data containers.
    //
    // This API was introduced in Visual Studio 14 RTM (DkmApiVersion.VS14RTM).
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("f9f8611d-e2ca-35c0-696a-eb4f7f38ee13") DkmCustomDataContainer : public DkmDataContainer
    {
        // Use DkmCustomDataContainer::Create to create this object
        private: DkmCustomDataContainer();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmCustomDataContainer();
        // This object cannot be copied
        private: DkmCustomDataContainer& operator=(const DkmCustomDataContainer&);
        private: DkmCustomDataContainer(const DkmCustomDataContainer&);

        private: const GUID m_UniqueId;
        private: DkmProcess* const m_pProcess;
        private: void* m__pExtendedData;

        // Unique id of this data container.
        //
        // This API was introduced in Visual Studio 14 RTM (DkmApiVersion.VS14RTM).
        public: DECLSPEC_NOTHROW const GUID& STDMETHODCALLTYPE UniqueId(
            );

        // DkmProcess represents a target process which is being debugged. The debugger
        // debugs processes, so this is the basic unit of debugging. A DkmProcess can
        // represent a system process or a virtual process such as minidumps.
        //
        // This API was introduced in Visual Studio 14 RTM (DkmApiVersion.VS14RTM).
        public: _Ret_ DECLSPEC_NOTHROW DkmProcess* STDMETHODCALLTYPE Process(
            );

        /// <summary>
        /// Closes a DkmCustomDataContainer object instance. This will release any resources
        /// associated with this object across all components. This includes resources across
        /// computer or managed/native marshalling boundaries.
        ///
        /// DkmCustomDataContainer objects are automatically closed when their associated
        /// DkmProcess object is closed.
        ///
        /// This API was introduced in Visual Studio 14 RTM (DkmApiVersion.VS14RTM).
        /// </summary>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Close(
            );

        /// <summary>
        /// Create a new DkmCustomDataContainer object instance.
        ///
        /// This API was introduced in Visual Studio 14 RTM (DkmApiVersion.VS14RTM).
        /// </summary>
        /// <param name="pProcess">
        /// [In] DkmProcess represents a target process which is being debugged. The debugger
        /// debugs processes, so this is the basic unit of debugging. A DkmProcess can
        /// represent a system process or a virtual process such as minidumps.
        /// </param>
        /// <param name="DataItem">
        /// [In] Data object to add to the new DkmCustomDataContainer instance.
        /// DkmDataItem::Null() in the case that the caller doesn't need to add a data item.
        /// </param>
        /// <param name="ppCreatedObject">
        /// [Out] Result of this method call.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ DkmProcess* pProcess,
            _In_ const DkmDataItem& DataItem,
            _Deref_out_ Evaluation::DkmCustomDataContainer** ppCreatedObject
            );
    }; // end of DkmCustomDataContainer

    // Contains information about a custom UI visualizer which can be displayed for an
    // evaluation result.
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("4dfdfab9-7dc9-9b57-f046-463c417add1c") DkmCustomUIVisualizerInfo : public IUnknown
    {
        private: ___ReferenceCount_t m_ReferenceCount;
        private: DkmDispatcherObjectFlags_t m_ObjectFlags;
        private: const GUID* m_pTypeId;
        private: size_t m_ObjectGCHandle;
        // Use DkmCustomUIVisualizerInfo::Create to create this object
        private: DkmCustomUIVisualizerInfo();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmCustomUIVisualizerInfo();
        // This object cannot be copied
        private: DkmCustomUIVisualizerInfo& operator=(const DkmCustomUIVisualizerInfo&);
        private: DkmCustomUIVisualizerInfo(const DkmCustomUIVisualizerInfo&);

        // Contains additional fields of DkmCustomUIVisualizerInfo which were added after the
        // class was initally introduced.
        private: struct ___ExtendedData
        {
            ___ExtendedData();

            // [Optional] The full name of the UI-side class of the Custom Managed
            // Visualizer.
            OPTIONAL DkmString* const pUISideVisualizerTypeName;

            // [Optional] The full name of the UI-side visualizer assembly.
            OPTIONAL DkmString* const pUISideVisualizerAssemblyName;

            // The location of the UI-side visualizer assembly.
            const Evaluation::DkmClrCustomVisualizerAssemblyLocation_t UISideVisualizerAssemblyLocation;

            // [Optional] The full name of the the debuggee-side class of the Custom Managed
            // Visualizer.
            OPTIONAL DkmString* const pDebuggeeSideVisualizerTypeName;

            // [Optional] The full name of the debuggee-side visualizer assembly.
            OPTIONAL DkmString* const pDebuggeeSideVisualizerAssemblyName;
        };

        private: const UINT32 m_Id;
        private: DkmString* const m_pMenuName;
        private: OPTIONAL DkmString* const m_pDescription;
        private: DkmString* const m_pMetric;
        private: ___ExtendedData* const m__pExtendedData;

        // Unique id for this viewer.
        public: DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE Id(
            );

        // The text that will appear in the drop-down menu.
        public: _Ret_ DECLSPEC_NOTHROW DkmString* STDMETHODCALLTYPE MenuName(
            );

        // [Optional] The description of the custom viewer.
        public: _Ret_opt_ DECLSPEC_NOTHROW DkmString* STDMETHODCALLTYPE Description(
            );

        // The name of the EE metric under which viewer CLSID is stored.
        public: _Ret_ DECLSPEC_NOTHROW DkmString* STDMETHODCALLTYPE Metric(
            );

        // [Optional] The full name of the UI-side class of the Custom Managed Visualizer.
        //
        // This API was introduced in Visual Studio 14 RTM (DkmApiVersion.VS14RTM).
        public: _Ret_opt_ DECLSPEC_NOTHROW DkmString* STDMETHODCALLTYPE UISideVisualizerTypeName(
            );

        // [Optional] The full name of the UI-side visualizer assembly.
        //
        // This API was introduced in Visual Studio 14 RTM (DkmApiVersion.VS14RTM).
        public: _Ret_opt_ DECLSPEC_NOTHROW DkmString* STDMETHODCALLTYPE UISideVisualizerAssemblyName(
            );

        // The location of the UI-side visualizer assembly.
        //
        // This API was introduced in Visual Studio 14 RTM (DkmApiVersion.VS14RTM).
        public: DECLSPEC_NOTHROW Evaluation::DkmClrCustomVisualizerAssemblyLocation_t STDMETHODCALLTYPE UISideVisualizerAssemblyLocation(
            );

        // [Optional] The full name of the the debuggee-side class of the Custom Managed
        // Visualizer.
        //
        // This API was introduced in Visual Studio 14 RTM (DkmApiVersion.VS14RTM).
        public: _Ret_opt_ DECLSPEC_NOTHROW DkmString* STDMETHODCALLTYPE DebuggeeSideVisualizerTypeName(
            );

        // [Optional] The full name of the debuggee-side visualizer assembly.
        //
        // This API was introduced in Visual Studio 14 RTM (DkmApiVersion.VS14RTM).
        public: _Ret_opt_ DECLSPEC_NOTHROW DkmString* STDMETHODCALLTYPE DebuggeeSideVisualizerAssemblyName(
            );

        /// <summary>
        /// Create a new DkmCustomUIVisualizerInfo object instance.
        /// </summary>
        /// <param name="Id">
        /// [In] Unique id for this viewer.
        /// </param>
        /// <param name="pMenuName">
        /// [In] The text that will appear in the drop-down menu.
        /// </param>
        /// <param name="pDescription">
        /// [In,Optional] The description of the custom viewer.
        /// </param>
        /// <param name="pMetric">
        /// [In] The name of the EE metric under which viewer CLSID is stored.
        /// </param>
        /// <param name="ppCreatedObject">
        /// [Out] Result of this method call.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ UINT32 Id,
            _In_ DkmString* pMenuName,
            _In_opt_ DkmString* pDescription,
            _In_ DkmString* pMetric,
            _Deref_out_ Evaluation::DkmCustomUIVisualizerInfo** ppCreatedObject
            );

        /// <summary>
        /// Create a new DkmCustomUIVisualizerInfo object instance.
        ///
        /// This API was introduced in Visual Studio 14 RTM (DkmApiVersion.VS14RTM).
        /// </summary>
        /// <param name="Id">
        /// [In] Unique id for this viewer.
        /// </param>
        /// <param name="pMenuName">
        /// [In] The text that will appear in the drop-down menu.
        /// </param>
        /// <param name="pDescription">
        /// [In,Optional] The description of the custom viewer.
        /// </param>
        /// <param name="pMetric">
        /// [In] The name of the EE metric under which viewer CLSID is stored.
        /// </param>
        /// <param name="pUISideVisualizerTypeName">
        /// [In,Optional] The full name of the UI-side class of the Custom Managed
        /// Visualizer.
        /// </param>
        /// <param name="pUISideVisualizerAssemblyName">
        /// [In,Optional] The full name of the UI-side visualizer assembly.
        /// </param>
        /// <param name="UISideVisualizerAssemblyLocation">
        /// [In] The location of the UI-side visualizer assembly.
        /// </param>
        /// <param name="pDebuggeeSideVisualizerTypeName">
        /// [In,Optional] The full name of the the debuggee-side class of the Custom Managed
        /// Visualizer.
        /// </param>
        /// <param name="pDebuggeeSideVisualizerAssemblyName">
        /// [In,Optional] The full name of the debuggee-side visualizer assembly.
        /// </param>
        /// <param name="ppCreatedObject">
        /// [Out] Result of this method call.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ UINT32 Id,
            _In_ DkmString* pMenuName,
            _In_opt_ DkmString* pDescription,
            _In_ DkmString* pMetric,
            _In_opt_ DkmString* pUISideVisualizerTypeName,
            _In_opt_ DkmString* pUISideVisualizerAssemblyName,
            _In_ Evaluation::DkmClrCustomVisualizerAssemblyLocation_t UISideVisualizerAssemblyLocation,
            _In_opt_ DkmString* pDebuggeeSideVisualizerTypeName,
            _In_opt_ DkmString* pDebuggeeSideVisualizerAssemblyName,
            _Deref_out_ Evaluation::DkmCustomUIVisualizerInfo** ppCreatedObject
            );
    }; // end of DkmCustomUIVisualizerInfo

    // Represents an address in data.
    //
    // Derived classes: DkmGPUDataAddress
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("90d3adc4-f34b-4b9e-83d3-4ce6f6bcbde2") DkmDataAddress : public IUnknown
    {
        private: ___ReferenceCount_t m_ReferenceCount;
        private: DkmDispatcherObjectFlags_t m_ObjectFlags;
        private: const GUID* m_pTypeId;
        private: size_t m_ObjectGCHandle;
        // Use DkmDataAddress::Create to create this object
        private: DkmDataAddress();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmDataAddress();
        // This object cannot be copied
        private: DkmDataAddress& operator=(const DkmDataAddress&);
        private: DkmDataAddress(const DkmDataAddress&);

        private: DkmRuntimeInstance* const m_pRuntimeInstance;
        private: const UINT64 m_Value;
        private: OPTIONAL DkmInstructionAddress* const m_pInstructionAddress;
        private: void* m__pExtendedData;

        // The DkmRuntimeInstance class represents an execution environment which is loaded
        // into a DkmProcess and which contains code to be debugged.
        public: _Ret_ DECLSPEC_NOTHROW DkmRuntimeInstance* STDMETHODCALLTYPE RuntimeInstance(
            );

        // Data address.
        public: DECLSPEC_NOTHROW UINT64 STDMETHODCALLTYPE Value(
            );

        // [Optional] Set when the data address is an instruction address.
        public: _Ret_opt_ DECLSPEC_NOTHROW DkmInstructionAddress* STDMETHODCALLTYPE InstructionAddress(
            );

        // DkmProcess represents a target process which is being debugged. The debugger
        // debugs processes, so this is the basic unit of debugging. A DkmProcess can
        // represent a system process or a virtual process such as minidumps.
        public: _Ret_ DECLSPEC_NOTHROW DkmProcess* STDMETHODCALLTYPE Process(
            );

        /// <summary>
        /// Create a new DkmDataAddress object instance.
        /// </summary>
        /// <param name="pRuntimeInstance">
        /// [In] The DkmRuntimeInstance class represents an execution environment which is
        /// loaded into a DkmProcess and which contains code to be debugged.
        /// </param>
        /// <param name="Value">
        /// [In] Data address.
        /// </param>
        /// <param name="pInstructionAddress">
        /// [In,Optional] Set when the data address is an instruction address.
        /// </param>
        /// <param name="ppCreatedObject">
        /// [Out] Result of this method call.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ DkmRuntimeInstance* pRuntimeInstance,
            _In_ UINT64 Value,
            _In_opt_ DkmInstructionAddress* pInstructionAddress,
            _Deref_out_ Evaluation::DkmDataAddress** ppCreatedObject
            );
    }; // end of DkmDataAddress

    // Result of an asynchronous DkmInspectionContext.EvaluateExpression call.
    struct DkmEvaluateExpressionAsyncResult
    {
        // HRESULT code returned from the caller. This will be
        // DkmExceptionCode.COR_E_OPERATIONCANCELED (0x8013153B) if the operation was
        // canceled before processing was complete. E_PROCESS_DESTROYED indicates that the
        // process exited while attempting to evaluate.
        HRESULT ErrorCode;

        // Object containing the result of the evaluation. This object must be closed by the
        // caller when the caller is done with the object.
        Evaluation::DkmEvaluationResult* pResultObject;
    };

    // Result of an asynchronous DkmInspectionContext.EvaluateReturnValue call.
    struct DkmEvaluateReturnValueAsyncResult
    {
        // HRESULT code returned from the caller. This will be
        // DkmExceptionCode.COR_E_OPERATIONCANCELED (0x8013153B) if the operation was
        // canceled before processing was complete. E_PROCESS_DESTROYED indicates that the
        // process exited while attempting to evaluate.
        HRESULT ErrorCode;

        // [Optional] Object containing the result of the evaluation. This object must be
        // closed by the caller when the caller is done with the object. If not present, the
        // function had no return value.
        OPTIONAL Evaluation::DkmEvaluationResult* pResultObject;
    };

    // Result of an asynchronous DkmInspectionContext.EvaluateReturnValue2 call.
    struct DkmEvaluateReturnValueAsyncResult2
    {
        // HRESULT code returned from the caller. This will be
        // DkmExceptionCode.COR_E_OPERATIONCANCELED (0x8013153B) if the operation was
        // canceled before processing was complete. E_PROCESS_DESTROYED indicates that the
        // process exited while attempting to evaluate.
        HRESULT ErrorCode;

        // [Optional] Object containing the result of the evaluation. This object must be
        // closed by the caller when the caller is done with the object. If not present, the
        // function had no return value.
        OPTIONAL Evaluation::DkmEvaluationResult* pResultObject;
    };

    // Result of an asynchronous DkmEvaluationResultEnumContext.GetItems call.
    struct DkmEvaluationEnumAsyncResult
    {
        // HRESULT code returned from the caller. This will be
        // DkmExceptionCode.COR_E_OPERATIONCANCELED (0x8013153B) if the operation was
        // canceled before processing was complete.
        HRESULT ErrorCode;

        // The DkmEvaluationResult items to return. Each item must be closed by the caller
        // when the caller is done.
        DkmArray<Evaluation::DkmEvaluationResult*> Items;
    };

    // Flags which effect how an input expression should be parsed, compiled or displayed.
    DEFINE_SCOPED_ENUM(DkmEvaluationFlags)
    {
        // Input expression should be treated with the default semantics.
        None = 0x0,
        // The text is an expression (not a statement).
        TreatAsExpression = 0x1,
        // The text might contain function name/parameter signatures, and the expression is
        // to be parsed [and later evaluated] as an address.
        TreatFunctionAsAddress = 0x2,
        // The expression evaluator should not evaluate expressions which have side effects,
        // such as assignment statements. The debugger UI will use this flag when the
        // expression needs to be treated with care, such as in data tips. It is up to the
        // expression evaluator to decide what is considered a side effect for their
        // language.
        NoSideEffects = 0x4,
        // Expression evaluators should not attempt a func-eval. If a component mistakenly
        // issues a func-eval with this flag set then the func-eval will not be honored.
        NoFuncEval = 0x8,
        // The expression evaluation is happening in the context of design-time expression
        // evaluation (DTEE). In this scenario, the user enters text in the immediate window
        // in design mode.
        DesignTime = 0x10,
        // Allow the variables to be declared as part of the expression.
        AllowImplicitVariables = 0x20,
        // Force evaluation to occur now. Somebody is requesting it (like the user). Since
        // this flag only impacts the display of the expression, it may be varied between
        // compile and display.
        ForceEvaluationNow = 0x40,
        // Display the type members as is without the aid of a native visualizer.
        ShowValueRaw = 0x80,
        // If the runtime in question supports interpreted func-evaluation, this flag means
        // to perform real func-evaluations rather than interpreting any function calls in
        // the process.
        ForceRealFuncEval = 0x100,
        // Expression evaluators should hide non-public members.
        HideNonPublicMembers = 0x200,
        // Expression evaluators should call ToString method if flag is not present.
        NoToString = 0x400,
        // Indicates that the expression evaluator should not calculate the Value or
        // EditableValue properties of the returned DkmEvaluationResult.  This flag is used
        // as a performance optimization in situations where the value and editable value are
        // not used and do not need to be computed.  When this flag is set, the resultant
        // evaluation result, if successful, will have the empty string for its value and
        // editable value.
        NoFormatting = 0x800,
        // Indicates that when C++ debugging and natvis is used to visualize an object, that
        // the [Raw View] node should be omitted. This flag may be used as a performance
        // optimization in situations where it is not needed.
        NoRawView = 0x1000,
        // Formatter should display the result as a string without quotation marks.
        NoQuotes = 0x2000,
        // The result should be displayed in Dynamic View.
        DynamicView = 0x4000,
        // Only the members that contain the query result should be displayed.
        ResultsOnly = 0x8000,
        // The value will not not be expanded.  If calculating whether a value can be
        // expanded is expensive, this flag indicates that determining the expandability is
        // not required.
        NoExpansion = 0x10000
    };
    DEFINE_SCOPED_ENUM_FLAG_OPERATORS(DkmEvaluationFlags_t);

    // The formatted result of an evaluation, ready to be displayed in an expression
    // evaluation window.
    //
    // Derived classes: DkmSuccessEvaluationResult, DkmFailedEvaluationResult,
    // DkmIntermediateEvaluationResult
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("a017f790-1e94-73fc-a4b5-53278ec5548b") DkmEvaluationResult : public DkmDataContainer
    {
        // Use DkmEvaluationResult::Create to create this object
        private: DkmEvaluationResult();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmEvaluationResult();
        // This object cannot be copied
        private: DkmEvaluationResult& operator=(const DkmEvaluationResult&);
        private: DkmEvaluationResult(const DkmEvaluationResult&);

        // DkmEvaluationResult is an abstract base class. This enum indicates which derived
        // class this object is an instance of.
        public: FORWARD_DECLARE_SCOPED_ENUM(Tag);
        DEFINE_SCOPED_ENUM(Tag)
        {
        // Object is an instance of 'DkmSuccessEvaluationResult'.
        SuccessResult = 0,
        // Object is an instance of 'DkmFailedEvaluationResult'.
        FailedResult = 1,
        // Object is an instance of 'DkmIntermediateEvaluationResult'.
        IntermediateResult = 2
        };

        private: const Tag_t m_TagValue;
        private: Evaluation::DkmInspectionContext* const m_pInspectionContext;
        private: CallStack::DkmStackWalkFrame* const m_pStackFrame;
        private: DkmString* const m_pName;
        private: OPTIONAL DkmString* const m_pFullName;
        private: const GUID m_UniqueId;
        private: void* m__pExtendedData;

        // DkmEvaluationResult is an abstract base class. This enum indicates which derived
        // class this object is an instance of.
        public: DECLSPEC_NOTHROW Tag_t STDMETHODCALLTYPE TagValue(
            );

        // Inspection context used to create this evaluation result.
        public: _Ret_ DECLSPEC_NOTHROW Evaluation::DkmInspectionContext* STDMETHODCALLTYPE InspectionContext(
            );

        // The stack frame this expression result was created on.
        public: _Ret_ DECLSPEC_NOTHROW CallStack::DkmStackWalkFrame* STDMETHODCALLTYPE StackFrame(
            );

        // The name of the expression this result applies to.
        public: _Ret_ DECLSPEC_NOTHROW DkmString* STDMETHODCALLTYPE Name(
            );

        // [Optional] The full name of the expression this result applies to. This value is
        // used to allow child elements to be added to the watch window (Add Watch from the
        // context menu), and to refresh parts of the evaluation tree. As an example of how
        // FullName differs from name, the name of the 0th element of an array in C++ is
        // '[0]' while the full name would by 'myArrayVariable[0]'. For Visual Studio 14 and
        // later it's possible to calculate the full name later if needed. To do this, the
        // expression evaluator should create the DkmEvaluationResult with a null full name
        // and implement IDkmFullNameProvider.  Concord will then call
        // IDkmFullNameProvider.CalculateFullName to get the full name when needed in the UI.
        public: _Ret_opt_ DECLSPEC_NOTHROW DkmString* STDMETHODCALLTYPE FullName(
            );

        // Guid which uniquely identifies this evaluation result.
        public: DECLSPEC_NOTHROW const GUID& STDMETHODCALLTYPE UniqueId(
            );

        // Language used to perform inspections.
        public: _Ret_ DECLSPEC_NOTHROW Evaluation::DkmLanguage* STDMETHODCALLTYPE Language(
            );

        // The InspectionSession allows the various components which examine data in the
        // target process to store private data with the same lifetime. Inspection sessions
        // are closed when the user attempts to continue the process.
        public: _Ret_ DECLSPEC_NOTHROW Evaluation::DkmInspectionSession* STDMETHODCALLTYPE InspectionSession(
            );

        // Indicates which runtime monitor will be used to perform this evaluation.
        public: _Ret_ DECLSPEC_NOTHROW DkmRuntimeInstance* STDMETHODCALLTYPE RuntimeInstance(
            );

        /// <summary>
        /// Closes the evaluation result object to release the resources associated with it.
        /// This method must be invoked by the component which initiated the enumeration (ex:
        /// called DkmInspectionContext.EvaluateExpression,
        /// DkmEvaluationResultEnumContext.GetItems, etc).
        ///
        /// DkmEvaluationResult objects are automatically closed when their associated
        /// DkmInspectionSession object is closed.
        /// </summary>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Close(
            );

        /// <summary>
        /// Gets an enumeration context used to obtain the children of this evaluation
        /// result. This is used in all expression evaluation windows.
        ///
        /// This method will append a new work item to the specified work list, and return
        /// once the work item has been appended. The actual processing of the work item is
        /// asynchronous. The caller will be notified that the request is complete through
        /// the completion routine.
        ///
        /// Location constraint: IDE components may call this method regardless of what type
        /// of code is being debugged. This method is also currently supported for debug
        /// monitor components, when debugging code running under the CLR; however this
        /// functionality may be removed in a future version.
        /// </summary>
        /// <param name="pWorkList">
        /// WorkList to append the new work item to.
        /// </param>
        /// <param name="InitialRequestSize">
        /// [In] The initial number of children that the caller would like returned. This
        /// value can be zero if no children will be initially returned. This value may be
        /// larger than the number of children that this expression has, in which case all
        /// children should be returned. Very large or negative values should not be used as
        /// arrays can have extremely large sizes which would cause out-of-memory if all
        /// elements were requested.
        /// </param>
        /// <param name="pInspectionContext">
        /// [In] The inspection context to use for computing the children.  This may differ
        /// from the original inspection context with respect to settings, such as radix,
        /// evaluation flags, or timeout.
        /// </param>
        /// <param name="pCompletionRoutine">
        /// Routine to fire when the request is complete. If the request is successfully
        /// appended to the work list, this will always fire (including when the operation is
        /// canceled). This will never fire if appending the work item fails.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetChildren(
            _In_ DkmWorkList* pWorkList,
            _In_ UINT32 InitialRequestSize,
            _In_ Evaluation::DkmInspectionContext* pInspectionContext,
            _In_ IDkmCompletionRoutine<Evaluation::DkmGetChildrenAsyncResult>* pCompletionRoutine
            );

        /// <summary>
        /// Modifies the value of the given evaluation result (assumed to be non-read-only)
        /// to match the given string. This is used after the user edits a value in any of
        /// the evaluation windows.
        ///
        /// Location constraint: IDE components may call this method regardless of what type
        /// of code is being debugged. This method is also currently supported for debug
        /// monitor components, when debugging code running under the CLR; however this
        /// functionality may be removed in a future version.
        /// </summary>
        /// <param name="pValue">
        /// [In] Textual representation of value to assign to the evaluation result.
        /// </param>
        /// <param name="Timeout">
        /// [In] If a function evaluation is needed to assign the value, specifies the
        /// timeout to use.
        /// </param>
        /// <param name="ppErrorText">
        /// [Out,Optional] If the operation failed, this indicates the reason why. This value
        /// should be null if the operation succeeded. In native code, an S_OK return value
        /// is used when returning error text.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE SetValueAsString(
            _In_ DkmString* pValue,
            _In_ UINT32 Timeout,
            _Deref_out_opt_ DkmString** ppErrorText
            );

        /// <summary>
        /// This method is used for evaluation results that include
        /// DkmEvaluationResultFlags.RawString to obtain the the underlying string, with no
        /// enclosing quotes or escape sequences. This is method is invoked to display one of
        /// the various string visualizers in an expression evaluation window (click the
        /// magnifying glass icon).
        ///
        /// Location constraint: IDE components may call this method regardless of what type
        /// of code is being debugged. This method is also currently supported for debug
        /// monitor components, when debugging code running under the CLR; however this
        /// functionality may be removed in a future version.
        /// </summary>
        /// <param name="ppStringValue">
        /// [Out,Optional] The underlying string value.
        /// </param>
        /// <returns>
        /// S_OK is returned if *ppStringValue is non-NULL, S_FALSE is returned when
        /// *ppStringValue is NULL, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetUnderlyingString(
            _Deref_out_opt_ DkmString** ppStringValue
            );

        /// <summary>
        /// Creates an object id for this particular expression.
        ///
        /// Location constraint: IDE components may call this method regardless of what type
        /// of code is being debugged. This method is also currently supported for debug
        /// monitor components, when debugging code running under the CLR; however this
        /// functionality may be removed in a future version.
        /// </summary>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE CreateObjectId(
            );

        /// <summary>
        /// Destroys an object id for this particular expression.
        ///
        /// Location constraint: IDE components may call this method regardless of what type
        /// of code is being debugged. This method is also currently supported for debug
        /// monitor components, when debugging code running under the CLR; however this
        /// functionality may be removed in a future version.
        /// </summary>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE DestroyObjectId(
            );
    }; // end of DkmEvaluationResult

    // Specifies the access control level (public, private, etc) of the represented
    // field/method/property. This is principally used by the debugger UI to select icons in
    // the watch and other expression evaluation windows.
    DEFINE_SCOPED_ENUM(DkmEvaluationResultAccessType)
    {
        // Not applicable (the result of the expression is not a field of a class).
        None = 0,
        // Indicates that the result of the expression is a public field.
        Public = 1,
        // Indicates that the result of the expression is a private field.
        Private = 2,
        // Indicates that the result of the expression is a protected field.
        Protected = 3,
        // Indicates that the result of the expression is a final field.
        Final = 4,
        // Indicates that the result of the expression is an internal field.
        Internal = 5
    };

    // The category (ex: Data, Method, etc) of the underlying value represented by this
    // evaluation result. This is principally used by the debugger UI to select icons in the
    // watch and other expression evaluation windows.
    DEFINE_SCOPED_ENUM(DkmEvaluationResultCategory)
    {
        // Indicates that the evaluation result does not belong to a category listed in this
        // enumeration.
        Other = 0,
        // Indicates that the evaluation result represents data.
        Data = 1,
        // Indicates that the evaluation result represents a method.
        Method = 2,
        // Indicates that the evaluation result represents a event.
        Event = 3,
        // Indicates that the evaluation result represents a property.
        Property = 4,
        // Indicates that the evaluation result represents a class.
        Class = 5,
        // Indicates that the evaluation result represents an interface.
        Interface = 6,
        // Node in the evaluation result tree to access fields/properties/etc of a base
        // class.
        BaseClass = 7,
        // Node in the evaluation result tree to access fields/properties/etc of an inner
        // class.
        InnerClass = 8,
        // Node in the evaluation result tree to access fields/properties/etc of the most
        // derived class.
        MostDerivedClass = 9
    };

    // Context object used to enumerate child members of an evaluation result, or to
    // enumerate local variables from a stack frame. This is logically similar to an
    // enumerator, except that access to elements is index-based rather than sequential.
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("8a77c186-e7a6-31bc-b218-d7ea66212f8b") DkmEvaluationResultEnumContext : public DkmDataContainer
    {
        // Use DkmEvaluationResultEnumContext::Create to create this object
        private: DkmEvaluationResultEnumContext();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmEvaluationResultEnumContext();
        // This object cannot be copied
        private: DkmEvaluationResultEnumContext& operator=(const DkmEvaluationResultEnumContext&);
        private: DkmEvaluationResultEnumContext(const DkmEvaluationResultEnumContext&);

        private: const UINT32 m_Count;
        private: CallStack::DkmStackWalkFrame* const m_pStackFrame;
        private: Evaluation::DkmInspectionContext* const m_pInspectionContext;
        private: const GUID m_UniqueId;
        private: void* m__pExtendedData;

        // The number of items (DkmEvaluationResults) which can be obtained through this
        // DkmEvaluationResultEnumContext.
        public: DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE Count(
            );

        // The stack frame this expression result was created on.
        public: _Ret_ DECLSPEC_NOTHROW CallStack::DkmStackWalkFrame* STDMETHODCALLTYPE StackFrame(
            );

        // Inspection context used to create this enumeration context.
        public: _Ret_ DECLSPEC_NOTHROW Evaluation::DkmInspectionContext* STDMETHODCALLTYPE InspectionContext(
            );

        // Guid which uniquely identifies this enumeration context.
        public: DECLSPEC_NOTHROW const GUID& STDMETHODCALLTYPE UniqueId(
            );

        // Language used to perform inspections.
        public: _Ret_ DECLSPEC_NOTHROW Evaluation::DkmLanguage* STDMETHODCALLTYPE Language(
            );

        // The InspectionSession allows the various components which examine data in the
        // target process to store private data with the same lifetime. Inspection sessions
        // are closed when the user attempts to continue the process.
        public: _Ret_ DECLSPEC_NOTHROW Evaluation::DkmInspectionSession* STDMETHODCALLTYPE InspectionSession(
            );

        // Indicates which runtime monitor will be used to perform this evaluation.
        public: _Ret_ DECLSPEC_NOTHROW DkmRuntimeInstance* STDMETHODCALLTYPE RuntimeInstance(
            );

        /// <summary>
        /// Closes the enum context object to release the resources associated with it. This
        /// method must be invoked by the component which initiated the enumeration (ex:
        /// called DkmEvaluationResult.GetChildren or DkmInspectionContext.GetFrameLocals).
        ///
        /// DkmEvaluationResultEnumContext objects are automatically closed when their
        /// associated DkmInspectionSession object is closed.
        /// </summary>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Close(
            );

        /// <summary>
        /// Create a new DkmEvaluationResultEnumContext object instance.
        /// </summary>
        /// <param name="Count">
        /// [In] The number of items (DkmEvaluationResults) which can be obtained through
        /// this DkmEvaluationResultEnumContext.
        /// </param>
        /// <param name="pStackFrame">
        /// [In] The stack frame this expression result was created on.
        /// </param>
        /// <param name="pInspectionContext">
        /// [In] Inspection context used to create this enumeration context.
        /// </param>
        /// <param name="DataItem">
        /// [In] Data object to add to the new DkmEvaluationResultEnumContext instance.
        /// DkmDataItem::Null() in the case that the caller doesn't need to add a data item.
        /// </param>
        /// <param name="ppCreatedObject">
        /// [Out] Result of this method call.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ UINT32 Count,
            _In_ CallStack::DkmStackWalkFrame* pStackFrame,
            _In_ Evaluation::DkmInspectionContext* pInspectionContext,
            _In_ const DkmDataItem& DataItem,
            _Deref_out_ Evaluation::DkmEvaluationResultEnumContext** ppCreatedObject
            );

        /// <summary>
        /// Obtain DkmEvaluationResult items from this enumeration context. This is used to
        /// obtain local variables of a stack frame or child members from an evaluation
        /// result.
        ///
        /// This method will append a new work item to the specified work list, and return
        /// once the work item has been appended. The actual processing of the work item is
        /// asynchronous. The caller will be notified that the request is complete through
        /// the completion routine.
        ///
        /// Location constraint: IDE components may call this method regardless of what type
        /// of code is being debugged. This method is also currently supported for debug
        /// monitor components, when debugging code running under the CLR; however this
        /// functionality may be removed in a future version.
        /// </summary>
        /// <param name="pWorkList">
        /// WorkList to append the new work item to.
        /// </param>
        /// <param name="StartIndex">
        /// [In] The zero-based index of the first item to obtain.
        /// </param>
        /// <param name="Count">
        /// [In] The number of items to try and return. This value may be larger than the
        /// total number of remaining items, in which case all remaining items should be
        /// returned. Very large or negative values should not be used as arrays can have
        /// extremely large sizes which would cause out-of-memory if all elements were
        /// requested.
        /// </param>
        /// <param name="pCompletionRoutine">
        /// Routine to fire when the request is complete. If the request is successfully
        /// appended to the work list, this will always fire (including when the operation is
        /// canceled). This will never fire if appending the work item fails.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetItems(
            _In_ DkmWorkList* pWorkList,
            _In_ UINT32 StartIndex,
            _In_ UINT32 Count,
            _In_ IDkmCompletionRoutine<Evaluation::DkmEvaluationEnumAsyncResult>* pCompletionRoutine
            );
    }; // end of DkmEvaluationResultEnumContext

    // Flags which indicate attributes of an expression evaluation result.
    DEFINE_SCOPED_ENUM(DkmEvaluationResultFlags)
    {
        // No attribute flags are set.
        None = 0x0,
        // Indicates that the evaluation caused a side effect.
        SideEffect = 0x1,
        // Indicates that the result of this evaluation has children which can be accessed
        // through IDkmLanguageExpressionEvaluator.GetChildrenEnumContext.
        Expandable = 0x2,
        // Indicates that the result of the evaluation is a Boolean value.
        Boolean = 0x4,
        // If the Boolean flag is set, indicates that the result of the evaluation is "true",
        // as opposed to "false".
        BooleanTrue = 0x8,
        // Indicates that the result of the expression represents a conceptual string that
        // can be displayed in the string viewer.  The EE should be prepared to provide the
        // raw string via IDkmLanguageExpressionEvaluator::GetUnderlyingString().
        RawString = 0x10,
        // Indicates that the result of the expression evaluation is an address that can be
        // navigated to in the memory window.
        Address = 0x20,
        // Indicates that the result of the expression evaluation is read-only.  If false,
        // the user will be allowed to modify the value.
        ReadOnly = 0x40,
        // Indicates that the IL interpreter was used to get the result of the expression
        // evaluation.
        ILInterpreter = 0x80,
        // Indicates that the expression contains side effects that were discarded by the IL
        // interpreter.  To flush the side effects, the user should re-evaluate the
        // expression with real func-evals turned on.
        UnflushedSideEffects = 0x100,
        // Indicates that the expression has an object id associated with it.
        HasObjectId = 0x200,
        // Indicates that the expression can have an object id assigned to it.
        CanHaveObjectId = 0x400,
        // Indicates that the expression was rejected because it has a cross thread
        // dependency.
        CrossThreadDependency = 0x800,
        // Indicates that the value is invalid.
        Invalid = 0x1000,
        // Indicates that the object being inspected has a visualizer associated with it.
        // Currently, this flag is only implemented for C++ and is set whenever the result of
        // the evaluation has a natvis entry associated with it.
        Visualized = 0x2000,
        // Indicates that the Evaluation Results was marked as an Error but has an expandable
        // object. An example of this is the VB EE results that is an Exception object.
        ExpandableError = 0x4000,
        // Indicates that the function or property being evaluated threw an exception. Not
        // all expression evaluators set this flag.
        ExceptionThrown = 0x8000,
        // Indicates that this value is the return value of a function that was called during
        // the last step.
        ReturnValue = 0x10000,
        // Indicates that the type of the value is a built-in type.
        IsBuiltInType = 0x20000
    };
    DEFINE_SCOPED_ENUM_FLAG_OPERATORS(DkmEvaluationResultFlags_t);

    // If the result of an expression evaluation is data, indicates where the data is stored.
    // This is principally used by the debugger UI to select icons in the watch and other
    // expression evaluation windows.
    DEFINE_SCOPED_ENUM(DkmEvaluationResultStorageType)
    {
        // Indicates that the evaluation result does not have a storage type.
        None = 0,
        // Indicates that the evaluation result represents a global variable.
        Global = 1,
        // Indicates that the evaluation result represents a static variable.
        Static = 2,
        // Indicates that the evaluation result represents a register.
        Register = 3
    };

    // Type modifier flags (ex: const). These are principally used by the debugger UI to
    // select icons in the watch and other expression evaluation windows.
    DEFINE_SCOPED_ENUM(DkmEvaluationResultTypeModifierFlags)
    {
        // None.
        None = 0x0,
        // Indicates that the represented method/property is virtual.
        Virtual = 0x1,
        // Indicates that the represented value is a constant.
        Constant = 0x2,
        // Indicates that the represented method/class is synchronized.
        Synchronized = 0x4,
        // Indicates that the represented field is volatile.
        Volatile = 0x8
    };
    DEFINE_SCOPED_ENUM_FLAG_OPERATORS(DkmEvaluationResultTypeModifierFlags_t);

    // Result of an asynchronous DkmCompiledInspectionQuery.Execute call.
    struct DkmExecuteQueryAsyncResult
    {
        // HRESULT code returned from the caller. This will be
        // DkmExceptionCode.COR_E_OPERATIONCANCELED (0x8013153B) if the operation was
        // canceled before processing was complete.
        HRESULT ErrorCode;

        // Results of the evaluations. Each ILEvaluationResult object contains an index that
        // indicates which DkmILInstruction in the instructions parameter this result came
        // from. NOTE: some instructions will not return a result.
        DkmArray<Evaluation::IL::DkmILEvaluationResult*> Results;

        // If an expected error occurs evaluating the DkmIL, indicates the reason for the
        // failure.
        Evaluation::IL::DkmILFailureReason_t FailureReason;
    };

    // Base class for all expression value homes.
    //
    // Derived classes: DkmFakeValueHome, DkmPointerValueHome
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("b39a3432-f736-a099-a999-08b0bd3c13bf") DkmExpressionValueHome : public IUnknown
    {
        private: ___ReferenceCount_t m_ReferenceCount;
        private: DkmDispatcherObjectFlags_t m_ObjectFlags;
        private: const GUID* m_pTypeId;
        private: size_t m_ObjectGCHandle;
        // Use DkmExpressionValueHome::Create to create this object
        private: DkmExpressionValueHome();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmExpressionValueHome();
        // This object cannot be copied
        private: DkmExpressionValueHome& operator=(const DkmExpressionValueHome&);
        private: DkmExpressionValueHome(const DkmExpressionValueHome&);

        // DkmExpressionValueHome is an abstract base class. This enum indicates which
        // derived class this object is an instance of.
        public: FORWARD_DECLARE_SCOPED_ENUM(Tag);
        DEFINE_SCOPED_ENUM(Tag)
        {
        // Object is an instance of 'DkmPointerValueHome'.
        PointerValueHome = 0,
        // Object is an instance of 'DkmFakeValueHome'.
        FakeValueHome = 1
        };

        private: const Tag_t m_TagValue;
        private: void* m__pExtendedData;

        // DkmExpressionValueHome is an abstract base class. This enum indicates which
        // derived class this object is an instance of.
        public: DECLSPEC_NOTHROW Tag_t STDMETHODCALLTYPE TagValue(
            );
    }; // end of DkmExpressionValueHome

    // Flags impacting how function evaluation requests are performed.
    DEFINE_SCOPED_ENUM(DkmFuncEvalFlags)
    {
        // The function evaluation will continue past stopping events (ex: breakpoints will
        // be skipped) and will execute on a single thread (all other threads will be left
        // suspended).
        None = 0x0,
        // Indicates that stopping events should be processed normally during the function
        // evaluation. This option is used for function evaluation requests from the
        // immediate window. When this flag is missing, most stopping events are immediately
        // suppressed. This flag should only be enabled by the AD7 AL.
        AllowStoppingEvents = 0x1,
        // All threads should run during the function evaluation. If this flag is missing,
        // all threads other than the evaluating thread are suspended during the evaluation.
        // A component may use this flag in conjunction with the thread suspension API in
        // order to suspend a subset of the threads in the application. This flag may not be
        // used with function evaluation requests from the event thread.
        RunAllThreads = 0x2
    };
    DEFINE_SCOPED_ENUM_FLAG_OPERATORS(DkmFuncEvalFlags_t);

    // Result of an asynchronous DkmEvaluationResult.GetChildren call.
    struct DkmGetChildrenAsyncResult
    {
        // HRESULT code returned from the caller. This will be
        // DkmExceptionCode.COR_E_OPERATIONCANCELED (0x8013153B) if the operation was
        // canceled before processing was complete.
        HRESULT ErrorCode;

        // The initial children to return. Each child must be closed by the caller when the
        // caller is done.
        DkmArray<Evaluation::DkmEvaluationResult*> InitialChildren;

        // Context object used to enumerate the children, including the children already
        // returned via the InitialChildren parameter. This object must be closed by the
        // caller of this API when enumeration is complete.
        Evaluation::DkmEvaluationResultEnumContext* pEnumContext;
    };

    // Result of an asynchronous DkmInspectionContext.GetFrameArguments call.
    struct DkmGetFrameArgumentsAsyncResult
    {
        // HRESULT code returned from the caller. This will be
        // DkmExceptionCode.COR_E_OPERATIONCANCELED (0x8013153B) if the operation was
        // canceled before processing was complete.
        HRESULT ErrorCode;

        // DkmEvaluationResult for each argument. Each DkmEvaluationResult must be closed by
        // the caller when done with the object.
        DkmArray<Evaluation::DkmEvaluationResult*> Arguments;
    };

    // Result of an asynchronous DkmInspectionContext.GetFrameLocals call.
    struct DkmGetFrameLocalsAsyncResult
    {
        // HRESULT code returned from the caller. This will be
        // DkmExceptionCode.COR_E_OPERATIONCANCELED (0x8013153B) if the operation was
        // canceled before processing was complete.
        HRESULT ErrorCode;

        // Context object used to enumerate child members of an evaluation result, or to
        // enumerate local variables from a stack frame. This is logically similar to an
        // enumerator, except that access to elements is index-based rather than sequential.
        Evaluation::DkmEvaluationResultEnumContext* pEnumContext;
    };

    // Result of an asynchronous DkmInspectionContext.GetFrameName call.
    struct DkmGetFrameNameAsyncResult
    {
        // HRESULT code returned from the caller. This will be
        // DkmExceptionCode.COR_E_OPERATIONCANCELED (0x8013153B) if the operation was
        // canceled before processing was complete.
        HRESULT ErrorCode;

        // Language's representation of the name of this frame.
        DkmString* pFrameName;
    };

    // Result of an asynchronous DkmInspectionContext.GetFrameReturnType call.
    struct DkmGetFrameReturnTypeAsyncResult
    {
        // HRESULT code returned from the caller. This will be
        // DkmExceptionCode.COR_E_OPERATIONCANCELED (0x8013153B) if the operation was
        // canceled before processing was complete.
        HRESULT ErrorCode;

        // [Optional] Language's representation of the return type for this frame.
        OPTIONAL DkmString* pReturnType;
    };

    // Result of an asynchronous DkmLanguage.GetLanguageSettings call.
    struct DkmGetLanguageSettingsAsyncResult
    {
        // HRESULT code returned from the caller. This will be
        // DkmExceptionCode.COR_E_OPERATIONCANCELED (0x8013153B) if the operation was
        // canceled before processing was complete.
        HRESULT ErrorCode;

        // Pairing between the name of a setting and its value.
        DkmArray<DkmLanguageRegistrySetting*> Settings;
    };

    // Context to use for IL evaluation.
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("0791dedd-cf53-fb48-30ad-66b9bb8699a6") DkmILContext : public IUnknown
    {
        private: ___ReferenceCount_t m_ReferenceCount;
        private: DkmDispatcherObjectFlags_t m_ObjectFlags;
        private: const GUID* m_pTypeId;
        private: size_t m_ObjectGCHandle;
        // Use DkmILContext::Create to create this object
        private: DkmILContext();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmILContext();
        // This object cannot be copied
        private: DkmILContext& operator=(const DkmILContext&);
        private: DkmILContext(const DkmILContext&);

        // Optional section that describes an alternate thread to use for evaluation.
        public: struct ThreadOverride
        {
            // Global-to-kernel thread ID to use for evaluation.
            UINT64 ThreadId;
        };

        // Contains additional fields of DkmILContext which were added after the class was
        // initally introduced.
        private: struct ___ExtendedData
        {
            ___ExtendedData();

            // [Optional] Custom data to associate with this DkmILContext.  This is used to
            // convey information associated with a particular execution of a
            // DkmCompiledInspectionQuery.
            OPTIONAL Evaluation::DkmCustomDataContainer* const pDataContainer;
        };

        private: OPTIONAL const Evaluation::DkmILContext::ThreadOverride* const m_pThreadOverride;
        private: CallStack::DkmStackWalkFrame* const m_pStackFrame;
        private: ___ExtendedData* const m__pExtendedData;

        // [Optional] Optional section that describes an alternate thread to use for
        // evaluation.
        public: _Ret_opt_ DECLSPEC_NOTHROW const Evaluation::DkmILContext::ThreadOverride* STDMETHODCALLTYPE ThreadOverridePart(
            );

        // Stack frame to use for evaluation.  The specific thread to use may be overridden
        // using the optional ThreadOverride part.
        public: _Ret_ DECLSPEC_NOTHROW CallStack::DkmStackWalkFrame* STDMETHODCALLTYPE StackFrame(
            );

        // [Optional] Custom data to associate with this DkmILContext.  This is used to
        // convey information associated with a particular execution of a
        // DkmCompiledInspectionQuery.
        //
        // This API was introduced in Visual Studio 14 RTM (DkmApiVersion.VS14RTM).
        public: _Ret_opt_ DECLSPEC_NOTHROW Evaluation::DkmCustomDataContainer* STDMETHODCALLTYPE DataContainer(
            );

        /// <summary>
        /// Create a new DkmILContext object instance.
        /// </summary>
        /// <param name="pStackFrame">
        /// [In] Stack frame to use for evaluation.  The specific thread to use may be
        /// overridden using the optional ThreadOverride part.
        /// </param>
        /// <param name="pThreadOverride">
        /// [In,Optional] Optional section that describes an alternate thread to use for
        /// evaluation.
        /// </param>
        /// <param name="ppCreatedObject">
        /// [Out] Result of this method call.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ CallStack::DkmStackWalkFrame* pStackFrame,
            _In_opt_ const Evaluation::DkmILContext::ThreadOverride* pThreadOverride,
            _Deref_out_ Evaluation::DkmILContext** ppCreatedObject
            );

        /// <summary>
        /// Create a new DkmILContext object instance.
        ///
        /// This API was introduced in Visual Studio 14 RTM (DkmApiVersion.VS14RTM).
        /// </summary>
        /// <param name="pStackFrame">
        /// [In] Stack frame to use for evaluation.  The specific thread to use may be
        /// overridden using the optional ThreadOverride part.
        /// </param>
        /// <param name="pDataContainer">
        /// [In,Optional] Custom data to associate with this DkmILContext.  This is used to
        /// convey information associated with a particular execution of a
        /// DkmCompiledInspectionQuery.
        /// </param>
        /// <param name="pThreadOverride">
        /// [In,Optional] Optional section that describes an alternate thread to use for
        /// evaluation.
        /// </param>
        /// <param name="ppCreatedObject">
        /// [Out] Result of this method call.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ CallStack::DkmStackWalkFrame* pStackFrame,
            _In_opt_ Evaluation::DkmCustomDataContainer* pDataContainer,
            _In_opt_ const Evaluation::DkmILContext::ThreadOverride* pThreadOverride,
            _Deref_out_ Evaluation::DkmILContext** ppCreatedObject
            );

        /// <summary>
        /// Closes this compiled inspection query.  This should be called after executing the
        /// query, when data associated with the context is no longer needed.
        ///
        /// This API was introduced in Visual Studio 14 RTM (DkmApiVersion.VS14RTM).
        /// </summary>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Close(
            );
    }; // end of DkmILContext

    // Options and target context to use while performing the inspection operation.
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("0807c826-3338-dd99-2f3a-202ba8fb9da7") DkmInspectionContext : public IUnknown
    {
        private: ___ReferenceCount_t m_ReferenceCount;
        private: DkmDispatcherObjectFlags_t m_ObjectFlags;
        private: const GUID* m_pTypeId;
        private: size_t m_ObjectGCHandle;
        // Use DkmInspectionContext::Create to create this object
        private: DkmInspectionContext();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmInspectionContext();
        // This object cannot be copied
        private: DkmInspectionContext& operator=(const DkmInspectionContext&);
        private: DkmInspectionContext(const DkmInspectionContext&);

        // Contains additional fields of DkmInspectionContext which were added after the
        // class was initally introduced.
        private: struct ___ExtendedData
        {
            ___ExtendedData();

            // [Optional] Specifies an optional list of full paths to visualization files to
            // use, in addition to the default files from the users profile directory and the
            // Visual Studio installation directory.  Precedence between conflicting
            // visualizers in these paths, relative to the standard paths are resolved
            // according to the information specified in
            // 'AdditionalVisualizationDataPriority'.
            OPTIONAL Evaluation::DkmCompiledVisualizationData* const pAdditionalVisualizationData;

            // If AdditionalVisualizationData is specified, specifies the priority of such
            // data, relative to the default search locations.
            const Evaluation::DkmCompiledVisualizationDataPriority_t AdditionalVisualizationDataPriority;

            // [Optional] Raw representation of values for $ReturnValue1, $ReturnValue2, etc.
            OPTIONAL DkmReadOnlyCollection<Evaluation::DkmRawReturnValueContainer*>* const pReturnValues;
        };

        private: Evaluation::DkmInspectionSession* const m_pInspectionSession;
        private: DkmRuntimeInstance* const m_pRuntimeInstance;
        private: DkmThread* const m_pThread;
        private: const UINT32 m_Timeout;
        private: const Evaluation::DkmEvaluationFlags_t m_EvaluationFlags;
        private: const Evaluation::DkmFuncEvalFlags_t m_FuncEvalFlags;
        private: const UINT32 m_Radix;
        private: Evaluation::DkmLanguage* const m_pLanguage;
        private: OPTIONAL Evaluation::DkmRawReturnValue* const m_pReturnValue;
        private: ___ExtendedData* const m__pExtendedData;

        // The InspectionSession allows the various components which examine data in the
        // target process to store private data with the same lifetime. Inspection sessions
        // are closed when the user attempts to continue the process.
        public: _Ret_ DECLSPEC_NOTHROW Evaluation::DkmInspectionSession* STDMETHODCALLTYPE InspectionSession(
            );

        // Indicates which runtime monitor will be used to perform this evaluation.
        public: _Ret_ DECLSPEC_NOTHROW DkmRuntimeInstance* STDMETHODCALLTYPE RuntimeInstance(
            );

        // The thread being examined.
        public: _Ret_ DECLSPEC_NOTHROW DkmThread* STDMETHODCALLTYPE Thread(
            );

        // This is the timeout to be used for potentially slow operations such as a function
        // evaluation. This value is in milliseconds.
        public: DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE Timeout(
            );

        // Flags which effect how an input expression should be parsed, compiled or
        // displayed.
        public: DECLSPEC_NOTHROW Evaluation::DkmEvaluationFlags_t STDMETHODCALLTYPE EvaluationFlags(
            );

        // Flags impacting how function evaluation requests are performed.
        public: DECLSPEC_NOTHROW Evaluation::DkmFuncEvalFlags_t STDMETHODCALLTYPE FuncEvalFlags(
            );

        // The radix to use when formatting integer data. Currently supported values are '16'
        // and '10'.
        public: DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE Radix(
            );

        // Language used to perform inspections.
        public: _Ret_ DECLSPEC_NOTHROW Evaluation::DkmLanguage* STDMETHODCALLTYPE Language(
            );

        // [Optional] Deprecated - do not use.  Instead, components should use the
        // ReturnValues property as the list of all return values and set $ReturnValue to
        // represent the last return value item in the list.
        public: _Ret_opt_ DECLSPEC_NOTHROW Evaluation::DkmRawReturnValue* STDMETHODCALLTYPE ReturnValue(
            );

        // [Optional] Specifies an optional list of full paths to visualization files to use,
        // in addition to the default files from the users profile directory and the Visual
        // Studio installation directory.  Precedence between conflicting visualizers in
        // these paths, relative to the standard paths are resolved according to the
        // information specified in 'AdditionalVisualizationDataPriority'.
        //
        // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
        public: _Ret_opt_ DECLSPEC_NOTHROW Evaluation::DkmCompiledVisualizationData* STDMETHODCALLTYPE AdditionalVisualizationData(
            );

        // If AdditionalVisualizationData is specified, specifies the priority of such data,
        // relative to the default search locations.
        //
        // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
        public: DECLSPEC_NOTHROW Evaluation::DkmCompiledVisualizationDataPriority_t STDMETHODCALLTYPE AdditionalVisualizationDataPriority(
            );

        // [Optional] Raw representation of values for $ReturnValue1, $ReturnValue2, etc.
        //
        // This API was introduced in Visual Studio 14 RTM (DkmApiVersion.VS14RTM).
        public: _Ret_opt_ DECLSPEC_NOTHROW DkmReadOnlyCollection<Evaluation::DkmRawReturnValueContainer*>* STDMETHODCALLTYPE ReturnValues(
            );

        /// <summary>
        /// Create a new DkmInspectionContext object instance.
        /// </summary>
        /// <param name="pInspectionSession">
        /// [In] The InspectionSession allows the various components which examine data in
        /// the target process to store private data with the same lifetime. Inspection
        /// sessions are closed when the user attempts to continue the process.
        /// </param>
        /// <param name="pRuntimeInstance">
        /// [In] Indicates which runtime monitor will be used to perform this evaluation.
        /// </param>
        /// <param name="pThread">
        /// [In] The thread being examined.
        /// </param>
        /// <param name="Timeout">
        /// [In] This is the timeout to be used for potentially slow operations such as a
        /// function evaluation. This value is in milliseconds.
        /// </param>
        /// <param name="EvaluationFlags">
        /// [In] Flags which effect how an input expression should be parsed, compiled or
        /// displayed.
        /// </param>
        /// <param name="FuncEvalFlags">
        /// [In] Flags impacting how function evaluation requests are performed.
        /// </param>
        /// <param name="Radix">
        /// [In] The radix to use when formatting integer data. Currently supported values
        /// are '16' and '10'.
        /// </param>
        /// <param name="pLanguage">
        /// [In] Language used to perform inspections.
        /// </param>
        /// <param name="pReturnValue">
        /// [In,Optional] Deprecated - do not use.  Instead, components should use the
        /// ReturnValues property as the list of all return values and set $ReturnValue to
        /// represent the last return value item in the list.
        /// </param>
        /// <param name="ppCreatedObject">
        /// [Out] Result of this method call.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ Evaluation::DkmInspectionSession* pInspectionSession,
            _In_ DkmRuntimeInstance* pRuntimeInstance,
            _In_ DkmThread* pThread,
            _In_ UINT32 Timeout,
            _In_ Evaluation::DkmEvaluationFlags_t EvaluationFlags,
            _In_ Evaluation::DkmFuncEvalFlags_t FuncEvalFlags,
            _In_ UINT32 Radix,
            _In_ Evaluation::DkmLanguage* pLanguage,
            _In_opt_ Evaluation::DkmRawReturnValue* pReturnValue,
            _Deref_out_ Evaluation::DkmInspectionContext** ppCreatedObject
            );

        /// <summary>
        /// Create a new DkmInspectionContext object instance.
        ///
        /// This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
        /// </summary>
        /// <param name="pInspectionSession">
        /// [In] The InspectionSession allows the various components which examine data in
        /// the target process to store private data with the same lifetime. Inspection
        /// sessions are closed when the user attempts to continue the process.
        /// </param>
        /// <param name="pRuntimeInstance">
        /// [In] Indicates which runtime monitor will be used to perform this evaluation.
        /// </param>
        /// <param name="pThread">
        /// [In] The thread being examined.
        /// </param>
        /// <param name="Timeout">
        /// [In] This is the timeout to be used for potentially slow operations such as a
        /// function evaluation. This value is in milliseconds.
        /// </param>
        /// <param name="EvaluationFlags">
        /// [In] Flags which effect how an input expression should be parsed, compiled or
        /// displayed.
        /// </param>
        /// <param name="FuncEvalFlags">
        /// [In] Flags impacting how function evaluation requests are performed.
        /// </param>
        /// <param name="Radix">
        /// [In] The radix to use when formatting integer data. Currently supported values
        /// are '16' and '10'.
        /// </param>
        /// <param name="pLanguage">
        /// [In] Language used to perform inspections.
        /// </param>
        /// <param name="pReturnValue">
        /// [In,Optional] Deprecated - do not use.  Instead, components should use the
        /// ReturnValues property as the list of all return values and set $ReturnValue to
        /// represent the last return value item in the list.
        /// </param>
        /// <param name="pAdditionalVisualizationData">
        /// [In,Optional] Specifies an optional list of full paths to visualization files to
        /// use, in addition to the default files from the users profile directory and the
        /// Visual Studio installation directory.  Precedence between conflicting visualizers
        /// in these paths, relative to the standard paths are resolved according to the
        /// information specified in 'AdditionalVisualizationDataPriority'.
        /// </param>
        /// <param name="AdditionalVisualizationDataPriority">
        /// [In] If AdditionalVisualizationData is specified, specifies the priority of such
        /// data, relative to the default search locations.
        /// </param>
        /// <param name="ppCreatedObject">
        /// [Out] Result of this method call.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ Evaluation::DkmInspectionSession* pInspectionSession,
            _In_ DkmRuntimeInstance* pRuntimeInstance,
            _In_ DkmThread* pThread,
            _In_ UINT32 Timeout,
            _In_ Evaluation::DkmEvaluationFlags_t EvaluationFlags,
            _In_ Evaluation::DkmFuncEvalFlags_t FuncEvalFlags,
            _In_ UINT32 Radix,
            _In_ Evaluation::DkmLanguage* pLanguage,
            _In_opt_ Evaluation::DkmRawReturnValue* pReturnValue,
            _In_opt_ Evaluation::DkmCompiledVisualizationData* pAdditionalVisualizationData,
            _In_ Evaluation::DkmCompiledVisualizationDataPriority_t AdditionalVisualizationDataPriority,
            _Deref_out_ Evaluation::DkmInspectionContext** ppCreatedObject
            );

        /// <summary>
        /// Create a new DkmInspectionContext object instance.
        ///
        /// This API was introduced in Visual Studio 14 RTM (DkmApiVersion.VS14RTM).
        /// </summary>
        /// <param name="pInspectionSession">
        /// [In] The InspectionSession allows the various components which examine data in
        /// the target process to store private data with the same lifetime. Inspection
        /// sessions are closed when the user attempts to continue the process.
        /// </param>
        /// <param name="pRuntimeInstance">
        /// [In] Indicates which runtime monitor will be used to perform this evaluation.
        /// </param>
        /// <param name="pThread">
        /// [In] The thread being examined.
        /// </param>
        /// <param name="Timeout">
        /// [In] This is the timeout to be used for potentially slow operations such as a
        /// function evaluation. This value is in milliseconds.
        /// </param>
        /// <param name="EvaluationFlags">
        /// [In] Flags which effect how an input expression should be parsed, compiled or
        /// displayed.
        /// </param>
        /// <param name="FuncEvalFlags">
        /// [In] Flags impacting how function evaluation requests are performed.
        /// </param>
        /// <param name="Radix">
        /// [In] The radix to use when formatting integer data. Currently supported values
        /// are '16' and '10'.
        /// </param>
        /// <param name="pLanguage">
        /// [In] Language used to perform inspections.
        /// </param>
        /// <param name="pReturnValue">
        /// [In,Optional] Deprecated - do not use.  Instead, components should use the
        /// ReturnValues property as the list of all return values and set $ReturnValue to
        /// represent the last return value item in the list.
        /// </param>
        /// <param name="pAdditionalVisualizationData">
        /// [In,Optional] Specifies an optional list of full paths to visualization files to
        /// use, in addition to the default files from the users profile directory and the
        /// Visual Studio installation directory.  Precedence between conflicting visualizers
        /// in these paths, relative to the standard paths are resolved according to the
        /// information specified in 'AdditionalVisualizationDataPriority'.
        /// </param>
        /// <param name="AdditionalVisualizationDataPriority">
        /// [In] If AdditionalVisualizationData is specified, specifies the priority of such
        /// data, relative to the default search locations.
        /// </param>
        /// <param name="pReturnValues">
        /// [In,Optional] Raw representation of values for $ReturnValue1, $ReturnValue2, etc.
        /// </param>
        /// <param name="ppCreatedObject">
        /// [Out] Result of this method call.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ Evaluation::DkmInspectionSession* pInspectionSession,
            _In_ DkmRuntimeInstance* pRuntimeInstance,
            _In_ DkmThread* pThread,
            _In_ UINT32 Timeout,
            _In_ Evaluation::DkmEvaluationFlags_t EvaluationFlags,
            _In_ Evaluation::DkmFuncEvalFlags_t FuncEvalFlags,
            _In_ UINT32 Radix,
            _In_ Evaluation::DkmLanguage* pLanguage,
            _In_opt_ Evaluation::DkmRawReturnValue* pReturnValue,
            _In_opt_ Evaluation::DkmCompiledVisualizationData* pAdditionalVisualizationData,
            _In_ Evaluation::DkmCompiledVisualizationDataPriority_t AdditionalVisualizationDataPriority,
            _In_opt_ DkmReadOnlyCollection<Evaluation::DkmRawReturnValueContainer*>* pReturnValues,
            _Deref_out_ Evaluation::DkmInspectionContext** ppCreatedObject
            );

        #ifndef EXCLUDE_IDE_ONLY_APIS
        /// <summary>
        /// Bind the input expression and evaluate it. Then format the resulting value for
        /// display in the debugger. This is used for data tips, the watch windows, the
        /// immediate window, etc.
        ///
        /// This method will append a new work item to the specified work list, and return
        /// once the work item has been appended. The actual processing of the work item is
        /// asynchronous. The caller will be notified that the request is complete through
        /// the completion routine.
        ///
        /// Location constraint: API must be called from an IDE component (component level
        /// &gt; 100,000).
        /// </summary>
        /// <param name="pWorkList">
        /// WorkList to append the new work item to.
        /// </param>
        /// <param name="pThreads">
        /// [In] The compute threads to use when executing the query.
        /// </param>
        /// <param name="pStackFrame">
        /// [In] Stack frame to match on compute threads.
        /// </param>
        /// <param name="pExpression">
        /// [In] Expression to evaluate.
        /// </param>
        /// <param name="pCompletionRoutine">
        /// Routine to fire when the request is complete. If the request is successfully
        /// appended to the work list, this will always fire (including when the operation is
        /// canceled). This will never fire if appending the work item fails.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE EvaluateExpressionOnThreads(
            _In_ DkmWorkList* pWorkList,
            _In_ DkmReadOnlyCollection<UINT64>* pThreads,
            _In_ CallStack::DkmStackWalkFrame* pStackFrame,
            _In_ Evaluation::DkmLanguageExpression* pExpression,
            _In_ IDkmCompletionRoutine<Evaluation::Group::DkmEvaluateExpressionOnThreadsAsyncResult>* pCompletionRoutine
            );
        #endif // #ifndef EXCLUDE_IDE_ONLY_APIS

        /// <summary>
        /// Bind the input expression and evaluate it. Then format the resulting value for
        /// display in the debugger. This is used for data tips, the watch windows, the
        /// immediate window, etc.
        ///
        /// This method will append a new work item to the specified work list, and return
        /// once the work item has been appended. The actual processing of the work item is
        /// asynchronous. The caller will be notified that the request is complete through
        /// the completion routine.
        ///
        /// Location constraint: IDE components may call this method regardless of what type
        /// of code is being debugged. This method is also currently supported for debug
        /// monitor components, when debugging code running under the CLR; however this
        /// functionality may be removed in a future version.
        /// </summary>
        /// <param name="pWorkList">
        /// WorkList to append the new work item to.
        /// </param>
        /// <param name="pExpression">
        /// [In] DkmLanguageExpression represents an expression to be parsed and evaluated by
        /// an expression evaluator.
        /// </param>
        /// <param name="pStackFrame">
        /// [In] Stack frame to evaluate the expression in.
        /// </param>
        /// <param name="pCompletionRoutine">
        /// Routine to fire when the request is complete. If the request is successfully
        /// appended to the work list, this will always fire (including when the operation is
        /// canceled). This will never fire if appending the work item fails.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE EvaluateExpression(
            _In_ DkmWorkList* pWorkList,
            _In_ Evaluation::DkmLanguageExpression* pExpression,
            _In_ CallStack::DkmStackWalkFrame* pStackFrame,
            _In_ IDkmCompletionRoutine<Evaluation::DkmEvaluateExpressionAsyncResult>* pCompletionRoutine
            );

        /// <summary>
        /// Gets an enumeration context used to obtain the local variables of this stack
        /// frame. This is used in computing the locals window.
        ///
        /// This method will append a new work item to the specified work list, and return
        /// once the work item has been appended. The actual processing of the work item is
        /// asynchronous. The caller will be notified that the request is complete through
        /// the completion routine.
        ///
        /// Location constraint: IDE components may call this method regardless of what type
        /// of code is being debugged. This method is also currently supported for debug
        /// monitor components, when debugging code running under the CLR; however this
        /// functionality may be removed in a future version.
        /// </summary>
        /// <param name="pWorkList">
        /// WorkList to append the new work item to.
        /// </param>
        /// <param name="pStackFrame">
        /// [In] Stack frame to evaluate the expression in.
        /// </param>
        /// <param name="pCompletionRoutine">
        /// Routine to fire when the request is complete. If the request is successfully
        /// appended to the work list, this will always fire (including when the operation is
        /// canceled). This will never fire if appending the work item fails.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetFrameLocals(
            _In_ DkmWorkList* pWorkList,
            _In_ CallStack::DkmStackWalkFrame* pStackFrame,
            _In_ IDkmCompletionRoutine<Evaluation::DkmGetFrameLocalsAsyncResult>* pCompletionRoutine
            );

        /// <summary>
        /// Provides information on the arguments of a stack frame. This is currently only
        /// exposed through the VS automation model (EnvDTE.StackFrame.Arguments).
        ///
        /// This method will append a new work item to the specified work list, and return
        /// once the work item has been appended. The actual processing of the work item is
        /// asynchronous. The caller will be notified that the request is complete through
        /// the completion routine.
        ///
        /// Location constraint: IDE components may call this method regardless of what type
        /// of code is being debugged. This method is also currently supported for debug
        /// monitor components, when debugging code running under the CLR; however this
        /// functionality may be removed in a future version.
        /// </summary>
        /// <param name="pWorkList">
        /// WorkList to append the new work item to.
        /// </param>
        /// <param name="pFrame">
        /// [In] Walked frames which the evaluator is requested to describe.
        /// </param>
        /// <param name="pCompletionRoutine">
        /// Routine to fire when the request is complete. If the request is successfully
        /// appended to the work list, this will always fire (including when the operation is
        /// canceled). This will never fire if appending the work item fails.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetFrameArguments(
            _In_ DkmWorkList* pWorkList,
            _In_ CallStack::DkmStackWalkFrame* pFrame,
            _In_ IDkmCompletionRoutine<Evaluation::DkmGetFrameArgumentsAsyncResult>* pCompletionRoutine
            );

        /// <summary>
        /// Provides a text representation for a stack frame. This is used when building the
        /// formatted call stack.
        ///
        /// This method will append a new work item to the specified work list, and return
        /// once the work item has been appended. The actual processing of the work item is
        /// asynchronous. The caller will be notified that the request is complete through
        /// the completion routine.
        ///
        /// Location constraint: IDE components may call this method regardless of what type
        /// of code is being debugged. This method is also currently supported for debug
        /// monitor components, when debugging code running under the CLR; however this
        /// functionality may be removed in a future version.
        /// </summary>
        /// <param name="pWorkList">
        /// WorkList to append the new work item to.
        /// </param>
        /// <param name="pFrame">
        /// [In] Walked frames which the evaluator is requested to describe.
        /// </param>
        /// <param name="ArgumentFlags">
        /// [In] Flags to indicate what information about the arguments should be included in
        /// the frame name.
        /// </param>
        /// <param name="pCompletionRoutine">
        /// Routine to fire when the request is complete. If the request is successfully
        /// appended to the work list, this will always fire (including when the operation is
        /// canceled). This will never fire if appending the work item fails.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetFrameName(
            _In_ DkmWorkList* pWorkList,
            _In_ CallStack::DkmStackWalkFrame* pFrame,
            _In_ Evaluation::DkmVariableInfoFlags_t ArgumentFlags,
            _In_ IDkmCompletionRoutine<Evaluation::DkmGetFrameNameAsyncResult>* pCompletionRoutine
            );

        #ifndef EXCLUDE_IDE_ONLY_APIS
        /// <summary>
        /// Provides a text representation of the return type for one or more stack frame.
        /// This is currently only exposed through the VS automation model
        /// (EnvDTE.StackFrame.ReturnType).
        ///
        /// This method will append a new work item to the specified work list, and return
        /// once the work item has been appended. The actual processing of the work item is
        /// asynchronous. The caller will be notified that the request is complete through
        /// the completion routine.
        ///
        /// Location constraint: API must be called from an IDE component (component level
        /// &gt; 100,000).
        /// </summary>
        /// <param name="pWorkList">
        /// WorkList to append the new work item to.
        /// </param>
        /// <param name="pFrame">
        /// [In] Walked frames which the evaluator is requested to describe.
        /// </param>
        /// <param name="pCompletionRoutine">
        /// Routine to fire when the request is complete. If the request is successfully
        /// appended to the work list, this will always fire (including when the operation is
        /// canceled). This will never fire if appending the work item fails.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetFrameReturnType(
            _In_ DkmWorkList* pWorkList,
            _In_ CallStack::DkmStackWalkFrame* pFrame,
            _In_ IDkmCompletionRoutine<Evaluation::DkmGetFrameReturnTypeAsyncResult>* pCompletionRoutine
            );
        #endif // #ifndef EXCLUDE_IDE_ONLY_APIS

        #ifndef EXCLUDE_IDE_ONLY_APIS
        /// <summary>
        /// Evaluates and formats a given DkmRawReturnValue using solely the provided data.
        ///
        /// This method will append a new work item to the specified work list, and return
        /// once the work item has been appended. The actual processing of the work item is
        /// asynchronous. The caller will be notified that the request is complete through
        /// the completion routine.
        ///
        /// Location constraint: API must be called from an IDE component (component level
        /// &gt; 100,000).
        /// </summary>
        /// <param name="pWorkList">
        /// WorkList to append the new work item to.
        /// </param>
        /// <param name="pStackFrame">
        /// [In] Stack frame that provides the context of in which to evaluate the
        /// expression.
        /// </param>
        /// <param name="pRawReturnValue">
        /// [In] Return value target and cached context.
        /// </param>
        /// <param name="pCompletionRoutine">
        /// Routine to fire when the request is complete. If the request is successfully
        /// appended to the work list, this will always fire (including when the operation is
        /// canceled). This will never fire if appending the work item fails.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE EvaluateReturnValue(
            _In_ DkmWorkList* pWorkList,
            _In_ CallStack::DkmStackWalkFrame* pStackFrame,
            _In_ Evaluation::DkmRawReturnValue* pRawReturnValue,
            _In_ IDkmCompletionRoutine<Evaluation::DkmEvaluateReturnValueAsyncResult>* pCompletionRoutine
            );
        #endif // #ifndef EXCLUDE_IDE_ONLY_APIS

        #ifndef EXCLUDE_IDE_ONLY_APIS
        /// <summary>
        /// Get a DkmCompiledClrLocalsQuery to allow viewing of local variables.
        ///
        /// Location constraint: API must be called from an IDE component (component level
        /// &gt; 100,000).
        ///
        /// This API was introduced in Visual Studio 14 RTM (DkmApiVersion.VS14RTM).
        /// </summary>
        /// <param name="pInstructionAddress">
        /// [In] The code context to use for getting local variables.
        /// </param>
        /// <param name="ArgumentsOnly">
        /// [In] If set to true, get a query for arguments only.
        /// </param>
        /// <param name="ppResult">
        /// [Out] The local variables query.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetClrLocalVariableQuery(
            _In_ Clr::DkmClrInstructionAddress* pInstructionAddress,
            _In_ bool ArgumentsOnly,
            _Deref_out_ Evaluation::ClrCompilation::DkmCompiledClrLocalsQuery** ppResult
            );
        #endif // #ifndef EXCLUDE_IDE_ONLY_APIS

        #ifndef EXCLUDE_MONITOR_ONLY_APIS
        /// <summary>
        /// Gets the type name string to display in the UI for the given DkmClrType.
        ///
        /// Location constraint: API must be called from a Monitor component (component level
        /// &lt; 100,000).
        ///
        /// This API was introduced in Visual Studio 14 RTM (DkmApiVersion.VS14RTM).
        /// </summary>
        /// <param name="pClrType">
        /// [In] The type to get the name for.
        /// </param>
        /// <param name="pCustomTypeInfo">
        /// [In,Optional] The optional information provided by the expression compiler for
        /// identifying compiler intrinsic type information.
        /// </param>
        /// <param name="pFormatSpecifiers">
        /// [In,Optional] The optional format specifier(s) to use when formatting this
        /// result.
        /// </param>
        /// <param name="ppTypeName">
        /// [Out] The type name string.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetTypeName(
            _In_ Clr::DkmClrType* pClrType,
            _In_opt_ Evaluation::ClrCompilation::DkmClrCustomTypeInfo* pCustomTypeInfo,
            _In_opt_ DkmReadOnlyCollection<DkmString*>* pFormatSpecifiers,
            _Deref_out_ DkmString** ppTypeName
            );
        #endif // #ifndef EXCLUDE_MONITOR_ONLY_APIS

        #ifndef EXCLUDE_IDE_ONLY_APIS
        /// <summary>
        /// Evaluates and formats a given DkmRawReturnValue using solely the provided data.
        ///
        /// This method will append a new work item to the specified work list, and return
        /// once the work item has been appended. The actual processing of the work item is
        /// asynchronous. The caller will be notified that the request is complete through
        /// the completion routine.
        ///
        /// Location constraint: API must be called from an IDE component (component level
        /// &gt; 100,000).
        ///
        /// This API was introduced in Visual Studio 14 RTM (DkmApiVersion.VS14RTM).
        /// </summary>
        /// <param name="pWorkList">
        /// WorkList to append the new work item to.
        /// </param>
        /// <param name="pStackFrame">
        /// [In] Stack frame that provides the context of in which to evaluate the
        /// expression.
        /// </param>
        /// <param name="pRawReturnValue">
        /// [In] Return value target and cached context.
        /// </param>
        /// <param name="pCompletionRoutine">
        /// Routine to fire when the request is complete. If the request is successfully
        /// appended to the work list, this will always fire (including when the operation is
        /// canceled). This will never fire if appending the work item fails.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE EvaluateReturnValue2(
            _In_ DkmWorkList* pWorkList,
            _In_ CallStack::DkmStackWalkFrame* pStackFrame,
            _In_ Evaluation::DkmRawReturnValueContainer* pRawReturnValue,
            _In_ IDkmCompletionRoutine<Evaluation::DkmEvaluateReturnValueAsyncResult2>* pCompletionRoutine
            );
        #endif // #ifndef EXCLUDE_IDE_ONLY_APIS
    }; // end of DkmInspectionContext

    // DkmInspectionSession allows the various components which inspect data to store private
    // data which is associated with a group of evaluations.
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("79035fe3-c25f-1535-6595-2b6b79621f50") DkmInspectionSession : public DkmDataContainer
    {
        // Use DkmInspectionSession::Create to create this object
        private: DkmInspectionSession();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmInspectionSession();
        // This object cannot be copied
        private: DkmInspectionSession& operator=(const DkmInspectionSession&);
        private: DkmInspectionSession(const DkmInspectionSession&);

        private: DkmProcess* const m_pProcess;
        private: const GUID m_UniqueId;
        private: void* m__pExtendedData;
        private: void* m_pEnumContextCollection0;
        private: void* m_pResultCollection0;
        private: void* m_pStackContextCollection0;
        private: void* m_pVisualizedExpressionCollection0;

        // DkmProcess represents a target process which is being debugged. The debugger
        // debugs processes, so this is the basic unit of debugging. A DkmProcess can
        // represent a system process or a virtual process such as minidumps.
        public: _Ret_ DECLSPEC_NOTHROW DkmProcess* STDMETHODCALLTYPE Process(
            );

        // Guid which uniquely identifies this inspection session.
        public: DECLSPEC_NOTHROW const GUID& STDMETHODCALLTYPE UniqueId(
            );

        /// <summary>
        /// Closes a DkmInspectionSession object instance. This will release any resources
        /// associated with this object across all components. This includes resources across
        /// computer or managed/native marshalling boundaries.
        ///
        /// DkmInspectionSession objects are automatically closed when their associated
        /// DkmProcess object is closed.
        ///
        /// This method may only be called by the component which created the object.
        /// </summary>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Close(
            );

        /// <summary>
        /// Create a new DkmInspectionSession object instance. The caller is responsible for
        /// closing the created object after they are done.
        /// </summary>
        /// <param name="pProcess">
        /// [In] DkmProcess represents a target process which is being debugged. The debugger
        /// debugs processes, so this is the basic unit of debugging. A DkmProcess can
        /// represent a system process or a virtual process such as minidumps.
        /// </param>
        /// <param name="DataItem">
        /// [In] Data object to add to the new DkmInspectionSession instance.
        /// DkmDataItem::Null() in the case that the caller doesn't need to add a data item.
        /// </param>
        /// <param name="ppCreatedObject">
        /// [Out] Result of this method call.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ DkmProcess* pProcess,
            _In_ const DkmDataItem& DataItem,
            _Deref_out_ Evaluation::DkmInspectionSession** ppCreatedObject
            );

        /// <summary>
        /// Find a DkmRawReturnValueContainer element within this DkmInspectionSession. If no
        /// element with the given input key is present, FindReturnValueContainer will fail.
        ///
        /// This API was introduced in Visual Studio 14 RTM (DkmApiVersion.VS14RTM).
        /// </summary>
        /// <param name="Id">
        /// [In] Search key used to find the element.
        /// </param>
        /// <param name="ppReturnValueContainer">
        /// [Out] Result of the search.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// E_XAPI_OBJECT_NOT_FOUND indicates that the search key cannot be found.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE FindReturnValueContainer(
            _In_ UINT32 Id,
            _Deref_out_ Evaluation::DkmRawReturnValueContainer** ppReturnValueContainer
            );

        /// <summary>
        /// GetReturnValueContainers enumerates the DkmRawReturnValueContainer elements of
        /// this DkmInspectionSession object.
        ///
        /// This API was introduced in Visual Studio 14 RTM (DkmApiVersion.VS14RTM).
        /// </summary>
        /// <param name="pReturnValueContainers">
        /// [Out] Array containing the enumerated elements.
        ///
        /// The memory for the DkmArray members is allocated by the method implementation
        /// using DkmAllocBytes/DkmAllocArray. It is freed by the caller using the
        /// CAutoDkmArray template or with DkmFreeMemory and manual element release.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetReturnValueContainers(
            _Out_ DkmArray<Evaluation::DkmRawReturnValueContainer*>* pReturnValueContainers
            );
    }; // end of DkmInspectionSession

    // Describes a programming language.
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("7dbbd573-0a29-3ba3-6f5d-42c8faf933e0") DkmLanguage : public IUnknown
    {
        private: ___ReferenceCount_t m_ReferenceCount;
        private: DkmDispatcherObjectFlags_t m_ObjectFlags;
        private: const GUID* m_pTypeId;
        private: size_t m_ObjectGCHandle;
        // Use DkmLanguage::Create to create this object
        private: DkmLanguage();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmLanguage();
        // This object cannot be copied
        private: DkmLanguage& operator=(const DkmLanguage&);
        private: DkmLanguage(const DkmLanguage&);

        private: DkmString* const m_pName;
        private: const Evaluation::DkmCompilerId m_Id;
        private: void* m__pExtendedData;

        // Name of the programming language (ex: C++). This string will appear in the call
        // stack window.
        public: _Ret_ DECLSPEC_NOTHROW DkmString* STDMETHODCALLTYPE Name(
            );

        // LanguageId/VendorId pair for this DkmLanguage object. For the default language,
        // both of these values will be Guid.Empty. For all other languages, both of these
        // values are non-zero.
        public: DECLSPEC_NOTHROW const Evaluation::DkmCompilerId& STDMETHODCALLTYPE Id(
            );

        /// <summary>
        /// Create a new DkmLanguage object instance.
        /// </summary>
        /// <param name="pName">
        /// [In] Name of the programming language (ex: C++). This string will appear in the
        /// call stack window.
        /// </param>
        /// <param name="Id">
        /// [In] LanguageId/VendorId pair for this DkmLanguage object. For the default
        /// language, both of these values will be Guid.Empty. For all other languages, both
        /// of these values are non-zero.
        /// </param>
        /// <param name="ppCreatedObject">
        /// [Out] Result of this method call.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ DkmString* pName,
            _In_ const Evaluation::DkmCompilerId& Id,
            _Deref_out_ Evaluation::DkmLanguage** ppCreatedObject
            );

        /// <summary>
        /// Reads language-specific from the registry.  The settings are stored under
        /// HKLM\Software\Microsoft\VisualStudio\14.0\AD7Metrics\ExpressionEvaluator\[Languag
        ///  Guid]\[Vendor Guid].
        /// </summary>
        /// <param name="pSettings">
        /// [Out] Pairing between the name of a setting and its value.
        ///
        /// The memory for the DkmArray members is allocated by the method implementation
        /// using DkmAllocBytes/DkmAllocArray. It is freed by the caller using the
        /// CAutoDkmArray template or with DkmFreeMemory and manual element release.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetLanguageSettings(
            _Out_ DkmArray<DkmLanguageRegistrySetting*>* pSettings
            );

        /// <summary>
        /// Reads language-specific from the registry.  The settings are stored under
        /// HKLM\Software\Microsoft\VisualStudio\14.0\AD7Metrics\ExpressionEvaluator\[Languag
        ///  Guid]\[Vendor Guid].
        ///
        /// This method will append a new work item to the specified work list, and return
        /// once the work item has been appended. The actual processing of the work item is
        /// asynchronous. The caller will be notified that the request is complete through
        /// the completion routine.
        /// </summary>
        /// <param name="pWorkList">
        /// WorkList to append the new work item to.
        /// </param>
        /// <param name="pCompletionRoutine">
        /// Routine to fire when the request is complete. If the request is successfully
        /// appended to the work list, this will always fire (including when the operation is
        /// canceled). This will never fire if appending the work item fails.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetLanguageSettings(
            _In_ DkmWorkList* pWorkList,
            _In_ IDkmCompletionRoutine<Evaluation::DkmGetLanguageSettingsAsyncResult>* pCompletionRoutine
            );

        /// <summary>
        /// Reads a file path as a metric of the given name for the expression evaluator of
        /// the given language. Then, reads the entire contents of the file, on the Visual
        /// Studio computer, and returns the contents as a string.
        ///
        /// This API was introduced in Visual Studio 14 RTM (DkmApiVersion.VS14RTM).
        /// </summary>
        /// <param name="pMetricName">
        /// [In] The name of the metric that contains the full path to the file.
        /// </param>
        /// <param name="ppContents">
        /// [Out] The contents of the file that was referenced by the metric.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetEEMetricFile(
            _In_ DkmString* pMetricName,
            _Deref_out_ DkmString** ppContents
            );
    }; // end of DkmLanguage

    // DkmLanguageExpression represents an expression to be parsed and evaluated by an
    // expression evaluator.
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("dce7ad4c-45b3-1220-86da-a2cd4ca64ab0") DkmLanguageExpression : public DkmDataContainer
    {
        // Use DkmLanguageExpression::Create to create this object
        private: DkmLanguageExpression();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmLanguageExpression();
        // This object cannot be copied
        private: DkmLanguageExpression& operator=(const DkmLanguageExpression&);
        private: DkmLanguageExpression(const DkmLanguageExpression&);

        private: Evaluation::DkmLanguage* const m_pLanguage;
        private: const Evaluation::DkmEvaluationFlags_t m_CompilationFlags;
        private: DkmString* const m_pText;
        private: const GUID m_UniqueId;
        private: void* m__pExtendedData;

        // Describes a programming language.
        public: _Ret_ DECLSPEC_NOTHROW Evaluation::DkmLanguage* STDMETHODCALLTYPE Language(
            );

        // Flags which effect how the condition text should be compiled by the expression
        // evaluator. During evaluation, the caller must ensure that the DkmEvaluationFlags
        // set on the InspectionContext agree with this value -- that is that they may only
        // differ by the last set of flags which are only relevant to the display of values.
        public: DECLSPEC_NOTHROW Evaluation::DkmEvaluationFlags_t STDMETHODCALLTYPE CompilationFlags(
            );

        // Source text of the parsed expression.
        public: _Ret_ DECLSPEC_NOTHROW DkmString* STDMETHODCALLTYPE Text(
            );

        // Guid which uniquely identifies this expression object.
        public: DECLSPEC_NOTHROW const GUID& STDMETHODCALLTYPE UniqueId(
            );

        /// <summary>
        /// Closes a DkmLanguageExpression object instance. This will release any resources
        /// associated with this object across all components. This includes resources across
        /// computer or managed/native marshalling boundaries.
        ///
        /// This method may only be called by the component which created the object.
        /// </summary>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Close(
            );

        /// <summary>
        /// Creates a new DkmLanguageExpression object. This can be evaluated with
        /// DkmInspectionContext.EvaluateExpression. The caller is responsible for closing
        /// the created object after they are done.
        /// </summary>
        /// <param name="pLanguage">
        /// [In] Describes a programming language.
        /// </param>
        /// <param name="CompilationFlags">
        /// [In] Flags which effect how the condition text should be compiled by the
        /// expression evaluator. During evaluation, the caller must ensure that the
        /// DkmEvaluationFlags set on the InspectionContext agree with this value -- that is
        /// that they may only differ by the last set of flags which are only relevant to the
        /// display of values.
        /// </param>
        /// <param name="pText">
        /// [In] Source text of the parsed expression.
        /// </param>
        /// <param name="DataItem">
        /// [In] Data object to add to the new DkmLanguageExpression instance.
        /// DkmDataItem::Null() in the case that the caller doesn't need to add a data item.
        /// </param>
        /// <param name="ppCreatedObject">
        /// [Out] Result of this method call.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ Evaluation::DkmLanguage* pLanguage,
            _In_ Evaluation::DkmEvaluationFlags_t CompilationFlags,
            _In_ DkmString* pText,
            _In_ const DkmDataItem& DataItem,
            _Deref_out_ Evaluation::DkmLanguageExpression** ppCreatedObject
            );

        /// <summary>
        /// Compile the expression into MSIL code that can be executed by the CLR or debugger
        /// to evaluate the expression.
        ///
        /// This API was introduced in Visual Studio 14 RTM (DkmApiVersion.VS14RTM).
        /// </summary>
        /// <param name="pInstructionAddress">
        /// [In] The code context to use for compiling the expression.
        /// </param>
        /// <param name="pInspectionContext">
        /// [In,Optional] The inspection context for this evaluation.  This value is null if
        /// there is no current evaluation context. An example of a time when there is no
        /// evaluation context is when compiling conditional breakpoints.
        /// </param>
        /// <param name="ppError">
        /// [Out,Optional] Indicates any error compiling the expression.  If the code
        /// compiles successfully, this value should be null. It should also be null for
        /// cases where the language or expression is not supported and the debug engine
        /// needs to fall back to the default implementation. In error cases, this value
        /// indicates the reason for the compile error and the caller should return S_OK.
        /// </param>
        /// <param name="ppResult">
        /// [Out,Optional] The compiled expression.  If Result is null, and Error is not
        /// null, there was a compile error.  If both are null, compilation of the expression
        /// is not supported and the debug engine needs to use the legacy expression
        /// evaluator.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE CompileExpression(
            _In_ Clr::DkmClrInstructionAddress* pInstructionAddress,
            _In_opt_ Evaluation::DkmInspectionContext* pInspectionContext,
            _Deref_out_opt_ DkmString** ppError,
            _Deref_out_opt_ Evaluation::ClrCompilation::DkmCompiledClrInspectionQuery** ppResult
            );

        #ifndef EXCLUDE_IDE_ONLY_APIS
        /// <summary>
        /// Compile the given expression and generate code to assign the value of the
        /// expression to an L-Value.
        ///
        /// Location constraint: API must be called from an IDE component (component level
        /// &gt; 100,000).
        ///
        /// This API was introduced in Visual Studio 14 RTM (DkmApiVersion.VS14RTM).
        /// </summary>
        /// <param name="pInstructionAddress">
        /// [In] The code context to use for compiling the expression.
        /// </param>
        /// <param name="pLValue">
        /// [In] The L-value of the assignment.  This is the result of a previous evaluation.
        /// </param>
        /// <param name="ppError">
        /// [Out,Optional] Indicates any error compiling the expression or the reason the
        /// assignment is invalid. If the compiler can generate code for the assignment, this
        /// value should be null. In error cases, this value indicates the reason for the
        /// compile error and the caller should return S_OK.
        /// </param>
        /// <param name="ppResult">
        /// [Out,Optional] The compiled assignment operation.  If Result is null, and Error
        /// is not null, there was a compile error.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE CompileAssignment(
            _In_ Clr::DkmClrInstructionAddress* pInstructionAddress,
            _In_ Evaluation::DkmEvaluationResult* pLValue,
            _Deref_out_opt_ DkmString** ppError,
            _Deref_out_opt_ Evaluation::ClrCompilation::DkmCompiledClrInspectionQuery** ppResult
            );
        #endif // #ifndef EXCLUDE_IDE_ONLY_APIS

        #ifndef EXCLUDE_IDE_ONLY_APIS
        /// <summary>
        /// Compile the given DebuggerDisplayAttribute string.  The resulting IL should
        /// return a string. For debugger display, there is no code context.  Instead the
        /// compiler must do its binding based on a type token.
        ///
        /// Location constraint: API must be called from an IDE component (component level
        /// &gt; 100,000).
        ///
        /// This API was introduced in Visual Studio 14 RTM (DkmApiVersion.VS14RTM).
        /// </summary>
        /// <param name="pModuleInstance">
        /// [In] The module instance containing the type the DebuggerDisplayAttribute applies
        /// to.
        /// </param>
        /// <param name="Token">
        /// [In] The metadata token of the type the DebuggerDisplayAttribute applies to.
        /// </param>
        /// <param name="ppError">
        /// [Out,Optional] Indicates any error compiling the expression.  If the code
        /// compiles successfully, this value should be null. In error cases, this value
        /// indicates the reason for the compile error and the caller should return S_OK.
        /// </param>
        /// <param name="ppResult">
        /// [Out,Optional] The compiled display attribute.  If Result is null, and Error is
        /// not null, there was a compile error.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE CompileDisplayAttribute(
            _In_ Clr::DkmClrModuleInstance* pModuleInstance,
            _In_ UINT32 Token,
            _Deref_out_opt_ DkmString** ppError,
            _Deref_out_opt_ Evaluation::ClrCompilation::DkmCompiledClrInspectionQuery** ppResult
            );
        #endif // #ifndef EXCLUDE_IDE_ONLY_APIS

        #ifndef EXCLUDE_MONITOR_ONLY_APIS
        /// <summary>
        /// This method is used internally by the CLR Expression Evaluator.
        ///
        /// Location constraint: API must be called from a Monitor component (component level
        /// &lt; 100,000).
        ///
        /// This API was introduced in Visual Studio 14 RTM (DkmApiVersion.VS14RTM).
        /// </summary>
        /// <param name="pModuleInstance">
        /// [In] The module instance containing the type the DebuggerDisplayAttribute applies
        /// to.
        /// </param>
        /// <param name="Token">
        /// [In] The metadata token of the type the DebuggerDisplayAttribute applies to.
        /// </param>
        /// <param name="ppError">
        /// [Out,Optional] Indicates any error compiling the expression.  If the code
        /// compiles successfully, this value should be null. In error cases, this value
        /// indicates the reason for the compile error and the caller should return S_OK.
        /// </param>
        /// <param name="ppResult">
        /// [Out,Optional] The compiled display attribute.  If Result is null, and Error is
        /// not null, there was a compile error.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE CompileDisplayAttributeInternal(
            _In_ Clr::DkmClrModuleInstance* pModuleInstance,
            _In_ UINT32 Token,
            _Deref_out_opt_ DkmString** ppError,
            _Deref_out_opt_ Evaluation::ClrCompilation::DkmCompiledClrInspectionQuery** ppResult
            );
        #endif // #ifndef EXCLUDE_MONITOR_ONLY_APIS

        #ifndef EXCLUDE_MONITOR_ONLY_APIS
        /// <summary>
        /// This method is used internally by the CLR Expression Evaluator.
        ///
        /// This method will append a new work item to the specified work list, and return
        /// once the work item has been appended. The actual processing of the work item is
        /// asynchronous. The caller will be notified that the request is complete through
        /// the completion routine.
        ///
        /// Location constraint: API must be called from a Monitor component (component level
        /// &lt; 100,000).
        ///
        /// This API was introduced in Visual Studio 14 RTM (DkmApiVersion.VS14RTM).
        /// </summary>
        /// <param name="pWorkList">
        /// WorkList to append the new work item to.
        /// </param>
        /// <param name="pModuleInstance">
        /// [In] The module instance containing the type the DebuggerDisplayAttribute applies
        /// to.
        /// </param>
        /// <param name="Token">
        /// [In] The metadata token of the type the DebuggerDisplayAttribute applies to.
        /// </param>
        /// <param name="pCompletionRoutine">
        /// Routine to fire when the request is complete. If the request is successfully
        /// appended to the work list, this will always fire (including when the operation is
        /// canceled). This will never fire if appending the work item fails.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE CompileDisplayAttributeInternal(
            _In_ DkmWorkList* pWorkList,
            _In_ Clr::DkmClrModuleInstance* pModuleInstance,
            _In_ UINT32 Token,
            _In_ IDkmCompletionRoutine<Evaluation::DkmCompileDisplayAttributeInternalAsyncResult>* pCompletionRoutine
            );
        #endif // #ifndef EXCLUDE_MONITOR_ONLY_APIS
    }; // end of DkmLanguageExpression

    // Unique id for a programming language. These values must also be registered under
    // $(RegRoot)\AD7Metric\ExpressionEvaluator and returned from symbol providers (through
    // GetCompilerId) and language services (through IVsLanguageDebugInfo.GetLanguageID).
    struct DkmLanguageId
    {
        // Visual Basic.
        // VB is defined as {3a12d0b8-c26c-11d0-b442-00a0244a1dd2}.
        static const GUID VB;
        // JScript (ECMA Script).
        // JScript is defined as {3a12d0b6-c26c-11d0-b442-00a0244a1dd2}.
        static const GUID JScript;
        // C.
        // C is defined as {63a08714-fc37-11d2-904c-00c04fa302a1}.
        static const GUID C;
        // C++.
        // Cpp is defined as {3a12d0b7-c26c-11d0-b442-00a0244a1dd2}.
        static const GUID Cpp;
        // T-SQL.
        // SQL is defined as {3a12d0b9-c26c-11d0-b442-00a0244a1dd2}.
        static const GUID SQL;
        // Script.
        // Script is defined as {f7fa31da-c32a-11d0-b442-00a0244a1dd2}.
        static const GUID Script;
        // C#.
        // CSharp is defined as {3f5162f8-07c6-11d3-9053-00c04fa302a1}.
        static const GUID CSharp;
        // Fortran.
        // Fortran is defined as {28731592-73f5-4ed0-a07b-f322c8ff9cac}.
        static const GUID Fortran;
        // Cobol.
        // Cobol is defined as {af046cd1-d0e1-11d2-977c-00a0c9b4d50c}.
        static const GUID Cobol;
        // Pascal.
        // Pascal is defined as {af046cd2-d0e1-11d2-977c-00a0c9b4d50c}.
        static const GUID Pascal;
        // Java.
        // Java is defined as {3a12d0b4-c26c-11d0-b442-00a0244a1dd2}.
        static const GUID Java;
        // MSIL Assembly.
        // ILAssembly is defined as {af046cd3-d0e1-11d2-977c-00a0c9b4d50c}.
        static const GUID ILAssembly;
        // Language used for causality function breakpoints (ASMX).
        // CausalityBreakpoint is defined as {61d3986e-1220-4877-b909-096f0c29b0dd}.
        static const GUID CausalityBreakpoint;
        // Language used for specifying MVID/METHOD_TOKEN. This is used for Indigo. Example:
        // '{6AF7F59F-ED82-4f76-95BE-6BB908DBDC69}/06000001'.
        // MethodId is defined as {ee1ff7c4-775c-449c-a9c9-be4542742f64}.
        static const GUID MethodId;
        // Client side (targeting IE) script.
        // ClientScript is defined as {fdeabccd-1bec-4495-9624-f35e7dcf2c7f}.
        static const GUID ClientScript;
        // HLSL.
        // HLSL is defined as {53cd816a-fb44-4c89-8d93-af7e251de590}.
        static const GUID HLSL;
    };
    __declspec(selectany) const GUID DkmLanguageId::VB = { 0x3a12d0b8, 0xc26c, 0x11d0, { 0xb4, 0x42, 0x0, 0xa0, 0x24, 0x4a, 0x1d, 0xd2 } };
    __declspec(selectany) const GUID DkmLanguageId::JScript = { 0x3a12d0b6, 0xc26c, 0x11d0, { 0xb4, 0x42, 0x0, 0xa0, 0x24, 0x4a, 0x1d, 0xd2 } };
    __declspec(selectany) const GUID DkmLanguageId::C = { 0x63a08714, 0xfc37, 0x11d2, { 0x90, 0x4c, 0x0, 0xc0, 0x4f, 0xa3, 0x2, 0xa1 } };
    __declspec(selectany) const GUID DkmLanguageId::Cpp = { 0x3a12d0b7, 0xc26c, 0x11d0, { 0xb4, 0x42, 0x0, 0xa0, 0x24, 0x4a, 0x1d, 0xd2 } };
    __declspec(selectany) const GUID DkmLanguageId::SQL = { 0x3a12d0b9, 0xc26c, 0x11d0, { 0xb4, 0x42, 0x0, 0xa0, 0x24, 0x4a, 0x1d, 0xd2 } };
    __declspec(selectany) const GUID DkmLanguageId::Script = { 0xf7fa31da, 0xc32a, 0x11d0, { 0xb4, 0x42, 0x0, 0xa0, 0x24, 0x4a, 0x1d, 0xd2 } };
    __declspec(selectany) const GUID DkmLanguageId::CSharp = { 0x3f5162f8, 0x7c6, 0x11d3, { 0x90, 0x53, 0x0, 0xc0, 0x4f, 0xa3, 0x2, 0xa1 } };
    __declspec(selectany) const GUID DkmLanguageId::Fortran = { 0x28731592, 0x73f5, 0x4ed0, { 0xa0, 0x7b, 0xf3, 0x22, 0xc8, 0xff, 0x9c, 0xac } };
    __declspec(selectany) const GUID DkmLanguageId::Cobol = { 0xaf046cd1, 0xd0e1, 0x11d2, { 0x97, 0x7c, 0x0, 0xa0, 0xc9, 0xb4, 0xd5, 0xc } };
    __declspec(selectany) const GUID DkmLanguageId::Pascal = { 0xaf046cd2, 0xd0e1, 0x11d2, { 0x97, 0x7c, 0x0, 0xa0, 0xc9, 0xb4, 0xd5, 0xc } };
    __declspec(selectany) const GUID DkmLanguageId::Java = { 0x3a12d0b4, 0xc26c, 0x11d0, { 0xb4, 0x42, 0x0, 0xa0, 0x24, 0x4a, 0x1d, 0xd2 } };
    __declspec(selectany) const GUID DkmLanguageId::ILAssembly = { 0xaf046cd3, 0xd0e1, 0x11d2, { 0x97, 0x7c, 0x0, 0xa0, 0xc9, 0xb4, 0xd5, 0xc } };
    __declspec(selectany) const GUID DkmLanguageId::CausalityBreakpoint = { 0x61d3986e, 0x1220, 0x4877, { 0xb9, 0x9, 0x9, 0x6f, 0xc, 0x29, 0xb0, 0xdd } };
    __declspec(selectany) const GUID DkmLanguageId::MethodId = { 0xee1ff7c4, 0x775c, 0x449c, { 0xa9, 0xc9, 0xbe, 0x45, 0x42, 0x74, 0x2f, 0x64 } };
    __declspec(selectany) const GUID DkmLanguageId::ClientScript = { 0xfdeabccd, 0x1bec, 0x4495, { 0x96, 0x24, 0xf3, 0x5e, 0x7d, 0xcf, 0x2c, 0x7f } };
    __declspec(selectany) const GUID DkmLanguageId::HLSL = { 0x53cd816a, 0xfb44, 0x4c89, { 0x8d, 0x93, 0xaf, 0x7e, 0x25, 0x1d, 0xe5, 0x90 } };

    // Pairing between an instruction address and the language that should be used to decode
    // it.
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("42745737-3842-1f94-1ea8-2c310a3a61c1") DkmLanguageInstructionAddress : public IUnknown
    {
        private: ___ReferenceCount_t m_ReferenceCount;
        private: DkmDispatcherObjectFlags_t m_ObjectFlags;
        private: const GUID* m_pTypeId;
        private: size_t m_ObjectGCHandle;
        // Use DkmLanguageInstructionAddress::Create to create this object
        private: DkmLanguageInstructionAddress();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmLanguageInstructionAddress();
        // This object cannot be copied
        private: DkmLanguageInstructionAddress& operator=(const DkmLanguageInstructionAddress&);
        private: DkmLanguageInstructionAddress(const DkmLanguageInstructionAddress&);

        private: Evaluation::DkmLanguage* const m_pLanguage;
        private: DkmInstructionAddress* const m_pAddress;
        private: void* m__pExtendedData;

        // Describes a programming language.
        public: _Ret_ DECLSPEC_NOTHROW Evaluation::DkmLanguage* STDMETHODCALLTYPE Language(
            );

        // Abstract representation of an executable code location (ex: EIP value). If
        // resolved, an Instruction Address will be within a particular module instance. An
        // Instruction Address is always within a particular Runtime Instance.
        public: _Ret_ DECLSPEC_NOTHROW DkmInstructionAddress* STDMETHODCALLTYPE Address(
            );

        // The DkmRuntimeInstance class represents an execution environment which is loaded
        // into a DkmProcess and which contains code to be debugged.
        public: _Ret_ DECLSPEC_NOTHROW DkmRuntimeInstance* STDMETHODCALLTYPE RuntimeInstance(
            );

        /// <summary>
        /// Create a new DkmLanguageInstructionAddress object instance.
        /// </summary>
        /// <param name="pLanguage">
        /// [In] Describes a programming language.
        /// </param>
        /// <param name="pAddress">
        /// [In] Abstract representation of an executable code location (ex: EIP value). If
        /// resolved, an Instruction Address will be within a particular module instance. An
        /// Instruction Address is always within a particular Runtime Instance.
        /// </param>
        /// <param name="ppCreatedObject">
        /// [Out] Result of this method call.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ Evaluation::DkmLanguage* pLanguage,
            _In_ DkmInstructionAddress* pAddress,
            _Deref_out_ Evaluation::DkmLanguageInstructionAddress** ppCreatedObject
            );

        #ifndef EXCLUDE_IDE_ONLY_APIS
        /// <summary>
        /// This method is obsolete and should not be used.
        ///
        /// Location constraint: API must be called from an IDE component (component level
        /// &gt; 100,000).
        /// </summary>
        /// <param name="pExpression">
        /// [In] Not used.
        /// </param>
        /// <param name="ppError">
        /// [Out,Optional] Not used.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Compile(
            _In_ Evaluation::DkmLanguageExpression* pExpression,
            _Deref_out_opt_ Evaluation::DkmFailedEvaluationResult** ppError
            );
        #endif // #ifndef EXCLUDE_IDE_ONLY_APIS

        #ifndef EXCLUDE_IDE_ONLY_APIS
        /// <summary>
        /// Compiles an input breakpoint condition into an inspection query which can be
        /// evaluated on the target computer. If the breakpoint condition uses
        /// DkmBreakpointConditionOperator.BreakWhenTrue, the expression evaluator should
        /// require that the specified condition evaluates to a Boolean value. The created
        /// query must return only a single result. For BreakWhenTrue conditions, this must
        /// be either a 4-byte or 1-byte value, and any non-zero value is considered true.
        ///
        /// Location constraint: API must be called from an IDE component (component level
        /// &gt; 100,000).
        /// </summary>
        /// <param name="pCondition">
        /// [In] Breakpoint condition to compile.
        /// </param>
        /// <param name="ppCompiledCondition">
        /// [Out,Optional] The result of the compilation. This is null in the case that the
        /// compilation failed. In this case, ErrorText should indicate the reason for the
        /// failure.
        /// </param>
        /// <param name="ppErrorText">
        /// [Out,Optional] If the compilation failed, this indicates the reason why. This
        /// value should be null if the compile succeeded. If the compile does fail, S_FALSE
        /// is returned (native code only).
        /// </param>
        /// <returns>
        /// S_OK is returned if *ppCompiledCondition is non-NULL, S_FALSE is returned when
        /// *ppCompiledCondition is NULL, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE CompileCondition(
            _In_ Breakpoints::DkmBreakpointCondition* pCondition,
            _Deref_out_opt_ Evaluation::DkmCompiledInspectionQuery** ppCompiledCondition,
            _Deref_out_opt_ DkmString** ppErrorText
            );
        #endif // #ifndef EXCLUDE_IDE_ONLY_APIS

        /// <summary>
        /// Provides a text representation for a method symbol. This is used when describing
        /// an address in the UI, for example the 'Function' column in the breakpoints
        /// window.
        /// </summary>
        /// <param name="ArgumentFlags">
        /// [In] Flags to indicate what information about the arguments should be included in
        /// the method name.  As parameter values cannot be obtained without a stack frame
        /// and a stack frame is not available here, the "Values" flag will never be present.
        /// </param>
        /// <param name="ppMethodName">
        /// [Out] Language's representation of the name of this method.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetMethodName(
            _In_ Evaluation::DkmVariableInfoFlags_t ArgumentFlags,
            _Deref_out_ DkmString** ppMethodName
            );

        #ifndef EXCLUDE_IDE_ONLY_APIS
        /// <summary>
        /// Called during a Step-Into to determine special behavior for a particular
        /// function.
        ///
        /// Location constraint: API must be called from an IDE component (component level
        /// &gt; 100,000).
        /// </summary>
        /// <param name="pStepIntoFlags">
        /// [Out] Flags which describe how to proceed with a Step-Into action.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetStepIntoFlags(
            _Out_ Stepping::DkmLanguageStepIntoFlags_t* pStepIntoFlags
            );
        #endif // #ifndef EXCLUDE_IDE_ONLY_APIS
    }; // end of DkmLanguageInstructionAddress

    // Set of platform dependent registers that may hold the return value of a function call.
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("b2c0ed0b-6a96-c138-034a-49a67ab87104") DkmNativeReturnValueRegister : public IUnknown
    {
        private: ___ReferenceCount_t m_ReferenceCount;
        private: DkmDispatcherObjectFlags_t m_ObjectFlags;
        private: const GUID* m_pTypeId;
        private: size_t m_ObjectGCHandle;
        // Use DkmNativeReturnValueRegister::Create to create this object
        private: DkmNativeReturnValueRegister();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmNativeReturnValueRegister();
        // This object cannot be copied
        private: DkmNativeReturnValueRegister& operator=(const DkmNativeReturnValueRegister&);
        private: DkmNativeReturnValueRegister(const DkmNativeReturnValueRegister&);

        private: const CV_HREG_e m_Identifier;
        private: DkmReadOnlyCollection<BYTE>* const m_pValue;
        private: void* m__pExtendedData;

        // The code-view register ID constant.
        public: DECLSPEC_NOTHROW CV_HREG_e STDMETHODCALLTYPE Identifier(
            );

        // The value of the register. The size of the register in bytes can be found by the
        // length of this array.
        public: _Ret_ DECLSPEC_NOTHROW DkmReadOnlyCollection<BYTE>* STDMETHODCALLTYPE Value(
            );

        /// <summary>
        /// Create a new DkmNativeReturnValueRegister object instance.
        /// </summary>
        /// <param name="Identifier">
        /// [In] The code-view register ID constant.
        /// </param>
        /// <param name="pValue">
        /// [In] The value of the register. The size of the register in bytes can be found by
        /// the length of this array.
        /// </param>
        /// <param name="ppCreatedObject">
        /// [Out] Result of this method call.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ CV_HREG_e Identifier,
            _In_ DkmReadOnlyCollection<BYTE>* pValue,
            _Deref_out_ Evaluation::DkmNativeReturnValueRegister** ppCreatedObject
            );
    }; // end of DkmNativeReturnValueRegister

    // DkmRawReturnValue carries sufficient context that can be used to partially reconstruct
    // and visualize a function-call's return value.
    //
    // Derived classes: DkmCustomRawReturnValue, DkmNativeRawReturnValue,
    // DkmRawManagedReturnValue
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("eecc8d2d-81c3-9823-e89f-1438471e579d") DkmRawReturnValue : public IUnknown
    {
        private: ___ReferenceCount_t m_ReferenceCount;
        private: DkmDispatcherObjectFlags_t m_ObjectFlags;
        private: const GUID* m_pTypeId;
        private: size_t m_ObjectGCHandle;
        // Use DkmRawReturnValue::Create to create this object
        private: DkmRawReturnValue();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmRawReturnValue();
        // This object cannot be copied
        private: DkmRawReturnValue& operator=(const DkmRawReturnValue&);
        private: DkmRawReturnValue(const DkmRawReturnValue&);

        // DkmRawReturnValue is an abstract base class. This enum indicates which derived
        // class this object is an instance of.
        public: FORWARD_DECLARE_SCOPED_ENUM(Tag);
        DEFINE_SCOPED_ENUM(Tag)
        {
        // Object is an instance of 'DkmNativeRawReturnValue'.
        NativeRawReturnValue = 0,
        // Object is an instance of 'DkmCustomRawReturnValue'.
        CustomRawReturnValue = 1,
        // Object is an instance of 'DkmRawManagedReturnValue'.
        ManagedReturnValue = 2
        };

        private: const Tag_t m_TagValue;
        private: DkmInstructionAddress* const m_pReturnFrom;
        private: void* m__pExtendedData;

        // DkmRawReturnValue is an abstract base class. This enum indicates which derived
        // class this object is an instance of.
        public: DECLSPEC_NOTHROW Tag_t STDMETHODCALLTYPE TagValue(
            );

        // IP address within the symbol that was returned called and from.  Note that there's
        // no guarantee where in the function this address will be.
        public: _Ret_ DECLSPEC_NOTHROW DkmInstructionAddress* STDMETHODCALLTYPE ReturnFrom(
            );
    }; // end of DkmRawReturnValue

    // Reference object that can be used to attach data items to a DkmRawReturnValue.
    //
    // This API was introduced in Visual Studio 14 RTM (DkmApiVersion.VS14RTM).
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("b7478b79-2e9f-083d-2757-f1b2f20df1f5") DkmRawReturnValueContainer : public DkmDataContainer
    {
        // Use DkmRawReturnValueContainer::Create to create this object
        private: DkmRawReturnValueContainer();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmRawReturnValueContainer();
        // This object cannot be copied
        private: DkmRawReturnValueContainer& operator=(const DkmRawReturnValueContainer&);
        private: DkmRawReturnValueContainer(const DkmRawReturnValueContainer&);

        private: Evaluation::DkmInspectionSession* const m_pInspectionSession;
        private: const UINT32 m_Id;
        private: Evaluation::DkmRawReturnValue* const m_pRawReturnValue;
        private: void* m__pExtendedData;

        // The inspection session that owns this frame data object.
        //
        // This API was introduced in Visual Studio 14 RTM (DkmApiVersion.VS14RTM).
        public: _Ret_ DECLSPEC_NOTHROW Evaluation::DkmInspectionSession* STDMETHODCALLTYPE InspectionSession(
            );

        // Unique identifier of this return value.  The first return value is zero, then one,
        // etc.  Return value id's are unique only within a particular DkmInspectionSession.
        //
        // This API was introduced in Visual Studio 14 RTM (DkmApiVersion.VS14RTM).
        public: DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE Id(
            );

        // The DkmRawReturnValue object that this container refers to.
        //
        // This API was introduced in Visual Studio 14 RTM (DkmApiVersion.VS14RTM).
        public: _Ret_ DECLSPEC_NOTHROW Evaluation::DkmRawReturnValue* STDMETHODCALLTYPE RawReturnValue(
            );

        /// <summary>
        /// Create a new DkmRawReturnValueContainer object instance.
        ///
        /// This API was introduced in Visual Studio 14 RTM (DkmApiVersion.VS14RTM).
        /// </summary>
        /// <param name="pInspectionSession">
        /// [In] The inspection session that owns this frame data object.
        /// </param>
        /// <param name="Id">
        /// [In] Unique identifier of this return value.  The first return value is zero,
        /// then one, etc.  Return value id's are unique only within a particular
        /// DkmInspectionSession.
        /// </param>
        /// <param name="pRawReturnValue">
        /// [In] The DkmRawReturnValue object that this container refers to.
        /// </param>
        /// <param name="DataItem">
        /// [In] Data object to add to the new DkmRawReturnValueContainer instance.
        /// DkmDataItem::Null() in the case that the caller doesn't need to add a data item.
        /// </param>
        /// <param name="ppCreatedObject">
        /// [Out] Result of this method call.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ Evaluation::DkmInspectionSession* pInspectionSession,
            _In_ UINT32 Id,
            _In_ Evaluation::DkmRawReturnValue* pRawReturnValue,
            _In_ const DkmDataItem& DataItem,
            _Deref_out_ Evaluation::DkmRawReturnValueContainer** ppCreatedObject
            );
    }; // end of DkmRawReturnValueContainer

    // Flags the expression evaluator passes to the visualizer addin describing the value in
    // question. For instance, this will include if the object is a pointer or if it is a
    // reference.
    DEFINE_SCOPED_ENUM(DkmRootVisualizedExpressionFlags)
    {
        // No flags set.
        None = 0x1,
        // Deprecated; no longer used.
        IsPointer = 0x2,
        // Deprecated; no longer used.
        IsReference = 0x4,
        // Deprecated; no longer used.
        IsArray = 0x8
    };
    DEFINE_SCOPED_ENUM_FLAG_OPERATORS(DkmRootVisualizedExpressionFlags_t);

    // Flags that indicate what information is requested for a variable.
    DEFINE_SCOPED_ENUM(DkmVariableInfoFlags)
    {
        // No flags are set.
        None = 0x0,
        // Provide information about the types of variables.
        Types = 0x1,
        // Types names should be provided as an alias rather than in their full form. For
        // example, return 'std::map<int,int>' instead of
        // 'std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >'.
        // This flag is only valid when paired with the 'Types' flag.
        TypeAliases = 0x2,
        // Provide information about the names of variables.
        Names = 0x4,
        // Provide full names of the variables.
        FullNames = 0x8,
        // Provide information about the values of variables.  This flag is set for
        // GetFrameName() when the user has toggled the option "Show Parameter Values". This
        // flag is never set for calls to GetMethodName().
        Values = 0x10
    };
    DEFINE_SCOPED_ENUM_FLAG_OPERATORS(DkmVariableInfoFlags_t);

    // Guid value which, along with the DkmLanguageId, can identify the compiler/interpreter
    // used to compile/interpret the target code. The vendor id is used along with the
    // language id to select expression evaluators. This value is used as many compilers may
    // exist for the same programming language. But even though the compilers may all use the
    // same programming language, they will generally not be able to use the same expression
    // evaluator.
    struct DkmVendorId
    {
        // Indicates that the compiler/interpreter was produced by Microsoft.
        // Microsoft is defined as {994b45c4-e6e9-11d2-903f-00c04fa302a1}.
        static const GUID Microsoft;
    };
    __declspec(selectany) const GUID DkmVendorId::Microsoft = { 0x994b45c4, 0xe6e9, 0x11d2, { 0x90, 0x3f, 0x0, 0xc0, 0x4f, 0xa3, 0x2, 0xa1 } };

    // Dispatcher object used for custom visualization through a concord EE addin.
    //
    // Derived classes: DkmChildVisualizedExpression, DkmRootVisualizedExpression
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("2db1132d-77a6-ae00-a7f7-b2c910327b56") DkmVisualizedExpression : public DkmDataContainer
    {
        // Use DkmVisualizedExpression::Create to create this object
        private: DkmVisualizedExpression();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmVisualizedExpression();
        // This object cannot be copied
        private: DkmVisualizedExpression& operator=(const DkmVisualizedExpression&);
        private: DkmVisualizedExpression(const DkmVisualizedExpression&);

        // DkmVisualizedExpression is an abstract base class. This enum indicates which
        // derived class this object is an instance of.
        public: FORWARD_DECLARE_SCOPED_ENUM(Tag);
        DEFINE_SCOPED_ENUM(Tag)
        {
        // Object is an instance of 'DkmRootVisualizedExpression'.
        RootVisualizedExpression = 0,
        // Object is an instance of 'DkmChildVisualizedExpression'.
        ChildVisualizedExpression = 1
        };

        private: const Tag_t m_TagValue;
        private: Evaluation::DkmInspectionContext* const m_pInspectionContext;
        private: const GUID m_UniqueId;
        private: const GUID m_VisualizerId;
        private: const GUID m_SourceId;
        private: CallStack::DkmStackWalkFrame* const m_pStackFrame;
        private: OPTIONAL Evaluation::DkmExpressionValueHome* const m_pValueHome;
        private: void* m__pExtendedData;

        // DkmVisualizedExpression is an abstract base class. This enum indicates which
        // derived class this object is an instance of.
        public: DECLSPEC_NOTHROW Tag_t STDMETHODCALLTYPE TagValue(
            );

        // Options and target context to use while performing the inspection operation.
        public: _Ret_ DECLSPEC_NOTHROW Evaluation::DkmInspectionContext* STDMETHODCALLTYPE InspectionContext(
            );

        // Guid which uniquely identifies this instance.
        public: DECLSPEC_NOTHROW const GUID& STDMETHODCALLTYPE UniqueId(
            );

        // Guid which ties together the addin and the expressions that call that addin. The
        // addin should use the Guid provided in the native visualizer file as a filter.
        public: DECLSPEC_NOTHROW const GUID& STDMETHODCALLTYPE VisualizerId(
            );

        // Guid which ties together the expression evaluator that created this object and the
        // object itself. Generally used by expression evaluators to filter their
        // implementation of IDkmCustomVisualizerCallback to only DkmVisualizedExpression
        // they created.
        public: DECLSPEC_NOTHROW const GUID& STDMETHODCALLTYPE SourceId(
            );

        // Stack frame the expression is being evaluated in expression in.
        public: _Ret_ DECLSPEC_NOTHROW CallStack::DkmStackWalkFrame* STDMETHODCALLTYPE StackFrame(
            );

        // [Optional] The location at which the value is stored, which can be modified to
        // edit the value.  This should be null for read-only values, such as integer
        // constants.
        public: _Ret_opt_ DECLSPEC_NOTHROW Evaluation::DkmExpressionValueHome* STDMETHODCALLTYPE ValueHome(
            );

        // The InspectionSession allows the various components which examine data in the
        // target process to store private data with the same lifetime. Inspection sessions
        // are closed when the user attempts to continue the process.
        public: _Ret_ DECLSPEC_NOTHROW Evaluation::DkmInspectionSession* STDMETHODCALLTYPE InspectionSession(
            );

        // Indicates which runtime monitor will be used to perform this evaluation.
        public: _Ret_ DECLSPEC_NOTHROW DkmRuntimeInstance* STDMETHODCALLTYPE RuntimeInstance(
            );

        /// <summary>
        /// Closes a DkmVisualizedExpression object instance. This will release any resources
        /// associated with this object across all components. This includes resources across
        /// computer or managed/native marshalling boundaries.
        ///
        /// DkmVisualizedExpression objects are automatically closed when their associated
        /// DkmInspectionSession object is closed.
        /// </summary>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Close(
            );

        #ifndef EXCLUDE_IDE_ONLY_APIS
        /// <summary>
        /// Evaluate a visualized expression returning a DkmEvaluationResult for it.
        ///
        /// Location constraint: API must be called from an IDE component (component level
        /// &gt; 100,000).
        /// </summary>
        /// <param name="ppResultObject">
        /// [Out] Object containing the result of the evaluation. This object must be closed
        /// by the caller when the caller is done with the object. The expression evaluator
        /// reserves the right to override this instance so do not rely on storing data items
        /// in the DkmEvaluationResult instance. Use the DkmVisualizedExpression instance as
        /// a data container instead.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE EvaluateVisualizedExpression(
            _Deref_out_ Evaluation::DkmEvaluationResult** ppResultObject
            );
        #endif // #ifndef EXCLUDE_IDE_ONLY_APIS

        #ifndef EXCLUDE_IDE_ONLY_APIS
        /// <summary>
        /// Called by the expression evaluator when a visualized expression's children are
        /// being expanded, the the value is being set, or the underlying string is being
        /// obtained. If the visualizer addin wants complete control of the expression it
        /// should return false. It will then receive calls to GetChildren, GetItems,
        /// SetValueAsString, and GetUnderlyingString. If the visualizer addin wants to
        /// completely defer these operations to the expression evaluator, it should return
        /// true. It must also give the expression evaluator back the instance of
        /// DkmEvaluationResult that came from the EE via one of the
        /// IDkmCustomVisualizerCallback methods. Note that the addin MUST have obtained the
        /// default DkmEvaluationResult from the EE if it wants the EE to control the object.
        /// Returning true from this method is primarily used by visualizer addins that just
        /// tweak something small like the view of a value but don't want to modify expansion
        /// or setting values.
        ///
        /// Location constraint: API must be called from an IDE component (component level
        /// &gt; 100,000).
        /// </summary>
        /// <param name="pUseDefaultEvaluationBehavior">
        /// [Out] Return true to use default expansion, false otherwise.
        /// </param>
        /// <param name="ppDefaultEvaluationResult">
        /// [Out,Optional] The instance of DkmEvaluationResult returned from a call to one of
        /// the methods of IDkmCustomVisualizerCallback. The expression evaluator can only
        /// control DkmEvaluationResults it understands.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE UseDefaultEvaluationBehavior(
            _Out_ bool* pUseDefaultEvaluationBehavior,
            _Deref_out_opt_ Evaluation::DkmEvaluationResult** ppDefaultEvaluationResult
            );
        #endif // #ifndef EXCLUDE_IDE_ONLY_APIS

        #ifndef EXCLUDE_IDE_ONLY_APIS
        /// <summary>
        /// Gets an enumeration context used to obtain the children of this evaluation
        /// result. This is used in all expression evaluation windows.
        ///
        /// Location constraint: API must be called from an IDE component (component level
        /// &gt; 100,000).
        /// </summary>
        /// <param name="InitialRequestSize">
        /// [In] The initial number of children that the caller would like returned. This
        /// value can be zero if no children will be initially returned. This value may be
        /// larger than the number of children that this expression has, in which case all
        /// children should be returned. Very large or negative values should not be used as
        /// arrays can have extremely large sizes which would cause out-of-memory if all
        /// elements were requested.
        /// </param>
        /// <param name="pInspectionContext">
        /// [In] The inspection context to use for computing the children.  This may differ
        /// from the original inspection context with respect to settings, such as radix,
        /// evaluation flags, or timeout.
        /// </param>
        /// <param name="pInitialChildren">
        /// [Out] The initial children to return.
        ///
        /// The memory for the DkmArray members is allocated by the method implementation
        /// using DkmAllocBytes/DkmAllocArray. It is freed by the caller using the
        /// CAutoDkmArray template or with DkmFreeMemory and manual element release.
        /// </param>
        /// <param name="ppEnumContext">
        /// [Out] Context object used to enumerate the children. This object must be closed
        /// by the caller of this API when enumeration is complete.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetChildren(
            _In_ UINT32 InitialRequestSize,
            _In_ Evaluation::DkmInspectionContext* pInspectionContext,
            _Out_ DkmArray<Evaluation::DkmChildVisualizedExpression*>* pInitialChildren,
            _Deref_out_ Evaluation::DkmEvaluationResultEnumContext** ppEnumContext
            );
        #endif // #ifndef EXCLUDE_IDE_ONLY_APIS

        #ifndef EXCLUDE_IDE_ONLY_APIS
        /// <summary>
        /// Called to obtain items from a instance of DkmEvaluationResultEnumContext created
        /// by an earlier call to GetChildren.
        ///
        /// Location constraint: API must be called from an IDE component (component level
        /// &gt; 100,000).
        /// </summary>
        /// <param name="pEnumContext">
        /// [In] The enum context to use for this call. This instance will have been returned
        /// from a previous call to DkmVisualizedExpression.
        /// </param>
        /// <param name="StartIndex">
        /// [In] The zero-based index of the first item to obtain.
        /// </param>
        /// <param name="Count">
        /// [In] The number of items to try and return. This value may be larger than the
        /// total number of remaining items, in which case all remaining items should be
        /// returned. Very large or negative values should not be used as arrays can have
        /// extremely large sizes which would cause out-of-memory if all elements were
        /// requested.
        /// </param>
        /// <param name="pItems">
        /// [Out] The DkmChildVisualizedExpression items to return.
        ///
        /// The memory for the DkmArray members is allocated by the method implementation
        /// using DkmAllocBytes/DkmAllocArray. It is freed by the caller using the
        /// CAutoDkmArray template or with DkmFreeMemory and manual element release.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetItems(
            _In_ Evaluation::DkmEvaluationResultEnumContext* pEnumContext,
            _In_ UINT32 StartIndex,
            _In_ UINT32 Count,
            _Out_ DkmArray<Evaluation::DkmChildVisualizedExpression*>* pItems
            );
        #endif // #ifndef EXCLUDE_IDE_ONLY_APIS

        #ifndef EXCLUDE_IDE_ONLY_APIS
        /// <summary>
        /// Modifies the value of the given evaluation result (assumed to be non-read-only)
        /// to match the given string. This is used after the user edits a value in any of
        /// the evaluation windows.
        ///
        /// Location constraint: API must be called from an IDE component (component level
        /// &gt; 100,000).
        /// </summary>
        /// <param name="pValue">
        /// [In] Textual representation of value to assign to the evaluation result.
        /// </param>
        /// <param name="Timeout">
        /// [In] If a function evaluation is needed to assign the value, specifies the
        /// timeout to use.
        /// </param>
        /// <param name="ppErrorText">
        /// [Out,Optional] If the operation failed, this indicates the reason why. This value
        /// should be null if the operation succeeded. In native code, an S_OK return value
        /// is used when returning error text.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE SetValueAsString(
            _In_ DkmString* pValue,
            _In_ UINT32 Timeout,
            _Deref_out_opt_ DkmString** ppErrorText
            );
        #endif // #ifndef EXCLUDE_IDE_ONLY_APIS

        #ifndef EXCLUDE_IDE_ONLY_APIS
        /// <summary>
        /// This method is used for evaluation results that include
        /// DkmEvaluationResultFlags.RawString to obtain the the underlying string, with no
        /// enclosing quotes or escape sequences. This is method is invoked to display one of
        /// the various string visualizers in an expression evaluation window (click the
        /// magnifying glass icon).
        ///
        /// Location constraint: API must be called from an IDE component (component level
        /// &gt; 100,000).
        /// </summary>
        /// <param name="ppStringValue">
        /// [Out,Optional] The underlying string value.
        /// </param>
        /// <returns>
        /// S_OK is returned if *ppStringValue is non-NULL, S_FALSE is returned when
        /// *ppStringValue is NULL, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetUnderlyingString(
            _Deref_out_opt_ DkmString** ppStringValue
            );
        #endif // #ifndef EXCLUDE_IDE_ONLY_APIS

        #ifndef EXCLUDE_IDE_ONLY_APIS
        /// <summary>
        /// Allows custom expression evaluator addins to obtain the symbol interface for the
        /// type being visualized. This is not stored in the DkmVisualizedExpression directly
        /// to enable addins that live on the remote machine and do not depend on symbols.
        ///
        /// Location constraint: API must be called from an IDE component (component level
        /// &gt; 100,000).
        /// </summary>
        /// <param name="TypeSymbolInterfaceId">
        /// [In] The GUID of the TypeSymbolInterface interface requested from the caller. For
        /// the Microsoft native C++ expression evaluator, this should be IID_IDiaSymbol.
        /// </param>
        /// <param name="ppTypeSymbolInterface">
        /// [Out] The symbol interface of the type that was used to evaluate the expression.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetSymbolInterface(
            _In_ const GUID& TypeSymbolInterfaceId,
            _Deref_out_ IUnknown** ppTypeSymbolInterface
            );
        #endif // #ifndef EXCLUDE_IDE_ONLY_APIS

        /// <summary>
        /// This method allows a visualizer addin use the expression evaluator to compile and
        /// evaluate the default value for an expression. The addin can use this result as-is
        /// or override fields by creating a new result. The addin can also choose to use the
        /// expression evaluator for expansion using the the get children callbacks.
        /// </summary>
        /// <param name="pInspectionContext">
        /// [In] The inspection context to use for this evaluation.
        /// </param>
        /// <param name="pExpression">
        /// [In] The expression the visualizer addin to would like the expression evaluator
        /// to evaluate.
        /// </param>
        /// <param name="pStackFrame">
        /// [In] Stack frame to evaluate the expression in.
        /// </param>
        /// <param name="ppResultObject">
        /// [Out] Object containing the result of the evaluation.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// E_PROCESS_DESTROYED indicates that the process exited while attempting to
        /// evaluate.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE EvaluateExpressionCallback(
            _In_ Evaluation::DkmInspectionContext* pInspectionContext,
            _In_ Evaluation::DkmLanguageExpression* pExpression,
            _In_ CallStack::DkmStackWalkFrame* pStackFrame,
            _Deref_out_ Evaluation::DkmEvaluationResult** ppResultObject
            );

        /// <summary>
        /// This method will construct a default full name for a custom visualized child
        /// expression. This name will be the root expression's full name and an expand
        /// format string that will cause the expression evaluator to callback to the
        /// visualizer to obtain children. The DkmVisualizedExpression instance this is
        /// called on should be the parent visualized expression for a child and the root
        /// visualized expression for a root.
        /// </summary>
        /// <param name="Index">
        /// [In] The index of child for which this full name is created. Ignored in the case
        /// of a root item.
        /// </param>
        /// <param name="ppFullName">
        /// [Out] The returned full name string.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE CreateDefaultChildFullName(
            _In_ INT32 Index,
            _Deref_out_ DkmString** ppFullName
            );

        /// <summary>
        /// This method allows a visualizer addin use the expression evaluator for expansion.
        /// The evaluation result contained within the visualized expression must have come
        /// from the expression evaluator via EvaluateExpressionCallback.
        /// </summary>
        /// <param name="pDefaultEvaluationResult">
        /// [In] The evaluation result returned from the expression evaluator for this
        /// expression. The expression evaluator can only control the expansion of
        /// evaluations it understands.
        /// </param>
        /// <param name="InitialRequestSize">
        /// [In] The initial number of children that the caller would like returned. This
        /// value can be zero if no children will be initially returned. This value may be
        /// larger than the number of children that this expression has, in which case all
        /// children should be returned. Very large or negative values should not be used as
        /// arrays can have extremely large sizes which would cause out-of-memory if all
        /// elements were requested.
        /// </param>
        /// <param name="pInspectionContext">
        /// [In] The inspection context to use for computing the children.  This may differ
        /// from the original inspection context with respect to settings, such as radix,
        /// evaluation flags, or timeout.
        /// </param>
        /// <param name="pInitialChildren">
        /// [Out] The initial children to return. Each child must be closed by the caller
        /// when the caller is done.
        ///
        /// The memory for the DkmArray members is allocated by the method implementation
        /// using DkmAllocBytes/DkmAllocArray. It is freed by the caller using the
        /// CAutoDkmArray template or with DkmFreeMemory and manual element release.
        /// </param>
        /// <param name="ppEnumContext">
        /// [Out] Context object used to enumerate the children. This object must be closed
        /// by the caller of this API when enumeration is complete.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetChildrenCallback(
            _In_ Evaluation::DkmEvaluationResult* pDefaultEvaluationResult,
            _In_ UINT32 InitialRequestSize,
            _In_ Evaluation::DkmInspectionContext* pInspectionContext,
            _Out_ DkmArray<Evaluation::DkmEvaluationResult*>* pInitialChildren,
            _Deref_out_ Evaluation::DkmEvaluationResultEnumContext** ppEnumContext
            );

        /// <summary>
        /// This method allows a visualizer addin use the expression evaluator for expansion
        /// using the passed enumeration context. This is used to obtain local variables of a
        /// stack frame or child members from an evaluation result.
        /// </summary>
        /// <param name="pEnumContext">
        /// [In] Context object used to enumerate the children.
        /// </param>
        /// <param name="StartIndex">
        /// [In] The zero-based index of the first item to obtain.
        /// </param>
        /// <param name="Count">
        /// [In] The number of items to try and return. This value may be larger than the
        /// total number of remaining items, in which case all remaining items should be
        /// returned. Very large or negative values should not be used as arrays can have
        /// extremely large sizes which would cause out-of-memory if all elements were
        /// requested.
        /// </param>
        /// <param name="pItems">
        /// [Out] The DkmEvaluationResult items to return. Each item must be closed by the
        /// caller when the caller is done.
        ///
        /// The memory for the DkmArray members is allocated by the method implementation
        /// using DkmAllocBytes/DkmAllocArray. It is freed by the caller using the
        /// CAutoDkmArray template or with DkmFreeMemory and manual element release.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetItemsCallback(
            _In_ Evaluation::DkmEvaluationResultEnumContext* pEnumContext,
            _In_ UINT32 StartIndex,
            _In_ UINT32 Count,
            _Out_ DkmArray<Evaluation::DkmEvaluationResult*>* pItems
            );

        /// <summary>
        /// Modifies the value of the given evaluation result (assumed to be non-read-only)
        /// to match the given string. This is used after the user edits a value in any of
        /// the evaluation windows.
        /// </summary>
        /// <param name="pDefaultEvaluationResult">
        /// [In] The evaluation result returned from the expression evaluator for this
        /// expression. The expression evaluator can only control evaluations it understands.
        /// </param>
        /// <param name="pValue">
        /// [In] Textual representation of value to assign to the evaluation result.
        /// </param>
        /// <param name="Timeout">
        /// [In] If a function evaluation is needed to assign the value, specifies the
        /// timeout to use.
        /// </param>
        /// <param name="ppErrorText">
        /// [Out,Optional] If the operation failed, this indicates the reason why. This value
        /// should be null if the operation succeeded. In native code, an S_OK return value
        /// is used when returning error text.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE SetValueAsStringCallback(
            _In_ Evaluation::DkmEvaluationResult* pDefaultEvaluationResult,
            _In_ DkmString* pValue,
            _In_ UINT32 Timeout,
            _Deref_out_opt_ DkmString** ppErrorText
            );

        /// <summary>
        /// This method is used for evaluation results that include
        /// DkmEvaluationResultFlags.RawString to obtain the the underlying string, with no
        /// enclosing quotes or escape sequences. This is method is invoked to display one of
        /// the various string visualizers in an expression evaluation window (click the
        /// magnifying glass icon).
        /// </summary>
        /// <param name="pDefaultEvaluationResult">
        /// [In] The evaluation result returned from the expression evaluator for this
        /// expression. The expression evaluator can only control evaluations it understands.
        /// </param>
        /// <param name="ppStringValue">
        /// [Out,Optional] The underlying string value.
        /// </param>
        /// <returns>
        /// S_OK is returned if *ppStringValue is non-NULL, S_FALSE is returned when
        /// *ppStringValue is NULL, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetUnderlyingStringCallback(
            _In_ Evaluation::DkmEvaluationResult* pDefaultEvaluationResult,
            _Deref_out_opt_ DkmString** ppStringValue
            );
    }; // end of DkmVisualizedExpression


    // Dispatcher object which represents a child node of a visualized expression. Each node
    // returned from GetChildren / GetItems should be an instance of this object..
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("08e6ff27-0cdf-ea67-dc1a-4fa958d3fbbd") DkmChildVisualizedExpression : public Evaluation::DkmVisualizedExpression
    {
        // Use DkmChildVisualizedExpression::Create to create this object
        private: DkmChildVisualizedExpression();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmChildVisualizedExpression();
        // This object cannot be copied
        private: DkmChildVisualizedExpression& operator=(const DkmChildVisualizedExpression&);
        private: DkmChildVisualizedExpression(const DkmChildVisualizedExpression&);

        private: Evaluation::DkmEvaluationResult* const m_pEvaluationResult;
        private: Evaluation::DkmVisualizedExpression* const m_pParent;
        private: const UINT32 m_Index;
        private: void* m__pExtendedData;

        // The result of evaluating this visualized child. The expression evaluator reserves
        // the right to override this instance so do not rely on storing data items in the
        // DkmEvaluationResult instance. Use the DkmVisualizedExpression instance as a data
        // container instead.
        public: _Ret_ DECLSPEC_NOTHROW Evaluation::DkmEvaluationResult* STDMETHODCALLTYPE EvaluationResult(
            );

        // The Parent of this visualized child.
        public: _Ret_ DECLSPEC_NOTHROW Evaluation::DkmVisualizedExpression* STDMETHODCALLTYPE Parent(
            );

        // The index of this child in the parent object's child collection. The expression
        // evaluator will use this when processing the full name of a child item. The full
        // name is used when the user clicks on an item and says Add To Watch or when the
        // user types something in the watch window directly. If the visualizer does not
        // provide a full name, then callback to the expression evaluator to construct a
        // default expand expression  The value of the index field will be used to obtain the
        // correct expand expression.
        public: DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE Index(
            );

        // Attempt to cast a 'DkmVisualizedExpression' to a 'DkmChildVisualizedExpression'. Return
        // NULL if the path object is not a 'DkmChildVisualizedExpression'.
        // pChildVisualizedExpression : [In,Optional] Object to attempt to cast
        // Return Value : [Optional] Result of the cast.
        public: static DECLSPEC_NOTHROW DkmChildVisualizedExpression* TryCast(
            DkmVisualizedExpression* pVisualizedExpression
            )
        {
            if (pVisualizedExpression == NULL || pVisualizedExpression->TagValue() != Tag::ChildVisualizedExpression)
                return NULL;

            return static_cast<DkmChildVisualizedExpression*>(pVisualizedExpression);
        }

        /// <summary>
        /// Create a new DkmChildVisualizedExpression object instance.
        /// </summary>
        /// <param name="pInspectionContext">
        /// [In] Options and target context to use while performing the inspection operation.
        /// </param>
        /// <param name="VisualizerId">
        /// [In] Guid which ties together the addin and the expressions that call that addin.
        /// The addin should use the Guid provided in the native visualizer file as a filter.
        /// </param>
        /// <param name="SourceId">
        /// [In] Guid which ties together the expression evaluator that created this object
        /// and the object itself. Generally used by expression evaluators to filter their
        /// implementation of IDkmCustomVisualizerCallback to only DkmVisualizedExpression
        /// they created.
        /// </param>
        /// <param name="pStackFrame">
        /// [In] Stack frame the expression is being evaluated in expression in.
        /// </param>
        /// <param name="pValueHome">
        /// [In,Optional] The location at which the value is stored, which can be modified to
        /// edit the value.  This should be null for read-only values, such as integer
        /// constants.
        /// </param>
        /// <param name="pEvaluationResult">
        /// [In] The result of evaluating this visualized child. The expression evaluator
        /// reserves the right to override this instance so do not rely on storing data items
        /// in the DkmEvaluationResult instance. Use the DkmVisualizedExpression instance as
        /// a data container instead.
        /// </param>
        /// <param name="pParent">
        /// [In] The Parent of this visualized child.
        /// </param>
        /// <param name="Index">
        /// [In] The index of this child in the parent object's child collection. The
        /// expression evaluator will use this when processing the full name of a child item.
        /// The full name is used when the user clicks on an item and says Add To Watch or
        /// when the user types something in the watch window directly. If the visualizer
        /// does not provide a full name, then callback to the expression evaluator to
        /// construct a default expand expression  The value of the index field will be used
        /// to obtain the correct expand expression.
        /// </param>
        /// <param name="DataItem">
        /// [In] Data object to add to the new DkmChildVisualizedExpression instance.
        /// DkmDataItem::Null() in the case that the caller doesn't need to add a data item.
        /// </param>
        /// <param name="ppCreatedObject">
        /// [Out] Result of this method call.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ Evaluation::DkmInspectionContext* pInspectionContext,
            _In_ const GUID& VisualizerId,
            _In_ const GUID& SourceId,
            _In_ CallStack::DkmStackWalkFrame* pStackFrame,
            _In_opt_ Evaluation::DkmExpressionValueHome* pValueHome,
            _In_ Evaluation::DkmEvaluationResult* pEvaluationResult,
            _In_ Evaluation::DkmVisualizedExpression* pParent,
            _In_ UINT32 Index,
            _In_ const DkmDataItem& DataItem,
            _Deref_out_ Evaluation::DkmChildVisualizedExpression** ppCreatedObject
            );
    }; // end of DkmChildVisualizedExpression

    // An inspection query compiled to a custom format. The RuntimeType indicates the format
    // of the query.
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("951e8d5e-e5f3-78d8-3492-0b2615b06e42") DkmCompiledCustomInspectionQuery : public Evaluation::DkmCompiledInspectionQuery
    {
        // Use DkmCompiledCustomInspectionQuery::Create to create this object
        private: DkmCompiledCustomInspectionQuery();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmCompiledCustomInspectionQuery();
        // This object cannot be copied
        private: DkmCompiledCustomInspectionQuery& operator=(const DkmCompiledCustomInspectionQuery&);
        private: DkmCompiledCustomInspectionQuery(const DkmCompiledCustomInspectionQuery&);

        private: DkmReadOnlyCollection<BYTE>* const m_pInstructions;
        private: void* m__pExtendedData;

        // Body of the query.
        public: _Ret_ DECLSPEC_NOTHROW DkmReadOnlyCollection<BYTE>* STDMETHODCALLTYPE Instructions(
            );

        // Attempt to cast a 'DkmCompiledInspectionQuery' to a 'DkmCompiledCustomInspectionQuery'. Return
        // NULL if the path object is not a 'DkmCompiledCustomInspectionQuery'.
        // pCustomQuery : [In,Optional] Object to attempt to cast
        // Return Value : [Optional] Result of the cast.
        public: static DECLSPEC_NOTHROW DkmCompiledCustomInspectionQuery* TryCast(
            DkmCompiledInspectionQuery* pQuery
            )
        {
            if (pQuery == NULL || pQuery->TagValue() != Tag::CustomQuery)
                return NULL;

            return static_cast<DkmCompiledCustomInspectionQuery*>(pQuery);
        }

        /// <summary>
        /// Create a new DkmCompiledCustomInspectionQuery object instance.
        /// </summary>
        /// <param name="pRuntimeInstance">
        /// [In] The DkmRuntimeInstance class represents an execution environment which is
        /// loaded into a DkmProcess and which contains code to be debugged.
        /// </param>
        /// <param name="QueryKind">
        /// [In] Indicates the type of inspection query. This is used to select a component
        /// to process the query.
        /// </param>
        /// <param name="pInstructions">
        /// [In] Body of the query.
        /// </param>
        /// <param name="ppCreatedObject">
        /// [Out] Result of this method call.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ DkmRuntimeInstance* pRuntimeInstance,
            _In_ const GUID& QueryKind,
            _In_ DkmReadOnlyCollection<BYTE>* pInstructions,
            _Deref_out_ Evaluation::DkmCompiledCustomInspectionQuery** ppCreatedObject
            );

        /// <summary>
        /// Create a new DkmCompiledCustomInspectionQuery object instance.
        ///
        /// This API was introduced in Visual Studio 14 RTM (DkmApiVersion.VS14RTM).
        /// </summary>
        /// <param name="pRuntimeInstance">
        /// [In] The DkmRuntimeInstance class represents an execution environment which is
        /// loaded into a DkmProcess and which contains code to be debugged.
        /// </param>
        /// <param name="QueryKind">
        /// [In] Indicates the type of inspection query. This is used to select a component
        /// to process the query.
        /// </param>
        /// <param name="pDataContainer">
        /// [In,Optional] Custom Data to associate with this inspection query.  It will
        /// persist as long as the query has the potential to execute.
        /// </param>
        /// <param name="LanguageId">
        /// [In] The language of the expression evaluator that created this query.
        /// </param>
        /// <param name="pInstructions">
        /// [In] Body of the query.
        /// </param>
        /// <param name="ppCreatedObject">
        /// [Out] Result of this method call.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ DkmRuntimeInstance* pRuntimeInstance,
            _In_ const GUID& QueryKind,
            _In_opt_ Evaluation::DkmCustomDataContainer* pDataContainer,
            _In_ const Evaluation::DkmCompilerId& LanguageId,
            _In_ DkmReadOnlyCollection<BYTE>* pInstructions,
            _Deref_out_ Evaluation::DkmCompiledCustomInspectionQuery** ppCreatedObject
            );
    }; // end of DkmCompiledCustomInspectionQuery

    // DkmCustomRawReturnValue carries sufficient context that can be used to partially
    // reconstruct and visualize a function-call's return value in a custom runtime
    // environment.
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("911c2fd8-96c3-e527-3e60-c2dc9c429d21") DkmCustomRawReturnValue : public Evaluation::DkmRawReturnValue
    {
        // Use DkmCustomRawReturnValue::Create to create this object
        private: DkmCustomRawReturnValue();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmCustomRawReturnValue();
        // This object cannot be copied
        private: DkmCustomRawReturnValue& operator=(const DkmCustomRawReturnValue&);
        private: DkmCustomRawReturnValue(const DkmCustomRawReturnValue&);

        private: DkmReadOnlyCollection<BYTE>* const m_pValue;
        private: void* m__pExtendedData;

        // Custom raw return value.
        public: _Ret_ DECLSPEC_NOTHROW DkmReadOnlyCollection<BYTE>* STDMETHODCALLTYPE Value(
            );

        // Attempt to cast a 'DkmRawReturnValue' to a 'DkmCustomRawReturnValue'. Return
        // NULL if the path object is not a 'DkmCustomRawReturnValue'.
        // pCustomRawReturnValue : [In,Optional] Object to attempt to cast
        // Return Value : [Optional] Result of the cast.
        public: static DECLSPEC_NOTHROW DkmCustomRawReturnValue* TryCast(
            DkmRawReturnValue* pRawReturnValue
            )
        {
            if (pRawReturnValue == NULL || pRawReturnValue->TagValue() != Tag::CustomRawReturnValue)
                return NULL;

            return static_cast<DkmCustomRawReturnValue*>(pRawReturnValue);
        }

        /// <summary>
        /// Create a new DkmCustomRawReturnValue object instance.
        /// </summary>
        /// <param name="pReturnFrom">
        /// [In] IP address within the symbol that was returned called and from.  Note that
        /// there's no guarantee where in the function this address will be.
        /// </param>
        /// <param name="pValue">
        /// [In] Custom raw return value.
        /// </param>
        /// <param name="ppCreatedObject">
        /// [Out] Result of this method call.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ DkmInstructionAddress* pReturnFrom,
            _In_ DkmReadOnlyCollection<BYTE>* pValue,
            _Deref_out_ Evaluation::DkmCustomRawReturnValue** ppCreatedObject
            );
    }; // end of DkmCustomRawReturnValue

    // The formatted result of a failed evaluation, ready to be displayed in an expression
    // evaluation window.
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("066fdcd5-e1d5-a0ba-95c4-f4c4973557fc") DkmFailedEvaluationResult : public Evaluation::DkmEvaluationResult
    {
        // Use DkmFailedEvaluationResult::Create to create this object
        private: DkmFailedEvaluationResult();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmFailedEvaluationResult();
        // This object cannot be copied
        private: DkmFailedEvaluationResult& operator=(const DkmFailedEvaluationResult&);
        private: DkmFailedEvaluationResult(const DkmFailedEvaluationResult&);

        // Contains additional fields of DkmFailedEvaluationResult which were added after the
        // class was initally introduced.
        private: struct ___ExtendedData
        {
            ___ExtendedData();

            // [Optional] A string that describes the type of the value.
            OPTIONAL DkmString* const pType;
        };

        private: DkmString* const m_pErrorMessage;
        private: const Evaluation::DkmEvaluationResultFlags_t m_Flags;
        private: ___ExtendedData* const m__pExtendedData;

        // Specifies the error message to display to the user.
        public: _Ret_ DECLSPEC_NOTHROW DkmString* STDMETHODCALLTYPE ErrorMessage(
            );

        // Flags which indicate attributes of an expression evaluation result.
        public: DECLSPEC_NOTHROW Evaluation::DkmEvaluationResultFlags_t STDMETHODCALLTYPE Flags(
            );

        // [Optional] A string that describes the type of the value.
        //
        // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
        public: _Ret_opt_ DECLSPEC_NOTHROW DkmString* STDMETHODCALLTYPE Type(
            );

        // Attempt to cast a 'DkmEvaluationResult' to a 'DkmFailedEvaluationResult'. Return
        // NULL if the path object is not a 'DkmFailedEvaluationResult'.
        // pFailedResult : [In,Optional] Object to attempt to cast
        // Return Value : [Optional] Result of the cast.
        public: static DECLSPEC_NOTHROW DkmFailedEvaluationResult* TryCast(
            DkmEvaluationResult* pResult
            )
        {
            if (pResult == NULL || pResult->TagValue() != Tag::FailedResult)
                return NULL;

            return static_cast<DkmFailedEvaluationResult*>(pResult);
        }

        /// <summary>
        /// Create a new DkmFailedEvaluationResult object instance.
        /// </summary>
        /// <param name="pInspectionContext">
        /// [In] Inspection context used to create this evaluation result.
        /// </param>
        /// <param name="pStackFrame">
        /// [In] The stack frame this expression result was created on.
        /// </param>
        /// <param name="pName">
        /// [In] The name of the expression this result applies to.
        /// </param>
        /// <param name="pFullName">
        /// [In,Optional] The full name of the expression this result applies to. This value
        /// is used to allow child elements to be added to the watch window (Add Watch from
        /// the context menu), and to refresh parts of the evaluation tree. As an example of
        /// how FullName differs from name, the name of the 0th element of an array in C++ is
        /// '[0]' while the full name would by 'myArrayVariable[0]'. For Visual Studio 14 and
        /// later it's possible to calculate the full name later if needed. To do this, the
        /// expression evaluator should create the DkmEvaluationResult with a null full name
        /// and implement IDkmFullNameProvider.  Concord will then call
        /// IDkmFullNameProvider.CalculateFullName to get the full name when needed in the
        /// UI.
        /// </param>
        /// <param name="pErrorMessage">
        /// [In] Specifies the error message to display to the user.
        /// </param>
        /// <param name="Flags">
        /// [In] Flags which indicate attributes of an expression evaluation result.
        /// </param>
        /// <param name="DataItem">
        /// [In] Data object to add to the new DkmFailedEvaluationResult instance.
        /// DkmDataItem::Null() in the case that the caller doesn't need to add a data item.
        /// </param>
        /// <param name="ppCreatedObject">
        /// [Out] Result of this method call.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ Evaluation::DkmInspectionContext* pInspectionContext,
            _In_ CallStack::DkmStackWalkFrame* pStackFrame,
            _In_ DkmString* pName,
            _In_opt_ DkmString* pFullName,
            _In_ DkmString* pErrorMessage,
            _In_ Evaluation::DkmEvaluationResultFlags_t Flags,
            _In_ const DkmDataItem& DataItem,
            _Deref_out_ Evaluation::DkmFailedEvaluationResult** ppCreatedObject
            );

        /// <summary>
        /// Create a new DkmFailedEvaluationResult object instance.
        ///
        /// This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
        /// </summary>
        /// <param name="pInspectionContext">
        /// [In] Inspection context used to create this evaluation result.
        /// </param>
        /// <param name="pStackFrame">
        /// [In] The stack frame this expression result was created on.
        /// </param>
        /// <param name="pName">
        /// [In] The name of the expression this result applies to.
        /// </param>
        /// <param name="pFullName">
        /// [In,Optional] The full name of the expression this result applies to. This value
        /// is used to allow child elements to be added to the watch window (Add Watch from
        /// the context menu), and to refresh parts of the evaluation tree. As an example of
        /// how FullName differs from name, the name of the 0th element of an array in C++ is
        /// '[0]' while the full name would by 'myArrayVariable[0]'. For Visual Studio 14 and
        /// later it's possible to calculate the full name later if needed. To do this, the
        /// expression evaluator should create the DkmEvaluationResult with a null full name
        /// and implement IDkmFullNameProvider.  Concord will then call
        /// IDkmFullNameProvider.CalculateFullName to get the full name when needed in the
        /// UI.
        /// </param>
        /// <param name="pErrorMessage">
        /// [In] Specifies the error message to display to the user.
        /// </param>
        /// <param name="Flags">
        /// [In] Flags which indicate attributes of an expression evaluation result.
        /// </param>
        /// <param name="pType">
        /// [In,Optional] A string that describes the type of the value.
        /// </param>
        /// <param name="DataItem">
        /// [In] Data object to add to the new DkmFailedEvaluationResult instance.
        /// DkmDataItem::Null() in the case that the caller doesn't need to add a data item.
        /// </param>
        /// <param name="ppCreatedObject">
        /// [Out] Result of this method call.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ Evaluation::DkmInspectionContext* pInspectionContext,
            _In_ CallStack::DkmStackWalkFrame* pStackFrame,
            _In_ DkmString* pName,
            _In_opt_ DkmString* pFullName,
            _In_ DkmString* pErrorMessage,
            _In_ Evaluation::DkmEvaluationResultFlags_t Flags,
            _In_opt_ DkmString* pType,
            _In_ const DkmDataItem& DataItem,
            _Deref_out_ Evaluation::DkmFailedEvaluationResult** ppCreatedObject
            );
    }; // end of DkmFailedEvaluationResult

    // An instance of DkmExpressionValueHome that does not represent anything real. Normally
    // used to represent values that do not actually exist in the debuggee.
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("c9ee3ff6-d57e-80e4-f57e-e00fad2f7fab") DkmFakeValueHome : public Evaluation::DkmExpressionValueHome
    {
        // Use DkmFakeValueHome::Create to create this object
        private: DkmFakeValueHome();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmFakeValueHome();
        // This object cannot be copied
        private: DkmFakeValueHome& operator=(const DkmFakeValueHome&);
        private: DkmFakeValueHome(const DkmFakeValueHome&);

        private: const UINT64 m_Address;
        private: void* m__pExtendedData;

        // Deprecated.  Do not use.
        public: DECLSPEC_NOTHROW UINT64 STDMETHODCALLTYPE Address(
            );

        // Attempt to cast a 'DkmExpressionValueHome' to a 'DkmFakeValueHome'. Return
        // NULL if the path object is not a 'DkmFakeValueHome'.
        // pFakeValueHome : [In,Optional] Object to attempt to cast
        // Return Value : [Optional] Result of the cast.
        public: static DECLSPEC_NOTHROW DkmFakeValueHome* TryCast(
            DkmExpressionValueHome* pExpressionValueHome
            )
        {
            if (pExpressionValueHome == NULL || pExpressionValueHome->TagValue() != Tag::FakeValueHome)
                return NULL;

            return static_cast<DkmFakeValueHome*>(pExpressionValueHome);
        }

        /// <summary>
        /// Create a new DkmFakeValueHome object instance.
        /// </summary>
        /// <param name="Address">
        /// [In] Deprecated.  Do not use.
        /// </param>
        /// <param name="ppCreatedObject">
        /// [Out] Result of this method call.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ UINT64 Address,
            _Deref_out_ Evaluation::DkmFakeValueHome** ppCreatedObject
            );
    }; // end of DkmFakeValueHome

    // The formatted result of an evaluation that must be re-evaluated by a different
    // Expression Evaluator.
    //
    // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("1fe38f12-16e3-0c9d-7bdb-91aabf324221") DkmIntermediateEvaluationResult : public Evaluation::DkmEvaluationResult
    {
        // Use DkmIntermediateEvaluationResult::Create to create this object
        private: DkmIntermediateEvaluationResult();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmIntermediateEvaluationResult();
        // This object cannot be copied
        private: DkmIntermediateEvaluationResult& operator=(const DkmIntermediateEvaluationResult&);
        private: DkmIntermediateEvaluationResult(const DkmIntermediateEvaluationResult&);

        private: DkmString* const m_pExpression;
        private: Evaluation::DkmLanguage* const m_pIntermediateLanguage;
        private: DkmRuntimeInstance* const m_pTargetRuntime;
        private: void* m__pExtendedData;

        // Expression that should be evaluated by a different Expression Evaluator than the
        // one that generated the DkmIntermediateResult.
        //
        // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
        public: _Ret_ DECLSPEC_NOTHROW DkmString* STDMETHODCALLTYPE Expression(
            );

        // The language of Expression.  This is different from
        // DkmEvaluationResult->Language(), which specifies the language of the initial
        // evaluation. IntermediateLanguage specifies the language of the re-evaluation.
        //
        // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
        public: _Ret_ DECLSPEC_NOTHROW Evaluation::DkmLanguage* STDMETHODCALLTYPE IntermediateLanguage(
            );

        // The runtime of the Expression Evaluator that would consume the intermediate result
        // and produce a final result.
        //
        // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
        public: _Ret_ DECLSPEC_NOTHROW DkmRuntimeInstance* STDMETHODCALLTYPE TargetRuntime(
            );

        // Attempt to cast a 'DkmEvaluationResult' to a 'DkmIntermediateEvaluationResult'. Return
        // NULL if the path object is not a 'DkmIntermediateEvaluationResult'.
        // pIntermediateResult : [In,Optional] Object to attempt to cast
        // Return Value : [Optional] Result of the cast.
        public: static DECLSPEC_NOTHROW DkmIntermediateEvaluationResult* TryCast(
            DkmEvaluationResult* pResult
            )
        {
            if (pResult == NULL || pResult->TagValue() != Tag::IntermediateResult)
                return NULL;

            return static_cast<DkmIntermediateEvaluationResult*>(pResult);
        }

        /// <summary>
        /// Create a new DkmIntermediateEvaluationResult object instance.
        ///
        /// This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
        /// </summary>
        /// <param name="pInspectionContext">
        /// [In] Inspection context used to create this evaluation result.
        /// </param>
        /// <param name="pStackFrame">
        /// [In] The stack frame this expression result was created on.
        /// </param>
        /// <param name="pName">
        /// [In] The name of the expression this result applies to.
        /// </param>
        /// <param name="pFullName">
        /// [In,Optional] The full name of the expression this result applies to. This value
        /// is used to allow child elements to be added to the watch window (Add Watch from
        /// the context menu), and to refresh parts of the evaluation tree. As an example of
        /// how FullName differs from name, the name of the 0th element of an array in C++ is
        /// '[0]' while the full name would by 'myArrayVariable[0]'. For Visual Studio 14 and
        /// later it's possible to calculate the full name later if needed. To do this, the
        /// expression evaluator should create the DkmEvaluationResult with a null full name
        /// and implement IDkmFullNameProvider.  Concord will then call
        /// IDkmFullNameProvider.CalculateFullName to get the full name when needed in the
        /// UI.
        /// </param>
        /// <param name="pExpression">
        /// [In] Expression that should be evaluated by a different Expression Evaluator than
        /// the one that generated the DkmIntermediateResult.
        /// </param>
        /// <param name="pIntermediateLanguage">
        /// [In] The language of Expression.  This is different from
        /// DkmEvaluationResult-&gt;Language(), which specifies the language of the initial
        /// evaluation. IntermediateLanguage specifies the language of the re-evaluation.
        /// </param>
        /// <param name="pTargetRuntime">
        /// [In] The runtime of the Expression Evaluator that would consume the intermediate
        /// result and produce a final result.
        /// </param>
        /// <param name="DataItem">
        /// [In] Data object to add to the new DkmIntermediateEvaluationResult instance.
        /// DkmDataItem::Null() in the case that the caller doesn't need to add a data item.
        /// </param>
        /// <param name="ppCreatedObject">
        /// [Out] Result of this method call.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ Evaluation::DkmInspectionContext* pInspectionContext,
            _In_ CallStack::DkmStackWalkFrame* pStackFrame,
            _In_ DkmString* pName,
            _In_opt_ DkmString* pFullName,
            _In_ DkmString* pExpression,
            _In_ Evaluation::DkmLanguage* pIntermediateLanguage,
            _In_ DkmRuntimeInstance* pTargetRuntime,
            _In_ const DkmDataItem& DataItem,
            _Deref_out_ Evaluation::DkmIntermediateEvaluationResult** ppCreatedObject
            );
    }; // end of DkmIntermediateEvaluationResult

    // DkmNativeRawReturnValue carries sufficient context that can be used to partially
    // reconstruct and visualize a function-call's return value within the context of Native
    // stepping.
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("694dbdcd-80b2-9743-a624-3629d195f5b4") DkmNativeRawReturnValue : public Evaluation::DkmRawReturnValue
    {
        // Use DkmNativeRawReturnValue::Create to create this object
        private: DkmNativeRawReturnValue();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmNativeRawReturnValue();
        // This object cannot be copied
        private: DkmNativeRawReturnValue& operator=(const DkmNativeRawReturnValue&);
        private: DkmNativeRawReturnValue(const DkmNativeRawReturnValue&);

        private: DkmReadOnlyCollection<Evaluation::DkmNativeReturnValueRegister*>* const m_pRegisters;
        private: DkmReadOnlyCollection<BYTE>* const m_pMemory;
        private: void* m__pExtendedData;

        // Set of platform dependent registers that may hold the return value.
        public: _Ret_ DECLSPEC_NOTHROW DkmReadOnlyCollection<Evaluation::DkmNativeReturnValueRegister*>* STDMETHODCALLTYPE Registers(
            );

        // The result of copying some (platform dependent) number of bytes at the address
        // referenced by the (platform dependent) return-value register.  May be used to
        // provide visualizations for pointer return values.
        public: _Ret_ DECLSPEC_NOTHROW DkmReadOnlyCollection<BYTE>* STDMETHODCALLTYPE Memory(
            );

        // Attempt to cast a 'DkmRawReturnValue' to a 'DkmNativeRawReturnValue'. Return
        // NULL if the path object is not a 'DkmNativeRawReturnValue'.
        // pNativeRawReturnValue : [In,Optional] Object to attempt to cast
        // Return Value : [Optional] Result of the cast.
        public: static DECLSPEC_NOTHROW DkmNativeRawReturnValue* TryCast(
            DkmRawReturnValue* pRawReturnValue
            )
        {
            if (pRawReturnValue == NULL || pRawReturnValue->TagValue() != Tag::NativeRawReturnValue)
                return NULL;

            return static_cast<DkmNativeRawReturnValue*>(pRawReturnValue);
        }

        /// <summary>
        /// Create a new DkmNativeRawReturnValue object instance.
        /// </summary>
        /// <param name="pReturnFrom">
        /// [In] IP address within the symbol that was returned called and from.  Note that
        /// there's no guarantee where in the function this address will be.
        /// </param>
        /// <param name="pRegisters">
        /// [In] Set of platform dependent registers that may hold the return value.
        /// </param>
        /// <param name="pMemory">
        /// [In] The result of copying some (platform dependent) number of bytes at the
        /// address referenced by the (platform dependent) return-value register.  May be
        /// used to provide visualizations for pointer return values.
        /// </param>
        /// <param name="ppCreatedObject">
        /// [Out] Result of this method call.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ DkmInstructionAddress* pReturnFrom,
            _In_ DkmReadOnlyCollection<Evaluation::DkmNativeReturnValueRegister*>* pRegisters,
            _In_ DkmReadOnlyCollection<BYTE>* pMemory,
            _Deref_out_ Evaluation::DkmNativeRawReturnValue** ppCreatedObject
            );
    }; // end of DkmNativeRawReturnValue

    // An instance of DkmExpressionValueHome that defines a linear address in the debuggee.
    // The expression evaluator addin should format the object pointed to by this address.
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("bea748f3-61f0-5175-ef91-1b4b1f6e4cca") DkmPointerValueHome : public Evaluation::DkmExpressionValueHome
    {
        // Use DkmPointerValueHome::Create to create this object
        private: DkmPointerValueHome();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmPointerValueHome();
        // This object cannot be copied
        private: DkmPointerValueHome& operator=(const DkmPointerValueHome&);
        private: DkmPointerValueHome(const DkmPointerValueHome&);

        private: const UINT64 m_Address;
        private: void* m__pExtendedData;

        // A straight linear address in the debuggee process.
        public: DECLSPEC_NOTHROW UINT64 STDMETHODCALLTYPE Address(
            );

        // Attempt to cast a 'DkmExpressionValueHome' to a 'DkmPointerValueHome'. Return
        // NULL if the path object is not a 'DkmPointerValueHome'.
        // pPointerValueHome : [In,Optional] Object to attempt to cast
        // Return Value : [Optional] Result of the cast.
        public: static DECLSPEC_NOTHROW DkmPointerValueHome* TryCast(
            DkmExpressionValueHome* pExpressionValueHome
            )
        {
            if (pExpressionValueHome == NULL || pExpressionValueHome->TagValue() != Tag::PointerValueHome)
                return NULL;

            return static_cast<DkmPointerValueHome*>(pExpressionValueHome);
        }

        /// <summary>
        /// Create a new DkmPointerValueHome object instance.
        /// </summary>
        /// <param name="Address">
        /// [In] A straight linear address in the debuggee process.
        /// </param>
        /// <param name="ppCreatedObject">
        /// [Out] Result of this method call.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ UINT64 Address,
            _Deref_out_ Evaluation::DkmPointerValueHome** ppCreatedObject
            );
    }; // end of DkmPointerValueHome

    // DkmRawManagedReturnValue carries method-call's return value within the context of
    // managed stepping.
    //
    // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("bac1944f-d24a-e177-8b80-48d02d5b4839") DkmRawManagedReturnValue : public Evaluation::DkmRawReturnValue
    {
        // Use DkmRawManagedReturnValue::Create to create this object
        private: DkmRawManagedReturnValue();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmRawManagedReturnValue();
        // This object cannot be copied
        private: DkmRawManagedReturnValue& operator=(const DkmRawManagedReturnValue&);
        private: DkmRawManagedReturnValue(const DkmRawManagedReturnValue&);

        private: Clr::DkmManagedReturnValueContext* const m_pContext;
        private: void* m__pExtendedData;

        // Context information wraps method's return value.
        //
        // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
        public: _Ret_ DECLSPEC_NOTHROW Clr::DkmManagedReturnValueContext* STDMETHODCALLTYPE Context(
            );

        // Attempt to cast a 'DkmRawReturnValue' to a 'DkmRawManagedReturnValue'. Return
        // NULL if the path object is not a 'DkmRawManagedReturnValue'.
        // pManagedReturnValue : [In,Optional] Object to attempt to cast
        // Return Value : [Optional] Result of the cast.
        public: static DECLSPEC_NOTHROW DkmRawManagedReturnValue* TryCast(
            DkmRawReturnValue* pRawReturnValue
            )
        {
            if (pRawReturnValue == NULL || pRawReturnValue->TagValue() != Tag::ManagedReturnValue)
                return NULL;

            return static_cast<DkmRawManagedReturnValue*>(pRawReturnValue);
        }

        /// <summary>
        /// Create a new DkmRawManagedReturnValue object instance.
        ///
        /// This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
        /// </summary>
        /// <param name="pReturnFrom">
        /// [In] IP address within the symbol that was returned called and from.  Note that
        /// there's no guarantee where in the function this address will be.
        /// </param>
        /// <param name="pContext">
        /// [In] Context information wraps method's return value.
        /// </param>
        /// <param name="ppCreatedObject">
        /// [Out] Result of this method call.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ DkmInstructionAddress* pReturnFrom,
            _In_ Clr::DkmManagedReturnValueContext* pContext,
            _Deref_out_ Evaluation::DkmRawManagedReturnValue** ppCreatedObject
            );
    }; // end of DkmRawManagedReturnValue

    // Dispatcher object which represents a top-level visualized expression. An instance is
    // created by the expression evaluator when it determines a type should be visualized.
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("78ad085c-7b73-5937-a063-e2c7f4ee6556") DkmRootVisualizedExpression : public Evaluation::DkmVisualizedExpression
    {
        // Use DkmRootVisualizedExpression::Create to create this object
        private: DkmRootVisualizedExpression();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmRootVisualizedExpression();
        // This object cannot be copied
        private: DkmRootVisualizedExpression& operator=(const DkmRootVisualizedExpression&);
        private: DkmRootVisualizedExpression(const DkmRootVisualizedExpression&);

        // Contains additional fields of DkmRootVisualizedExpression which were added after
        // the class was initally introduced.
        private: struct ___ExtendedData
        {
            ___ExtendedData();

            // [Optional] The type of the object being inspected.  This is often the same
            // type that is being referred to by the natvis entry that triggered the addin.
            // However, it can also be a pointer or reference to the type, or even a base or
            // derived class of the type. The addin should make no assumptions about what is
            // in this string and should not attempt to parse it to obtain information about
            // the object.  Most addins should pass this string along through, as is to the
            // 'Type' property of the evaluation result they create.  However, an addin may
            // choose to add additional annotations to the 'Type' string before returning it
            // back. Except for a hint of what to put in the 'Type' field of the result, this
            // string is irrelevant to the visualization of the object.  Regardless of
            // whether the original object is a pointer, reference, base type, or derived
            // type, the supplied DkmExpressionValueHome will always identify the location of
            // the object itself, never a pointer or reference to the object. An empty type
            // string may be passed in here if the type of the evaluation result does not
            // matter for the scenario in which the visualizer is being invoked.
            OPTIONAL DkmString* const pType;
        };

        private: OPTIONAL Symbols::DkmModule* const m_pModule;
        private: DkmString* const m_pName;
        private: DkmString* const m_pFullName;
        private: const Evaluation::DkmRootVisualizedExpressionFlags_t m_Flags;
        private: const UINT32 m_ArrayLength;
        private: ___ExtendedData* const m__pExtendedData;

        // [Optional] The module that contains the type symbol.
        public: _Ret_opt_ DECLSPEC_NOTHROW Symbols::DkmModule* STDMETHODCALLTYPE Module(
            );

        // The name of the expression up to the root node. Addins can choose to use this name
        // or construct their own.
        public: _Ret_ DECLSPEC_NOTHROW DkmString* STDMETHODCALLTYPE Name(
            );

        // The full name of the expression up to the root node. Addins can choose to use this
        // full name or construct their own. However, if the addin uses a different full
        // name, it must be parsed by the expression evaluator.
        public: _Ret_ DECLSPEC_NOTHROW DkmString* STDMETHODCALLTYPE FullName(
            );

        // Flags the expression evaluator passes to the visualizer addin describing the value
        // in question. For instance, this will include if the object is a pointer or if it
        // is a reference.
        public: DECLSPEC_NOTHROW Evaluation::DkmRootVisualizedExpressionFlags_t STDMETHODCALLTYPE Flags(
            );

        // Deprecated: no longer used.
        public: DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE ArrayLength(
            );

        // [Optional] The type of the object being inspected.  This is often the same type
        // that is being referred to by the natvis entry that triggered the addin.  However,
        // it can also be a pointer or reference to the type, or even a base or derived class
        // of the type. The addin should make no assumptions about what is in this string and
        // should not attempt to parse it to obtain information about the object.  Most
        // addins should pass this string along through, as is to the 'Type' property of the
        // evaluation result they create.  However, an addin may choose to add additional
        // annotations to the 'Type' string before returning it back. Except for a hint of
        // what to put in the 'Type' field of the result, this string is irrelevant to the
        // visualization of the object.  Regardless of whether the original object is a
        // pointer, reference, base type, or derived type, the supplied
        // DkmExpressionValueHome will always identify the location of the object itself,
        // never a pointer or reference to the object. An empty type string may be passed in
        // here if the type of the evaluation result does not matter for the scenario in
        // which the visualizer is being invoked.
        //
        // This API was introduced in Visual Studio 14 RTM (DkmApiVersion.VS14RTM).
        public: _Ret_opt_ DECLSPEC_NOTHROW DkmString* STDMETHODCALLTYPE Type(
            );

        // Attempt to cast a 'DkmVisualizedExpression' to a 'DkmRootVisualizedExpression'. Return
        // NULL if the path object is not a 'DkmRootVisualizedExpression'.
        // pRootVisualizedExpression : [In,Optional] Object to attempt to cast
        // Return Value : [Optional] Result of the cast.
        public: static DECLSPEC_NOTHROW DkmRootVisualizedExpression* TryCast(
            DkmVisualizedExpression* pVisualizedExpression
            )
        {
            if (pVisualizedExpression == NULL || pVisualizedExpression->TagValue() != Tag::RootVisualizedExpression)
                return NULL;

            return static_cast<DkmRootVisualizedExpression*>(pVisualizedExpression);
        }

        /// <summary>
        /// Create a new DkmRootVisualizedExpression object instance.
        /// </summary>
        /// <param name="pInspectionContext">
        /// [In] Options and target context to use while performing the inspection operation.
        /// </param>
        /// <param name="VisualizerId">
        /// [In] Guid which ties together the addin and the expressions that call that addin.
        /// The addin should use the Guid provided in the native visualizer file as a filter.
        /// </param>
        /// <param name="SourceId">
        /// [In] Guid which ties together the expression evaluator that created this object
        /// and the object itself. Generally used by expression evaluators to filter their
        /// implementation of IDkmCustomVisualizerCallback to only DkmVisualizedExpression
        /// they created.
        /// </param>
        /// <param name="pStackFrame">
        /// [In] Stack frame the expression is being evaluated in expression in.
        /// </param>
        /// <param name="pValueHome">
        /// [In,Optional] The location at which the value is stored, which can be modified to
        /// edit the value.  This should be null for read-only values, such as integer
        /// constants.
        /// </param>
        /// <param name="pModule">
        /// [In,Optional] The module that contains the type symbol.
        /// </param>
        /// <param name="pName">
        /// [In] The name of the expression up to the root node. Addins can choose to use
        /// this name or construct their own.
        /// </param>
        /// <param name="pFullName">
        /// [In] The full name of the expression up to the root node. Addins can choose to
        /// use this full name or construct their own. However, if the addin uses a different
        /// full name, it must be parsed by the expression evaluator.
        /// </param>
        /// <param name="Flags">
        /// [In] Flags the expression evaluator passes to the visualizer addin describing the
        /// value in question. For instance, this will include if the object is a pointer or
        /// if it is a reference.
        /// </param>
        /// <param name="ArrayLength">
        /// [In] Deprecated: no longer used.
        /// </param>
        /// <param name="DataItem">
        /// [In] Data object to add to the new DkmRootVisualizedExpression instance.
        /// DkmDataItem::Null() in the case that the caller doesn't need to add a data item.
        /// </param>
        /// <param name="ppCreatedObject">
        /// [Out] Result of this method call.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ Evaluation::DkmInspectionContext* pInspectionContext,
            _In_ const GUID& VisualizerId,
            _In_ const GUID& SourceId,
            _In_ CallStack::DkmStackWalkFrame* pStackFrame,
            _In_opt_ Evaluation::DkmExpressionValueHome* pValueHome,
            _In_opt_ Symbols::DkmModule* pModule,
            _In_ DkmString* pName,
            _In_ DkmString* pFullName,
            _In_ Evaluation::DkmRootVisualizedExpressionFlags_t Flags,
            _In_ UINT32 ArrayLength,
            _In_ const DkmDataItem& DataItem,
            _Deref_out_ Evaluation::DkmRootVisualizedExpression** ppCreatedObject
            );

        /// <summary>
        /// Create a new DkmRootVisualizedExpression object instance.
        ///
        /// This API was introduced in Visual Studio 14 RTM (DkmApiVersion.VS14RTM).
        /// </summary>
        /// <param name="pInspectionContext">
        /// [In] Options and target context to use while performing the inspection operation.
        /// </param>
        /// <param name="VisualizerId">
        /// [In] Guid which ties together the addin and the expressions that call that addin.
        /// The addin should use the Guid provided in the native visualizer file as a filter.
        /// </param>
        /// <param name="SourceId">
        /// [In] Guid which ties together the expression evaluator that created this object
        /// and the object itself. Generally used by expression evaluators to filter their
        /// implementation of IDkmCustomVisualizerCallback to only DkmVisualizedExpression
        /// they created.
        /// </param>
        /// <param name="pStackFrame">
        /// [In] Stack frame the expression is being evaluated in expression in.
        /// </param>
        /// <param name="pValueHome">
        /// [In,Optional] The location at which the value is stored, which can be modified to
        /// edit the value.  This should be null for read-only values, such as integer
        /// constants.
        /// </param>
        /// <param name="pModule">
        /// [In,Optional] The module that contains the type symbol.
        /// </param>
        /// <param name="pName">
        /// [In] The name of the expression up to the root node. Addins can choose to use
        /// this name or construct their own.
        /// </param>
        /// <param name="pFullName">
        /// [In] The full name of the expression up to the root node. Addins can choose to
        /// use this full name or construct their own. However, if the addin uses a different
        /// full name, it must be parsed by the expression evaluator.
        /// </param>
        /// <param name="Flags">
        /// [In] Flags the expression evaluator passes to the visualizer addin describing the
        /// value in question. For instance, this will include if the object is a pointer or
        /// if it is a reference.
        /// </param>
        /// <param name="ArrayLength">
        /// [In] Deprecated: no longer used.
        /// </param>
        /// <param name="pType">
        /// [In,Optional] The type of the object being inspected.  This is often the same
        /// type that is being referred to by the natvis entry that triggered the addin.
        /// However, it can also be a pointer or reference to the type, or even a base or
        /// derived class of the type. The addin should make no assumptions about what is in
        /// this string and should not attempt to parse it to obtain information about the
        /// object.  Most addins should pass this string along through, as is to the 'Type'
        /// property of the evaluation result they create.  However, an addin may choose to
        /// add additional annotations to the 'Type' string before returning it back. Except
        /// for a hint of what to put in the 'Type' field of the result, this string is
        /// irrelevant to the visualization of the object.  Regardless of whether the
        /// original object is a pointer, reference, base type, or derived type, the supplied
        /// DkmExpressionValueHome will always identify the location of the object itself,
        /// never a pointer or reference to the object. An empty type string may be passed in
        /// here if the type of the evaluation result does not matter for the scenario in
        /// which the visualizer is being invoked.
        /// </param>
        /// <param name="DataItem">
        /// [In] Data object to add to the new DkmRootVisualizedExpression instance.
        /// DkmDataItem::Null() in the case that the caller doesn't need to add a data item.
        /// </param>
        /// <param name="ppCreatedObject">
        /// [Out] Result of this method call.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ Evaluation::DkmInspectionContext* pInspectionContext,
            _In_ const GUID& VisualizerId,
            _In_ const GUID& SourceId,
            _In_ CallStack::DkmStackWalkFrame* pStackFrame,
            _In_opt_ Evaluation::DkmExpressionValueHome* pValueHome,
            _In_opt_ Symbols::DkmModule* pModule,
            _In_ DkmString* pName,
            _In_ DkmString* pFullName,
            _In_ Evaluation::DkmRootVisualizedExpressionFlags_t Flags,
            _In_ UINT32 ArrayLength,
            _In_opt_ DkmString* pType,
            _In_ const DkmDataItem& DataItem,
            _Deref_out_ Evaluation::DkmRootVisualizedExpression** ppCreatedObject
            );
    }; // end of DkmRootVisualizedExpression

    // The formatted result of a successful evaluation, ready to be displayed in an
    // expression evaluation window.
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("5d948996-5805-1795-8b6b-535f0bc32bde") DkmSuccessEvaluationResult : public Evaluation::DkmEvaluationResult
    {
        // Use DkmSuccessEvaluationResult::Create to create this object
        private: DkmSuccessEvaluationResult();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmSuccessEvaluationResult();
        // This object cannot be copied
        private: DkmSuccessEvaluationResult& operator=(const DkmSuccessEvaluationResult&);
        private: DkmSuccessEvaluationResult(const DkmSuccessEvaluationResult&);

        private: const Evaluation::DkmEvaluationResultFlags_t m_Flags;
        private: OPTIONAL DkmString* const m_pValue;
        private: OPTIONAL DkmString* const m_pEditableValue;
        private: OPTIONAL DkmString* const m_pType;
        private: const Evaluation::DkmEvaluationResultCategory_t m_Category;
        private: const Evaluation::DkmEvaluationResultAccessType_t m_Access;
        private: const Evaluation::DkmEvaluationResultStorageType_t m_StorageType;
        private: const Evaluation::DkmEvaluationResultTypeModifierFlags_t m_TypeModifierFlags;
        private: OPTIONAL Evaluation::DkmDataAddress* const m_pAddress;
        private: OPTIONAL DkmReadOnlyCollection<Evaluation::DkmCustomUIVisualizerInfo*>* const m_pCustomUIVisualizers;
        private: OPTIONAL DkmReadOnlyCollection<DkmModuleInstance*>* const m_pExternalModules;
        private: void* m__pExtendedData;
        private: void* m_pPropertyProxyCollection0;

        // Flags which indicate attributes of an expression evaluation result.
        public: DECLSPEC_NOTHROW Evaluation::DkmEvaluationResultFlags_t STDMETHODCALLTYPE Flags(
            );

        // [Optional] String that describes the value.
        public: _Ret_opt_ DECLSPEC_NOTHROW DkmString* STDMETHODCALLTYPE Value(
            );

        // [Optional] If the value is writable, specifies the default string to be used when
        // you double-click on the value to edit it.  The EE should be able to parse and
        // evaluate this string and get back the current evaluation result.  If the value is
        // read-only, the editable value is ignored and should be null.
        public: _Ret_opt_ DECLSPEC_NOTHROW DkmString* STDMETHODCALLTYPE EditableValue(
            );

        // [Optional] A string that describes the type of the value.
        public: _Ret_opt_ DECLSPEC_NOTHROW DkmString* STDMETHODCALLTYPE Type(
            );

        // The category (ex: Data, Method, etc) of this evaluation result.
        public: DECLSPEC_NOTHROW Evaluation::DkmEvaluationResultCategory_t STDMETHODCALLTYPE Category(
            );

        // The access control level (public, private, etc) of the evaluation result.
        public: DECLSPEC_NOTHROW Evaluation::DkmEvaluationResultAccessType_t STDMETHODCALLTYPE Access(
            );

        // The storage type (ex: static) of the evaluation result.
        public: DECLSPEC_NOTHROW Evaluation::DkmEvaluationResultStorageType_t STDMETHODCALLTYPE StorageType(
            );

        // Type modifier flags (ex: const) of the evaluation result.
        public: DECLSPEC_NOTHROW Evaluation::DkmEvaluationResultTypeModifierFlags_t STDMETHODCALLTYPE TypeModifierFlags(
            );

        // [Optional] If the result is an address (i.e. the address flag is set in Flags),
        // specifies the location of the backing value.  This is used when the evaluation
        // result is used as the input to the memory window or disassembly window.  If it is
        // an instruction address then it must have the CPUInstruction address set.
        public: _Ret_opt_ DECLSPEC_NOTHROW Evaluation::DkmDataAddress* STDMETHODCALLTYPE Address(
            );

        // [Optional] A list of custom viewers for this object.
        public: _Ret_opt_ DECLSPEC_NOTHROW DkmReadOnlyCollection<Evaluation::DkmCustomUIVisualizerInfo*>* STDMETHODCALLTYPE CustomUIVisualizers(
            );

        // [Optional] If available, a list of external modules, not including the current
        // module, that are used for the inspection of the object.  Loading symbols for as
        // many modules in this list as possible will enhance the display of the object.
        public: _Ret_opt_ DECLSPEC_NOTHROW DkmReadOnlyCollection<DkmModuleInstance*>* STDMETHODCALLTYPE ExternalModules(
            );

        // Attempt to cast a 'DkmEvaluationResult' to a 'DkmSuccessEvaluationResult'. Return
        // NULL if the path object is not a 'DkmSuccessEvaluationResult'.
        // pSuccessResult : [In,Optional] Object to attempt to cast
        // Return Value : [Optional] Result of the cast.
        public: static DECLSPEC_NOTHROW DkmSuccessEvaluationResult* TryCast(
            DkmEvaluationResult* pResult
            )
        {
            if (pResult == NULL || pResult->TagValue() != Tag::SuccessResult)
                return NULL;

            return static_cast<DkmSuccessEvaluationResult*>(pResult);
        }

        /// <summary>
        /// Create a new DkmSuccessEvaluationResult object instance.
        /// </summary>
        /// <param name="pInspectionContext">
        /// [In] Inspection context used to create this evaluation result.
        /// </param>
        /// <param name="pStackFrame">
        /// [In] The stack frame this expression result was created on.
        /// </param>
        /// <param name="pName">
        /// [In] The name of the expression this result applies to.
        /// </param>
        /// <param name="pFullName">
        /// [In,Optional] The full name of the expression this result applies to. This value
        /// is used to allow child elements to be added to the watch window (Add Watch from
        /// the context menu), and to refresh parts of the evaluation tree. As an example of
        /// how FullName differs from name, the name of the 0th element of an array in C++ is
        /// '[0]' while the full name would by 'myArrayVariable[0]'. For Visual Studio 14 and
        /// later it's possible to calculate the full name later if needed. To do this, the
        /// expression evaluator should create the DkmEvaluationResult with a null full name
        /// and implement IDkmFullNameProvider.  Concord will then call
        /// IDkmFullNameProvider.CalculateFullName to get the full name when needed in the
        /// UI.
        /// </param>
        /// <param name="Flags">
        /// [In] Flags which indicate attributes of an expression evaluation result.
        /// </param>
        /// <param name="pValue">
        /// [In,Optional] String that describes the value.
        /// </param>
        /// <param name="pEditableValue">
        /// [In,Optional] If the value is writable, specifies the default string to be used
        /// when you double-click on the value to edit it.  The EE should be able to parse
        /// and evaluate this string and get back the current evaluation result.  If the
        /// value is read-only, the editable value is ignored and should be null.
        /// </param>
        /// <param name="pType">
        /// [In,Optional] A string that describes the type of the value.
        /// </param>
        /// <param name="Category">
        /// [In] The category (ex: Data, Method, etc) of this evaluation result.
        /// </param>
        /// <param name="Access">
        /// [In] The access control level (public, private, etc) of the evaluation result.
        /// </param>
        /// <param name="StorageType">
        /// [In] The storage type (ex: static) of the evaluation result.
        /// </param>
        /// <param name="TypeModifierFlags">
        /// [In] Type modifier flags (ex: const) of the evaluation result.
        /// </param>
        /// <param name="pAddress">
        /// [In,Optional] If the result is an address (i.e. the address flag is set in
        /// Flags), specifies the location of the backing value.  This is used when the
        /// evaluation result is used as the input to the memory window or disassembly
        /// window.  If it is an instruction address then it must have the CPUInstruction
        /// address set.
        /// </param>
        /// <param name="pCustomUIVisualizers">
        /// [In,Optional] A list of custom viewers for this object.
        /// </param>
        /// <param name="pExternalModules">
        /// [In,Optional] If available, a list of external modules, not including the current
        /// module, that are used for the inspection of the object.  Loading symbols for as
        /// many modules in this list as possible will enhance the display of the object.
        /// </param>
        /// <param name="DataItem">
        /// [In] Data object to add to the new DkmSuccessEvaluationResult instance.
        /// DkmDataItem::Null() in the case that the caller doesn't need to add a data item.
        /// </param>
        /// <param name="ppCreatedObject">
        /// [Out] Result of this method call.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ Evaluation::DkmInspectionContext* pInspectionContext,
            _In_ CallStack::DkmStackWalkFrame* pStackFrame,
            _In_ DkmString* pName,
            _In_opt_ DkmString* pFullName,
            _In_ Evaluation::DkmEvaluationResultFlags_t Flags,
            _In_opt_ DkmString* pValue,
            _In_opt_ DkmString* pEditableValue,
            _In_opt_ DkmString* pType,
            _In_ Evaluation::DkmEvaluationResultCategory_t Category,
            _In_ Evaluation::DkmEvaluationResultAccessType_t Access,
            _In_ Evaluation::DkmEvaluationResultStorageType_t StorageType,
            _In_ Evaluation::DkmEvaluationResultTypeModifierFlags_t TypeModifierFlags,
            _In_opt_ Evaluation::DkmDataAddress* pAddress,
            _In_opt_ DkmReadOnlyCollection<Evaluation::DkmCustomUIVisualizerInfo*>* pCustomUIVisualizers,
            _In_opt_ DkmReadOnlyCollection<DkmModuleInstance*>* pExternalModules,
            _In_ const DkmDataItem& DataItem,
            _Deref_out_ Evaluation::DkmSuccessEvaluationResult** ppCreatedObject
            );

        #ifndef EXCLUDE_IDE_ONLY_APIS
        /// <summary>
        /// Instantiates the debuggee-side Custom Visualizer type in the debuggee process.
        ///
        /// Location constraint: API must be called from an IDE component (component level
        /// &gt; 100,000).
        ///
        /// This API was introduced in Visual Studio 14 RTM (DkmApiVersion.VS14RTM).
        /// </summary>
        /// <param name="SelectedVisualizerIndex">
        /// [In] The index of the selected visualizer.
        /// </param>
        /// <param name="ppExceptionType">
        /// [Out,Optional] The type of the exception thrown, if any.
        /// </param>
        /// <param name="ppExceptionStackTrace">
        /// [Out,Optional] The stack trace of the exception thrown, if any.
        /// </param>
        /// <param name="ppExceptionMessage">
        /// [Out,Optional] The exception message, if any.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE CreateDebuggeeSideVisualizerObject(
            _In_ UINT32 SelectedVisualizerIndex,
            _Deref_out_opt_ DkmString** ppExceptionType,
            _Deref_out_opt_ DkmString** ppExceptionStackTrace,
            _Deref_out_opt_ DkmString** ppExceptionMessage
            );
        #endif // #ifndef EXCLUDE_IDE_ONLY_APIS

        #ifndef EXCLUDE_IDE_ONLY_APIS
        /// <summary>
        /// Releases the debuggee-side Custom Visualizer type in the debuggee process.
        ///
        /// Location constraint: API must be called from an IDE component (component level
        /// &gt; 100,000).
        ///
        /// This API was introduced in Visual Studio 14 RTM (DkmApiVersion.VS14RTM).
        /// </summary>
        /// <param name="pResult">
        /// [Out] If the handle was successfully removed, return true. If no handle, return
        /// false.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE DestroyDebuggeeSideVisualizerObject(
            _Out_ bool* pResult
            );
        #endif // #ifndef EXCLUDE_IDE_ONLY_APIS

        #ifndef EXCLUDE_IDE_ONLY_APIS
        /// <summary>
        /// Resolves an assembly name to the path of the assembly or to its raw bytes.
        ///
        /// Location constraint: API must be called from an IDE component (component level
        /// &gt; 100,000).
        ///
        /// This API was introduced in Visual Studio 14 RTM (DkmApiVersion.VS14RTM).
        /// </summary>
        /// <param name="pAssemblyName">
        /// [In] The fully qualified name of the assembly to resolve.
        /// </param>
        /// <param name="ppAssemblyPath">
        /// [Out,Optional] The path of the resolved assembly for local debugging.
        /// </param>
        /// <param name="ppAssemblyBytes">
        /// [Out,Optional] The byte array of the resolved assembly for remote debugging.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ResolveAssembly(
            _In_ DkmString* pAssemblyName,
            _Deref_out_opt_ DkmString** ppAssemblyPath,
            _Deref_out_opt_ DkmReadOnlyCollection<BYTE>** ppAssemblyBytes
            );
        #endif // #ifndef EXCLUDE_IDE_ONLY_APIS

        #ifndef EXCLUDE_IDE_ONLY_APIS
        /// <summary>
        /// Executes the debuggee-side Custom Visualizer type's GetData(...) method.
        ///
        /// Location constraint: API must be called from an IDE component (component level
        /// &gt; 100,000).
        ///
        /// This API was introduced in Visual Studio 14 RTM (DkmApiVersion.VS14RTM).
        /// </summary>
        /// <param name="ppVisualizerObject">
        /// [Out,Optional] The raw bytes of the GetData(...) method marshalled as a byte
        /// array.
        /// </param>
        /// <param name="ppExceptionType">
        /// [Out,Optional] The type of the exception thrown, if any.
        /// </param>
        /// <param name="ppExceptionStackTrace">
        /// [Out,Optional] The stack trace of the exception thrown, if any.
        /// </param>
        /// <param name="ppExceptionMessage">
        /// [Out,Optional] The exception message, if any.
        /// </param>
        /// <returns>
        /// S_OK is returned if *ppVisualizerObject is non-NULL, S_FALSE is returned when
        /// *ppVisualizerObject is NULL, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetDataFromDebuggeeSideVisualizer(
            _Deref_out_opt_ DkmReadOnlyCollection<BYTE>** ppVisualizerObject,
            _Deref_out_opt_ DkmString** ppExceptionType,
            _Deref_out_opt_ DkmString** ppExceptionStackTrace,
            _Deref_out_opt_ DkmString** ppExceptionMessage
            );
        #endif // #ifndef EXCLUDE_IDE_ONLY_APIS

        #ifndef EXCLUDE_IDE_ONLY_APIS
        /// <summary>
        /// Executes the debuggee-side Custom Visualizer type's TransferData(...) method.
        ///
        /// Location constraint: API must be called from an IDE component (component level
        /// &gt; 100,000).
        ///
        /// This API was introduced in Visual Studio 14 RTM (DkmApiVersion.VS14RTM).
        /// </summary>
        /// <param name="DataIn">
        /// [In] The data to transfer to the debuggee-side Visualizer class.
        ///
        /// The memory for the DkmArray members is allocated by the caller, and can be from
        /// any source (stack memory, static buffer, heap, etc). The implementation should
        /// not modify the members.
        /// </param>
        /// <param name="ppResponse">
        /// [Out,Optional] The raw bytes of the result of the TransferData(...) method
        /// marshalled as a byte array.
        /// </param>
        /// <param name="ppExceptionType">
        /// [Out,Optional] The type of the exception thrown, if any.
        /// </param>
        /// <param name="ppExceptionStackTrace">
        /// [Out,Optional] The stack trace of the exception thrown, if any.
        /// </param>
        /// <param name="ppExceptionMessage">
        /// [Out,Optional] The exception message, if any.
        /// </param>
        /// <returns>
        /// S_OK is returned if *ppResponse is non-NULL, S_FALSE is returned when *ppResponse
        /// is NULL, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE TransferDataToDebuggeeSideVisualizer(
            _In_ const DkmArray<BYTE>& DataIn,
            _Deref_out_opt_ DkmReadOnlyCollection<BYTE>** ppResponse,
            _Deref_out_opt_ DkmString** ppExceptionType,
            _Deref_out_opt_ DkmString** ppExceptionStackTrace,
            _Deref_out_opt_ DkmString** ppExceptionMessage
            );
        #endif // #ifndef EXCLUDE_IDE_ONLY_APIS

        #ifndef EXCLUDE_IDE_ONLY_APIS
        /// <summary>
        /// Executes the debuggee-side Custom Visualizer type's CreateReplacementObject(...)
        /// method, and writes the result to the visualized object handle.
        ///
        /// Location constraint: API must be called from an IDE component (component level
        /// &gt; 100,000).
        ///
        /// This API was introduced in Visual Studio 14 RTM (DkmApiVersion.VS14RTM).
        /// </summary>
        /// <param name="DataIn">
        /// [In] The data to transfer to the debuggee-side Visualizer class.
        ///
        /// The memory for the DkmArray members is allocated by the caller, and can be from
        /// any source (stack memory, static buffer, heap, etc). The implementation should
        /// not modify the members.
        /// </param>
        /// <param name="ppExceptionType">
        /// [Out,Optional] The type of the exception thrown, if any.
        /// </param>
        /// <param name="ppExceptionStackTrace">
        /// [Out,Optional] The stack trace of the exception thrown, if any.
        /// </param>
        /// <param name="ppExceptionMessage">
        /// [Out,Optional] The exception message, if any.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE CreateReplacementObjectOnDebuggeeSideVisualizer(
            _In_ const DkmArray<BYTE>& DataIn,
            _Deref_out_opt_ DkmString** ppExceptionType,
            _Deref_out_opt_ DkmString** ppExceptionStackTrace,
            _Deref_out_opt_ DkmString** ppExceptionMessage
            );
        #endif // #ifndef EXCLUDE_IDE_ONLY_APIS

        #ifndef EXCLUDE_MONITOR_ONLY_APIS
        /// <summary>
        /// Gets the underlying DkmClrValue from a DkmSuccessEvaluationResult, if it exists.
        ///
        /// Location constraint: API must be called from a Monitor component (component level
        /// &lt; 100,000).
        ///
        /// This API was introduced in Visual Studio 14 RTM (DkmApiVersion.VS14RTM).
        /// </summary>
        /// <param name="ppResult">
        /// [Out,Optional] The DkmClrValue, if it exists.
        /// </param>
        /// <returns>
        /// S_OK is returned if *ppResult is non-NULL, S_FALSE is returned when *ppResult is
        /// NULL, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetClrValue(
            _Deref_out_opt_ Evaluation::ClrCompilation::DkmClrValue** ppResult
            );
        #endif // #ifndef EXCLUDE_MONITOR_ONLY_APIS
    }; // end of DkmSuccessEvaluationResult

}; // end namespace Evaluation

// Contains types used for evaluating expressions that are compiled into MSIL.
namespace Evaluation { namespace ClrCompilation {
    // Flags that may be set as a result of compiling an expression to be evaluated.
    //
    // This API was introduced in Visual Studio 14 RTM (DkmApiVersion.VS14RTM).
    DEFINE_SCOPED_ENUM(DkmClrCompilationResultFlags)
    {
        // No result flags set.
        None = 0x0,
        // Indicates that the compiler detects the possibility of side effects if this
        // expression is evaluated. This means the expression is an assignment, method call,
        // or other expression likely to change the state of the debuggee. Although property
        // getters and indexers have the potential to cause side effects, these should be
        // assumed to not have side effects.
        PotentialSideEffect = 0x1,
        // Indicates that the result of the expression will be read-only.
        ReadOnlyResult = 0x2,
        // Indicates that the return type of compiled expression is boolean.
        BoolResult = 0x4
    };
    DEFINE_SCOPED_ENUM_FLAG_OPERATORS(DkmClrCompilationResultFlags_t);

    // A custom type info is an object passed between an IDkmClrExpressionCompiler and an
    // IDkmClrResultProvider, this can be used by the result provider to decode a
    // compiler-specific type that does not have an underlying CLR type. A result provider
    // should always check the PayloadTypeId for a compiler it recognizes before attempting
    // to decode the included payload.
    //
    // This API was introduced in Visual Studio 14 RTM (DkmApiVersion.VS14RTM).
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("24ac6f62-f3f8-1f2f-52db-986e3e96f38e") DkmClrCustomTypeInfo : public IUnknown
    {
        private: ___ReferenceCount_t m_ReferenceCount;
        private: DkmDispatcherObjectFlags_t m_ObjectFlags;
        private: const GUID* m_pTypeId;
        private: size_t m_ObjectGCHandle;
        // Use DkmClrCustomTypeInfo::Create to create this object
        private: DkmClrCustomTypeInfo();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmClrCustomTypeInfo();
        // This object cannot be copied
        private: DkmClrCustomTypeInfo& operator=(const DkmClrCustomTypeInfo&);
        private: DkmClrCustomTypeInfo(const DkmClrCustomTypeInfo&);

        private: const GUID m_PayloadTypeId;
        private: DkmReadOnlyCollection<BYTE>* const m_pPayload;
        private: void* m__pExtendedData;

        // This Guid is used to identify the type of the payload. This allows result
        // providers to ignore ClrCustomTypeInfos from different compilers.
        //
        // This API was introduced in Visual Studio 14 RTM (DkmApiVersion.VS14RTM).
        public: DECLSPEC_NOTHROW const GUID& STDMETHODCALLTYPE PayloadTypeId(
            );

        // Data payload that contains compiler-specific custom information to be used by a
        // result provider to decode the given type.
        //
        // This API was introduced in Visual Studio 14 RTM (DkmApiVersion.VS14RTM).
        public: _Ret_ DECLSPEC_NOTHROW DkmReadOnlyCollection<BYTE>* STDMETHODCALLTYPE Payload(
            );

        /// <summary>
        /// Create a new DkmClrCustomTypeInfo object instance.
        ///
        /// This API was introduced in Visual Studio 14 RTM (DkmApiVersion.VS14RTM).
        /// </summary>
        /// <param name="PayloadTypeId">
        /// [In] This Guid is used to identify the type of the payload. This allows result
        /// providers to ignore ClrCustomTypeInfos from different compilers.
        /// </param>
        /// <param name="pPayload">
        /// [In] Data payload that contains compiler-specific custom information to be used
        /// by a result provider to decode the given type.
        /// </param>
        /// <param name="ppCreatedObject">
        /// [Out] Result of this method call.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ const GUID& PayloadTypeId,
            _In_ DkmReadOnlyCollection<BYTE>* pPayload,
            _Deref_out_ Evaluation::ClrCompilation::DkmClrCustomTypeInfo** ppCreatedObject
            );
    }; // end of DkmClrCustomTypeInfo

    // The state values a DebuggerBrowsable attribute can have.
    //
    // This API was introduced in Visual Studio 14 RTM (DkmApiVersion.VS14RTM).
    DEFINE_SCOPED_ENUM(DkmClrDebuggerBrowsableAttributeState)
    {
        // Indicates that the member is not displayed in the debugger variable windows.
        Never = 0,
        // Indicates that the member is displayed but not expanded by default.
        Collapsed = 1,
        // Indicates that the member itself is not shown, but its constituent objects are
        // displayed if it is an array or collection.
        RootHidden = 2
    };

    #ifndef EXCLUDE_MONITOR_ONLY_APIS
    // An attribute that affects the way the debugger displays the evaluation results for a
    // type. Example attributes are DebuggerDisplay and DebuggerTypeProxy.
    //
    // This API was introduced in Visual Studio 14 RTM (DkmApiVersion.VS14RTM).
    //
    // Derived classes: DkmClrDebuggerBrowsableAttribute, DkmClrDebuggerDisplayAttribute,
    // DkmClrDebuggerTypeProxyAttribute, DkmClrDebuggerVisualizerAttribute
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("24121b3a-c9a2-3977-09bd-1a2cdc550537") DkmClrEvalAttribute : public IUnknown
    {
        private: ___ReferenceCount_t m_ReferenceCount;
        private: DkmDispatcherObjectFlags_t m_ObjectFlags;
        private: const GUID* m_pTypeId;
        private: size_t m_ObjectGCHandle;
        // Use DkmClrEvalAttribute::Create to create this object
        private: DkmClrEvalAttribute();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmClrEvalAttribute();
        // This object cannot be copied
        private: DkmClrEvalAttribute& operator=(const DkmClrEvalAttribute&);
        private: DkmClrEvalAttribute(const DkmClrEvalAttribute&);

        // DkmClrEvalAttribute is an abstract base class. This enum indicates which derived
        // class this object is an instance of.
        public: FORWARD_DECLARE_SCOPED_ENUM(Tag);
        DEFINE_SCOPED_ENUM(Tag)
        {
        // Object is an instance of 'DkmClrDebuggerBrowsableAttribute'.
        DebuggerBrowsableAttribute = 0,
        // Object is an instance of 'DkmClrDebuggerDisplayAttribute'.
        DebuggerDisplayAttribute = 1,
        // Object is an instance of 'DkmClrDebuggerTypeProxyAttribute'.
        DebuggerTypeProxyAttribute = 2,
        // Object is an instance of 'DkmClrDebuggerVisualizerAttribute'.
        DebuggerVisualizerAttribute = 3
        };

        private: const Tag_t m_TagValue;
        private: Clr::DkmClrType* const m_pTargetType;
        private: OPTIONAL DkmString* const m_pTargetMember;
        private: void* m__pExtendedData;

        // DkmClrEvalAttribute is an abstract base class. This enum indicates which derived
        // class this object is an instance of.
        public: DECLSPEC_NOTHROW Tag_t STDMETHODCALLTYPE TagValue(
            );

        // The type this attribute applies to.
        //
        // This API was introduced in Visual Studio 14 RTM (DkmApiVersion.VS14RTM).
        public: _Ret_ DECLSPEC_NOTHROW Clr::DkmClrType* STDMETHODCALLTYPE TargetType(
            );

        // [Optional] The member this attribute applies to if applicable.
        //
        // This API was introduced in Visual Studio 14 RTM (DkmApiVersion.VS14RTM).
        public: _Ret_opt_ DECLSPEC_NOTHROW DkmString* STDMETHODCALLTYPE TargetMember(
            );

        // The module the type resides in.  If the type resides in a synthetic assembly, this
        // value will be a real module in the same AppDomain.
        //
        // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
        //
        // This API was introduced in Visual Studio 14 RTM (DkmApiVersion.VS14RTM).
        public: _Ret_ DECLSPEC_NOTHROW Clr::DkmClrModuleInstance* STDMETHODCALLTYPE ModuleInstance(
            );
    }; // end of DkmClrEvalAttribute
    #endif // #ifndef EXCLUDE_MONITOR_ONLY_APIS

    // Information about a local variable and how to inspect it. Currently local variable
    // info includes the user visible name of the variable and the method on the inspection
    // query to execute to get its value.
    //
    // This API was introduced in Visual Studio 14 RTM (DkmApiVersion.VS14RTM).
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("d1f5c36a-d669-2b14-c996-a6fd28e08cda") DkmClrLocalVariableInfo : public IUnknown
    {
        private: ___ReferenceCount_t m_ReferenceCount;
        private: DkmDispatcherObjectFlags_t m_ObjectFlags;
        private: const GUID* m_pTypeId;
        private: size_t m_ObjectGCHandle;
        // Use DkmClrLocalVariableInfo::Create to create this object
        private: DkmClrLocalVariableInfo();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmClrLocalVariableInfo();
        // This object cannot be copied
        private: DkmClrLocalVariableInfo& operator=(const DkmClrLocalVariableInfo&);
        private: DkmClrLocalVariableInfo(const DkmClrLocalVariableInfo&);

        private: DkmString* const m_pVariableName;
        private: DkmString* const m_pFullName;
        private: DkmString* const m_pMethodName;
        private: const Evaluation::ClrCompilation::DkmClrCompilationResultFlags_t m_CompilationFlags;
        private: const Evaluation::DkmEvaluationResultCategory_t m_ResultCategory;
        private: OPTIONAL Evaluation::ClrCompilation::DkmClrCustomTypeInfo* const m_pCustomTypeInfo;
        private: void* m__pExtendedData;

        // The user-visible name of the variable.
        //
        // This API was introduced in Visual Studio 14 RTM (DkmApiVersion.VS14RTM).
        public: _Ret_ DECLSPEC_NOTHROW DkmString* STDMETHODCALLTYPE VariableName(
            );

        // The full name of the variable.  This is the expression evaluated if the variable
        // is added to the Watch window.
        //
        // This API was introduced in Visual Studio 14 RTM (DkmApiVersion.VS14RTM).
        public: _Ret_ DECLSPEC_NOTHROW DkmString* STDMETHODCALLTYPE FullName(
            );

        // The name of the method to execute to get the value of this variable.
        //
        // This API was introduced in Visual Studio 14 RTM (DkmApiVersion.VS14RTM).
        public: _Ret_ DECLSPEC_NOTHROW DkmString* STDMETHODCALLTYPE MethodName(
            );

        // [Optional] Flags, provided by the compiler, describing the local variable.
        //
        // This API was introduced in Visual Studio 14 RTM (DkmApiVersion.VS14RTM).
        public: DECLSPEC_NOTHROW Evaluation::ClrCompilation::DkmClrCompilationResultFlags_t STDMETHODCALLTYPE CompilationFlags(
            );

        // [Optional] What category this variable belongs to, this controls the glyph
        // displayed in the evaluation windows.
        //
        // This API was introduced in Visual Studio 14 RTM (DkmApiVersion.VS14RTM).
        public: DECLSPEC_NOTHROW Evaluation::DkmEvaluationResultCategory_t STDMETHODCALLTYPE ResultCategory(
            );

        // [Optional] The optional information provided to the result formatter for
        // identifying compiler intrinsic type information.
        //
        // This API was introduced in Visual Studio 14 RTM (DkmApiVersion.VS14RTM).
        public: _Ret_opt_ DECLSPEC_NOTHROW Evaluation::ClrCompilation::DkmClrCustomTypeInfo* STDMETHODCALLTYPE CustomTypeInfo(
            );

        /// <summary>
        /// Create a new DkmClrLocalVariableInfo object instance.
        ///
        /// This API was introduced in Visual Studio 14 RTM (DkmApiVersion.VS14RTM).
        /// </summary>
        /// <param name="pVariableName">
        /// [In] The user-visible name of the variable.
        /// </param>
        /// <param name="pFullName">
        /// [In] The full name of the variable.  This is the expression evaluated if the
        /// variable is added to the Watch window.
        /// </param>
        /// <param name="pMethodName">
        /// [In] The name of the method to execute to get the value of this variable.
        /// </param>
        /// <param name="CompilationFlags">
        /// [In,Optional] Flags, provided by the compiler, describing the local variable.
        /// </param>
        /// <param name="ResultCategory">
        /// [In,Optional] What category this variable belongs to, this controls the glyph
        /// displayed in the evaluation windows.
        /// </param>
        /// <param name="pCustomTypeInfo">
        /// [In,Optional] The optional information provided to the result formatter for
        /// identifying compiler intrinsic type information.
        /// </param>
        /// <param name="ppCreatedObject">
        /// [Out] Result of this method call.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ DkmString* pVariableName,
            _In_ DkmString* pFullName,
            _In_ DkmString* pMethodName,
            _In_ Evaluation::ClrCompilation::DkmClrCompilationResultFlags_t CompilationFlags,
            _In_ Evaluation::DkmEvaluationResultCategory_t ResultCategory,
            _In_opt_ Evaluation::ClrCompilation::DkmClrCustomTypeInfo* pCustomTypeInfo,
            _Deref_out_ Evaluation::ClrCompilation::DkmClrLocalVariableInfo** ppCreatedObject
            );
    }; // end of DkmClrLocalVariableInfo

    #ifndef EXCLUDE_MONITOR_ONLY_APIS
    // A value resulting from a CLR inspection query.  These values are used by a Result
    // Formatter to generate DkmEvaluationResults.
    //
    // This API was introduced in Visual Studio 14 RTM (DkmApiVersion.VS14RTM).
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("8186570c-2529-edb5-ef0b-4e485f902e89") DkmClrValue : public DkmDataContainer
    {
        // Use DkmClrValue::Create to create this object
        private: DkmClrValue();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmClrValue();
        // This object cannot be copied
        private: DkmClrValue& operator=(const DkmClrValue&);
        private: DkmClrValue(const DkmClrValue&);

        private: Evaluation::DkmInspectionSession* const m_pInspectionSession;
        private: Evaluation::DkmLanguage* const m_pLanguage;
        private: OPTIONAL Clr::DkmClrType* const m_pType;
        private: const Evaluation::DkmEvaluationResultCategory_t m_Category;
        private: const Evaluation::DkmEvaluationResultAccessType_t m_Access;
        private: const Evaluation::DkmEvaluationResultStorageType_t m_StorageType;
        private: const Evaluation::DkmEvaluationResultTypeModifierFlags_t m_TypeModifierFlags;
        private: const bool m_IsNull;
        private: OPTIONAL DkmVariant* const m_pHostObjectValue;
        private: CallStack::DkmStackWalkFrame* const m_pStackFrame;
        private: const Evaluation::DkmEvaluationResultFlags_t m_EvalFlags;
        private: const Evaluation::DkmClrValueFlags_t m_ValueFlags;
        private: const UINT64 m_NativeComPointer;
        private: OPTIONAL Evaluation::DkmDataAddress* const m_pAddress;
        private: OPTIONAL DkmString* const m_pAlias;
        private: OPTIONAL DkmReadOnlyCollection<UINT32>* const m_pArrayDimensions;
        private: OPTIONAL DkmReadOnlyCollection<UINT32>* const m_pArrayLowerBounds;
        private: const GUID m_UniqueId;
        private: void* m__pExtendedData;

        // The InspectionSession allows the various components which examine data in the
        // target process to store private data with the same lifetime. Inspection sessions
        // are closed when the user attempts to continue the process.
        //
        // This API was introduced in Visual Studio 14 RTM (DkmApiVersion.VS14RTM).
        public: _Ret_ DECLSPEC_NOTHROW Evaluation::DkmInspectionSession* STDMETHODCALLTYPE InspectionSession(
            );

        // The language being used.
        //
        // This API was introduced in Visual Studio 14 RTM (DkmApiVersion.VS14RTM).
        public: _Ret_ DECLSPEC_NOTHROW Evaluation::DkmLanguage* STDMETHODCALLTYPE Language(
            );

        // [Optional] The runtime type of this node.  System.String, for example. This value
        // is null when the value is invalid AND the type cannot be determined.
        //
        // This API was introduced in Visual Studio 14 RTM (DkmApiVersion.VS14RTM).
        public: _Ret_opt_ DECLSPEC_NOTHROW Clr::DkmClrType* STDMETHODCALLTYPE Type(
            );

        // The category (ex: Data, Method, etc) of this evaluation result.
        //
        // This API was introduced in Visual Studio 14 RTM (DkmApiVersion.VS14RTM).
        public: DECLSPEC_NOTHROW Evaluation::DkmEvaluationResultCategory_t STDMETHODCALLTYPE Category(
            );

        // The access control level (public, private, etc) of the evaluation result.
        //
        // This API was introduced in Visual Studio 14 RTM (DkmApiVersion.VS14RTM).
        public: DECLSPEC_NOTHROW Evaluation::DkmEvaluationResultAccessType_t STDMETHODCALLTYPE Access(
            );

        // The storage type (ex: static) of the evaluation result.
        //
        // This API was introduced in Visual Studio 14 RTM (DkmApiVersion.VS14RTM).
        public: DECLSPEC_NOTHROW Evaluation::DkmEvaluationResultStorageType_t STDMETHODCALLTYPE StorageType(
            );

        // Type modifier flags (ex: const) of the evaluation result.
        //
        // This API was introduced in Visual Studio 14 RTM (DkmApiVersion.VS14RTM).
        public: DECLSPEC_NOTHROW Evaluation::DkmEvaluationResultTypeModifierFlags_t STDMETHODCALLTYPE TypeModifierFlags(
            );

        // True if the value is a null (or if there is no value).
        //
        // This API was introduced in Visual Studio 14 RTM (DkmApiVersion.VS14RTM).
        public: DECLSPEC_NOTHROW bool STDMETHODCALLTYPE IsNull(
            );

        // [Optional] The value of this node if the DkmClrValue is a value that can be
        // represented in the debugger process. If the DkmClrValue is of a complex type, this
        // value will be null.
        //
        // This API was introduced in Visual Studio 14 RTM (DkmApiVersion.VS14RTM).
        public: _Ret_opt_ DECLSPEC_NOTHROW DkmVariant* STDMETHODCALLTYPE HostObjectValue(
            );

        // The stack frame used as the inspection frame of the interpreted expression.
        //
        // This API was introduced in Visual Studio 14 RTM (DkmApiVersion.VS14RTM).
        public: _Ret_ DECLSPEC_NOTHROW CallStack::DkmStackWalkFrame* STDMETHODCALLTYPE StackFrame(
            );

        // Flags describing of the result of the evaluation that created this DkmClrValue.
        //
        // This API was introduced in Visual Studio 14 RTM (DkmApiVersion.VS14RTM).
        public: DECLSPEC_NOTHROW Evaluation::DkmEvaluationResultFlags_t STDMETHODCALLTYPE EvalFlags(
            );

        // Flags describing this value.
        //
        // This API was introduced in Visual Studio 14 RTM (DkmApiVersion.VS14RTM).
        public: DECLSPEC_NOTHROW Evaluation::DkmClrValueFlags_t STDMETHODCALLTYPE ValueFlags(
            );

        // An interface pointer to the native COM object if this value is an RCW.
        //
        // This API was introduced in Visual Studio 14 RTM (DkmApiVersion.VS14RTM).
        public: DECLSPEC_NOTHROW UINT64 STDMETHODCALLTYPE NativeComPointer(
            );

        // [Optional] If the result is an address (i.e. the address flag is set in Flags),
        // specifies the location of the backing value.  This is used when the evaluation
        // result is used as the input to the memory window or disassembly window.  If it is
        // an instruction address then it must have the CPUInstruction address set.
        //
        // This API was introduced in Visual Studio 14 RTM (DkmApiVersion.VS14RTM).
        public: _Ret_opt_ DECLSPEC_NOTHROW Evaluation::DkmDataAddress* STDMETHODCALLTYPE Address(
            );

        // [Optional] The alias for this value.  If the object has not been assigned an
        // alias, this value will be null.
        //
        // This API was introduced in Visual Studio 14 RTM (DkmApiVersion.VS14RTM).
        public: _Ret_opt_ DECLSPEC_NOTHROW DkmString* STDMETHODCALLTYPE Alias(
            );

        // [Optional] The dimensions of the the array.  This value is only valid if this
        // DkmClrValue is an array value.
        //
        // This API was introduced in Visual Studio 14 RTM (DkmApiVersion.VS14RTM).
        public: _Ret_opt_ DECLSPEC_NOTHROW DkmReadOnlyCollection<UINT32>* STDMETHODCALLTYPE ArrayDimensions(
            );

        // [Optional] The lower bounds of the the array.  This value is only valid if this
        // DkmClrValue is an array value.
        //
        // This API was introduced in Visual Studio 14 RTM (DkmApiVersion.VS14RTM).
        public: _Ret_opt_ DECLSPEC_NOTHROW DkmReadOnlyCollection<UINT32>* STDMETHODCALLTYPE ArrayLowerBounds(
            );

        // Guid which uniquely identifies this interpreted result.
        //
        // This API was introduced in Visual Studio 14 RTM (DkmApiVersion.VS14RTM).
        public: DECLSPEC_NOTHROW const GUID& STDMETHODCALLTYPE UniqueId(
            );

        /// <summary>
        /// Closes the CLR value to release resources associated with it.  This method must
        /// be invoked by the object that requested the evaluation query (ex: called
        /// DkmCompiledClrInspectionQuery.Execute).
        ///
        /// DkmClrValue objects are automatically closed when their associated
        /// DkmInspectionSession object is closed.
        ///
        /// Location constraint: API must be called from a Monitor component (component level
        /// &lt; 100,000).
        ///
        /// This API was introduced in Visual Studio 14 RTM (DkmApiVersion.VS14RTM).
        /// </summary>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Close(
            );

        /// <summary>
        /// Create a new DkmClrValue object instance.
        ///
        /// Location constraint: API must be called from a Monitor component (component level
        /// &lt; 100,000).
        ///
        /// This API was introduced in Visual Studio 14 RTM (DkmApiVersion.VS14RTM).
        /// </summary>
        /// <param name="pInspectionSession">
        /// [In] The InspectionSession allows the various components which examine data in
        /// the target process to store private data with the same lifetime. Inspection
        /// sessions are closed when the user attempts to continue the process.
        /// </param>
        /// <param name="pLanguage">
        /// [In] The language being used.
        /// </param>
        /// <param name="pType">
        /// [In,Optional] The runtime type of this node.  System.String, for example. This
        /// value is null when the value is invalid AND the type cannot be determined.
        /// </param>
        /// <param name="Category">
        /// [In] The category (ex: Data, Method, etc) of this evaluation result.
        /// </param>
        /// <param name="Access">
        /// [In] The access control level (public, private, etc) of the evaluation result.
        /// </param>
        /// <param name="StorageType">
        /// [In] The storage type (ex: static) of the evaluation result.
        /// </param>
        /// <param name="TypeModifierFlags">
        /// [In] Type modifier flags (ex: const) of the evaluation result.
        /// </param>
        /// <param name="IsNull">
        /// [In] True if the value is a null (or if there is no value).
        /// </param>
        /// <param name="pHostObjectValue">
        /// [In,Optional] The value of this node if the DkmClrValue is a value that can be
        /// represented in the debugger process. If the DkmClrValue is of a complex type,
        /// this value will be null.
        /// </param>
        /// <param name="pStackFrame">
        /// [In] The stack frame used as the inspection frame of the interpreted expression.
        /// </param>
        /// <param name="EvalFlags">
        /// [In] Flags describing of the result of the evaluation that created this
        /// DkmClrValue.
        /// </param>
        /// <param name="ValueFlags">
        /// [In] Flags describing this value.
        /// </param>
        /// <param name="NativeComPointer">
        /// [In] An interface pointer to the native COM object if this value is an RCW.
        /// </param>
        /// <param name="pAddress">
        /// [In,Optional] If the result is an address (i.e. the address flag is set in
        /// Flags), specifies the location of the backing value.  This is used when the
        /// evaluation result is used as the input to the memory window or disassembly
        /// window.  If it is an instruction address then it must have the CPUInstruction
        /// address set.
        /// </param>
        /// <param name="pAlias">
        /// [In,Optional] The alias for this value.  If the object has not been assigned an
        /// alias, this value will be null.
        /// </param>
        /// <param name="pArrayDimensions">
        /// [In,Optional] The dimensions of the the array.  This value is only valid if this
        /// DkmClrValue is an array value.
        /// </param>
        /// <param name="pArrayLowerBounds">
        /// [In,Optional] The lower bounds of the the array.  This value is only valid if
        /// this DkmClrValue is an array value.
        /// </param>
        /// <param name="DataItem">
        /// [In] Data object to add to the new DkmClrValue instance. DkmDataItem::Null() in
        /// the case that the caller doesn't need to add a data item.
        /// </param>
        /// <param name="ppCreatedObject">
        /// [Out] Result of this method call.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ Evaluation::DkmInspectionSession* pInspectionSession,
            _In_ Evaluation::DkmLanguage* pLanguage,
            _In_opt_ Clr::DkmClrType* pType,
            _In_ Evaluation::DkmEvaluationResultCategory_t Category,
            _In_ Evaluation::DkmEvaluationResultAccessType_t Access,
            _In_ Evaluation::DkmEvaluationResultStorageType_t StorageType,
            _In_ Evaluation::DkmEvaluationResultTypeModifierFlags_t TypeModifierFlags,
            _In_ bool IsNull,
            _In_opt_ DkmVariant* pHostObjectValue,
            _In_ CallStack::DkmStackWalkFrame* pStackFrame,
            _In_ Evaluation::DkmEvaluationResultFlags_t EvalFlags,
            _In_ Evaluation::DkmClrValueFlags_t ValueFlags,
            _In_ UINT64 NativeComPointer,
            _In_opt_ Evaluation::DkmDataAddress* pAddress,
            _In_opt_ DkmString* pAlias,
            _In_opt_ DkmReadOnlyCollection<UINT32>* pArrayDimensions,
            _In_opt_ DkmReadOnlyCollection<UINT32>* pArrayLowerBounds,
            _In_ const DkmDataItem& DataItem,
            _Deref_out_ Evaluation::ClrCompilation::DkmClrValue** ppCreatedObject
            );

        /// <summary>
        /// Get the value string to display in the UI for the given DkmClrValue.
        ///
        /// Location constraint: API must be called from a Monitor component (component level
        /// &lt; 100,000).
        ///
        /// This API was introduced in Visual Studio 14 RTM (DkmApiVersion.VS14RTM).
        /// </summary>
        /// <param name="pInspectionContext">
        /// [In] The inspection context for this evaluation.
        /// </param>
        /// <param name="pFormatSpecifiers">
        /// [In,Optional] The optional format specifier(s) to use when formatting this
        /// result.
        /// </param>
        /// <param name="ppValueString">
        /// [Out] The value string.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetValueString(
            _In_ Evaluation::DkmInspectionContext* pInspectionContext,
            _In_opt_ DkmReadOnlyCollection<DkmString*>* pFormatSpecifiers,
            _Deref_out_ DkmString** ppValueString
            );

        /// <summary>
        /// Determines if this value has an underlying string representation. If this method
        /// returns true, the user can use string visualizers to view this value in the
        /// debugger. GetUnderlyingString should return the underlying string representation.
        ///
        /// Location constraint: API must be called from a Monitor component (component level
        /// &lt; 100,000).
        ///
        /// This API was introduced in Visual Studio 14 RTM (DkmApiVersion.VS14RTM).
        /// </summary>
        /// <param name="pInspectionContext">
        /// [In] The inspection context for this evaluation.
        /// </param>
        /// <param name="pResult">
        /// [Out] True if this value has and underlying string representation.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE HasUnderlyingString(
            _In_ Evaluation::DkmInspectionContext* pInspectionContext,
            _Out_ bool* pResult
            );

        /// <summary>
        /// Get the underlying string representation of the value.
        ///
        /// Location constraint: API must be called from a Monitor component (component level
        /// &lt; 100,000).
        ///
        /// This API was introduced in Visual Studio 14 RTM (DkmApiVersion.VS14RTM).
        /// </summary>
        /// <param name="pInspectionContext">
        /// [In] The inspection context for this evaluation.
        /// </param>
        /// <param name="ppResult">
        /// [Out] The underlying string representation.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetUnderlyingString(
            _In_ Evaluation::DkmInspectionContext* pInspectionContext,
            _Deref_out_ DkmString** ppResult
            );

        /// <summary>
        /// Format a DkmClrValue and return a DkmEvaluationResult.
        ///
        /// This method will append a new work item to the specified work list, and return
        /// once the work item has been appended. The actual processing of the work item is
        /// asynchronous. The caller will be notified that the request is complete through
        /// the completion routine.
        ///
        /// Location constraint: API must be called from a Monitor component (component level
        /// &lt; 100,000).
        ///
        /// This API was introduced in Visual Studio 14 RTM (DkmApiVersion.VS14RTM).
        /// </summary>
        /// <param name="pWorkList">
        /// WorkList to append the new work item to.
        /// </param>
        /// <param name="pDeclaredType">
        /// [In,Optional] The declared type if it is different from the runtime type.
        /// </param>
        /// <param name="pCustomTypeInfo">
        /// [In,Optional] The optional information provided by the expression compiler for
        /// identifying compiler intrinsic type information.
        /// </param>
        /// <param name="pInspectionContext">
        /// [In] The inspection context for this evaluation.
        /// </param>
        /// <param name="pFormatSpecifiers">
        /// [In,Optional] The optional format specifier(s) to use when formatting this
        /// result.
        /// </param>
        /// <param name="pResultName">
        /// [In] The name of this result.  This value is typically the expression being
        /// evaluated.
        /// </param>
        /// <param name="pResultFullName">
        /// [In] The full name of this result.  This is the expression added to the Watch
        /// window if the user selects "Add to Watch".
        /// </param>
        /// <param name="pCompletionRoutine">
        /// Routine to fire when the request is complete. If the request is successfully
        /// appended to the work list, this will always fire (including when the operation is
        /// canceled). This will never fire if appending the work item fails.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetResult(
            _In_ DkmWorkList* pWorkList,
            _In_opt_ Clr::DkmClrType* pDeclaredType,
            _In_opt_ Evaluation::ClrCompilation::DkmClrCustomTypeInfo* pCustomTypeInfo,
            _In_ Evaluation::DkmInspectionContext* pInspectionContext,
            _In_opt_ DkmReadOnlyCollection<DkmString*>* pFormatSpecifiers,
            _In_ DkmString* pResultName,
            _In_ DkmString* pResultFullName,
            _In_ IDkmCompletionRoutine<Evaluation::ClrCompilation::DkmEvaluationAsyncResult>* pCompletionRoutine
            );

        /// <summary>
        /// Execute the ToString override on an object represented by the given DkmClrValue.
        /// If the value is of type object or does not override ToString, this method will
        /// return null.  This method requires function evaluation to be enabled.  If
        /// function evaluation is disabled by the user or for any other reason, this method
        /// will return null.  This method will also return null if the function evaluation
        /// fails for any reason.
        ///
        /// Location constraint: API must be called from a Monitor component (component level
        /// &lt; 100,000).
        ///
        /// This API was introduced in Visual Studio 14 RTM (DkmApiVersion.VS14RTM).
        /// </summary>
        /// <param name="pInspectionContext">
        /// [In] The inspection context for this evaluation.
        /// </param>
        /// <param name="ppResult">
        /// [Out,Optional] The result of calling ToString on the object represented by this
        /// DkmClrValue.
        /// </param>
        /// <returns>
        /// S_OK is returned if *ppResult is non-NULL, S_FALSE is returned when *ppResult is
        /// NULL, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE EvaluateToString(
            _In_ Evaluation::DkmInspectionContext* pInspectionContext,
            _Deref_out_opt_ DkmString** ppResult
            );

        /// <summary>
        /// Gets the string to display in the debugger UI for a CLR value given a
        /// DebuggerDisplay attribute string.
        ///
        /// This method will append a new work item to the specified work list, and return
        /// once the work item has been appended. The actual processing of the work item is
        /// asynchronous. The caller will be notified that the request is complete through
        /// the completion routine.
        ///
        /// Location constraint: API must be called from a Monitor component (component level
        /// &lt; 100,000).
        ///
        /// This API was introduced in Visual Studio 14 RTM (DkmApiVersion.VS14RTM).
        /// </summary>
        /// <param name="pWorkList">
        /// WorkList to append the new work item to.
        /// </param>
        /// <param name="pInspectionContext">
        /// [In] The inspection context for this evaluation.
        /// </param>
        /// <param name="pTargetType">
        /// [In] The type to use when evaluating debugger display attributes.
        /// </param>
        /// <param name="pFormatString">
        /// [In] The format string to be evaluated by the debugger.  For example "Count =
        /// {Count}".
        /// </param>
        /// <param name="pCompletionRoutine">
        /// Routine to fire when the request is complete. If the request is successfully
        /// appended to the work list, this will always fire (including when the operation is
        /// canceled). This will never fire if appending the work item fails.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE EvaluateDebuggerDisplayString(
            _In_ DkmWorkList* pWorkList,
            _In_ Evaluation::DkmInspectionContext* pInspectionContext,
            _In_ Clr::DkmClrType* pTargetType,
            _In_ DkmString* pFormatString,
            _In_ IDkmCompletionRoutine<Evaluation::ClrCompilation::DkmEvaluateDebuggerDisplayStringAsyncResult>* pCompletionRoutine
            );

        /// <summary>
        /// Instantiate a proxy class for a DkmClrValue with an associated DebuggerTypeProxy
        /// attribute.
        ///
        /// Location constraint: API must be called from a Monitor component (component level
        /// &lt; 100,000).
        ///
        /// This API was introduced in Visual Studio 14 RTM (DkmApiVersion.VS14RTM).
        /// </summary>
        /// <param name="pInspectionContext">
        /// [In] The inspection context for this evaluation.
        /// </param>
        /// <param name="pType">
        /// [In] The type of the proxy to instantiate.  The proxy type should have a
        /// constructor taking a single parameter. The debugger will pass the instance of the
        /// type being inspected to this constructor.
        /// </param>
        /// <param name="ppResult">
        /// [Out] A value representing the instantiated type proxy.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// E_INVALIDARG indicates that Type is an unconstructed generic type.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE InstantiateProxyType(
            _In_ Evaluation::DkmInspectionContext* pInspectionContext,
            _In_ Clr::DkmClrType* pType,
            _Deref_out_ Evaluation::ClrCompilation::DkmClrValue** ppResult
            );

        /// <summary>
        /// Instantiate the proxy class to use for iterating an IEnumerable value.
        ///
        /// Location constraint: API must be called from a Monitor component (component level
        /// &lt; 100,000).
        ///
        /// This API was introduced in Visual Studio 14 RTM (DkmApiVersion.VS14RTM).
        /// </summary>
        /// <param name="pInspectionContext">
        /// [In] The inspection context for this evaluation.
        /// </param>
        /// <param name="pEnumerableType">
        /// [In] The interface type (IEnumerable or IEnumerable&lt;T&gt;) to construct the
        /// the results view proxy for. This is needed because a class may implement several
        /// different IEnumerable interfaces.
        /// </param>
        /// <param name="ppResult">
        /// [Out,Optional] A value representing the instantiated results view proxy. This
        /// method returns null in case of failure instantiating the results view proxy.
        /// </param>
        /// <returns>
        /// S_OK is returned if *ppResult is non-NULL, S_FALSE is returned when *ppResult is
        /// NULL, and failure codes are used for any error. COR_E_INVALIDOPERATION indicates
        /// that this method was called on a DkmClrValue that does not implement the
        /// requested interface or represents a null value. E_INVALIDARG indicates that
        /// EnumerableType is not an interface type.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE InstantiateResultsViewProxy(
            _In_ Evaluation::DkmInspectionContext* pInspectionContext,
            _In_ Clr::DkmClrType* pEnumerableType,
            _Deref_out_opt_ Evaluation::ClrCompilation::DkmClrValue** ppResult
            );

        /// <summary>
        /// Instantiate the proxy class to use for iterating the dynamic members of an
        /// IDynamicMetaObjectProvider value.
        ///
        /// Location constraint: API must be called from a Monitor component (component level
        /// &lt; 100,000).
        ///
        /// This API was introduced in Visual Studio 14 RTM (DkmApiVersion.VS14RTM).
        /// </summary>
        /// <param name="pInspectionContext">
        /// [In] The inspection context for this evaluation.
        /// </param>
        /// <param name="ppResult">
        /// [Out,Optional] A value representing the instantiated results view proxy. This
        /// method returns null in case of failure instantiating the dynamic view proxy.
        /// </param>
        /// <returns>
        /// S_OK is returned if *ppResult is non-NULL, S_FALSE is returned when *ppResult is
        /// NULL, and failure codes are used for any error. COR_E_INVALIDOPERATION indicates
        /// that this method was called on a DkmClrValue that does not implement the
        /// IDynamicMetaObjectProvider interface or represents a null value.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE InstantiateDynamicViewProxy(
            _In_ Evaluation::DkmInspectionContext* pInspectionContext,
            _Deref_out_opt_ Evaluation::ClrCompilation::DkmClrValue** ppResult
            );

        /// <summary>
        /// Gets the value of a field or property as a DkmClrValue.
        ///
        /// Location constraint: API must be called from a Monitor component (component level
        /// &lt; 100,000).
        ///
        /// This API was introduced in Visual Studio 14 RTM (DkmApiVersion.VS14RTM).
        /// </summary>
        /// <param name="pMemberName">
        /// [In] The name of the member to get the value for.
        /// </param>
        /// <param name="MemberType">
        /// [In] The type of member to get the value for. The value should match a value of
        /// System.Reflection.MemberTypes. This method currently only supports getting the
        /// value for Fields (4) or Properties (16).
        /// </param>
        /// <param name="pParentTypeName">
        /// [In,Optional] The full name of the type containing the member to get the value
        /// for. If ParentTypeName value is null, this method will look for the member in the
        /// runtime type.
        /// </param>
        /// <param name="pInspectionContext">
        /// [In] The inspection context for this evaluation.
        /// </param>
        /// <param name="ppResult">
        /// [Out] The DkmClrValue for the given member.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetMemberValue(
            _In_ DkmString* pMemberName,
            _In_ UINT32 MemberType,
            _In_opt_ DkmString* pParentTypeName,
            _In_ Evaluation::DkmInspectionContext* pInspectionContext,
            _Deref_out_ Evaluation::ClrCompilation::DkmClrValue** ppResult
            );

        /// <summary>
        /// Get an array element.  This method may only be used if the DkmClrValue represents
        /// an array value.
        ///
        /// Location constraint: API must be called from a Monitor component (component level
        /// &lt; 100,000).
        ///
        /// This API was introduced in Visual Studio 14 RTM (DkmApiVersion.VS14RTM).
        /// </summary>
        /// <param name="Index">
        /// [In] The index or indices of the array element to get.
        ///
        /// The memory for the DkmArray members is allocated by the caller, and can be from
        /// any source (stack memory, static buffer, heap, etc). The implementation should
        /// not modify the members.
        /// </param>
        /// <param name="pInspectionContext">
        /// [In] The inspection context for this evaluation.
        /// </param>
        /// <param name="ppResult">
        /// [Out] The element value.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetArrayElement(
            _In_ const DkmArray<UINT32>& Index,
            _In_ Evaluation::DkmInspectionContext* pInspectionContext,
            _Deref_out_ Evaluation::ClrCompilation::DkmClrValue** ppResult
            );

        /// <summary>
        /// Dereference this pointer value to get the underlying value.  This method may only
        /// be used if the DkmClrValue represents a Pointer value.
        ///
        /// Location constraint: API must be called from a Monitor component (component level
        /// &lt; 100,000).
        ///
        /// This API was introduced in Visual Studio 14 RTM (DkmApiVersion.VS14RTM).
        /// </summary>
        /// <param name="pInspectionContext">
        /// [In] The inspection context for this evaluation.
        /// </param>
        /// <param name="ppResult">
        /// [Out] The dereferenced value.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Dereference(
            _In_ Evaluation::DkmInspectionContext* pInspectionContext,
            _Deref_out_ Evaluation::ClrCompilation::DkmClrValue** ppResult
            );
    }; // end of DkmClrValue
    #endif // #ifndef EXCLUDE_MONITOR_ONLY_APIS

    #ifndef EXCLUDE_MONITOR_ONLY_APIS
    // Result of an asynchronous DkmClrValue.EvaluateDebuggerDisplayString call.
    struct DkmEvaluateDebuggerDisplayStringAsyncResult
    {
        // HRESULT code returned from the caller. This will be
        // DkmExceptionCode.COR_E_OPERATIONCANCELED (0x8013153B) if the operation was
        // canceled before processing was complete.
        HRESULT ErrorCode;

        // The formatted value to display in the debugger UI.  For example "Count = 5".
        DkmString* pResult;
    };
    #endif // #ifndef EXCLUDE_MONITOR_ONLY_APIS

    #ifndef EXCLUDE_MONITOR_ONLY_APIS
    // Result of an asynchronous DkmClrValue.GetResult call.
    struct DkmEvaluationAsyncResult
    {
        // HRESULT code returned from the caller. This will be
        // DkmExceptionCode.COR_E_OPERATIONCANCELED (0x8013153B) if the operation was
        // canceled before processing was complete.
        HRESULT ErrorCode;

        // The formatted DkmEvaluationResult.
        Evaluation::DkmEvaluationResult* pResult;
    };
    #endif // #ifndef EXCLUDE_MONITOR_ONLY_APIS

    // Result of an asynchronous DkmCompiledClrInspectionQuery.Execute call.
    struct DkmExecuteClrInspectionQueryAsyncResult
    {
        // HRESULT code returned from the caller. This will be
        // DkmExceptionCode.COR_E_OPERATIONCANCELED (0x8013153B) if the operation was
        // canceled before processing was complete.
        HRESULT ErrorCode;

        // The formatted result of the inspection query.
        Evaluation::DkmEvaluationResult* pResult;
    };

    // Result of an asynchronous DkmCompiledClrLocalsQuery.GetLocalValues call.
    struct DkmGetLocalValuesAsyncResult
    {
        // HRESULT code returned from the caller. This will be
        // DkmExceptionCode.COR_E_OPERATIONCANCELED (0x8013153B) if the operation was
        // canceled before processing was complete.
        HRESULT ErrorCode;

        // The list formatted local variable evaluation results.
        DkmArray<Evaluation::DkmEvaluationResult*> Items;
    };

    #ifndef EXCLUDE_MONITOR_ONLY_APIS
    // Represents a DebuggerBrowsable attribute on a field or property and determines if and
    // how a member is displayed in the debugger variable windows. See msdn documentation for
    // DebuggerBrowsableAttribute.
    //
    // This API was introduced in Visual Studio 14 RTM (DkmApiVersion.VS14RTM).
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("43eb3a78-3101-f06f-6c8c-aed3dc61b616") DkmClrDebuggerBrowsableAttribute : public Evaluation::ClrCompilation::DkmClrEvalAttribute
    {
        // Use DkmClrDebuggerBrowsableAttribute::Create to create this object
        private: DkmClrDebuggerBrowsableAttribute();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmClrDebuggerBrowsableAttribute();
        // This object cannot be copied
        private: DkmClrDebuggerBrowsableAttribute& operator=(const DkmClrDebuggerBrowsableAttribute&);
        private: DkmClrDebuggerBrowsableAttribute(const DkmClrDebuggerBrowsableAttribute&);

        private: const Evaluation::ClrCompilation::DkmClrDebuggerBrowsableAttributeState_t m_State;
        private: void* m__pExtendedData;

        // The display state for the attribute.
        //
        // This API was introduced in Visual Studio 14 RTM (DkmApiVersion.VS14RTM).
        public: DECLSPEC_NOTHROW Evaluation::ClrCompilation::DkmClrDebuggerBrowsableAttributeState_t STDMETHODCALLTYPE State(
            );

        // Attempt to cast a 'DkmClrEvalAttribute' to a 'DkmClrDebuggerBrowsableAttribute'. Return
        // NULL if the path object is not a 'DkmClrDebuggerBrowsableAttribute'.
        // pDebuggerBrowsableAttribute : [In,Optional] Object to attempt to cast
        // Return Value : [Optional] Result of the cast.
        public: static DECLSPEC_NOTHROW DkmClrDebuggerBrowsableAttribute* TryCast(
            DkmClrEvalAttribute* pClrEvalAttribute
            )
        {
            if (pClrEvalAttribute == NULL || pClrEvalAttribute->TagValue() != Tag::DebuggerBrowsableAttribute)
                return NULL;

            return static_cast<DkmClrDebuggerBrowsableAttribute*>(pClrEvalAttribute);
        }

        /// <summary>
        /// Create a new DkmClrDebuggerBrowsableAttribute object instance.
        ///
        /// Location constraint: API must be called from a Monitor component (component level
        /// &lt; 100,000).
        ///
        /// This API was introduced in Visual Studio 14 RTM (DkmApiVersion.VS14RTM).
        /// </summary>
        /// <param name="pTargetType">
        /// [In] The type this attribute applies to.
        /// </param>
        /// <param name="pTargetMember">
        /// [In,Optional] The member this attribute applies to if applicable.
        /// </param>
        /// <param name="State">
        /// [In] The display state for the attribute.
        /// </param>
        /// <param name="ppCreatedObject">
        /// [Out] Result of this method call.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ Clr::DkmClrType* pTargetType,
            _In_opt_ DkmString* pTargetMember,
            _In_ Evaluation::ClrCompilation::DkmClrDebuggerBrowsableAttributeState_t State,
            _Deref_out_ Evaluation::ClrCompilation::DkmClrDebuggerBrowsableAttribute** ppCreatedObject
            );
    }; // end of DkmClrDebuggerBrowsableAttribute
    #endif // #ifndef EXCLUDE_MONITOR_ONLY_APIS

    #ifndef EXCLUDE_MONITOR_ONLY_APIS
    // Represents a DebuggerDisplay attribute on a type, enum, field, property, or delegate.
    // See msdn documentation for DebuggerDisplayAttribute.
    //
    // This API was introduced in Visual Studio 14 RTM (DkmApiVersion.VS14RTM).
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("dc405fce-5688-d055-6378-4c4b40f0f95c") DkmClrDebuggerDisplayAttribute : public Evaluation::ClrCompilation::DkmClrEvalAttribute
    {
        // Use DkmClrDebuggerDisplayAttribute::Create to create this object
        private: DkmClrDebuggerDisplayAttribute();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmClrDebuggerDisplayAttribute();
        // This object cannot be copied
        private: DkmClrDebuggerDisplayAttribute& operator=(const DkmClrDebuggerDisplayAttribute&);
        private: DkmClrDebuggerDisplayAttribute(const DkmClrDebuggerDisplayAttribute&);

        private: OPTIONAL DkmString* const m_pOriginatingAssemblyName;
        private: OPTIONAL DkmReadOnlyCollection<BYTE>* const m_pOriginatingAssemblyPublicKeyToken;
        private: OPTIONAL DkmString* const m_pValue;
        private: OPTIONAL DkmString* const m_pName;
        private: OPTIONAL DkmString* const m_pTypeName;
        private: void* m__pExtendedData;

        // [Optional] The simple name (not full name) of the originating assembly for this
        // attribute. This value is null if the attribute did not come from the debuggee
        // process.
        //
        // This API was introduced in Visual Studio 14 RTM (DkmApiVersion.VS14RTM).
        public: _Ret_opt_ DECLSPEC_NOTHROW DkmString* STDMETHODCALLTYPE OriginatingAssemblyName(
            );

        // [Optional] The public key token of the originating assembly. This value is null if
        // the originating assembly is not signed or the attribute did not come from the
        // debuggee process.
        //
        // This API was introduced in Visual Studio 14 RTM (DkmApiVersion.VS14RTM).
        public: _Ret_opt_ DECLSPEC_NOTHROW DkmReadOnlyCollection<BYTE>* STDMETHODCALLTYPE OriginatingAssemblyPublicKeyToken(
            );

        // [Optional] The value to display in the debugger variable windows.
        //
        // This API was introduced in Visual Studio 14 RTM (DkmApiVersion.VS14RTM).
        public: _Ret_opt_ DECLSPEC_NOTHROW DkmString* STDMETHODCALLTYPE Value(
            );

        // [Optional] The name to display in the debugger variable windows.
        //
        // This API was introduced in Visual Studio 14 RTM (DkmApiVersion.VS14RTM).
        public: _Ret_opt_ DECLSPEC_NOTHROW DkmString* STDMETHODCALLTYPE Name(
            );

        // [Optional] The type name to display in the debugger variable windows.
        //
        // This API was introduced in Visual Studio 14 RTM (DkmApiVersion.VS14RTM).
        public: _Ret_opt_ DECLSPEC_NOTHROW DkmString* STDMETHODCALLTYPE TypeName(
            );

        // Attempt to cast a 'DkmClrEvalAttribute' to a 'DkmClrDebuggerDisplayAttribute'. Return
        // NULL if the path object is not a 'DkmClrDebuggerDisplayAttribute'.
        // pDebuggerDisplayAttribute : [In,Optional] Object to attempt to cast
        // Return Value : [Optional] Result of the cast.
        public: static DECLSPEC_NOTHROW DkmClrDebuggerDisplayAttribute* TryCast(
            DkmClrEvalAttribute* pClrEvalAttribute
            )
        {
            if (pClrEvalAttribute == NULL || pClrEvalAttribute->TagValue() != Tag::DebuggerDisplayAttribute)
                return NULL;

            return static_cast<DkmClrDebuggerDisplayAttribute*>(pClrEvalAttribute);
        }

        /// <summary>
        /// Create a new DkmClrDebuggerDisplayAttribute object instance.
        ///
        /// Location constraint: API must be called from a Monitor component (component level
        /// &lt; 100,000).
        ///
        /// This API was introduced in Visual Studio 14 RTM (DkmApiVersion.VS14RTM).
        /// </summary>
        /// <param name="pTargetType">
        /// [In] The type this attribute applies to.
        /// </param>
        /// <param name="pTargetMember">
        /// [In,Optional] The member this attribute applies to if applicable.
        /// </param>
        /// <param name="pOriginatingAssemblyName">
        /// [In,Optional] The simple name (not full name) of the originating assembly for
        /// this attribute. This value is null if the attribute did not come from the
        /// debuggee process.
        /// </param>
        /// <param name="pOriginatingAssemblyPublicKeyToken">
        /// [In,Optional] The public key token of the originating assembly. This value is
        /// null if the originating assembly is not signed or the attribute did not come from
        /// the debuggee process.
        /// </param>
        /// <param name="pValue">
        /// [In,Optional] The value to display in the debugger variable windows.
        /// </param>
        /// <param name="pName">
        /// [In,Optional] The name to display in the debugger variable windows.
        /// </param>
        /// <param name="pTypeName">
        /// [In,Optional] The type name to display in the debugger variable windows.
        /// </param>
        /// <param name="ppCreatedObject">
        /// [Out] Result of this method call.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ Clr::DkmClrType* pTargetType,
            _In_opt_ DkmString* pTargetMember,
            _In_opt_ DkmString* pOriginatingAssemblyName,
            _In_opt_ DkmReadOnlyCollection<BYTE>* pOriginatingAssemblyPublicKeyToken,
            _In_opt_ DkmString* pValue,
            _In_opt_ DkmString* pName,
            _In_opt_ DkmString* pTypeName,
            _Deref_out_ Evaluation::ClrCompilation::DkmClrDebuggerDisplayAttribute** ppCreatedObject
            );
    }; // end of DkmClrDebuggerDisplayAttribute
    #endif // #ifndef EXCLUDE_MONITOR_ONLY_APIS

    #ifndef EXCLUDE_MONITOR_ONLY_APIS
    // Represents a DebuggerTypeProxy attribute on a type and specifies a display proxy for a
    // type. See msdn documentation for DebuggerTypeProxyAttribute.
    //
    // This API was introduced in Visual Studio 14 RTM (DkmApiVersion.VS14RTM).
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("76d380fb-f2af-56dc-228a-86ebfc5eec61") DkmClrDebuggerTypeProxyAttribute : public Evaluation::ClrCompilation::DkmClrEvalAttribute
    {
        // Use DkmClrDebuggerTypeProxyAttribute::Create to create this object
        private: DkmClrDebuggerTypeProxyAttribute();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmClrDebuggerTypeProxyAttribute();
        // This object cannot be copied
        private: DkmClrDebuggerTypeProxyAttribute& operator=(const DkmClrDebuggerTypeProxyAttribute&);
        private: DkmClrDebuggerTypeProxyAttribute(const DkmClrDebuggerTypeProxyAttribute&);

        private: Clr::DkmClrType* const m_pProxyType;
        private: void* m__pExtendedData;

        // The proxy type.
        //
        // This API was introduced in Visual Studio 14 RTM (DkmApiVersion.VS14RTM).
        public: _Ret_ DECLSPEC_NOTHROW Clr::DkmClrType* STDMETHODCALLTYPE ProxyType(
            );

        // Attempt to cast a 'DkmClrEvalAttribute' to a 'DkmClrDebuggerTypeProxyAttribute'. Return
        // NULL if the path object is not a 'DkmClrDebuggerTypeProxyAttribute'.
        // pDebuggerTypeProxyAttribute : [In,Optional] Object to attempt to cast
        // Return Value : [Optional] Result of the cast.
        public: static DECLSPEC_NOTHROW DkmClrDebuggerTypeProxyAttribute* TryCast(
            DkmClrEvalAttribute* pClrEvalAttribute
            )
        {
            if (pClrEvalAttribute == NULL || pClrEvalAttribute->TagValue() != Tag::DebuggerTypeProxyAttribute)
                return NULL;

            return static_cast<DkmClrDebuggerTypeProxyAttribute*>(pClrEvalAttribute);
        }

        /// <summary>
        /// Create a new DkmClrDebuggerTypeProxyAttribute object instance.
        ///
        /// Location constraint: API must be called from a Monitor component (component level
        /// &lt; 100,000).
        ///
        /// This API was introduced in Visual Studio 14 RTM (DkmApiVersion.VS14RTM).
        /// </summary>
        /// <param name="pTargetType">
        /// [In] The type this attribute applies to.
        /// </param>
        /// <param name="pTargetMember">
        /// [In,Optional] The member this attribute applies to if applicable.
        /// </param>
        /// <param name="pProxyType">
        /// [In] The proxy type.
        /// </param>
        /// <param name="ppCreatedObject">
        /// [Out] Result of this method call.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ Clr::DkmClrType* pTargetType,
            _In_opt_ DkmString* pTargetMember,
            _In_ Clr::DkmClrType* pProxyType,
            _Deref_out_ Evaluation::ClrCompilation::DkmClrDebuggerTypeProxyAttribute** ppCreatedObject
            );
    }; // end of DkmClrDebuggerTypeProxyAttribute
    #endif // #ifndef EXCLUDE_MONITOR_ONLY_APIS

    #ifndef EXCLUDE_MONITOR_ONLY_APIS
    // Represents a DebuggerVisualizer attribute on a type and specifies the IDE-side and
    // debuggee-side visualizer type names, and its description. See msdn documentation for
    // DebuggerVisualizerAttribute.
    //
    // This API was introduced in Visual Studio 14 RTM (DkmApiVersion.VS14RTM).
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("cd33e5a2-b44e-289c-67b0-97a054621689") DkmClrDebuggerVisualizerAttribute : public Evaluation::ClrCompilation::DkmClrEvalAttribute
    {
        // Use DkmClrDebuggerVisualizerAttribute::Create to create this object
        private: DkmClrDebuggerVisualizerAttribute();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmClrDebuggerVisualizerAttribute();
        // This object cannot be copied
        private: DkmClrDebuggerVisualizerAttribute& operator=(const DkmClrDebuggerVisualizerAttribute&);
        private: DkmClrDebuggerVisualizerAttribute(const DkmClrDebuggerVisualizerAttribute&);

        private: DkmString* const m_pUISideVisualizerTypeName;
        private: DkmString* const m_pUISideVisualizerAssemblyName;
        private: const Evaluation::DkmClrCustomVisualizerAssemblyLocation_t m_UISideVisualizerAssemblyLocation;
        private: DkmString* const m_pDebuggeeSideVisualizerTypeName;
        private: DkmString* const m_pDebuggeeSideVisualizerAssemblyName;
        private: DkmString* const m_pVisualizerDescription;
        private: void* m__pExtendedData;

        // The full name of the UI-side type of the Custom Managed Visualizer.
        //
        // This API was introduced in Visual Studio 14 RTM (DkmApiVersion.VS14RTM).
        public: _Ret_ DECLSPEC_NOTHROW DkmString* STDMETHODCALLTYPE UISideVisualizerTypeName(
            );

        // The full name of the assembly containing the UI-side type.
        //
        // This API was introduced in Visual Studio 14 RTM (DkmApiVersion.VS14RTM).
        public: _Ret_ DECLSPEC_NOTHROW DkmString* STDMETHODCALLTYPE UISideVisualizerAssemblyName(
            );

        // The location of the UI-side assembly.
        //
        // This API was introduced in Visual Studio 14 RTM (DkmApiVersion.VS14RTM).
        public: DECLSPEC_NOTHROW Evaluation::DkmClrCustomVisualizerAssemblyLocation_t STDMETHODCALLTYPE UISideVisualizerAssemblyLocation(
            );

        // The full name of the debuggee-side type of the Custom Managed Visualizer.
        //
        // This API was introduced in Visual Studio 14 RTM (DkmApiVersion.VS14RTM).
        public: _Ret_ DECLSPEC_NOTHROW DkmString* STDMETHODCALLTYPE DebuggeeSideVisualizerTypeName(
            );

        // The full name of the assembly containing the debuggee-side type.
        //
        // This API was introduced in Visual Studio 14 RTM (DkmApiVersion.VS14RTM).
        public: _Ret_ DECLSPEC_NOTHROW DkmString* STDMETHODCALLTYPE DebuggeeSideVisualizerAssemblyName(
            );

        // The visualizer description.
        //
        // This API was introduced in Visual Studio 14 RTM (DkmApiVersion.VS14RTM).
        public: _Ret_ DECLSPEC_NOTHROW DkmString* STDMETHODCALLTYPE VisualizerDescription(
            );

        // Attempt to cast a 'DkmClrEvalAttribute' to a 'DkmClrDebuggerVisualizerAttribute'. Return
        // NULL if the path object is not a 'DkmClrDebuggerVisualizerAttribute'.
        // pDebuggerVisualizerAttribute : [In,Optional] Object to attempt to cast
        // Return Value : [Optional] Result of the cast.
        public: static DECLSPEC_NOTHROW DkmClrDebuggerVisualizerAttribute* TryCast(
            DkmClrEvalAttribute* pClrEvalAttribute
            )
        {
            if (pClrEvalAttribute == NULL || pClrEvalAttribute->TagValue() != Tag::DebuggerVisualizerAttribute)
                return NULL;

            return static_cast<DkmClrDebuggerVisualizerAttribute*>(pClrEvalAttribute);
        }

        /// <summary>
        /// Create a new DkmClrDebuggerVisualizerAttribute object instance.
        ///
        /// Location constraint: API must be called from a Monitor component (component level
        /// &lt; 100,000).
        ///
        /// This API was introduced in Visual Studio 14 RTM (DkmApiVersion.VS14RTM).
        /// </summary>
        /// <param name="pTargetType">
        /// [In] The type this attribute applies to.
        /// </param>
        /// <param name="pTargetMember">
        /// [In,Optional] The member this attribute applies to if applicable.
        /// </param>
        /// <param name="pUISideVisualizerTypeName">
        /// [In] The full name of the UI-side type of the Custom Managed Visualizer.
        /// </param>
        /// <param name="pUISideVisualizerAssemblyName">
        /// [In] The full name of the assembly containing the UI-side type.
        /// </param>
        /// <param name="UISideVisualizerAssemblyLocation">
        /// [In] The location of the UI-side assembly.
        /// </param>
        /// <param name="pDebuggeeSideVisualizerTypeName">
        /// [In] The full name of the debuggee-side type of the Custom Managed Visualizer.
        /// </param>
        /// <param name="pDebuggeeSideVisualizerAssemblyName">
        /// [In] The full name of the assembly containing the debuggee-side type.
        /// </param>
        /// <param name="pVisualizerDescription">
        /// [In] The visualizer description.
        /// </param>
        /// <param name="ppCreatedObject">
        /// [Out] Result of this method call.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ Clr::DkmClrType* pTargetType,
            _In_opt_ DkmString* pTargetMember,
            _In_ DkmString* pUISideVisualizerTypeName,
            _In_ DkmString* pUISideVisualizerAssemblyName,
            _In_ Evaluation::DkmClrCustomVisualizerAssemblyLocation_t UISideVisualizerAssemblyLocation,
            _In_ DkmString* pDebuggeeSideVisualizerTypeName,
            _In_ DkmString* pDebuggeeSideVisualizerAssemblyName,
            _In_ DkmString* pVisualizerDescription,
            _Deref_out_ Evaluation::ClrCompilation::DkmClrDebuggerVisualizerAttribute** ppCreatedObject
            );
    }; // end of DkmClrDebuggerVisualizerAttribute
    #endif // #ifndef EXCLUDE_MONITOR_ONLY_APIS

    // Represents an evaluation query that has been compiled to managed IL code.
    //
    // This API was introduced in Visual Studio 14 RTM (DkmApiVersion.VS14RTM).
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("db5318eb-4272-2f7d-0a92-3697769aba6b") DkmCompiledClrInspectionQuery : public Evaluation::DkmCompiledInspectionQuery
    {
        // Use DkmCompiledClrInspectionQuery::Create to create this object
        private: DkmCompiledClrInspectionQuery();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmCompiledClrInspectionQuery();
        // This object cannot be copied
        private: DkmCompiledClrInspectionQuery& operator=(const DkmCompiledClrInspectionQuery&);
        private: DkmCompiledClrInspectionQuery(const DkmCompiledClrInspectionQuery&);

        private: DkmReadOnlyCollection<BYTE>* const m_pBinary;
        private: DkmString* const m_pTypeName;
        private: DkmString* const m_pMethodName;
        private: OPTIONAL DkmReadOnlyCollection<DkmString*>* const m_pFormatSpecifiers;
        private: const Evaluation::ClrCompilation::DkmClrCompilationResultFlags_t m_CompilationFlags;
        private: const Evaluation::DkmEvaluationResultCategory_t m_ResultCategory;
        private: const Evaluation::DkmEvaluationResultAccessType_t m_Access;
        private: const Evaluation::DkmEvaluationResultStorageType_t m_StorageType;
        private: const Evaluation::DkmEvaluationResultTypeModifierFlags_t m_TypeModifierFlags;
        private: OPTIONAL Evaluation::ClrCompilation::DkmClrCustomTypeInfo* const m_pCustomTypeInfo;
        private: const GUID m_UniqueId;
        private: void* m__pExtendedData;

        // Binary of the query assembly.
        //
        // This API was introduced in Visual Studio 14 RTM (DkmApiVersion.VS14RTM).
        public: _Ret_ DECLSPEC_NOTHROW DkmReadOnlyCollection<BYTE>* STDMETHODCALLTYPE Binary(
            );

        // The fully qualified name of the type containing the query method.
        //
        // This API was introduced in Visual Studio 14 RTM (DkmApiVersion.VS14RTM).
        public: _Ret_ DECLSPEC_NOTHROW DkmString* STDMETHODCALLTYPE TypeName(
            );

        // The name of the query method.
        //
        // This API was introduced in Visual Studio 14 RTM (DkmApiVersion.VS14RTM).
        public: _Ret_ DECLSPEC_NOTHROW DkmString* STDMETHODCALLTYPE MethodName(
            );

        // [Optional] The format specifier(s) to use when formatting the result of this
        // query.
        //
        // This API was introduced in Visual Studio 14 RTM (DkmApiVersion.VS14RTM).
        public: _Ret_opt_ DECLSPEC_NOTHROW DkmReadOnlyCollection<DkmString*>* STDMETHODCALLTYPE FormatSpecifiers(
            );

        // [Optional] Flags, provided by the compiler, describing the inspection query.
        //
        // This API was introduced in Visual Studio 14 RTM (DkmApiVersion.VS14RTM).
        public: DECLSPEC_NOTHROW Evaluation::ClrCompilation::DkmClrCompilationResultFlags_t STDMETHODCALLTYPE CompilationFlags(
            );

        // [Optional] What category this variable belongs to, this controls the glyph
        // displayed in the evaluation windows.
        //
        // This API was introduced in Visual Studio 14 RTM (DkmApiVersion.VS14RTM).
        public: DECLSPEC_NOTHROW Evaluation::DkmEvaluationResultCategory_t STDMETHODCALLTYPE ResultCategory(
            );

        // [Optional] The access control level (public, private, etc) of the evaluation
        // result.
        //
        // This API was introduced in Visual Studio 14 RTM (DkmApiVersion.VS14RTM).
        public: DECLSPEC_NOTHROW Evaluation::DkmEvaluationResultAccessType_t STDMETHODCALLTYPE Access(
            );

        // [Optional] The storage type (ex: static) of the evaluation result.
        //
        // This API was introduced in Visual Studio 14 RTM (DkmApiVersion.VS14RTM).
        public: DECLSPEC_NOTHROW Evaluation::DkmEvaluationResultStorageType_t STDMETHODCALLTYPE StorageType(
            );

        // [Optional] Type modifier flags (ex: const) of the evaluation result.
        //
        // This API was introduced in Visual Studio 14 RTM (DkmApiVersion.VS14RTM).
        public: DECLSPEC_NOTHROW Evaluation::DkmEvaluationResultTypeModifierFlags_t STDMETHODCALLTYPE TypeModifierFlags(
            );

        // [Optional] The optional information provided to the result formatter for
        // identifying compiler intrinsic type information.
        //
        // This API was introduced in Visual Studio 14 RTM (DkmApiVersion.VS14RTM).
        public: _Ret_opt_ DECLSPEC_NOTHROW Evaluation::ClrCompilation::DkmClrCustomTypeInfo* STDMETHODCALLTYPE CustomTypeInfo(
            );

        // Guid which uniquely identifies this query.
        //
        // This API was introduced in Visual Studio 14 RTM (DkmApiVersion.VS14RTM).
        public: DECLSPEC_NOTHROW const GUID& STDMETHODCALLTYPE UniqueId(
            );

        // Attempt to cast a 'DkmCompiledInspectionQuery' to a 'DkmCompiledClrInspectionQuery'. Return
        // NULL if the path object is not a 'DkmCompiledClrInspectionQuery'.
        // pCompiledClrInspectionQuery : [In,Optional] Object to attempt to cast
        // Return Value : [Optional] Result of the cast.
        public: static DECLSPEC_NOTHROW DkmCompiledClrInspectionQuery* TryCast(
            DkmCompiledInspectionQuery* pQuery
            )
        {
            if (pQuery == NULL || pQuery->TagValue() != Tag::CompiledClrInspectionQuery)
                return NULL;

            return static_cast<DkmCompiledClrInspectionQuery*>(pQuery);
        }

        /// <summary>
        /// Create a new DkmCompiledClrInspectionQuery object instance.
        ///
        /// This API was introduced in Visual Studio 14 RTM (DkmApiVersion.VS14RTM).
        /// </summary>
        /// <param name="pRuntimeInstance">
        /// [In] The DkmRuntimeInstance class represents an execution environment which is
        /// loaded into a DkmProcess and which contains code to be debugged.
        /// </param>
        /// <param name="pDataContainer">
        /// [In,Optional] Custom Data to associate with this inspection query.  It will
        /// persist as long as the query has the potential to execute.
        /// </param>
        /// <param name="LanguageId">
        /// [In] The language of the expression evaluator that created this query.
        /// </param>
        /// <param name="pBinary">
        /// [In] Binary of the query assembly.
        /// </param>
        /// <param name="pTypeName">
        /// [In] The fully qualified name of the type containing the query method.
        /// </param>
        /// <param name="pMethodName">
        /// [In] The name of the query method.
        /// </param>
        /// <param name="pFormatSpecifiers">
        /// [In,Optional] The format specifier(s) to use when formatting the result of this
        /// query.
        /// </param>
        /// <param name="CompilationFlags">
        /// [In,Optional] Flags, provided by the compiler, describing the inspection query.
        /// </param>
        /// <param name="ResultCategory">
        /// [In,Optional] What category this variable belongs to, this controls the glyph
        /// displayed in the evaluation windows.
        /// </param>
        /// <param name="Access">
        /// [In,Optional] The access control level (public, private, etc) of the evaluation
        /// result.
        /// </param>
        /// <param name="StorageType">
        /// [In,Optional] The storage type (ex: static) of the evaluation result.
        /// </param>
        /// <param name="TypeModifierFlags">
        /// [In,Optional] Type modifier flags (ex: const) of the evaluation result.
        /// </param>
        /// <param name="pCustomTypeInfo">
        /// [In,Optional] The optional information provided to the result formatter for
        /// identifying compiler intrinsic type information.
        /// </param>
        /// <param name="ppCreatedObject">
        /// [Out] Result of this method call.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ DkmRuntimeInstance* pRuntimeInstance,
            _In_opt_ Evaluation::DkmCustomDataContainer* pDataContainer,
            _In_ const Evaluation::DkmCompilerId& LanguageId,
            _In_ DkmReadOnlyCollection<BYTE>* pBinary,
            _In_ DkmString* pTypeName,
            _In_ DkmString* pMethodName,
            _In_opt_ DkmReadOnlyCollection<DkmString*>* pFormatSpecifiers,
            _In_ Evaluation::ClrCompilation::DkmClrCompilationResultFlags_t CompilationFlags,
            _In_ Evaluation::DkmEvaluationResultCategory_t ResultCategory,
            _In_ Evaluation::DkmEvaluationResultAccessType_t Access,
            _In_ Evaluation::DkmEvaluationResultStorageType_t StorageType,
            _In_ Evaluation::DkmEvaluationResultTypeModifierFlags_t TypeModifierFlags,
            _In_opt_ Evaluation::ClrCompilation::DkmClrCustomTypeInfo* pCustomTypeInfo,
            _Deref_out_ Evaluation::ClrCompilation::DkmCompiledClrInspectionQuery** ppCreatedObject
            );

        /// <summary>
        /// Execute a compiled inspection query and returns the result as a list of formatted
        /// DkmEvaluationResults.
        ///
        /// This method will append a new work item to the specified work list, and return
        /// once the work item has been appended. The actual processing of the work item is
        /// asynchronous. The caller will be notified that the request is complete through
        /// the completion routine.
        ///
        /// This API was introduced in Visual Studio 14 RTM (DkmApiVersion.VS14RTM).
        /// </summary>
        /// <param name="pWorkList">
        /// WorkList to append the new work item to.
        /// </param>
        /// <param name="pInspectionContext">
        /// [In] The inspection context for this query.
        /// </param>
        /// <param name="pILContext">
        /// [In] The stack context to execute the query against.
        /// </param>
        /// <param name="pExpressionName">
        /// [In] The name of the expression used to create this inspection query.
        /// </param>
        /// <param name="pCompletionRoutine">
        /// Routine to fire when the request is complete. If the request is successfully
        /// appended to the work list, this will always fire (including when the operation is
        /// canceled). This will never fire if appending the work item fails.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Execute(
            _In_ DkmWorkList* pWorkList,
            _In_ Evaluation::DkmInspectionContext* pInspectionContext,
            _In_ Evaluation::DkmILContext* pILContext,
            _In_ DkmString* pExpressionName,
            _In_ IDkmCompletionRoutine<Evaluation::ClrCompilation::DkmExecuteClrInspectionQueryAsyncResult>* pCompletionRoutine
            );
    }; // end of DkmCompiledClrInspectionQuery

    // Represents a query to populate local variable information using managed IL code.
    //
    // This API was introduced in Visual Studio 14 RTM (DkmApiVersion.VS14RTM).
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("cff3eb78-ae76-a013-0883-b6da3594048e") DkmCompiledClrLocalsQuery : public Evaluation::DkmCompiledInspectionQuery
    {
        // Use DkmCompiledClrLocalsQuery::Create to create this object
        private: DkmCompiledClrLocalsQuery();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmCompiledClrLocalsQuery();
        // This object cannot be copied
        private: DkmCompiledClrLocalsQuery& operator=(const DkmCompiledClrLocalsQuery&);
        private: DkmCompiledClrLocalsQuery(const DkmCompiledClrLocalsQuery&);

        private: DkmReadOnlyCollection<BYTE>* const m_pBinary;
        private: DkmString* const m_pTypeName;
        private: DkmReadOnlyCollection<Evaluation::ClrCompilation::DkmClrLocalVariableInfo*>* const m_pLocalInfo;
        private: const GUID m_UniqueId;
        private: void* m__pExtendedData;

        // Binary of the query assembly.
        //
        // This API was introduced in Visual Studio 14 RTM (DkmApiVersion.VS14RTM).
        public: _Ret_ DECLSPEC_NOTHROW DkmReadOnlyCollection<BYTE>* STDMETHODCALLTYPE Binary(
            );

        // The fully qualified name of the type containing the query method.
        //
        // This API was introduced in Visual Studio 14 RTM (DkmApiVersion.VS14RTM).
        public: _Ret_ DECLSPEC_NOTHROW DkmString* STDMETHODCALLTYPE TypeName(
            );

        // The collection of local variable names and method names on the query type to get
        // the values.
        //
        // This API was introduced in Visual Studio 14 RTM (DkmApiVersion.VS14RTM).
        public: _Ret_ DECLSPEC_NOTHROW DkmReadOnlyCollection<Evaluation::ClrCompilation::DkmClrLocalVariableInfo*>* STDMETHODCALLTYPE LocalInfo(
            );

        // Guid which uniquely identifies this query.
        //
        // This API was introduced in Visual Studio 14 RTM (DkmApiVersion.VS14RTM).
        public: DECLSPEC_NOTHROW const GUID& STDMETHODCALLTYPE UniqueId(
            );

        // Attempt to cast a 'DkmCompiledInspectionQuery' to a 'DkmCompiledClrLocalsQuery'. Return
        // NULL if the path object is not a 'DkmCompiledClrLocalsQuery'.
        // pCompiledClrLocalsQuery : [In,Optional] Object to attempt to cast
        // Return Value : [Optional] Result of the cast.
        public: static DECLSPEC_NOTHROW DkmCompiledClrLocalsQuery* TryCast(
            DkmCompiledInspectionQuery* pQuery
            )
        {
            if (pQuery == NULL || pQuery->TagValue() != Tag::CompiledClrLocalsQuery)
                return NULL;

            return static_cast<DkmCompiledClrLocalsQuery*>(pQuery);
        }

        /// <summary>
        /// Create a new DkmCompiledClrLocalsQuery object instance.
        ///
        /// This API was introduced in Visual Studio 14 RTM (DkmApiVersion.VS14RTM).
        /// </summary>
        /// <param name="pRuntimeInstance">
        /// [In] The DkmRuntimeInstance class represents an execution environment which is
        /// loaded into a DkmProcess and which contains code to be debugged.
        /// </param>
        /// <param name="pDataContainer">
        /// [In,Optional] Custom Data to associate with this inspection query.  It will
        /// persist as long as the query has the potential to execute.
        /// </param>
        /// <param name="LanguageId">
        /// [In] The language of the expression evaluator that created this query.
        /// </param>
        /// <param name="pBinary">
        /// [In] Binary of the query assembly.
        /// </param>
        /// <param name="pTypeName">
        /// [In] The fully qualified name of the type containing the query method.
        /// </param>
        /// <param name="pLocalInfo">
        /// [In] The collection of local variable names and method names on the query type to
        /// get the values.
        /// </param>
        /// <param name="ppCreatedObject">
        /// [Out] Result of this method call.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ DkmRuntimeInstance* pRuntimeInstance,
            _In_opt_ Evaluation::DkmCustomDataContainer* pDataContainer,
            _In_ const Evaluation::DkmCompilerId& LanguageId,
            _In_ DkmReadOnlyCollection<BYTE>* pBinary,
            _In_ DkmString* pTypeName,
            _In_ DkmReadOnlyCollection<Evaluation::ClrCompilation::DkmClrLocalVariableInfo*>* pLocalInfo,
            _Deref_out_ Evaluation::ClrCompilation::DkmCompiledClrLocalsQuery** ppCreatedObject
            );

        /// <summary>
        /// Execute a compiled inspection query to get a set of local variable values as a
        /// list of formatted DkmEvaluationResults.
        ///
        /// This method will append a new work item to the specified work list, and return
        /// once the work item has been appended. The actual processing of the work item is
        /// asynchronous. The caller will be notified that the request is complete through
        /// the completion routine.
        ///
        /// This API was introduced in Visual Studio 14 RTM (DkmApiVersion.VS14RTM).
        /// </summary>
        /// <param name="pWorkList">
        /// WorkList to append the new work item to.
        /// </param>
        /// <param name="pInspectionContext">
        /// [In] The inspection context for this query.
        /// </param>
        /// <param name="pILContext">
        /// [In] The stack context to execute the query against.
        /// </param>
        /// <param name="FirstLocalIndex">
        /// [In] The index of the first local variable to get the value for.
        /// </param>
        /// <param name="Count">
        /// [In] The number of local variables to get the value for.
        /// </param>
        /// <param name="pCompletionRoutine">
        /// Routine to fire when the request is complete. If the request is successfully
        /// appended to the work list, this will always fire (including when the operation is
        /// canceled). This will never fire if appending the work item fails.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetLocalValues(
            _In_ DkmWorkList* pWorkList,
            _In_ Evaluation::DkmInspectionContext* pInspectionContext,
            _In_ Evaluation::DkmILContext* pILContext,
            _In_ UINT32 FirstLocalIndex,
            _In_ UINT32 Count,
            _In_ IDkmCompletionRoutine<Evaluation::ClrCompilation::DkmGetLocalValuesAsyncResult>* pCompletionRoutine
            );
    }; // end of DkmCompiledClrLocalsQuery

};}; // end namespace Evaluation::ClrCompilation

// Contains the types used in the debugger's intermediate language (IL).
namespace Evaluation { namespace IL {
    // Describes the calling convention for a function evaluation on x86. Ignored for other
    // architectures.
    DEFINE_SCOPED_ENUM(DkmILCallingConvention)
    {
        // The x86 stdcall calling convention.
        StdCall = 0,
        // The x86 cdecl calling convention.
        CDecl = 1,
        // The x86 thiscall calling convention.
        ThisCall = 2,
        // The x86 fastcall calling convention.
        FastCall = 3
    };

    // An IL catch block, which can be used to recover from errors while executing IL.
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("1e8dd3ff-e859-f0c7-17a4-a59e0b7d7c62") DkmILCatchBlock : public IUnknown
    {
        private: ___ReferenceCount_t m_ReferenceCount;
        private: DkmDispatcherObjectFlags_t m_ObjectFlags;
        private: const GUID* m_pTypeId;
        private: size_t m_ObjectGCHandle;
        // Use DkmILCatchBlock::Create to create this object
        private: DkmILCatchBlock();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmILCatchBlock();
        // This object cannot be copied
        private: DkmILCatchBlock& operator=(const DkmILCatchBlock&);
        private: DkmILCatchBlock(const DkmILCatchBlock&);

        private: const Evaluation::IL::DkmILFailureReason_t m_ErrorCode;
        private: const UINT32 m_Target;
        private: void* m__pExtendedData;

        // The type of error to catch, "None" to catch all errors.
        public: DECLSPEC_NOTHROW Evaluation::IL::DkmILFailureReason_t STDMETHODCALLTYPE ErrorCode(
            );

        // The index of the IL instruction to jump to when the catch block executes.
        public: DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE Target(
            );

        /// <summary>
        /// Create a new DkmILCatchBlock object instance.
        /// </summary>
        /// <param name="ErrorCode">
        /// [In] The type of error to catch, "None" to catch all errors.
        /// </param>
        /// <param name="Target">
        /// [In] The index of the IL instruction to jump to when the catch block executes.
        /// </param>
        /// <param name="ppCreatedObject">
        /// [Out] Result of this method call.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ Evaluation::IL::DkmILFailureReason_t ErrorCode,
            _In_ UINT32 Target,
            _Deref_out_ Evaluation::IL::DkmILCatchBlock** ppCreatedObject
            );
    }; // end of DkmILCatchBlock

    // DkmILEvaluationResult represents the result of evaluating one DkmILInstruction.
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("892ad886-2235-9411-b588-a1da20887729") DkmILEvaluationResult : public IUnknown
    {
        private: ___ReferenceCount_t m_ReferenceCount;
        private: DkmDispatcherObjectFlags_t m_ObjectFlags;
        private: const GUID* m_pTypeId;
        private: size_t m_ObjectGCHandle;
        // Use DkmILEvaluationResult::Create to create this object
        private: DkmILEvaluationResult();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmILEvaluationResult();
        // This object cannot be copied
        private: DkmILEvaluationResult& operator=(const DkmILEvaluationResult&);
        private: DkmILEvaluationResult(const DkmILEvaluationResult&);

        // Contains additional fields of DkmILEvaluationResult which were added after the
        // class was initally introduced.
        private: struct ___ExtendedData
        {
            ___ExtendedData();

            // If true, indicates that the IL result is a pseudo-address, rather than an
            // actual value. The ResultBytes property of a pseudo-address will be the bytes
            // of the local variable that the pseudo-address refers to, excluding any bytes
            // prior to the offset of the pseudo-address.  The ResultBytes property of a
            // pseudo-address will be empty if the backing local variable does not exist, is
            // another pseudo-address, or is capturing fewer bytes than the byte offset of
            // the current pseudo-address. For details on pseudo-addresses, see the
            // DkmILPushLocalVariablePseudoAddress function.
            const bool IsPseudoAddress;

            // [Optional] If IsPseudoAddress is true, specifies the contents of the backing
            // data for the pseudo-address.  This will be NULL if the backing local variable
            // does not exist, is another pseudo-address, or contains fewer bytes than the
            // offset of the pseudo-address.
            OPTIONAL DkmReadOnlyCollection<BYTE>* const pDereferencedBytes;
        };

        private: const GUID m_SourceId;
        private: DkmReadOnlyCollection<BYTE>* const m_pResultBytes;
        private: ___ExtendedData* const m__pExtendedData;

        // UniqueId of the DkmILInstruction object that originally pushed the returned value
        // onto the evaluation stack.
        public: DECLSPEC_NOTHROW const GUID& STDMETHODCALLTYPE SourceId(
            );

        // The results of evaluating the DkmILInstruction.  Empty for pseudo-addresses.
        public: _Ret_ DECLSPEC_NOTHROW DkmReadOnlyCollection<BYTE>* STDMETHODCALLTYPE ResultBytes(
            );

        // If true, indicates that the IL result is a pseudo-address, rather than an actual
        // value. The ResultBytes property of a pseudo-address will be the bytes of the local
        // variable that the pseudo-address refers to, excluding any bytes prior to the
        // offset of the pseudo-address.  The ResultBytes property of a pseudo-address will
        // be empty if the backing local variable does not exist, is another pseudo-address,
        // or is capturing fewer bytes than the byte offset of the current pseudo-address.
        // For details on pseudo-addresses, see the DkmILPushLocalVariablePseudoAddress
        // function.
        //
        // This API was introduced in Visual Studio 14 RTM (DkmApiVersion.VS14RTM).
        public: DECLSPEC_NOTHROW bool STDMETHODCALLTYPE IsPseudoAddress(
            );

        // [Optional] If IsPseudoAddress is true, specifies the contents of the backing data
        // for the pseudo-address.  This will be NULL if the backing local variable does not
        // exist, is another pseudo-address, or contains fewer bytes than the offset of the
        // pseudo-address.
        //
        // This API was introduced in Visual Studio 14 RTM (DkmApiVersion.VS14RTM).
        public: _Ret_opt_ DECLSPEC_NOTHROW DkmReadOnlyCollection<BYTE>* STDMETHODCALLTYPE DereferencedBytes(
            );

        /// <summary>
        /// Create a new DkmILEvaluationResult object instance.
        /// </summary>
        /// <param name="SourceId">
        /// [In] UniqueId of the DkmILInstruction object that originally pushed the returned
        /// value onto the evaluation stack.
        /// </param>
        /// <param name="pResultBytes">
        /// [In] The results of evaluating the DkmILInstruction.  Empty for pseudo-addresses.
        /// </param>
        /// <param name="ppCreatedObject">
        /// [Out] Result of this method call.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ const GUID& SourceId,
            _In_ DkmReadOnlyCollection<BYTE>* pResultBytes,
            _Deref_out_ Evaluation::IL::DkmILEvaluationResult** ppCreatedObject
            );

        /// <summary>
        /// Create a new DkmILEvaluationResult object instance.
        ///
        /// This API was introduced in Visual Studio 14 RTM (DkmApiVersion.VS14RTM).
        /// </summary>
        /// <param name="SourceId">
        /// [In] UniqueId of the DkmILInstruction object that originally pushed the returned
        /// value onto the evaluation stack.
        /// </param>
        /// <param name="pResultBytes">
        /// [In] The results of evaluating the DkmILInstruction.  Empty for pseudo-addresses.
        /// </param>
        /// <param name="IsPseudoAddress">
        /// [In] If true, indicates that the IL result is a pseudo-address, rather than an
        /// actual value. The ResultBytes property of a pseudo-address will be the bytes of
        /// the local variable that the pseudo-address refers to, excluding any bytes prior
        /// to the offset of the pseudo-address.  The ResultBytes property of a
        /// pseudo-address will be empty if the backing local variable does not exist, is
        /// another pseudo-address, or is capturing fewer bytes than the byte offset of the
        /// current pseudo-address. For details on pseudo-addresses, see the
        /// DkmILPushLocalVariablePseudoAddress function.
        /// </param>
        /// <param name="pDereferencedBytes">
        /// [In,Optional] If IsPseudoAddress is true, specifies the contents of the backing
        /// data for the pseudo-address.  This will be NULL if the backing local variable
        /// does not exist, is another pseudo-address, or contains fewer bytes than the
        /// offset of the pseudo-address.
        /// </param>
        /// <param name="ppCreatedObject">
        /// [Out] Result of this method call.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ const GUID& SourceId,
            _In_ DkmReadOnlyCollection<BYTE>* pResultBytes,
            _In_ bool IsPseudoAddress,
            _In_opt_ DkmReadOnlyCollection<BYTE>* pDereferencedBytes,
            _Deref_out_ Evaluation::IL::DkmILEvaluationResult** ppCreatedObject
            );
    }; // end of DkmILEvaluationResult

    // Indicates a reason why an IL instruction failed to execute.  In addition to these
    // constants, negative values may be used to indicate customized error conditions
    // resulting from the execution of intrinsic functions.
    DEFINE_SCOPED_ENUM(DkmILFailureReason)
    {
        // The IL was evaluated successfully.
        None = 0,
        // An attempt was made to divide an integer by zero.
        DivideByZero = 1,
        // An attempt to read from the debuggee's memory failed.
        MemoryReadError = 2,
        // An attempt to write to the debuggee's memory failed.
        MemoryWriteError = 3,
        // An attempt to read the value of a register from the debuggee failed.
        RegisterReadError = 4,
        // An attempt to write to the value of a register from the debuggee failed.
        RegisterWriteError = 5,
        // Execution was terminated because the user cancelled the evaluation.
        Aborted = 6,
        // An attempt was made to read a string which was larger than the maximum length.
        StringTooLong = 7,
        // Execution was terminated because the evaluation timeout was exceeded.
        Timeout = 8,
        // A function evaluation is already in progress. Multiple function evaluations are
        // not supported.
        TooManyFuncEval = 9,
        // An attempt to abort the evaluation failed. The process is now in an indeterminate
        // state.
        AbortFailed = 10,
        // This operation is not supported while debugging a minidump.
        MinidumpNotSupported = 11,
        // The evaluation was aborted because an unhandled exception occurred in the process.
        AbortUnhandledException = 12,
        // This operation is not supported on a user-mode scheduled thread.
        UserModeScheduledNotSupported = 13,
        // A DkmILExtractBytes instruction failed because the range of bytes to extract falls
        // outside the bounds of the value.
        ByteExtractionOutOfBounds = 14,
        // An attempt was made to perform an unsupported operation with one or more
        // pseudo-address operands.
        InvalidPseudoAddressOperation = 15
    };

    // Flags affecting how arguments to a function evaluation are treated.
    DEFINE_SCOPED_ENUM(DkmILFunctionEvaluationArgumentFlags)
    {
        // No flags are set.
        Default = 0x0,
        // Set if this argument is a floating point value. This can affect how the value is
        // passed to the function.
        FloatingPoint = 0x1,
        // Set if this argument is a scalar type. On some architectures, this will affect how
        // the parameter is passed.
        Scalar = 0x2,
        // Set if the argument needs to be copied into the debuggee address space and then
        // passed by reference. Used to support string literals in argument parameters.
        CopyToDebuggee = 0x4,
        // Set if this argument is the this pointer for a call.
        ThisPointer = 0x8
    };
    DEFINE_SCOPED_ENUM_FLAG_OPERATORS(DkmILFunctionEvaluationArgumentFlags_t);

    // Flags affecting how a function evaluation should occur.
    DEFINE_SCOPED_ENUM(DkmILFunctionEvaluationFlags)
    {
        // No flags are set.
        Default = 0x0,
        // Set if this function returns a floating point value which changes how the return
        // value is found.
        FloatingPointReturn = 0x1,
        // Set if this function returns a scalar type. On some architectures this changes how
        // the value is returned.
        ScalarReturn = 0x2,
        // Set if the caller needs by-value return values returned as a reference on the
        // stack. The interpreter will make a copy of the return value on the debuggee stack
        // and return a pointer to that value. The value will only be valid in the debuggee
        // address space until the next continue or next function evaluation.
        ReturnAddressOfValue = 0x4,
        // Set if the return value will not be enregistered by the called function regardless
        // of return value size. This is used by the C++ expression evaluator when a class or
        // struct has a copy constructor defined and an instance of that class is being
        // returned by-value. The address of the return value on the stack will be returned
        // from the function evaluation. The value will only be valid in the debuggee address
        // space until the next continue or next function evaluation.
        NoEnregisteredReturn = 0x8,
        // Set if the function being called has a this pointer. The this pointer is the first
        // argument in the in the argument collection.
        HasThisPointer = 0x10,
        // Set if the return value for the function will be an enregistered complex return
        // type. This is used for the calling convention on arm where a composite type made
        // up of a number of elements of the same type is returned in registers. The size of
        // each element must be passed to the function evaluation instruction.
        // FloatingPointReturn is used to determine if the return value is in the in the
        // integer registers of the floating point registers.
        EnregisteredComplexReturn = 0x20
    };
    DEFINE_SCOPED_ENUM_FLAG_OPERATORS(DkmILFunctionEvaluationFlags_t);

    // Abstract base class for the concrete debugger immediate language instructions used by
    // expression evaluators to batch query information about the debuggee.
    //
    // Derived classes: DkmILAdd, DkmILAmpAdjustBufferTag, DkmILBeginTry, DkmILBitAnd,
    // DkmILBitFieldRead, DkmILBitFieldReadFromBytes, DkmILBitFieldWrite,
    // DkmILBitFieldWriteToBytes, DkmILBitNot, DkmILBitOr, DkmILBitShiftLeft,
    // DkmILBitShiftRight, DkmILBitXor, DkmILCompareEqual, DkmILCompareGreaterThan,
    // DkmILCompareGreaterThanOrEqual, DkmILCompareLessThan, DkmILCompareLessThanOrEqual,
    // DkmILCompareNotEqual, DkmILConvert, DkmILDivide, DkmILDuplicateTop, DkmILEndTry,
    // DkmILExecuteFunction, DkmILExecuteIntrinsic, DkmILExtractBytes, DkmILHlslBufferRead,
    // DkmILHlslGetGroupId, DkmILHlslGetThreadId, DkmILHlslIndexedRegisterRead,
    // DkmILHlslRegisterRead, DkmILIsFalse, DkmILIsTrue, DkmILJump, DkmILJumpIfFalse,
    // DkmILJumpIfTrue, DkmILLoad, DkmILMemoryRead, DkmILMemoryStringRead, DkmILMemoryWrite,
    // DkmILMultiply, DkmILNop, DkmILPop, DkmILPushConstant, DkmILRegisterRead,
    // DkmILRegisterWrite, DkmILRemainder, DkmILReturnTop, DkmILSave, DkmILSetBytesRegion,
    // DkmILSubtract, DkmILThrow, DkmILTlsGetValue, DkmILCheckTimeout,
    // DkmILExtractBytesPopArguments, DkmILPushLocalVariablePseudoAddress
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("fb5a5649-632c-d719-219e-d42a7ffffdc9") DkmILInstruction : public IUnknown
    {
        private: ___ReferenceCount_t m_ReferenceCount;
        private: DkmDispatcherObjectFlags_t m_ObjectFlags;
        private: const GUID* m_pTypeId;
        private: size_t m_ObjectGCHandle;
        // Use DkmILInstruction::Create to create this object
        private: DkmILInstruction();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmILInstruction();
        // This object cannot be copied
        private: DkmILInstruction& operator=(const DkmILInstruction&);
        private: DkmILInstruction(const DkmILInstruction&);

        // DkmILInstruction is an abstract base class. This enum indicates which derived
        // class this object is an instance of.
        public: FORWARD_DECLARE_SCOPED_ENUM(Tag);
        DEFINE_SCOPED_ENUM(Tag)
        {
        // Object is an instance of 'DkmILRegisterRead'.
        RegisterRead = 0,
        // Object is an instance of 'DkmILRegisterWrite'.
        RegisterWrite = 1,
        // Object is an instance of 'DkmILMemoryRead'.
        MemoryRead = 2,
        // Object is an instance of 'DkmILMemoryWrite'.
        MemoryWrite = 3,
        // Object is an instance of 'DkmILMemoryStringRead'.
        MemoryStringRead = 4,
        // Object is an instance of 'DkmILTlsGetValue'.
        TlsGetValue = 5,
        // Object is an instance of 'DkmILBitFieldRead'.
        BitFieldRead = 6,
        // Object is an instance of 'DkmILBitFieldWrite'.
        BitFieldWrite = 7,
        // Object is an instance of 'DkmILPushConstant'.
        PushConstant = 8,
        // Object is an instance of 'DkmILDuplicateTop'.
        DuplicateTop = 9,
        // Object is an instance of 'DkmILPop'.
        Pop = 10,
        // Object is an instance of 'DkmILSave'.
        Save = 11,
        // Object is an instance of 'DkmILLoad'.
        Load = 12,
        // Object is an instance of 'DkmILNop'.
        Nop = 13,
        // Object is an instance of 'DkmILAdd'.
        Add = 14,
        // Object is an instance of 'DkmILSubtract'.
        Subtract = 15,
        // Object is an instance of 'DkmILMultiply'.
        Multiply = 16,
        // Object is an instance of 'DkmILDivide'.
        Divide = 17,
        // Object is an instance of 'DkmILRemainder'.
        Remainder = 18,
        // Object is an instance of 'DkmILExtractBytes'.
        ExtractBytes = 19,
        // Object is an instance of 'DkmILSetBytesRegion'.
        SetBytesRegion = 20,
        // Object is an instance of 'DkmILBitFieldReadFromBytes'.
        BitFieldReadFromBytes = 21,
        // Object is an instance of 'DkmILBitFieldWriteToBytes'.
        BitFieldWriteToBytes = 22,
        // Object is an instance of 'DkmILBitAnd'.
        BitAnd = 23,
        // Object is an instance of 'DkmILBitOr'.
        BitOr = 24,
        // Object is an instance of 'DkmILBitXor'.
        BitXor = 25,
        // Object is an instance of 'DkmILBitShiftLeft'.
        BitShiftLeft = 26,
        // Object is an instance of 'DkmILBitShiftRight'.
        BitShiftRight = 27,
        // Object is an instance of 'DkmILBitNot'.
        BitNot = 28,
        // Object is an instance of 'DkmILIsTrue'.
        IsTrue = 29,
        // Object is an instance of 'DkmILIsFalse'.
        IsFalse = 30,
        // Object is an instance of 'DkmILCompareEqual'.
        CompareEqual = 31,
        // Object is an instance of 'DkmILCompareNotEqual'.
        CompareNotEqual = 32,
        // Object is an instance of 'DkmILCompareGreaterThan'.
        CompareGreaterThan = 33,
        // Object is an instance of 'DkmILCompareGreaterThanOrEqual'.
        CompareGreaterThanOrEqual = 34,
        // Object is an instance of 'DkmILCompareLessThan'.
        CompareLessThan = 35,
        // Object is an instance of 'DkmILCompareLessThanOrEqual'.
        CompareLessThanOrEqual = 36,
        // Object is an instance of 'DkmILConvert'.
        Convert = 37,
        // Object is an instance of 'DkmILReturnTop'.
        ReturnTop = 38,
        // Object is an instance of 'DkmILThrow'.
        Throw = 39,
        // Object is an instance of 'DkmILJump'.
        Jump = 40,
        // Object is an instance of 'DkmILJumpIfTrue'.
        JumpIfTrue = 41,
        // Object is an instance of 'DkmILJumpIfFalse'.
        JumpIfFalse = 42,
        // Object is an instance of 'DkmILExecuteIntrinsic'.
        ExecuteIntrinsic = 43,
        // Object is an instance of 'DkmILBeginTry'.
        BeginTry = 44,
        // Object is an instance of 'DkmILEndTry'.
        EndTry = 45,
        // Object is an instance of 'DkmILExecuteFunction'.
        ExecuteFunction = 46,
        // Object is an instance of 'DkmILHlslRegisterRead'.
        HlslRegisterRead = 47,
        // Object is an instance of 'DkmILHlslIndexedRegisterRead'.
        HlslIndexedRegisterRead = 48,
        // Object is an instance of 'DkmILHlslBufferRead'.
        HlslBufferRead = 49,
        // Object is an instance of 'DkmILHlslGetThreadId'.
        HlslGetThreadId = 50,
        // Object is an instance of 'DkmILHlslGetGroupId'.
        HlslGetGroupId = 51,
        // Object is an instance of 'DkmILAmpAdjustBufferTag'.
        AmpAdjustBufferTag = 52,
        // Object is an instance of 'DkmILExtractBytesPopArguments'.
        ExtractBytesPopArguments = 53,
        // Object is an instance of 'DkmILPushLocalVariablePseudoAddress'.
        PushLocalVariablePseudoAddress = 54,
        // Object is an instance of 'DkmILCheckTimeout'.
        CheckTimeout = 55
        };

        private: const Tag_t m_TagValue;
        private: const GUID m_UniqueId;
        private: void* m__pExtendedData;

        // DkmILInstruction is an abstract base class. This enum indicates which derived
        // class this object is an instance of.
        public: DECLSPEC_NOTHROW Tag_t STDMETHODCALLTYPE TagValue(
            );

        // Uniquely identifies the DkmILInstruction object. Used as a hash-table key to allow
        // for quickly matching up DkmIL instructions with their matching values.
        public: DECLSPEC_NOTHROW const GUID& STDMETHODCALLTYPE UniqueId(
            );
    }; // end of DkmILInstruction

    // A value that can be passed in as a parameter to an IL stream.
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("2aa6551e-a9cc-b1d5-d880-5ea0f21fd5e6") DkmILParameterValue : public IUnknown
    {
        private: ___ReferenceCount_t m_ReferenceCount;
        private: DkmDispatcherObjectFlags_t m_ObjectFlags;
        private: const GUID* m_pTypeId;
        private: size_t m_ObjectGCHandle;
        // Use DkmILParameterValue::Create to create this object
        private: DkmILParameterValue();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmILParameterValue();
        // This object cannot be copied
        private: DkmILParameterValue& operator=(const DkmILParameterValue&);
        private: DkmILParameterValue(const DkmILParameterValue&);

        // Contains additional fields of DkmILParameterValue which were added after the class
        // was initally introduced.
        private: struct ___ExtendedData
        {
            ___ExtendedData();

            // If true, the inspection query to execute will receive a pseudo-address of the
            // specified value, rather than the value itself.  If false, the inspection query
            // will directly receive the value as the specified parameter. For details on
            // pseudo-addresses, see the DkmILPushLocalVariablePseudoAddress instruction.
            const bool IsByRef;
        };

        private: const UINT32 m_LocalIndex;
        private: DkmReadOnlyCollection<BYTE>* const m_pValueBytes;
        private: ___ExtendedData* const m__pExtendedData;

        // The index of the local variable within the IL that will receive the parameter
        // value.  When the IL stream begins executing, the local variable at this index will
        // be preset to the parameter value.
        public: DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE LocalIndex(
            );

        // The bytes representing the value to pass in as the parameter.
        public: _Ret_ DECLSPEC_NOTHROW DkmReadOnlyCollection<BYTE>* STDMETHODCALLTYPE ValueBytes(
            );

        // If true, the inspection query to execute will receive a pseudo-address of the
        // specified value, rather than the value itself.  If false, the inspection query
        // will directly receive the value as the specified parameter. For details on
        // pseudo-addresses, see the DkmILPushLocalVariablePseudoAddress instruction.
        //
        // This API was introduced in Visual Studio 14 RTM (DkmApiVersion.VS14RTM).
        public: DECLSPEC_NOTHROW bool STDMETHODCALLTYPE IsByRef(
            );

        /// <summary>
        /// Create a new DkmILParameterValue object instance.
        /// </summary>
        /// <param name="LocalIndex">
        /// [In] The index of the local variable within the IL that will receive the
        /// parameter value.  When the IL stream begins executing, the local variable at this
        /// index will be preset to the parameter value.
        /// </param>
        /// <param name="pValueBytes">
        /// [In] The bytes representing the value to pass in as the parameter.
        /// </param>
        /// <param name="ppCreatedObject">
        /// [Out] Result of this method call.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ UINT32 LocalIndex,
            _In_ DkmReadOnlyCollection<BYTE>* pValueBytes,
            _Deref_out_ Evaluation::IL::DkmILParameterValue** ppCreatedObject
            );

        /// <summary>
        /// Create a new DkmILParameterValue object instance.
        ///
        /// This API was introduced in Visual Studio 14 RTM (DkmApiVersion.VS14RTM).
        /// </summary>
        /// <param name="LocalIndex">
        /// [In] The index of the local variable within the IL that will receive the
        /// parameter value.  When the IL stream begins executing, the local variable at this
        /// index will be preset to the parameter value.
        /// </param>
        /// <param name="pValueBytes">
        /// [In] The bytes representing the value to pass in as the parameter.
        /// </param>
        /// <param name="IsByRef">
        /// [In] If true, the inspection query to execute will receive a pseudo-address of
        /// the specified value, rather than the value itself.  If false, the inspection
        /// query will directly receive the value as the specified parameter. For details on
        /// pseudo-addresses, see the DkmILPushLocalVariablePseudoAddress instruction.
        /// </param>
        /// <param name="ppCreatedObject">
        /// [Out] Result of this method call.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ UINT32 LocalIndex,
            _In_ DkmReadOnlyCollection<BYTE>* pValueBytes,
            _In_ bool IsByRef,
            _Deref_out_ Evaluation::IL::DkmILParameterValue** ppCreatedObject
            );
    }; // end of DkmILParameterValue

    // Indicates the underlying primitive type (ex: UInt32) being operated on.
    DEFINE_SCOPED_ENUM(DkmPrimitiveObjectType)
    {
        // Represents a signed 8-bit integer.
        Int8 = 0,
        // Represents an unsigned 8-bit integer.
        UInt8 = 1,
        // Represents a signed 16-bit integer.
        Int16 = 2,
        // Represents an unsigned signed 16-bit integer.
        UInt16 = 3,
        // Represents a signed 32-bit integer.
        Int32 = 4,
        // Represents an unsigned 32-bit integer.
        UInt32 = 5,
        // Represents a signed 64-bit integer.
        Int64 = 6,
        // Represents an unsigned 64-bit integer.
        UInt64 = 7,
        // Represents a 32-bit single-precision floating-point value.
        Float = 8,
        // Represents a 64-bit double-precision floating-point value.
        Double = 9,
        // Represents a 10-byte floating-point value.
        LongDouble = 10
    };

    // An inspection query compiled to one or more DkmIL instructions.
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("b004e1ed-1890-adca-c358-d4fd722ecd98") DkmCompiledILInspectionQuery : public Evaluation::DkmCompiledInspectionQuery
    {
        // Use DkmCompiledILInspectionQuery::Create to create this object
        private: DkmCompiledILInspectionQuery();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmCompiledILInspectionQuery();
        // This object cannot be copied
        private: DkmCompiledILInspectionQuery& operator=(const DkmCompiledILInspectionQuery&);
        private: DkmCompiledILInspectionQuery(const DkmCompiledILInspectionQuery&);

        private: DkmReadOnlyCollection<Evaluation::IL::DkmILInstruction*>* const m_pInstructions;
        private: void* m__pExtendedData;

        // Body of the query.
        public: _Ret_ DECLSPEC_NOTHROW DkmReadOnlyCollection<Evaluation::IL::DkmILInstruction*>* STDMETHODCALLTYPE Instructions(
            );

        // Attempt to cast a 'DkmCompiledInspectionQuery' to a 'DkmCompiledILInspectionQuery'. Return
        // NULL if the path object is not a 'DkmCompiledILInspectionQuery'.
        // pDkmILQuery : [In,Optional] Object to attempt to cast
        // Return Value : [Optional] Result of the cast.
        public: static DECLSPEC_NOTHROW DkmCompiledILInspectionQuery* TryCast(
            DkmCompiledInspectionQuery* pQuery
            )
        {
            if (pQuery == NULL || pQuery->TagValue() != Tag::DkmILQuery)
                return NULL;

            return static_cast<DkmCompiledILInspectionQuery*>(pQuery);
        }

        /// <summary>
        /// Create a new DkmCompiledILInspectionQuery object instance.
        /// </summary>
        /// <param name="pRuntimeInstance">
        /// [In] The DkmRuntimeInstance class represents an execution environment which is
        /// loaded into a DkmProcess and which contains code to be debugged.
        /// </param>
        /// <param name="pInstructions">
        /// [In] Body of the query.
        /// </param>
        /// <param name="ppCreatedObject">
        /// [Out] Result of this method call.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ DkmRuntimeInstance* pRuntimeInstance,
            _In_ DkmReadOnlyCollection<Evaluation::IL::DkmILInstruction*>* pInstructions,
            _Deref_out_ Evaluation::IL::DkmCompiledILInspectionQuery** ppCreatedObject
            );

        /// <summary>
        /// Create a new DkmCompiledILInspectionQuery object instance.
        ///
        /// This API was introduced in Visual Studio 14 RTM (DkmApiVersion.VS14RTM).
        /// </summary>
        /// <param name="pRuntimeInstance">
        /// [In] The DkmRuntimeInstance class represents an execution environment which is
        /// loaded into a DkmProcess and which contains code to be debugged.
        /// </param>
        /// <param name="pDataContainer">
        /// [In,Optional] Custom Data to associate with this inspection query.  It will
        /// persist as long as the query has the potential to execute.
        /// </param>
        /// <param name="LanguageId">
        /// [In] The language of the expression evaluator that created this query.
        /// </param>
        /// <param name="pInstructions">
        /// [In] Body of the query.
        /// </param>
        /// <param name="ppCreatedObject">
        /// [Out] Result of this method call.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ DkmRuntimeInstance* pRuntimeInstance,
            _In_opt_ Evaluation::DkmCustomDataContainer* pDataContainer,
            _In_ const Evaluation::DkmCompilerId& LanguageId,
            _In_ DkmReadOnlyCollection<Evaluation::IL::DkmILInstruction*>* pInstructions,
            _Deref_out_ Evaluation::IL::DkmCompiledILInspectionQuery** ppCreatedObject
            );

        /// <summary>
        /// Executes a compiled inspection query and returns any results.
        /// </summary>
        /// <param name="pILContext">
        /// [In] The stack frame context we are evaluating on.
        /// </param>
        /// <param name="pThreads">
        /// [In] The compute threads to use when executing the query.
        /// </param>
        /// <param name="pParameters">
        /// [In,Optional] Parameters to pass to each thread.  The collection should be empty
        /// if unused, or have exactly as many members as the Threads parameter.
        /// </param>
        /// <param name="ppResult">
        /// [Out] Results of the evaluations.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ExecuteQueryOnThreads(
            _In_ Evaluation::DkmILContext* pILContext,
            _In_ DkmReadOnlyCollection<UINT64>* pThreads,
            _In_opt_ DkmReadOnlyCollection<Evaluation::Group::DkmILParameterValueCollection*>* pParameters,
            _Deref_out_ Evaluation::Group::DkmContextGroupEvaluationILResult** ppResult
            );

        /// <summary>
        /// Executes a compiled inspection query and returns any results.
        ///
        /// This method will append a new work item to the specified work list, and return
        /// once the work item has been appended. The actual processing of the work item is
        /// asynchronous. The caller will be notified that the request is complete through
        /// the completion routine.
        /// </summary>
        /// <param name="pWorkList">
        /// WorkList to append the new work item to.
        /// </param>
        /// <param name="pILContext">
        /// [In] The stack frame context we are evaluating on.
        /// </param>
        /// <param name="pThreads">
        /// [In] The compute threads to use when executing the query.
        /// </param>
        /// <param name="pParameters">
        /// [In,Optional] Parameters to pass to each thread.  The collection should be empty
        /// if unused, or have exactly as many members as the Threads parameter.
        /// </param>
        /// <param name="pCompletionRoutine">
        /// Routine to fire when the request is complete. If the request is successfully
        /// appended to the work list, this will always fire (including when the operation is
        /// canceled). This will never fire if appending the work item fails.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ExecuteQueryOnThreads(
            _In_ DkmWorkList* pWorkList,
            _In_ Evaluation::DkmILContext* pILContext,
            _In_ DkmReadOnlyCollection<UINT64>* pThreads,
            _In_opt_ DkmReadOnlyCollection<Evaluation::Group::DkmILParameterValueCollection*>* pParameters,
            _In_ IDkmCompletionRoutine<Evaluation::Group::DkmExecuteQueryOnThreadsAsyncResult>* pCompletionRoutine
            );
    }; // end of DkmCompiledILInspectionQuery

    // Pops two values off the evaluation stack, adds them, and pushes the sum onto the
    // evaluation stack. Both operands popped off the stack must be the size indicated by
    // DkmPrimitiveObjectType. The resultant value will have the same size as the operands.
    // In the event of overflow, the result will be truncated.
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("8cea2e5c-6a04-4523-4dad-b55f4052fc33") DkmILAdd : public Evaluation::IL::DkmILInstruction
    {
        // Use DkmILAdd::Create to create this object
        private: DkmILAdd();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmILAdd();
        // This object cannot be copied
        private: DkmILAdd& operator=(const DkmILAdd&);
        private: DkmILAdd(const DkmILAdd&);

        private: const Evaluation::IL::DkmPrimitiveObjectType_t m_Type;
        private: void* m__pExtendedData;

        // The type of addition to perform (e.g. integer vs. floating-point).
        public: DECLSPEC_NOTHROW Evaluation::IL::DkmPrimitiveObjectType_t STDMETHODCALLTYPE Type(
            );

        // Attempt to cast a 'DkmILInstruction' to a 'DkmILAdd'. Return
        // NULL if the path object is not a 'DkmILAdd'.
        // pAdd : [In,Optional] Object to attempt to cast
        // Return Value : [Optional] Result of the cast.
        public: static DECLSPEC_NOTHROW DkmILAdd* TryCast(
            DkmILInstruction* pILInstruction
            )
        {
            if (pILInstruction == NULL || pILInstruction->TagValue() != Tag::Add)
                return NULL;

            return static_cast<DkmILAdd*>(pILInstruction);
        }

        /// <summary>
        /// Create a new DkmILAdd object instance.
        /// </summary>
        /// <param name="Type">
        /// [In] The type of addition to perform (e.g. integer vs. floating-point).
        /// </param>
        /// <param name="ppCreatedObject">
        /// [Out] Result of this method call.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ Evaluation::IL::DkmPrimitiveObjectType_t Type,
            _Deref_out_ Evaluation::IL::DkmILAdd** ppCreatedObject
            );
    }; // end of DkmILAdd

    // A request to translate a C++ AMP pointer tag if its buffer has been forwarded.  Pops
    // the 32-bit tag off the stack, pushes the new 32-bit tag on the stack.  Usually a
    // no-op.
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("502429a9-011b-79f2-cd30-a5d0536c0376") DkmILAmpAdjustBufferTag : public Evaluation::IL::DkmILInstruction
    {
        // Use DkmILAmpAdjustBufferTag::Create to create this object
        private: DkmILAmpAdjustBufferTag();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmILAmpAdjustBufferTag();
        // This object cannot be copied
        private: DkmILAmpAdjustBufferTag& operator=(const DkmILAmpAdjustBufferTag&);
        private: DkmILAmpAdjustBufferTag(const DkmILAmpAdjustBufferTag&);

        private: void* m__pExtendedData;

        // Attempt to cast a 'DkmILInstruction' to a 'DkmILAmpAdjustBufferTag'. Return
        // NULL if the path object is not a 'DkmILAmpAdjustBufferTag'.
        // pAmpAdjustBufferTag : [In,Optional] Object to attempt to cast
        // Return Value : [Optional] Result of the cast.
        public: static DECLSPEC_NOTHROW DkmILAmpAdjustBufferTag* TryCast(
            DkmILInstruction* pILInstruction
            )
        {
            if (pILInstruction == NULL || pILInstruction->TagValue() != Tag::AmpAdjustBufferTag)
                return NULL;

            return static_cast<DkmILAmpAdjustBufferTag*>(pILInstruction);
        }

        /// <summary>
        /// Create a new DkmILAmpAdjustBufferTag object instance.
        /// </summary>
        /// <param name="ppCreatedObject">
        /// [Out] Result of this method call.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _Deref_out_ Evaluation::IL::DkmILAmpAdjustBufferTag** ppCreatedObject
            );
    }; // end of DkmILAmpAdjustBufferTag

    // Begins a try block.  If an error occurs within the execution of the try block, control
    // will jump to an appropriate catch block to allow the IL to recover from the error.
    // Exception handling in native IL works as follows: An exception in native IL means that
    // some operation, such as a register read or memory read failed.  Each exception is
    // identified by a 32-bit exception code that describes the problem.  Exception code
    // values are defined according to the DkmILFailureReason enumeration, and additional
    // user-defined values may also be used to handle exception-conditions that are specific
    // to an intrinsic function (e.g. attempt to take the log of 0).
    //
    // By default, when an exception occurs, the IL processing will stop immediately, causing
    // DkmCompiledInspectionQuery::ExecuteQuery() to fail, returning the exception code as an
    // out parameter.  To handle the exception with IL, the IL should execute a DkmILBeginTry
    // instruction to enter a guarded exception-handling state.  The IL processing will
    // remain in this state until a DkmILEndTryBlock instruction is executed.
    //
    // A DkmILBeginTryBlock instruction specifies what to do if an exception occurs within
    // the block.  The block's exception handling logic is defined by a collection of
    // DkmILCatchBlock objects.  Each catch block defines the exception code that the catch
    // block will catch, as well as the offset into the instruction stream where the catch
    // block is located at.
    //
    // Thus, when an exception occurs, we will do the following:
    //
    // 1) Check if we are inside a try block: No: Abort the IL operation and cause
    // DkmCompiledInspectionQuery::ExecuteQuery() to fail. Yes: 2) Examine the list of
    // DkmILCatchBlock objects associated with the try block in sequential order, looking for
    // a catch block that catches the exception code. (If more than one catch block works, we
    // use the first match and ignore the other matches). If we find a match: - Clear the
    // state that says we're in a try block (so any exceptions from the catch handler will go
    // unhandled unless a new try block gets set up) - Remove all values from the IL stack
    // that got pushed after we entered the try block.  Local variables, saved return values,
    // and IL stack values that were already pushed before the try block began are retained.
    // (It is illegal to pop a value off the stack inside a try block that got pushed outside
    // the try block). - Push the exception code on the stack as a 32-bit value - Transfer
    // control to the offset of the catch handler and continue the IL If we don't find a
    // match: - The exception is unhandled.  Abort the IL operation and cause
    // DkmCompiledInspectionQuery::ExecuteQuery() to fail.
    //
    // If during the execution of the inspection query, we detect that the work list has been
    // canceled, we will promptly abort the IL processing.  The IL will not have a chance to
    // handle this.
    //
    // In general, exception handling is allowed when an inspection fails, or an arithmetic
    // error occurs (e.g. division by zero), however, on error conditions that can only arise
    // through invalid IL (e.g. attempt to pop from empty stack), we do not guarantee that
    // exception handling of such errors will be supported.  If an exception occurs that we
    // do not support handling, the IL processing will simply abort.
    //
    // Currently, nested try blocks are not supported, that is, an attempt to execute a
    // DkmILBeginTry while already inside a try block is considered an error.
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("16f727a6-1a24-9c23-11b3-1a4cfe666cc6") DkmILBeginTry : public Evaluation::IL::DkmILInstruction
    {
        // Use DkmILBeginTry::Create to create this object
        private: DkmILBeginTry();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmILBeginTry();
        // This object cannot be copied
        private: DkmILBeginTry& operator=(const DkmILBeginTry&);
        private: DkmILBeginTry(const DkmILBeginTry&);

        private: DkmReadOnlyCollection<Evaluation::IL::DkmILCatchBlock*>* const m_pCatchBlocks;
        private: void* m__pExtendedData;

        // Ordered list of catch blocks to handle exceptions occurring within the try block.
        public: _Ret_ DECLSPEC_NOTHROW DkmReadOnlyCollection<Evaluation::IL::DkmILCatchBlock*>* STDMETHODCALLTYPE CatchBlocks(
            );

        // Attempt to cast a 'DkmILInstruction' to a 'DkmILBeginTry'. Return
        // NULL if the path object is not a 'DkmILBeginTry'.
        // pBeginTry : [In,Optional] Object to attempt to cast
        // Return Value : [Optional] Result of the cast.
        public: static DECLSPEC_NOTHROW DkmILBeginTry* TryCast(
            DkmILInstruction* pILInstruction
            )
        {
            if (pILInstruction == NULL || pILInstruction->TagValue() != Tag::BeginTry)
                return NULL;

            return static_cast<DkmILBeginTry*>(pILInstruction);
        }

        /// <summary>
        /// Create a new DkmILBeginTry object instance.
        /// </summary>
        /// <param name="pCatchBlocks">
        /// [In] Ordered list of catch blocks to handle exceptions occurring within the try
        /// block.
        /// </param>
        /// <param name="ppCreatedObject">
        /// [Out] Result of this method call.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ DkmReadOnlyCollection<Evaluation::IL::DkmILCatchBlock*>* pCatchBlocks,
            _Deref_out_ Evaluation::IL::DkmILBeginTry** ppCreatedObject
            );
    }; // end of DkmILBeginTry

    // Pops two integer values off of the evaluation stack.  Performs a bitwise and on the
    // two values, and pushes the result onto the stack. The two values popped from the stack
    // must be the same size.
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("1c046c38-4667-3b0c-3387-6efc9b66c74e") DkmILBitAnd : public Evaluation::IL::DkmILInstruction
    {
        // Use DkmILBitAnd::Create to create this object
        private: DkmILBitAnd();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmILBitAnd();
        // This object cannot be copied
        private: DkmILBitAnd& operator=(const DkmILBitAnd&);
        private: DkmILBitAnd(const DkmILBitAnd&);

        private: const Evaluation::IL::DkmPrimitiveObjectType_t m_Type;
        private: void* m__pExtendedData;

        // The type of operands to expect (e.g. 32-bit or 64-bit).  Floating-point modes are
        // not allowed.
        public: DECLSPEC_NOTHROW Evaluation::IL::DkmPrimitiveObjectType_t STDMETHODCALLTYPE Type(
            );

        // Attempt to cast a 'DkmILInstruction' to a 'DkmILBitAnd'. Return
        // NULL if the path object is not a 'DkmILBitAnd'.
        // pBitAnd : [In,Optional] Object to attempt to cast
        // Return Value : [Optional] Result of the cast.
        public: static DECLSPEC_NOTHROW DkmILBitAnd* TryCast(
            DkmILInstruction* pILInstruction
            )
        {
            if (pILInstruction == NULL || pILInstruction->TagValue() != Tag::BitAnd)
                return NULL;

            return static_cast<DkmILBitAnd*>(pILInstruction);
        }

        /// <summary>
        /// Create a new DkmILBitAnd object instance.
        /// </summary>
        /// <param name="Type">
        /// [In] The type of operands to expect (e.g. 32-bit or 64-bit).  Floating-point
        /// modes are not allowed.
        /// </param>
        /// <param name="ppCreatedObject">
        /// [Out] Result of this method call.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ Evaluation::IL::DkmPrimitiveObjectType_t Type,
            _Deref_out_ Evaluation::IL::DkmILBitAnd** ppCreatedObject
            );
    }; // end of DkmILBitAnd

    // Reads the value of a bit field from memory.  The address of the bit field is popped
    // off the stack.
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("9b7942ff-9ac4-effb-46a9-8f06682d8472") DkmILBitFieldRead : public Evaluation::IL::DkmILInstruction
    {
        // Use DkmILBitFieldRead::Create to create this object
        private: DkmILBitFieldRead();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmILBitFieldRead();
        // This object cannot be copied
        private: DkmILBitFieldRead& operator=(const DkmILBitFieldRead&);
        private: DkmILBitFieldRead(const DkmILBitFieldRead&);

        private: const UINT32 m_BitPosition;
        private: const UINT32 m_NumBits;
        private: const Evaluation::IL::DkmPrimitiveObjectType_t m_Type;
        private: void* m__pExtendedData;

        // The bit position to read from.  Must be between 0 and 63.
        public: DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE BitPosition(
            );

        // Number of bits to read.  Must be between 1 and 64.
        public: DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE NumBits(
            );

        // The type of object to read.  Must be an integer and must be at least as large, in
        // bits, as NumBits.
        public: DECLSPEC_NOTHROW Evaluation::IL::DkmPrimitiveObjectType_t STDMETHODCALLTYPE Type(
            );

        // Attempt to cast a 'DkmILInstruction' to a 'DkmILBitFieldRead'. Return
        // NULL if the path object is not a 'DkmILBitFieldRead'.
        // pBitFieldRead : [In,Optional] Object to attempt to cast
        // Return Value : [Optional] Result of the cast.
        public: static DECLSPEC_NOTHROW DkmILBitFieldRead* TryCast(
            DkmILInstruction* pILInstruction
            )
        {
            if (pILInstruction == NULL || pILInstruction->TagValue() != Tag::BitFieldRead)
                return NULL;

            return static_cast<DkmILBitFieldRead*>(pILInstruction);
        }

        /// <summary>
        /// Create a new DkmILBitFieldRead object instance.
        /// </summary>
        /// <param name="BitPosition">
        /// [In] The bit position to read from.  Must be between 0 and 63.
        /// </param>
        /// <param name="NumBits">
        /// [In] Number of bits to read.  Must be between 1 and 64.
        /// </param>
        /// <param name="Type">
        /// [In] The type of object to read.  Must be an integer and must be at least as
        /// large, in bits, as NumBits.
        /// </param>
        /// <param name="ppCreatedObject">
        /// [Out] Result of this method call.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ UINT32 BitPosition,
            _In_ UINT32 NumBits,
            _In_ Evaluation::IL::DkmPrimitiveObjectType_t Type,
            _Deref_out_ Evaluation::IL::DkmILBitFieldRead** ppCreatedObject
            );
    }; // end of DkmILBitFieldRead

    // Pops a value off the IL stack.  Then, reads a bit-field directly off that value.  This
    // is different from DkmILBitFieldRead in that the value popped from the stack directly
    // contains the value to read the bits from, rather than a memory address.
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("795365b6-659e-619a-ad13-37942b3f7788") DkmILBitFieldReadFromBytes : public Evaluation::IL::DkmILInstruction
    {
        // Use DkmILBitFieldReadFromBytes::Create to create this object
        private: DkmILBitFieldReadFromBytes();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmILBitFieldReadFromBytes();
        // This object cannot be copied
        private: DkmILBitFieldReadFromBytes& operator=(const DkmILBitFieldReadFromBytes&);
        private: DkmILBitFieldReadFromBytes(const DkmILBitFieldReadFromBytes&);

        private: const UINT32 m_ByteOffset;
        private: const UINT32 m_BitPosition;
        private: const UINT32 m_NumBits;
        private: const Evaluation::IL::DkmPrimitiveObjectType_t m_Type;
        private: void* m__pExtendedData;

        // Offset within the state of the value where the bit-field begins.
        public: DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE ByteOffset(
            );

        // The bit position to read from.  Must be between 0 and 63.
        public: DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE BitPosition(
            );

        // Number of bits to read.  Must be between 1 and 64.
        public: DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE NumBits(
            );

        // The type of object to read.  Must be an integer and must be at least as large, in
        // bits, as NumBits.
        public: DECLSPEC_NOTHROW Evaluation::IL::DkmPrimitiveObjectType_t STDMETHODCALLTYPE Type(
            );

        // Attempt to cast a 'DkmILInstruction' to a 'DkmILBitFieldReadFromBytes'. Return
        // NULL if the path object is not a 'DkmILBitFieldReadFromBytes'.
        // pBitFieldReadFromBytes : [In,Optional] Object to attempt to cast
        // Return Value : [Optional] Result of the cast.
        public: static DECLSPEC_NOTHROW DkmILBitFieldReadFromBytes* TryCast(
            DkmILInstruction* pILInstruction
            )
        {
            if (pILInstruction == NULL || pILInstruction->TagValue() != Tag::BitFieldReadFromBytes)
                return NULL;

            return static_cast<DkmILBitFieldReadFromBytes*>(pILInstruction);
        }

        /// <summary>
        /// Create a new DkmILBitFieldReadFromBytes object instance.
        /// </summary>
        /// <param name="ByteOffset">
        /// [In] Offset within the state of the value where the bit-field begins.
        /// </param>
        /// <param name="BitPosition">
        /// [In] The bit position to read from.  Must be between 0 and 63.
        /// </param>
        /// <param name="NumBits">
        /// [In] Number of bits to read.  Must be between 1 and 64.
        /// </param>
        /// <param name="Type">
        /// [In] The type of object to read.  Must be an integer and must be at least as
        /// large, in bits, as NumBits.
        /// </param>
        /// <param name="ppCreatedObject">
        /// [Out] Result of this method call.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ UINT32 ByteOffset,
            _In_ UINT32 BitPosition,
            _In_ UINT32 NumBits,
            _In_ Evaluation::IL::DkmPrimitiveObjectType_t Type,
            _Deref_out_ Evaluation::IL::DkmILBitFieldReadFromBytes** ppCreatedObject
            );
    }; // end of DkmILBitFieldReadFromBytes

    // Pops a value off the stack.  Then, pops a memory address off the stack.  Then,
    // modifies the value of the bit field at that memory address, at the given offset and
    // size, to match the value that was just popped off the stack.
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("2be85ffe-5c9c-7f41-cef6-cd2c051e2ee7") DkmILBitFieldWrite : public Evaluation::IL::DkmILInstruction
    {
        // Use DkmILBitFieldWrite::Create to create this object
        private: DkmILBitFieldWrite();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmILBitFieldWrite();
        // This object cannot be copied
        private: DkmILBitFieldWrite& operator=(const DkmILBitFieldWrite&);
        private: DkmILBitFieldWrite(const DkmILBitFieldWrite&);

        private: const UINT32 m_BitPosition;
        private: const UINT32 m_NumBits;
        private: void* m__pExtendedData;

        // The bit position to write to.  Must be between 0 and 63.
        public: DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE BitPosition(
            );

        // Number of bits to write.  Must be between 1 and 64.
        public: DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE NumBits(
            );

        // Attempt to cast a 'DkmILInstruction' to a 'DkmILBitFieldWrite'. Return
        // NULL if the path object is not a 'DkmILBitFieldWrite'.
        // pBitFieldWrite : [In,Optional] Object to attempt to cast
        // Return Value : [Optional] Result of the cast.
        public: static DECLSPEC_NOTHROW DkmILBitFieldWrite* TryCast(
            DkmILInstruction* pILInstruction
            )
        {
            if (pILInstruction == NULL || pILInstruction->TagValue() != Tag::BitFieldWrite)
                return NULL;

            return static_cast<DkmILBitFieldWrite*>(pILInstruction);
        }

        /// <summary>
        /// Create a new DkmILBitFieldWrite object instance.
        /// </summary>
        /// <param name="BitPosition">
        /// [In] The bit position to write to.  Must be between 0 and 63.
        /// </param>
        /// <param name="NumBits">
        /// [In] Number of bits to write.  Must be between 1 and 64.
        /// </param>
        /// <param name="ppCreatedObject">
        /// [Out] Result of this method call.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ UINT32 BitPosition,
            _In_ UINT32 NumBits,
            _Deref_out_ Evaluation::IL::DkmILBitFieldWrite** ppCreatedObject
            );
    }; // end of DkmILBitFieldWrite

    // Pops a value off the IL stack.  Then pops a second value off the IL stack.  The first
    // value to be popped (second to be pushed) will be treated as an object that contains a
    // bit field described herein.  The second value to be popped (first to be pushed) will
    // be the value of the bit field that will be inserted into the first value.  The result
    // of the modification is then pushed onto the IL stack.
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("470db7c1-3e41-3dde-ac43-bf52c441847d") DkmILBitFieldWriteToBytes : public Evaluation::IL::DkmILInstruction
    {
        // Use DkmILBitFieldWriteToBytes::Create to create this object
        private: DkmILBitFieldWriteToBytes();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmILBitFieldWriteToBytes();
        // This object cannot be copied
        private: DkmILBitFieldWriteToBytes& operator=(const DkmILBitFieldWriteToBytes&);
        private: DkmILBitFieldWriteToBytes(const DkmILBitFieldWriteToBytes&);

        private: const UINT32 m_ByteOffset;
        private: const UINT32 m_BitPosition;
        private: const UINT32 m_NumBits;
        private: void* m__pExtendedData;

        // Offset within the state of the value where the bit-field begins.
        public: DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE ByteOffset(
            );

        // The bit position to write to.  Must be between 0 and 63.
        public: DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE BitPosition(
            );

        // Number of bits to write.  Must be between 1 and 64.
        public: DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE NumBits(
            );

        // Attempt to cast a 'DkmILInstruction' to a 'DkmILBitFieldWriteToBytes'. Return
        // NULL if the path object is not a 'DkmILBitFieldWriteToBytes'.
        // pBitFieldWriteToBytes : [In,Optional] Object to attempt to cast
        // Return Value : [Optional] Result of the cast.
        public: static DECLSPEC_NOTHROW DkmILBitFieldWriteToBytes* TryCast(
            DkmILInstruction* pILInstruction
            )
        {
            if (pILInstruction == NULL || pILInstruction->TagValue() != Tag::BitFieldWriteToBytes)
                return NULL;

            return static_cast<DkmILBitFieldWriteToBytes*>(pILInstruction);
        }

        /// <summary>
        /// Create a new DkmILBitFieldWriteToBytes object instance.
        /// </summary>
        /// <param name="ByteOffset">
        /// [In] Offset within the state of the value where the bit-field begins.
        /// </param>
        /// <param name="BitPosition">
        /// [In] The bit position to write to.  Must be between 0 and 63.
        /// </param>
        /// <param name="NumBits">
        /// [In] Number of bits to write.  Must be between 1 and 64.
        /// </param>
        /// <param name="ppCreatedObject">
        /// [Out] Result of this method call.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ UINT32 ByteOffset,
            _In_ UINT32 BitPosition,
            _In_ UINT32 NumBits,
            _Deref_out_ Evaluation::IL::DkmILBitFieldWriteToBytes** ppCreatedObject
            );
    }; // end of DkmILBitFieldWriteToBytes

    // Pops an integer value off of the evaluation stack.  Inverts all the bits and pushes
    // the result onto the stack.
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("ead1642b-da0a-3e0e-0f8c-ab1c3279fb0f") DkmILBitNot : public Evaluation::IL::DkmILInstruction
    {
        // Use DkmILBitNot::Create to create this object
        private: DkmILBitNot();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmILBitNot();
        // This object cannot be copied
        private: DkmILBitNot& operator=(const DkmILBitNot&);
        private: DkmILBitNot(const DkmILBitNot&);

        private: const Evaluation::IL::DkmPrimitiveObjectType_t m_Type;
        private: void* m__pExtendedData;

        // The type of operands to expect (e.g. 32-bit or 64-bit).  Floating-point modes are
        // not allowed.
        public: DECLSPEC_NOTHROW Evaluation::IL::DkmPrimitiveObjectType_t STDMETHODCALLTYPE Type(
            );

        // Attempt to cast a 'DkmILInstruction' to a 'DkmILBitNot'. Return
        // NULL if the path object is not a 'DkmILBitNot'.
        // pBitNot : [In,Optional] Object to attempt to cast
        // Return Value : [Optional] Result of the cast.
        public: static DECLSPEC_NOTHROW DkmILBitNot* TryCast(
            DkmILInstruction* pILInstruction
            )
        {
            if (pILInstruction == NULL || pILInstruction->TagValue() != Tag::BitNot)
                return NULL;

            return static_cast<DkmILBitNot*>(pILInstruction);
        }

        /// <summary>
        /// Create a new DkmILBitNot object instance.
        /// </summary>
        /// <param name="Type">
        /// [In] The type of operands to expect (e.g. 32-bit or 64-bit).  Floating-point
        /// modes are not allowed.
        /// </param>
        /// <param name="ppCreatedObject">
        /// [Out] Result of this method call.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ Evaluation::IL::DkmPrimitiveObjectType_t Type,
            _Deref_out_ Evaluation::IL::DkmILBitNot** ppCreatedObject
            );
    }; // end of DkmILBitNot

    // Pops two integer values off of the evaluation stack.  Performs a bitwise or on the two
    // values, and pushes the result onto the stack. The two values popped from the stack
    // must be the same size.
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("59c33aa2-28f3-0da3-ed3a-676ae57f6470") DkmILBitOr : public Evaluation::IL::DkmILInstruction
    {
        // Use DkmILBitOr::Create to create this object
        private: DkmILBitOr();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmILBitOr();
        // This object cannot be copied
        private: DkmILBitOr& operator=(const DkmILBitOr&);
        private: DkmILBitOr(const DkmILBitOr&);

        private: const Evaluation::IL::DkmPrimitiveObjectType_t m_Type;
        private: void* m__pExtendedData;

        // The type of operands to expect (e.g. 32-bit or 64-bit).  Floating-point modes are
        // not allowed.
        public: DECLSPEC_NOTHROW Evaluation::IL::DkmPrimitiveObjectType_t STDMETHODCALLTYPE Type(
            );

        // Attempt to cast a 'DkmILInstruction' to a 'DkmILBitOr'. Return
        // NULL if the path object is not a 'DkmILBitOr'.
        // pBitOr : [In,Optional] Object to attempt to cast
        // Return Value : [Optional] Result of the cast.
        public: static DECLSPEC_NOTHROW DkmILBitOr* TryCast(
            DkmILInstruction* pILInstruction
            )
        {
            if (pILInstruction == NULL || pILInstruction->TagValue() != Tag::BitOr)
                return NULL;

            return static_cast<DkmILBitOr*>(pILInstruction);
        }

        /// <summary>
        /// Create a new DkmILBitOr object instance.
        /// </summary>
        /// <param name="Type">
        /// [In] The type of operands to expect (e.g. 32-bit or 64-bit).  Floating-point
        /// modes are not allowed.
        /// </param>
        /// <param name="ppCreatedObject">
        /// [Out] Result of this method call.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ Evaluation::IL::DkmPrimitiveObjectType_t Type,
            _Deref_out_ Evaluation::IL::DkmILBitOr** ppCreatedObject
            );
    }; // end of DkmILBitOr

    // Pops two integer values off of the evaluation stack.  Shifts the first value left by
    // the second value and pushes the result onto the evaluation stack. The first operand
    // must be the size indicated by by DkmPrimitiveObjectType. The second operand must be
    // 32-bit.
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("9e02b526-a3d3-1eb3-eaf5-0e817af4e47d") DkmILBitShiftLeft : public Evaluation::IL::DkmILInstruction
    {
        // Use DkmILBitShiftLeft::Create to create this object
        private: DkmILBitShiftLeft();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmILBitShiftLeft();
        // This object cannot be copied
        private: DkmILBitShiftLeft& operator=(const DkmILBitShiftLeft&);
        private: DkmILBitShiftLeft(const DkmILBitShiftLeft&);

        private: const Evaluation::IL::DkmPrimitiveObjectType_t m_Type;
        private: void* m__pExtendedData;

        // The type of operands to expect (e.g. 32-bit or 64-bit).  Floating-point modes are
        // not allowed.
        public: DECLSPEC_NOTHROW Evaluation::IL::DkmPrimitiveObjectType_t STDMETHODCALLTYPE Type(
            );

        // Attempt to cast a 'DkmILInstruction' to a 'DkmILBitShiftLeft'. Return
        // NULL if the path object is not a 'DkmILBitShiftLeft'.
        // pBitShiftLeft : [In,Optional] Object to attempt to cast
        // Return Value : [Optional] Result of the cast.
        public: static DECLSPEC_NOTHROW DkmILBitShiftLeft* TryCast(
            DkmILInstruction* pILInstruction
            )
        {
            if (pILInstruction == NULL || pILInstruction->TagValue() != Tag::BitShiftLeft)
                return NULL;

            return static_cast<DkmILBitShiftLeft*>(pILInstruction);
        }

        /// <summary>
        /// Create a new DkmILBitShiftLeft object instance.
        /// </summary>
        /// <param name="Type">
        /// [In] The type of operands to expect (e.g. 32-bit or 64-bit).  Floating-point
        /// modes are not allowed.
        /// </param>
        /// <param name="ppCreatedObject">
        /// [Out] Result of this method call.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ Evaluation::IL::DkmPrimitiveObjectType_t Type,
            _Deref_out_ Evaluation::IL::DkmILBitShiftLeft** ppCreatedObject
            );
    }; // end of DkmILBitShiftLeft

    // Pops two integer values off of the evaluation stack.  Shifts the first value right by
    // the second value and pushes the result onto the evaluation stack.  The first operand
    // must be the size indicated by by DkmPrimitiveObjectType. The second operand must be
    // 32-bit.
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("8b4645e9-19a8-ba08-9554-3f17f197f478") DkmILBitShiftRight : public Evaluation::IL::DkmILInstruction
    {
        // Use DkmILBitShiftRight::Create to create this object
        private: DkmILBitShiftRight();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmILBitShiftRight();
        // This object cannot be copied
        private: DkmILBitShiftRight& operator=(const DkmILBitShiftRight&);
        private: DkmILBitShiftRight(const DkmILBitShiftRight&);

        private: const Evaluation::IL::DkmPrimitiveObjectType_t m_Type;
        private: void* m__pExtendedData;

        // The type of operands to expect (e.g. 32-bit or 64-bit). Floating-point modes are
        // not allowed. Also, specifies whether the operation is signed or unsigned.  An
        // unsigned mode means the upper-bit will be filled with a zero; a signed mode means
        // the upper-bit will be preserved.
        public: DECLSPEC_NOTHROW Evaluation::IL::DkmPrimitiveObjectType_t STDMETHODCALLTYPE Type(
            );

        // Attempt to cast a 'DkmILInstruction' to a 'DkmILBitShiftRight'. Return
        // NULL if the path object is not a 'DkmILBitShiftRight'.
        // pBitShiftRight : [In,Optional] Object to attempt to cast
        // Return Value : [Optional] Result of the cast.
        public: static DECLSPEC_NOTHROW DkmILBitShiftRight* TryCast(
            DkmILInstruction* pILInstruction
            )
        {
            if (pILInstruction == NULL || pILInstruction->TagValue() != Tag::BitShiftRight)
                return NULL;

            return static_cast<DkmILBitShiftRight*>(pILInstruction);
        }

        /// <summary>
        /// Create a new DkmILBitShiftRight object instance.
        /// </summary>
        /// <param name="Type">
        /// [In] The type of operands to expect (e.g. 32-bit or 64-bit). Floating-point modes
        /// are not allowed. Also, specifies whether the operation is signed or unsigned.  An
        /// unsigned mode means the upper-bit will be filled with a zero; a signed mode means
        /// the upper-bit will be preserved.
        /// </param>
        /// <param name="ppCreatedObject">
        /// [Out] Result of this method call.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ Evaluation::IL::DkmPrimitiveObjectType_t Type,
            _Deref_out_ Evaluation::IL::DkmILBitShiftRight** ppCreatedObject
            );
    }; // end of DkmILBitShiftRight

    // Pops two integer values off of the evaluation stack.  Performs a bitwise exclusive-or
    // on the two values, and pushes the result onto the stack. The two values popped from
    // the stack must be the same size.
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("9f0eb985-42c0-fbc0-1d85-2371aca7e7c1") DkmILBitXor : public Evaluation::IL::DkmILInstruction
    {
        // Use DkmILBitXor::Create to create this object
        private: DkmILBitXor();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmILBitXor();
        // This object cannot be copied
        private: DkmILBitXor& operator=(const DkmILBitXor&);
        private: DkmILBitXor(const DkmILBitXor&);

        private: const Evaluation::IL::DkmPrimitiveObjectType_t m_Type;
        private: void* m__pExtendedData;

        // The type of operands to expect (e.g. 32-bit or 64-bit).  Floating-point modes are
        // not allowed.
        public: DECLSPEC_NOTHROW Evaluation::IL::DkmPrimitiveObjectType_t STDMETHODCALLTYPE Type(
            );

        // Attempt to cast a 'DkmILInstruction' to a 'DkmILBitXor'. Return
        // NULL if the path object is not a 'DkmILBitXor'.
        // pBitXor : [In,Optional] Object to attempt to cast
        // Return Value : [Optional] Result of the cast.
        public: static DECLSPEC_NOTHROW DkmILBitXor* TryCast(
            DkmILInstruction* pILInstruction
            )
        {
            if (pILInstruction == NULL || pILInstruction->TagValue() != Tag::BitXor)
                return NULL;

            return static_cast<DkmILBitXor*>(pILInstruction);
        }

        /// <summary>
        /// Create a new DkmILBitXor object instance.
        /// </summary>
        /// <param name="Type">
        /// [In] The type of operands to expect (e.g. 32-bit or 64-bit).  Floating-point
        /// modes are not allowed.
        /// </param>
        /// <param name="ppCreatedObject">
        /// [Out] Result of this method call.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ Evaluation::IL::DkmPrimitiveObjectType_t Type,
            _Deref_out_ Evaluation::IL::DkmILBitXor** ppCreatedObject
            );
    }; // end of DkmILBitXor

    // Checks if the timeout limit on the IL stream has been exceeded.  If so, throws an IL
    // exception with failure code 'Aborted'.  This exception may be handled in a catch
    // block, so immediate termination of the IL is not guaranteed.  Otherwise, this
    // instruction simply returns.
    //
    // This API was introduced in Visual Studio 14 RTM (DkmApiVersion.VS14RTM).
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("172f1d3a-23c9-6271-d5d2-6646bf7054ca") DkmILCheckTimeout : public Evaluation::IL::DkmILInstruction
    {
        // Use DkmILCheckTimeout::Create to create this object
        private: DkmILCheckTimeout();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmILCheckTimeout();
        // This object cannot be copied
        private: DkmILCheckTimeout& operator=(const DkmILCheckTimeout&);
        private: DkmILCheckTimeout(const DkmILCheckTimeout&);

        private: void* m__pExtendedData;

        // Attempt to cast a 'DkmILInstruction' to a 'DkmILCheckTimeout'. Return
        // NULL if the path object is not a 'DkmILCheckTimeout'.
        // pCheckTimeout : [In,Optional] Object to attempt to cast
        // Return Value : [Optional] Result of the cast.
        public: static DECLSPEC_NOTHROW DkmILCheckTimeout* TryCast(
            DkmILInstruction* pILInstruction
            )
        {
            if (pILInstruction == NULL || pILInstruction->TagValue() != Tag::CheckTimeout)
                return NULL;

            return static_cast<DkmILCheckTimeout*>(pILInstruction);
        }

        /// <summary>
        /// Create a new DkmILCheckTimeout object instance.
        ///
        /// This API was introduced in Visual Studio 14 RTM (DkmApiVersion.VS14RTM).
        /// </summary>
        /// <param name="ppCreatedObject">
        /// [Out] Result of this method call.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _Deref_out_ Evaluation::IL::DkmILCheckTimeout** ppCreatedObject
            );
    }; // end of DkmILCheckTimeout

    // Pops two values off of the evaluation stack.  If the two values are equal (same size,
    // all the bytes have the same value), pushes a 32-bit 1 onto the stack.  Otherwise,
    // pushes a 32-bit 0 onto the stack.
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("b7d7d75b-054e-16de-e7ac-157725ddf51c") DkmILCompareEqual : public Evaluation::IL::DkmILInstruction
    {
        // Use DkmILCompareEqual::Create to create this object
        private: DkmILCompareEqual();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmILCompareEqual();
        // This object cannot be copied
        private: DkmILCompareEqual& operator=(const DkmILCompareEqual&);
        private: DkmILCompareEqual(const DkmILCompareEqual&);

        private: const Evaluation::IL::DkmPrimitiveObjectType_t m_Type;
        private: void* m__pExtendedData;

        // The type of comparison to perform (e.g. integer vs. floating-point).
        public: DECLSPEC_NOTHROW Evaluation::IL::DkmPrimitiveObjectType_t STDMETHODCALLTYPE Type(
            );

        // Attempt to cast a 'DkmILInstruction' to a 'DkmILCompareEqual'. Return
        // NULL if the path object is not a 'DkmILCompareEqual'.
        // pCompareEqual : [In,Optional] Object to attempt to cast
        // Return Value : [Optional] Result of the cast.
        public: static DECLSPEC_NOTHROW DkmILCompareEqual* TryCast(
            DkmILInstruction* pILInstruction
            )
        {
            if (pILInstruction == NULL || pILInstruction->TagValue() != Tag::CompareEqual)
                return NULL;

            return static_cast<DkmILCompareEqual*>(pILInstruction);
        }

        /// <summary>
        /// Create a new DkmILCompareEqual object instance.
        /// </summary>
        /// <param name="Type">
        /// [In] The type of comparison to perform (e.g. integer vs. floating-point).
        /// </param>
        /// <param name="ppCreatedObject">
        /// [Out] Result of this method call.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ Evaluation::IL::DkmPrimitiveObjectType_t Type,
            _Deref_out_ Evaluation::IL::DkmILCompareEqual** ppCreatedObject
            );
    }; // end of DkmILCompareEqual

    // Pops two values off the evaluation stack and performs a numerical comparison of the
    // values, using the arithmetic mode specified. If the first operand is greater than the
    // second operand, pushes a 32-bit value of 1 on the stack; otherwise, pushes a 32-bit
    // value of 0 on the stack.
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("87da7a59-d3c5-2a9c-098a-b036d51c2bb6") DkmILCompareGreaterThan : public Evaluation::IL::DkmILInstruction
    {
        // Use DkmILCompareGreaterThan::Create to create this object
        private: DkmILCompareGreaterThan();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmILCompareGreaterThan();
        // This object cannot be copied
        private: DkmILCompareGreaterThan& operator=(const DkmILCompareGreaterThan&);
        private: DkmILCompareGreaterThan(const DkmILCompareGreaterThan&);

        private: const Evaluation::IL::DkmPrimitiveObjectType_t m_Type;
        private: void* m__pExtendedData;

        // The type of comparison to perform (e.g. integer vs. floating-point).
        public: DECLSPEC_NOTHROW Evaluation::IL::DkmPrimitiveObjectType_t STDMETHODCALLTYPE Type(
            );

        // Attempt to cast a 'DkmILInstruction' to a 'DkmILCompareGreaterThan'. Return
        // NULL if the path object is not a 'DkmILCompareGreaterThan'.
        // pCompareGreaterThan : [In,Optional] Object to attempt to cast
        // Return Value : [Optional] Result of the cast.
        public: static DECLSPEC_NOTHROW DkmILCompareGreaterThan* TryCast(
            DkmILInstruction* pILInstruction
            )
        {
            if (pILInstruction == NULL || pILInstruction->TagValue() != Tag::CompareGreaterThan)
                return NULL;

            return static_cast<DkmILCompareGreaterThan*>(pILInstruction);
        }

        /// <summary>
        /// Create a new DkmILCompareGreaterThan object instance.
        /// </summary>
        /// <param name="Type">
        /// [In] The type of comparison to perform (e.g. integer vs. floating-point).
        /// </param>
        /// <param name="ppCreatedObject">
        /// [Out] Result of this method call.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ Evaluation::IL::DkmPrimitiveObjectType_t Type,
            _Deref_out_ Evaluation::IL::DkmILCompareGreaterThan** ppCreatedObject
            );
    }; // end of DkmILCompareGreaterThan

    // Pops two values off the evaluation stack and performs a numerical comparison of the
    // values, using the arithmetic mode specified. If the first operand is greater than or
    // equal to the second operand, pushes a 32-bit value of 1 on the stack; otherwise,
    // pushes a 32-bit value of 0 on the stack.
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("8b58921f-dea7-4cbc-b533-8211e74e0d46") DkmILCompareGreaterThanOrEqual : public Evaluation::IL::DkmILInstruction
    {
        // Use DkmILCompareGreaterThanOrEqual::Create to create this object
        private: DkmILCompareGreaterThanOrEqual();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmILCompareGreaterThanOrEqual();
        // This object cannot be copied
        private: DkmILCompareGreaterThanOrEqual& operator=(const DkmILCompareGreaterThanOrEqual&);
        private: DkmILCompareGreaterThanOrEqual(const DkmILCompareGreaterThanOrEqual&);

        private: const Evaluation::IL::DkmPrimitiveObjectType_t m_Type;
        private: void* m__pExtendedData;

        // The type of comparison to perform (e.g. integer vs. floating-point).
        public: DECLSPEC_NOTHROW Evaluation::IL::DkmPrimitiveObjectType_t STDMETHODCALLTYPE Type(
            );

        // Attempt to cast a 'DkmILInstruction' to a 'DkmILCompareGreaterThanOrEqual'. Return
        // NULL if the path object is not a 'DkmILCompareGreaterThanOrEqual'.
        // pCompareGreaterThanOrEqual : [In,Optional] Object to attempt to cast
        // Return Value : [Optional] Result of the cast.
        public: static DECLSPEC_NOTHROW DkmILCompareGreaterThanOrEqual* TryCast(
            DkmILInstruction* pILInstruction
            )
        {
            if (pILInstruction == NULL || pILInstruction->TagValue() != Tag::CompareGreaterThanOrEqual)
                return NULL;

            return static_cast<DkmILCompareGreaterThanOrEqual*>(pILInstruction);
        }

        /// <summary>
        /// Create a new DkmILCompareGreaterThanOrEqual object instance.
        /// </summary>
        /// <param name="Type">
        /// [In] The type of comparison to perform (e.g. integer vs. floating-point).
        /// </param>
        /// <param name="ppCreatedObject">
        /// [Out] Result of this method call.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ Evaluation::IL::DkmPrimitiveObjectType_t Type,
            _Deref_out_ Evaluation::IL::DkmILCompareGreaterThanOrEqual** ppCreatedObject
            );
    }; // end of DkmILCompareGreaterThanOrEqual

    // Pops two values off the evaluation stack and performs a numerical comparison of the
    // values, using the arithmetic mode specified. If the first operand is less than the
    // second operand, pushes a 32-bit value of 1 on the stack; otherwise, pushes a 32-bit
    // value of 0 on the stack.
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("ed47674b-a628-ee40-8e2c-a7282e82f593") DkmILCompareLessThan : public Evaluation::IL::DkmILInstruction
    {
        // Use DkmILCompareLessThan::Create to create this object
        private: DkmILCompareLessThan();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmILCompareLessThan();
        // This object cannot be copied
        private: DkmILCompareLessThan& operator=(const DkmILCompareLessThan&);
        private: DkmILCompareLessThan(const DkmILCompareLessThan&);

        private: const Evaluation::IL::DkmPrimitiveObjectType_t m_Type;
        private: void* m__pExtendedData;

        // The type of comparison to perform (e.g. integer vs. floating-point).
        public: DECLSPEC_NOTHROW Evaluation::IL::DkmPrimitiveObjectType_t STDMETHODCALLTYPE Type(
            );

        // Attempt to cast a 'DkmILInstruction' to a 'DkmILCompareLessThan'. Return
        // NULL if the path object is not a 'DkmILCompareLessThan'.
        // pCompareLessThan : [In,Optional] Object to attempt to cast
        // Return Value : [Optional] Result of the cast.
        public: static DECLSPEC_NOTHROW DkmILCompareLessThan* TryCast(
            DkmILInstruction* pILInstruction
            )
        {
            if (pILInstruction == NULL || pILInstruction->TagValue() != Tag::CompareLessThan)
                return NULL;

            return static_cast<DkmILCompareLessThan*>(pILInstruction);
        }

        /// <summary>
        /// Create a new DkmILCompareLessThan object instance.
        /// </summary>
        /// <param name="Type">
        /// [In] The type of comparison to perform (e.g. integer vs. floating-point).
        /// </param>
        /// <param name="ppCreatedObject">
        /// [Out] Result of this method call.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ Evaluation::IL::DkmPrimitiveObjectType_t Type,
            _Deref_out_ Evaluation::IL::DkmILCompareLessThan** ppCreatedObject
            );
    }; // end of DkmILCompareLessThan

    // Pops two values off the evaluation stack and performs a numerical comparison of the
    // values, using the arithmetic mode specified. If the first operand is less than the
    // second operand, pushes a 32-bit value of 1 on the stack; otherwise, pushes a 32-bit
    // value of 0 on the stack.
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("a8439ea9-e9e0-7669-8d8e-38780379f045") DkmILCompareLessThanOrEqual : public Evaluation::IL::DkmILInstruction
    {
        // Use DkmILCompareLessThanOrEqual::Create to create this object
        private: DkmILCompareLessThanOrEqual();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmILCompareLessThanOrEqual();
        // This object cannot be copied
        private: DkmILCompareLessThanOrEqual& operator=(const DkmILCompareLessThanOrEqual&);
        private: DkmILCompareLessThanOrEqual(const DkmILCompareLessThanOrEqual&);

        private: const Evaluation::IL::DkmPrimitiveObjectType_t m_Type;
        private: void* m__pExtendedData;

        // The type of comparison to perform (e.g. integer vs. floating-point).
        public: DECLSPEC_NOTHROW Evaluation::IL::DkmPrimitiveObjectType_t STDMETHODCALLTYPE Type(
            );

        // Attempt to cast a 'DkmILInstruction' to a 'DkmILCompareLessThanOrEqual'. Return
        // NULL if the path object is not a 'DkmILCompareLessThanOrEqual'.
        // pCompareLessThanOrEqual : [In,Optional] Object to attempt to cast
        // Return Value : [Optional] Result of the cast.
        public: static DECLSPEC_NOTHROW DkmILCompareLessThanOrEqual* TryCast(
            DkmILInstruction* pILInstruction
            )
        {
            if (pILInstruction == NULL || pILInstruction->TagValue() != Tag::CompareLessThanOrEqual)
                return NULL;

            return static_cast<DkmILCompareLessThanOrEqual*>(pILInstruction);
        }

        /// <summary>
        /// Create a new DkmILCompareLessThanOrEqual object instance.
        /// </summary>
        /// <param name="Type">
        /// [In] The type of comparison to perform (e.g. integer vs. floating-point).
        /// </param>
        /// <param name="ppCreatedObject">
        /// [Out] Result of this method call.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ Evaluation::IL::DkmPrimitiveObjectType_t Type,
            _Deref_out_ Evaluation::IL::DkmILCompareLessThanOrEqual** ppCreatedObject
            );
    }; // end of DkmILCompareLessThanOrEqual

    // Pops two values off of the evaluation stack.  If the two values are not equal (same
    // size, all the bytes don't have the same value), pushes a 32-bit 1 onto the stack.
    // Otherwise, pushes a 32-bit 0 onto the stack.
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("26714063-5d3c-d8f5-a948-d903c3cd8702") DkmILCompareNotEqual : public Evaluation::IL::DkmILInstruction
    {
        // Use DkmILCompareNotEqual::Create to create this object
        private: DkmILCompareNotEqual();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmILCompareNotEqual();
        // This object cannot be copied
        private: DkmILCompareNotEqual& operator=(const DkmILCompareNotEqual&);
        private: DkmILCompareNotEqual(const DkmILCompareNotEqual&);

        private: const Evaluation::IL::DkmPrimitiveObjectType_t m_Type;
        private: void* m__pExtendedData;

        // The type of comparison to perform (e.g. integer vs. floating-point).
        public: DECLSPEC_NOTHROW Evaluation::IL::DkmPrimitiveObjectType_t STDMETHODCALLTYPE Type(
            );

        // Attempt to cast a 'DkmILInstruction' to a 'DkmILCompareNotEqual'. Return
        // NULL if the path object is not a 'DkmILCompareNotEqual'.
        // pCompareNotEqual : [In,Optional] Object to attempt to cast
        // Return Value : [Optional] Result of the cast.
        public: static DECLSPEC_NOTHROW DkmILCompareNotEqual* TryCast(
            DkmILInstruction* pILInstruction
            )
        {
            if (pILInstruction == NULL || pILInstruction->TagValue() != Tag::CompareNotEqual)
                return NULL;

            return static_cast<DkmILCompareNotEqual*>(pILInstruction);
        }

        /// <summary>
        /// Create a new DkmILCompareNotEqual object instance.
        /// </summary>
        /// <param name="Type">
        /// [In] The type of comparison to perform (e.g. integer vs. floating-point).
        /// </param>
        /// <param name="ppCreatedObject">
        /// [Out] Result of this method call.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ Evaluation::IL::DkmPrimitiveObjectType_t Type,
            _Deref_out_ Evaluation::IL::DkmILCompareNotEqual** ppCreatedObject
            );
    }; // end of DkmILCompareNotEqual

    // Pops a value off the evaluation stack and converts it from one type to another.
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("fe9357e0-21e3-b8fb-993e-9abc312fa934") DkmILConvert : public Evaluation::IL::DkmILInstruction
    {
        // Use DkmILConvert::Create to create this object
        private: DkmILConvert();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmILConvert();
        // This object cannot be copied
        private: DkmILConvert& operator=(const DkmILConvert&);
        private: DkmILConvert(const DkmILConvert&);

        private: const Evaluation::IL::DkmPrimitiveObjectType_t m_OriginalType;
        private: const Evaluation::IL::DkmPrimitiveObjectType_t m_TargetType;
        private: void* m__pExtendedData;

        // The expected type of the object to be popped from the stack. The actual object
        // popped from the stack must have a size that matches this type.
        public: DECLSPEC_NOTHROW Evaluation::IL::DkmPrimitiveObjectType_t STDMETHODCALLTYPE OriginalType(
            );

        // The type that you want to convert the value to.  This is the type of the object
        // that will be pushed onto the stack.
        public: DECLSPEC_NOTHROW Evaluation::IL::DkmPrimitiveObjectType_t STDMETHODCALLTYPE TargetType(
            );

        // Attempt to cast a 'DkmILInstruction' to a 'DkmILConvert'. Return
        // NULL if the path object is not a 'DkmILConvert'.
        // pConvert : [In,Optional] Object to attempt to cast
        // Return Value : [Optional] Result of the cast.
        public: static DECLSPEC_NOTHROW DkmILConvert* TryCast(
            DkmILInstruction* pILInstruction
            )
        {
            if (pILInstruction == NULL || pILInstruction->TagValue() != Tag::Convert)
                return NULL;

            return static_cast<DkmILConvert*>(pILInstruction);
        }

        /// <summary>
        /// Create a new DkmILConvert object instance.
        /// </summary>
        /// <param name="OriginalType">
        /// [In] The expected type of the object to be popped from the stack. The actual
        /// object popped from the stack must have a size that matches this type.
        /// </param>
        /// <param name="TargetType">
        /// [In] The type that you want to convert the value to.  This is the type of the
        /// object that will be pushed onto the stack.
        /// </param>
        /// <param name="ppCreatedObject">
        /// [Out] Result of this method call.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ Evaluation::IL::DkmPrimitiveObjectType_t OriginalType,
            _In_ Evaluation::IL::DkmPrimitiveObjectType_t TargetType,
            _Deref_out_ Evaluation::IL::DkmILConvert** ppCreatedObject
            );
    }; // end of DkmILConvert

    // Pops two values off the evaluation stack, divides them, and pushes the result onto the
    // evaluation stack. Both operands popped off the stack must be the size indicated by
    // DkmPrimitiveObjectType.  The first value popped from the stack will be divided by the
    // second value popped, so to evaluate "a / b", you would push a, then push b, then
    // divide. The resultant value will have the same size as the operands.  In the event of
    // overflow, the result will be truncated.
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("71a11e07-4158-8259-9f50-f764b86b0835") DkmILDivide : public Evaluation::IL::DkmILInstruction
    {
        // Use DkmILDivide::Create to create this object
        private: DkmILDivide();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmILDivide();
        // This object cannot be copied
        private: DkmILDivide& operator=(const DkmILDivide&);
        private: DkmILDivide(const DkmILDivide&);

        private: const Evaluation::IL::DkmPrimitiveObjectType_t m_Type;
        private: void* m__pExtendedData;

        // The type of subtraction to perform (e.g. integer vs. floating-point).
        public: DECLSPEC_NOTHROW Evaluation::IL::DkmPrimitiveObjectType_t STDMETHODCALLTYPE Type(
            );

        // Attempt to cast a 'DkmILInstruction' to a 'DkmILDivide'. Return
        // NULL if the path object is not a 'DkmILDivide'.
        // pDivide : [In,Optional] Object to attempt to cast
        // Return Value : [Optional] Result of the cast.
        public: static DECLSPEC_NOTHROW DkmILDivide* TryCast(
            DkmILInstruction* pILInstruction
            )
        {
            if (pILInstruction == NULL || pILInstruction->TagValue() != Tag::Divide)
                return NULL;

            return static_cast<DkmILDivide*>(pILInstruction);
        }

        /// <summary>
        /// Create a new DkmILDivide object instance.
        /// </summary>
        /// <param name="Type">
        /// [In] The type of subtraction to perform (e.g. integer vs. floating-point).
        /// </param>
        /// <param name="ppCreatedObject">
        /// [Out] Result of this method call.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ Evaluation::IL::DkmPrimitiveObjectType_t Type,
            _Deref_out_ Evaluation::IL::DkmILDivide** ppCreatedObject
            );
    }; // end of DkmILDivide

    // Make a duplicate copy of the value on the top of the DkmIL stack and push this copy on
    // top of the stack.  If the result of a DkmDuplicateTop gets returned, the GUID
    // associated with the result will be the GUID of the original instruction, not the GUID
    // of the DkmDuplicateTop.
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("75aea7e7-c6a1-78cf-bee0-c6025b37a868") DkmILDuplicateTop : public Evaluation::IL::DkmILInstruction
    {
        // Use DkmILDuplicateTop::Create to create this object
        private: DkmILDuplicateTop();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmILDuplicateTop();
        // This object cannot be copied
        private: DkmILDuplicateTop& operator=(const DkmILDuplicateTop&);
        private: DkmILDuplicateTop(const DkmILDuplicateTop&);

        private: void* m__pExtendedData;

        // Attempt to cast a 'DkmILInstruction' to a 'DkmILDuplicateTop'. Return
        // NULL if the path object is not a 'DkmILDuplicateTop'.
        // pDuplicateTop : [In,Optional] Object to attempt to cast
        // Return Value : [Optional] Result of the cast.
        public: static DECLSPEC_NOTHROW DkmILDuplicateTop* TryCast(
            DkmILInstruction* pILInstruction
            )
        {
            if (pILInstruction == NULL || pILInstruction->TagValue() != Tag::DuplicateTop)
                return NULL;

            return static_cast<DkmILDuplicateTop*>(pILInstruction);
        }

        /// <summary>
        /// Create a new DkmILDuplicateTop object instance.
        /// </summary>
        /// <param name="ppCreatedObject">
        /// [Out] Result of this method call.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _Deref_out_ Evaluation::IL::DkmILDuplicateTop** ppCreatedObject
            );
    }; // end of DkmILDuplicateTop

    // Ends a try block.  After this, all exceptions will go unhandled unless a new
    // DkmILBeginTry instruction is executed.
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("e67ca9b0-423e-11e2-fa72-fef237717a9a") DkmILEndTry : public Evaluation::IL::DkmILInstruction
    {
        // Use DkmILEndTry::Create to create this object
        private: DkmILEndTry();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmILEndTry();
        // This object cannot be copied
        private: DkmILEndTry& operator=(const DkmILEndTry&);
        private: DkmILEndTry(const DkmILEndTry&);

        private: void* m__pExtendedData;

        // Attempt to cast a 'DkmILInstruction' to a 'DkmILEndTry'. Return
        // NULL if the path object is not a 'DkmILEndTry'.
        // pEndTry : [In,Optional] Object to attempt to cast
        // Return Value : [Optional] Result of the cast.
        public: static DECLSPEC_NOTHROW DkmILEndTry* TryCast(
            DkmILInstruction* pILInstruction
            )
        {
            if (pILInstruction == NULL || pILInstruction->TagValue() != Tag::EndTry)
                return NULL;

            return static_cast<DkmILEndTry*>(pILInstruction);
        }

        /// <summary>
        /// Create a new DkmILEndTry object instance.
        /// </summary>
        /// <param name="ppCreatedObject">
        /// [Out] Result of this method call.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _Deref_out_ Evaluation::IL::DkmILEndTry** ppCreatedObject
            );
    }; // end of DkmILEndTry

    // Pops the address of the function off the eval stack. Then, pops the arguments off the
    // IL stack in reverse order (prior to the DkmILExecuteFunction instruction, arguments
    // should be pushed on the stack in order). Next, executes the function in the debuggee
    // process . The return value for the function is copied to the IL Stack as a byte array.
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("2d26c57a-7bf3-02dc-3bcb-a593bc8e5ca0") DkmILExecuteFunction : public Evaluation::IL::DkmILInstruction
    {
        // Use DkmILExecuteFunction::Create to create this object
        private: DkmILExecuteFunction();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmILExecuteFunction();
        // This object cannot be copied
        private: DkmILExecuteFunction& operator=(const DkmILExecuteFunction&);
        private: DkmILExecuteFunction(const DkmILExecuteFunction&);

        private: const UINT32 m_ArgumentCount;
        private: const UINT32 m_ReturnValueSize;
        private: const Evaluation::IL::DkmILCallingConvention_t m_CallingConvention;
        private: const Evaluation::IL::DkmILFunctionEvaluationFlags_t m_Flags;
        private: DkmReadOnlyCollection<Evaluation::IL::DkmILFunctionEvaluationArgumentFlags_t>* const m_pArgumentFlags;
        private: const UINT32 m_UniformComplexReturnElementSize;
        private: void* m__pExtendedData;

        // The number of arguments to pass to the intrinsic function.  These arguments are
        // popped off the IL stack.
        public: DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE ArgumentCount(
            );

        // The size of the return value in bytes. This dictates how the return address is
        // found on some architectures. For instance, on x86, a 4 byte or less return value
        // is returned in EAX. An 8 byte return value is returned in EDX:EAX, and for
        // anything larger, a pointer is returned in EAX to an object on the heap, or for by
        // value returns, to an object on the stack after the stack is cleaned up.
        public: DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE ReturnValueSize(
            );

        // The calling convention of the function to be executed. Ignored on non-x86
        // processors that only have a single calling convention.
        public: DECLSPEC_NOTHROW Evaluation::IL::DkmILCallingConvention_t STDMETHODCALLTYPE CallingConvention(
            );

        // Flags affecting how a function evaluation should occur.
        public: DECLSPEC_NOTHROW Evaluation::IL::DkmILFunctionEvaluationFlags_t STDMETHODCALLTYPE Flags(
            );

        // Flags affecting arguments to a function evaluation. There will be one argument
        // flag for each argument.
        public: _Ret_ DECLSPEC_NOTHROW DkmReadOnlyCollection<Evaluation::IL::DkmILFunctionEvaluationArgumentFlags_t>* STDMETHODCALLTYPE ArgumentFlags(
            );

        // Used for the arm calling convention where a complex type containing all elements
        // the same size are returned enregistered. This is only used if the
        // EnregisteredComplexReturn flag in DkmILFunctionEvaluationFlags is set. This value
        // should return the size of each element in the complex type. FloatingPointReturn is
        // used to determine if the return value is in the in the integer registers of the
        // floating point registers. The IL Interpreter will copy these values onto the stack
        // and return a pointer to that location as if they were not enregistered.
        public: DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE UniformComplexReturnElementSize(
            );

        // Attempt to cast a 'DkmILInstruction' to a 'DkmILExecuteFunction'. Return
        // NULL if the path object is not a 'DkmILExecuteFunction'.
        // pExecuteFunction : [In,Optional] Object to attempt to cast
        // Return Value : [Optional] Result of the cast.
        public: static DECLSPEC_NOTHROW DkmILExecuteFunction* TryCast(
            DkmILInstruction* pILInstruction
            )
        {
            if (pILInstruction == NULL || pILInstruction->TagValue() != Tag::ExecuteFunction)
                return NULL;

            return static_cast<DkmILExecuteFunction*>(pILInstruction);
        }

        /// <summary>
        /// Create a new DkmILExecuteFunction object instance.
        /// </summary>
        /// <param name="ArgumentCount">
        /// [In] The number of arguments to pass to the intrinsic function.  These arguments
        /// are popped off the IL stack.
        /// </param>
        /// <param name="ReturnValueSize">
        /// [In] The size of the return value in bytes. This dictates how the return address
        /// is found on some architectures. For instance, on x86, a 4 byte or less return
        /// value is returned in EAX. An 8 byte return value is returned in EDX:EAX, and for
        /// anything larger, a pointer is returned in EAX to an object on the heap, or for by
        /// value returns, to an object on the stack after the stack is cleaned up.
        /// </param>
        /// <param name="CallingConvention">
        /// [In] The calling convention of the function to be executed. Ignored on non-x86
        /// processors that only have a single calling convention.
        /// </param>
        /// <param name="Flags">
        /// [In] Flags affecting how a function evaluation should occur.
        /// </param>
        /// <param name="pArgumentFlags">
        /// [In] Flags affecting arguments to a function evaluation. There will be one
        /// argument flag for each argument.
        /// </param>
        /// <param name="UniformComplexReturnElementSize">
        /// [In] Used for the arm calling convention where a complex type containing all
        /// elements the same size are returned enregistered. This is only used if the
        /// EnregisteredComplexReturn flag in DkmILFunctionEvaluationFlags is set. This value
        /// should return the size of each element in the complex type. FloatingPointReturn
        /// is used to determine if the return value is in the in the integer registers of
        /// the floating point registers. The IL Interpreter will copy these values onto the
        /// stack and return a pointer to that location as if they were not enregistered.
        /// </param>
        /// <param name="ppCreatedObject">
        /// [Out] Result of this method call.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ UINT32 ArgumentCount,
            _In_ UINT32 ReturnValueSize,
            _In_ Evaluation::IL::DkmILCallingConvention_t CallingConvention,
            _In_ Evaluation::IL::DkmILFunctionEvaluationFlags_t Flags,
            _In_ DkmReadOnlyCollection<Evaluation::IL::DkmILFunctionEvaluationArgumentFlags_t>* pArgumentFlags,
            _In_ UINT32 UniformComplexReturnElementSize,
            _Deref_out_ Evaluation::IL::DkmILExecuteFunction** ppCreatedObject
            );
    }; // end of DkmILExecuteFunction

    // Pops the arguments off the IL stack in reverse order (prior to the
    // DkmILExecuteIntrinsic instruction, arguments should be pushed on the stack in order).
    // Then, executes an EE-defined operation that makes use of these values.  Then, pushes
    // the result back onto the IL stack.
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("b78030f6-2d05-231a-c0d6-bf554010824e") DkmILExecuteIntrinsic : public Evaluation::IL::DkmILInstruction
    {
        // Use DkmILExecuteIntrinsic::Create to create this object
        private: DkmILExecuteIntrinsic();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmILExecuteIntrinsic();
        // This object cannot be copied
        private: DkmILExecuteIntrinsic& operator=(const DkmILExecuteIntrinsic&);
        private: DkmILExecuteIntrinsic(const DkmILExecuteIntrinsic&);

        private: const GUID m_SourceId;
        private: const GUID m_LanguageId;
        private: const UINT32 m_Id;
        private: const UINT32 m_ArgumentCount;
        private: OPTIONAL DkmReadOnlyCollection<Evaluation::DkmCompiledInspectionQuery*>* const m_pSubroutines;
        private: void* m__pExtendedData;

        // Identifies the source of an object. SourceIds are used to enable filtering in
        // scenarios when multiple components may be creating instances of a class. For
        // example, source ids can be used to determine if a breakpoint comes from the AD7 AL
        // (ex: user breakpoint, or other breakpoint visible at the SDM level) instead of a
        // breakpoint which may be created by another component (for example an internal
        // breakpoint used for stepping).
        public: DECLSPEC_NOTHROW const GUID& STDMETHODCALLTYPE SourceId(
            );

        // The language associated with the intrinsic function.
        public: DECLSPEC_NOTHROW const GUID& STDMETHODCALLTYPE LanguageId(
            );

        // A unique identifier for the intrinsic function within the language.
        public: DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE Id(
            );

        // The number of arguments to pass to the intrinsic function.  These arguments are
        // popped off the IL stack.
        public: DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE ArgumentCount(
            );

        // [Optional] Optional collection of subroutines that the intrinsic function can call
        // into.
        public: _Ret_opt_ DECLSPEC_NOTHROW DkmReadOnlyCollection<Evaluation::DkmCompiledInspectionQuery*>* STDMETHODCALLTYPE Subroutines(
            );

        // Attempt to cast a 'DkmILInstruction' to a 'DkmILExecuteIntrinsic'. Return
        // NULL if the path object is not a 'DkmILExecuteIntrinsic'.
        // pExecuteIntrinsic : [In,Optional] Object to attempt to cast
        // Return Value : [Optional] Result of the cast.
        public: static DECLSPEC_NOTHROW DkmILExecuteIntrinsic* TryCast(
            DkmILInstruction* pILInstruction
            )
        {
            if (pILInstruction == NULL || pILInstruction->TagValue() != Tag::ExecuteIntrinsic)
                return NULL;

            return static_cast<DkmILExecuteIntrinsic*>(pILInstruction);
        }

        /// <summary>
        /// Create a new DkmILExecuteIntrinsic object instance.
        /// </summary>
        /// <param name="SourceId">
        /// [In] Identifies the source of an object. SourceIds are used to enable filtering
        /// in scenarios when multiple components may be creating instances of a class. For
        /// example, source ids can be used to determine if a breakpoint comes from the AD7
        /// AL (ex: user breakpoint, or other breakpoint visible at the SDM level) instead of
        /// a breakpoint which may be created by another component (for example an internal
        /// breakpoint used for stepping).
        /// </param>
        /// <param name="LanguageId">
        /// [In] The language associated with the intrinsic function.
        /// </param>
        /// <param name="Id">
        /// [In] A unique identifier for the intrinsic function within the language.
        /// </param>
        /// <param name="ArgumentCount">
        /// [In] The number of arguments to pass to the intrinsic function.  These arguments
        /// are popped off the IL stack.
        /// </param>
        /// <param name="pSubroutines">
        /// [In,Optional] Optional collection of subroutines that the intrinsic function can
        /// call into.
        /// </param>
        /// <param name="ppCreatedObject">
        /// [Out] Result of this method call.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ const GUID& SourceId,
            _In_ const GUID& LanguageId,
            _In_ UINT32 Id,
            _In_ UINT32 ArgumentCount,
            _In_opt_ DkmReadOnlyCollection<Evaluation::DkmCompiledInspectionQuery*>* pSubroutines,
            _Deref_out_ Evaluation::IL::DkmILExecuteIntrinsic** ppCreatedObject
            );

        #ifndef EXCLUDE_MONITOR_ONLY_APIS
        /// <summary>
        /// Executes an intrinsic function.
        ///
        /// Location constraint: API must be called from a Monitor component (component level
        /// &lt; 100,000).
        /// </summary>
        /// <param name="pILContext">
        /// [In] The stack frame context we are evaluating on.
        /// </param>
        /// <param name="Arguments">
        /// [In] The arguments supplied to the intrinsic function.
        ///
        /// The memory for the DkmArray members is allocated by the caller, and can be from
        /// any source (stack memory, static buffer, heap, etc). The implementation should
        /// not modify the members.
        /// </param>
        /// <param name="pSubroutines">
        /// [In,Optional] Optional array of IL-based subroutines that the intrinsic function
        /// may choose to invoke during its operation.
        /// </param>
        /// <param name="pResults">
        /// [Out] The results of the evaluation to be pushed onto the IL stack (in order).
        ///
        /// The memory for the DkmArray members is allocated by the method implementation
        /// using DkmAllocBytes/DkmAllocArray. It is freed by the caller using the
        /// CAutoDkmArray template or with DkmFreeMemory and manual element release.
        /// </param>
        /// <param name="pFailureReason">
        /// [Out] If an error occurs, specifies the reason for the error.  To indicate an
        /// error code whose meaning is specific to the particular intrinsic function being
        /// executed, return a value less than zero.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Execute(
            _In_ Evaluation::DkmILContext* pILContext,
            _In_ const DkmArray<Evaluation::IL::DkmILEvaluationResult*>& Arguments,
            _In_opt_ DkmReadOnlyCollection<Evaluation::DkmCompiledInspectionQuery*>* pSubroutines,
            _Out_ DkmArray<Evaluation::IL::DkmILEvaluationResult*>* pResults,
            _Out_ Evaluation::IL::DkmILFailureReason_t* pFailureReason
            );
        #endif // #ifndef EXCLUDE_MONITOR_ONLY_APIS

        #ifndef EXCLUDE_MONITOR_ONLY_APIS
        /// <summary>
        /// Executes an intrinsic function.
        ///
        /// Location constraint: API must be called from a Monitor component (component level
        /// &lt; 100,000).
        ///
        /// This API was introduced in Visual Studio 14 RTM (DkmApiVersion.VS14RTM).
        /// </summary>
        /// <param name="pILContext">
        /// [In] The stack frame context we are evaluating on.
        /// </param>
        /// <param name="pInspectionQuery">
        /// [In] Currently executing instruction query that this intrinsic function belongs
        /// to.
        /// </param>
        /// <param name="Arguments">
        /// [In] The arguments supplied to the intrinsic function.
        ///
        /// The memory for the DkmArray members is allocated by the caller, and can be from
        /// any source (stack memory, static buffer, heap, etc). The implementation should
        /// not modify the members.
        /// </param>
        /// <param name="pSubroutines">
        /// [In,Optional] Optional array of IL-based subroutines that the intrinsic function
        /// may choose to invoke during its operation.
        /// </param>
        /// <param name="pResults">
        /// [Out] The results of the evaluation to be pushed onto the IL stack (in order).
        ///
        /// The memory for the DkmArray members is allocated by the method implementation
        /// using DkmAllocBytes/DkmAllocArray. It is freed by the caller using the
        /// CAutoDkmArray template or with DkmFreeMemory and manual element release.
        /// </param>
        /// <param name="pFailureReason">
        /// [Out] If an error occurs, specifies the reason for the error.  To indicate an
        /// error code whose meaning is specific to the particular intrinsic function being
        /// executed, return a value less than zero.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Execute(
            _In_ Evaluation::DkmILContext* pILContext,
            _In_ Evaluation::IL::DkmCompiledILInspectionQuery* pInspectionQuery,
            _In_ const DkmArray<Evaluation::IL::DkmILEvaluationResult*>& Arguments,
            _In_opt_ DkmReadOnlyCollection<Evaluation::DkmCompiledInspectionQuery*>* pSubroutines,
            _Out_ DkmArray<Evaluation::IL::DkmILEvaluationResult*>* pResults,
            _Out_ Evaluation::IL::DkmILFailureReason_t* pFailureReason
            );
        #endif // #ifndef EXCLUDE_MONITOR_ONLY_APIS
    }; // end of DkmILExecuteIntrinsic

    // Pops a value off the IL stack and extracts a subset of the bytes of that value,
    // pushing the result back onto the IL stack. If the entire region of bytes to extract
    // doesn't fall within the bounds of the value popped from the stack, an IL exception of
    // code ByteExtractionOutOfBounds will be thrown.
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("fe1217c9-bd40-4691-c912-72577c056ee1") DkmILExtractBytes : public Evaluation::IL::DkmILInstruction
    {
        // Use DkmILExtractBytes::Create to create this object
        private: DkmILExtractBytes();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmILExtractBytes();
        // This object cannot be copied
        private: DkmILExtractBytes& operator=(const DkmILExtractBytes&);
        private: DkmILExtractBytes(const DkmILExtractBytes&);

        private: const UINT32 m_Offset;
        private: const UINT32 m_Length;
        private: void* m__pExtendedData;

        // The offset of the first byte to extract.
        public: DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE Offset(
            );

        // The number of bytes to extract.
        public: DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE Length(
            );

        // Attempt to cast a 'DkmILInstruction' to a 'DkmILExtractBytes'. Return
        // NULL if the path object is not a 'DkmILExtractBytes'.
        // pExtractBytes : [In,Optional] Object to attempt to cast
        // Return Value : [Optional] Result of the cast.
        public: static DECLSPEC_NOTHROW DkmILExtractBytes* TryCast(
            DkmILInstruction* pILInstruction
            )
        {
            if (pILInstruction == NULL || pILInstruction->TagValue() != Tag::ExtractBytes)
                return NULL;

            return static_cast<DkmILExtractBytes*>(pILInstruction);
        }

        /// <summary>
        /// Create a new DkmILExtractBytes object instance.
        /// </summary>
        /// <param name="Offset">
        /// [In] The offset of the first byte to extract.
        /// </param>
        /// <param name="Length">
        /// [In] The number of bytes to extract.
        /// </param>
        /// <param name="ppCreatedObject">
        /// [Out] Result of this method call.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ UINT32 Offset,
            _In_ UINT32 Length,
            _Deref_out_ Evaluation::IL::DkmILExtractBytes** ppCreatedObject
            );
    }; // end of DkmILExtractBytes

    // Pops a length, offset, and blob of bytes from the IL stack (in that order).  Extracts
    // the portion of the blob of bytes at the given offset of the given length, pushing the
    // result back onto the stack.  The length and offset popped from the stack will be
    // interpreted as either 32-bit or 64-bit unsigned integers, depending on the address
    // space of the debuggee.  If the entire region of bytes to extract doesn't fall within
    // the bounds of the value popped from the stack, an IL exception of code
    // ByteExtractionOutOfBounds will be thrown. This is similar to the DkmILExtractBytes
    // instruction, except the offset and length are popped from the stack and do not need to
    // be known at the time that the IL is generated.
    //
    // This API was introduced in Visual Studio 14 RTM (DkmApiVersion.VS14RTM).
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("ea7acbb9-0112-e75a-b624-97624126aed8") DkmILExtractBytesPopArguments : public Evaluation::IL::DkmILInstruction
    {
        // Use DkmILExtractBytesPopArguments::Create to create this object
        private: DkmILExtractBytesPopArguments();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmILExtractBytesPopArguments();
        // This object cannot be copied
        private: DkmILExtractBytesPopArguments& operator=(const DkmILExtractBytesPopArguments&);
        private: DkmILExtractBytesPopArguments(const DkmILExtractBytesPopArguments&);

        private: void* m__pExtendedData;

        // Attempt to cast a 'DkmILInstruction' to a 'DkmILExtractBytesPopArguments'. Return
        // NULL if the path object is not a 'DkmILExtractBytesPopArguments'.
        // pExtractBytesPopArguments : [In,Optional] Object to attempt to cast
        // Return Value : [Optional] Result of the cast.
        public: static DECLSPEC_NOTHROW DkmILExtractBytesPopArguments* TryCast(
            DkmILInstruction* pILInstruction
            )
        {
            if (pILInstruction == NULL || pILInstruction->TagValue() != Tag::ExtractBytesPopArguments)
                return NULL;

            return static_cast<DkmILExtractBytesPopArguments*>(pILInstruction);
        }

        /// <summary>
        /// Create a new DkmILExtractBytesPopArguments object instance.
        ///
        /// This API was introduced in Visual Studio 14 RTM (DkmApiVersion.VS14RTM).
        /// </summary>
        /// <param name="ppCreatedObject">
        /// [Out] Result of this method call.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _Deref_out_ Evaluation::IL::DkmILExtractBytesPopArguments** ppCreatedObject
            );
    }; // end of DkmILExtractBytesPopArguments

    // A request to read data from a shader shared buffer.  The offset in the buffer is
    // popped from the IL stack.  The result is pushed on the IL stack.
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("d6e46654-0686-441c-3d86-ff6bf50f4df6") DkmILHlslBufferRead : public Evaluation::IL::DkmILInstruction
    {
        // Use DkmILHlslBufferRead::Create to create this object
        private: DkmILHlslBufferRead();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmILHlslBufferRead();
        // This object cannot be copied
        private: DkmILHlslBufferRead& operator=(const DkmILHlslBufferRead&);
        private: DkmILHlslBufferRead(const DkmILHlslBufferRead&);

        private: const CV_HREG_e m_RegisterId;
        private: const UINT32 m_RegisterIndex;
        private: const UINT32 m_BytesToRead;
        private: void* m__pExtendedData;

        // The VSD3D_REGISTER_SET value cast to a CvRegisterId.
        public: DECLSPEC_NOTHROW CV_HREG_e STDMETHODCALLTYPE RegisterId(
            );

        // The index of the register to read.
        public: DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE RegisterIndex(
            );

        // The number of bytes to read from the shared buffer.
        public: DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE BytesToRead(
            );

        // Attempt to cast a 'DkmILInstruction' to a 'DkmILHlslBufferRead'. Return
        // NULL if the path object is not a 'DkmILHlslBufferRead'.
        // pHlslBufferRead : [In,Optional] Object to attempt to cast
        // Return Value : [Optional] Result of the cast.
        public: static DECLSPEC_NOTHROW DkmILHlslBufferRead* TryCast(
            DkmILInstruction* pILInstruction
            )
        {
            if (pILInstruction == NULL || pILInstruction->TagValue() != Tag::HlslBufferRead)
                return NULL;

            return static_cast<DkmILHlslBufferRead*>(pILInstruction);
        }

        /// <summary>
        /// Create a new DkmILHlslBufferRead object instance.
        /// </summary>
        /// <param name="RegisterId">
        /// [In] The VSD3D_REGISTER_SET value cast to a CvRegisterId.
        /// </param>
        /// <param name="RegisterIndex">
        /// [In] The index of the register to read.
        /// </param>
        /// <param name="BytesToRead">
        /// [In] The number of bytes to read from the shared buffer.
        /// </param>
        /// <param name="ppCreatedObject">
        /// [Out] Result of this method call.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ CV_HREG_e RegisterId,
            _In_ UINT32 RegisterIndex,
            _In_ UINT32 BytesToRead,
            _Deref_out_ Evaluation::IL::DkmILHlslBufferRead** ppCreatedObject
            );
    }; // end of DkmILHlslBufferRead

    // A request to 'read' the current group ID.  The result is pushed on the stack.
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("dd58ab29-83d2-c4d4-e499-e85e5bf99277") DkmILHlslGetGroupId : public Evaluation::IL::DkmILInstruction
    {
        // Use DkmILHlslGetGroupId::Create to create this object
        private: DkmILHlslGetGroupId();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmILHlslGetGroupId();
        // This object cannot be copied
        private: DkmILHlslGetGroupId& operator=(const DkmILHlslGetGroupId&);
        private: DkmILHlslGetGroupId(const DkmILHlslGetGroupId&);

        private: const GPU::DkmHlslThreadIdComponents_t m_GroupIdComponents;
        private: void* m__pExtendedData;

        // Specifies what portion of the thread group ID should be pushed on the stack.
        public: DECLSPEC_NOTHROW GPU::DkmHlslThreadIdComponents_t STDMETHODCALLTYPE GroupIdComponents(
            );

        // Attempt to cast a 'DkmILInstruction' to a 'DkmILHlslGetGroupId'. Return
        // NULL if the path object is not a 'DkmILHlslGetGroupId'.
        // pHlslGetGroupId : [In,Optional] Object to attempt to cast
        // Return Value : [Optional] Result of the cast.
        public: static DECLSPEC_NOTHROW DkmILHlslGetGroupId* TryCast(
            DkmILInstruction* pILInstruction
            )
        {
            if (pILInstruction == NULL || pILInstruction->TagValue() != Tag::HlslGetGroupId)
                return NULL;

            return static_cast<DkmILHlslGetGroupId*>(pILInstruction);
        }

        /// <summary>
        /// Create a new DkmILHlslGetGroupId object instance.
        /// </summary>
        /// <param name="GroupIdComponents">
        /// [In] Specifies what portion of the thread group ID should be pushed on the stack.
        /// </param>
        /// <param name="ppCreatedObject">
        /// [Out] Result of this method call.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ GPU::DkmHlslThreadIdComponents_t GroupIdComponents,
            _Deref_out_ Evaluation::IL::DkmILHlslGetGroupId** ppCreatedObject
            );
    }; // end of DkmILHlslGetGroupId

    // A request to 'read' the current thread ID.  The result is pushed on the stack.
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("2c425193-043f-3d02-59b1-cedd50363ca6") DkmILHlslGetThreadId : public Evaluation::IL::DkmILInstruction
    {
        // Use DkmILHlslGetThreadId::Create to create this object
        private: DkmILHlslGetThreadId();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmILHlslGetThreadId();
        // This object cannot be copied
        private: DkmILHlslGetThreadId& operator=(const DkmILHlslGetThreadId&);
        private: DkmILHlslGetThreadId(const DkmILHlslGetThreadId&);

        private: const bool m_UseDispatchId;
        private: const bool m_UseFlatModel;
        private: const GPU::DkmHlslThreadIdComponents_t m_ThreadIdComponents;
        private: void* m__pExtendedData;

        // Indicates whether the thread ID should be returned relative to the dispatch (true)
        // or relative to the tile (false).
        public: DECLSPEC_NOTHROW bool STDMETHODCALLTYPE UseDispatchId(
            );

        // Instructs the debugger to fetch the thread id in flat format (if true), or as a
        // vector (if false).
        public: DECLSPEC_NOTHROW bool STDMETHODCALLTYPE UseFlatModel(
            );

        // Specifies what portion of the thread ID should be pushed on the stack.
        public: DECLSPEC_NOTHROW GPU::DkmHlslThreadIdComponents_t STDMETHODCALLTYPE ThreadIdComponents(
            );

        // Attempt to cast a 'DkmILInstruction' to a 'DkmILHlslGetThreadId'. Return
        // NULL if the path object is not a 'DkmILHlslGetThreadId'.
        // pHlslGetThreadId : [In,Optional] Object to attempt to cast
        // Return Value : [Optional] Result of the cast.
        public: static DECLSPEC_NOTHROW DkmILHlslGetThreadId* TryCast(
            DkmILInstruction* pILInstruction
            )
        {
            if (pILInstruction == NULL || pILInstruction->TagValue() != Tag::HlslGetThreadId)
                return NULL;

            return static_cast<DkmILHlslGetThreadId*>(pILInstruction);
        }

        /// <summary>
        /// Create a new DkmILHlslGetThreadId object instance.
        /// </summary>
        /// <param name="UseDispatchId">
        /// [In] Indicates whether the thread ID should be returned relative to the dispatch
        /// (true) or relative to the tile (false).
        /// </param>
        /// <param name="UseFlatModel">
        /// [In] Instructs the debugger to fetch the thread id in flat format (if true), or
        /// as a vector (if false).
        /// </param>
        /// <param name="ThreadIdComponents">
        /// [In] Specifies what portion of the thread ID should be pushed on the stack.
        /// </param>
        /// <param name="ppCreatedObject">
        /// [Out] Result of this method call.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ bool UseDispatchId,
            _In_ bool UseFlatModel,
            _In_ GPU::DkmHlslThreadIdComponents_t ThreadIdComponents,
            _Deref_out_ Evaluation::IL::DkmILHlslGetThreadId** ppCreatedObject
            );
    }; // end of DkmILHlslGetThreadId

    // A request to read the value of a specific register.  The index of the first vector
    // element to read is popped from the IL stack.  The result is pushed on the IL stack.
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("64daf200-37b1-379f-b698-4a181200b8db") DkmILHlslIndexedRegisterRead : public Evaluation::IL::DkmILInstruction
    {
        // Use DkmILHlslIndexedRegisterRead::Create to create this object
        private: DkmILHlslIndexedRegisterRead();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmILHlslIndexedRegisterRead();
        // This object cannot be copied
        private: DkmILHlslIndexedRegisterRead& operator=(const DkmILHlslIndexedRegisterRead&);
        private: DkmILHlslIndexedRegisterRead(const DkmILHlslIndexedRegisterRead&);

        private: const CV_HREG_e m_RegisterId;
        private: const UINT32 m_RegisterIndex;
        private: const UINT32 m_ByteOffset;
        private: const UINT32 m_BytesToRead;
        private: const UINT32 m_VectorElements;
        private: void* m__pExtendedData;

        // The VSD3D_REGISTER_SET value cast to a CvRegisterId.
        public: DECLSPEC_NOTHROW CV_HREG_e STDMETHODCALLTYPE RegisterId(
            );

        // The index of the register to read.
        public: DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE RegisterIndex(
            );

        // The offset in bytes from the beginning of the register to begin reading.
        public: DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE ByteOffset(
            );

        // The number of bytes to be read from each vector register.
        public: DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE BytesToRead(
            );

        // The number of vector elements to read.
        public: DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE VectorElements(
            );

        // Attempt to cast a 'DkmILInstruction' to a 'DkmILHlslIndexedRegisterRead'. Return
        // NULL if the path object is not a 'DkmILHlslIndexedRegisterRead'.
        // pHlslIndexedRegisterRead : [In,Optional] Object to attempt to cast
        // Return Value : [Optional] Result of the cast.
        public: static DECLSPEC_NOTHROW DkmILHlslIndexedRegisterRead* TryCast(
            DkmILInstruction* pILInstruction
            )
        {
            if (pILInstruction == NULL || pILInstruction->TagValue() != Tag::HlslIndexedRegisterRead)
                return NULL;

            return static_cast<DkmILHlslIndexedRegisterRead*>(pILInstruction);
        }

        /// <summary>
        /// Create a new DkmILHlslIndexedRegisterRead object instance.
        /// </summary>
        /// <param name="RegisterId">
        /// [In] The VSD3D_REGISTER_SET value cast to a CvRegisterId.
        /// </param>
        /// <param name="RegisterIndex">
        /// [In] The index of the register to read.
        /// </param>
        /// <param name="ByteOffset">
        /// [In] The offset in bytes from the beginning of the register to begin reading.
        /// </param>
        /// <param name="BytesToRead">
        /// [In] The number of bytes to be read from each vector register.
        /// </param>
        /// <param name="VectorElements">
        /// [In] The number of vector elements to read.
        /// </param>
        /// <param name="ppCreatedObject">
        /// [Out] Result of this method call.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ CV_HREG_e RegisterId,
            _In_ UINT32 RegisterIndex,
            _In_ UINT32 ByteOffset,
            _In_ UINT32 BytesToRead,
            _In_ UINT32 VectorElements,
            _Deref_out_ Evaluation::IL::DkmILHlslIndexedRegisterRead** ppCreatedObject
            );
    }; // end of DkmILHlslIndexedRegisterRead

    // A request to read the value of a specific register.  The result is pushed on the IL
    // stack.
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("967c6835-6825-8a43-1d23-c4b5f9fb2719") DkmILHlslRegisterRead : public Evaluation::IL::DkmILInstruction
    {
        // Use DkmILHlslRegisterRead::Create to create this object
        private: DkmILHlslRegisterRead();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmILHlslRegisterRead();
        // This object cannot be copied
        private: DkmILHlslRegisterRead& operator=(const DkmILHlslRegisterRead&);
        private: DkmILHlslRegisterRead(const DkmILHlslRegisterRead&);

        private: const CV_HREG_e m_RegisterId;
        private: const UINT32 m_RegisterIndex;
        private: const UINT32 m_ByteOffset;
        private: const UINT32 m_BytesToRead;
        private: const UINT32 m_FirstElement;
        private: const UINT32 m_VectorElements;
        private: void* m__pExtendedData;

        // The VSD3D_REGISTER_SET value cast to a CvRegisterId.
        public: DECLSPEC_NOTHROW CV_HREG_e STDMETHODCALLTYPE RegisterId(
            );

        // The index of the register to read.
        public: DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE RegisterIndex(
            );

        // The offset in bytes from the beginning of the register to begin reading.
        public: DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE ByteOffset(
            );

        // The number of bytes to be read from each vector register.
        public: DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE BytesToRead(
            );

        // The index of the first vector element.
        public: DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE FirstElement(
            );

        // The number of vector elements to read.
        public: DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE VectorElements(
            );

        // Attempt to cast a 'DkmILInstruction' to a 'DkmILHlslRegisterRead'. Return
        // NULL if the path object is not a 'DkmILHlslRegisterRead'.
        // pHlslRegisterRead : [In,Optional] Object to attempt to cast
        // Return Value : [Optional] Result of the cast.
        public: static DECLSPEC_NOTHROW DkmILHlslRegisterRead* TryCast(
            DkmILInstruction* pILInstruction
            )
        {
            if (pILInstruction == NULL || pILInstruction->TagValue() != Tag::HlslRegisterRead)
                return NULL;

            return static_cast<DkmILHlslRegisterRead*>(pILInstruction);
        }

        /// <summary>
        /// Create a new DkmILHlslRegisterRead object instance.
        /// </summary>
        /// <param name="RegisterId">
        /// [In] The VSD3D_REGISTER_SET value cast to a CvRegisterId.
        /// </param>
        /// <param name="RegisterIndex">
        /// [In] The index of the register to read.
        /// </param>
        /// <param name="ByteOffset">
        /// [In] The offset in bytes from the beginning of the register to begin reading.
        /// </param>
        /// <param name="BytesToRead">
        /// [In] The number of bytes to be read from each vector register.
        /// </param>
        /// <param name="FirstElement">
        /// [In] The index of the first vector element.
        /// </param>
        /// <param name="VectorElements">
        /// [In] The number of vector elements to read.
        /// </param>
        /// <param name="ppCreatedObject">
        /// [Out] Result of this method call.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ CV_HREG_e RegisterId,
            _In_ UINT32 RegisterIndex,
            _In_ UINT32 ByteOffset,
            _In_ UINT32 BytesToRead,
            _In_ UINT32 FirstElement,
            _In_ UINT32 VectorElements,
            _Deref_out_ Evaluation::IL::DkmILHlslRegisterRead** ppCreatedObject
            );
    }; // end of DkmILHlslRegisterRead

    // Pops a value off of the evaluation stack.  If the value is zero, pushes a 32-bit value
    // of 1 on the stack. Otherwise, pushes a 32-bit value of 0 on the stack.
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("58671534-8e49-9c48-c2a8-201d29bac5ef") DkmILIsFalse : public Evaluation::IL::DkmILInstruction
    {
        // Use DkmILIsFalse::Create to create this object
        private: DkmILIsFalse();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmILIsFalse();
        // This object cannot be copied
        private: DkmILIsFalse& operator=(const DkmILIsFalse&);
        private: DkmILIsFalse(const DkmILIsFalse&);

        private: const Evaluation::IL::DkmPrimitiveObjectType_t m_Type;
        private: void* m__pExtendedData;

        // The type of comparison to perform (e.g. integer vs. floating-point).
        public: DECLSPEC_NOTHROW Evaluation::IL::DkmPrimitiveObjectType_t STDMETHODCALLTYPE Type(
            );

        // Attempt to cast a 'DkmILInstruction' to a 'DkmILIsFalse'. Return
        // NULL if the path object is not a 'DkmILIsFalse'.
        // pIsFalse : [In,Optional] Object to attempt to cast
        // Return Value : [Optional] Result of the cast.
        public: static DECLSPEC_NOTHROW DkmILIsFalse* TryCast(
            DkmILInstruction* pILInstruction
            )
        {
            if (pILInstruction == NULL || pILInstruction->TagValue() != Tag::IsFalse)
                return NULL;

            return static_cast<DkmILIsFalse*>(pILInstruction);
        }

        /// <summary>
        /// Create a new DkmILIsFalse object instance.
        /// </summary>
        /// <param name="Type">
        /// [In] The type of comparison to perform (e.g. integer vs. floating-point).
        /// </param>
        /// <param name="ppCreatedObject">
        /// [Out] Result of this method call.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ Evaluation::IL::DkmPrimitiveObjectType_t Type,
            _Deref_out_ Evaluation::IL::DkmILIsFalse** ppCreatedObject
            );
    }; // end of DkmILIsFalse

    // Pops a value off of the evaluation stack.  If the value is non-zero, pushes a 32-bit
    // value of 1 on the stack. Otherwise, pushes a 32-bit value of 0 on the stack.
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("fefef4e7-d812-5005-f1c2-e817b63e0e5c") DkmILIsTrue : public Evaluation::IL::DkmILInstruction
    {
        // Use DkmILIsTrue::Create to create this object
        private: DkmILIsTrue();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmILIsTrue();
        // This object cannot be copied
        private: DkmILIsTrue& operator=(const DkmILIsTrue&);
        private: DkmILIsTrue(const DkmILIsTrue&);

        private: const Evaluation::IL::DkmPrimitiveObjectType_t m_Type;
        private: void* m__pExtendedData;

        // The type of comparison to perform (e.g. integer vs. floating-point).
        public: DECLSPEC_NOTHROW Evaluation::IL::DkmPrimitiveObjectType_t STDMETHODCALLTYPE Type(
            );

        // Attempt to cast a 'DkmILInstruction' to a 'DkmILIsTrue'. Return
        // NULL if the path object is not a 'DkmILIsTrue'.
        // pIsTrue : [In,Optional] Object to attempt to cast
        // Return Value : [Optional] Result of the cast.
        public: static DECLSPEC_NOTHROW DkmILIsTrue* TryCast(
            DkmILInstruction* pILInstruction
            )
        {
            if (pILInstruction == NULL || pILInstruction->TagValue() != Tag::IsTrue)
                return NULL;

            return static_cast<DkmILIsTrue*>(pILInstruction);
        }

        /// <summary>
        /// Create a new DkmILIsTrue object instance.
        /// </summary>
        /// <param name="Type">
        /// [In] The type of comparison to perform (e.g. integer vs. floating-point).
        /// </param>
        /// <param name="ppCreatedObject">
        /// [Out] Result of this method call.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ Evaluation::IL::DkmPrimitiveObjectType_t Type,
            _Deref_out_ Evaluation::IL::DkmILIsTrue** ppCreatedObject
            );
    }; // end of DkmILIsTrue

    // Jumps to another instruction in the instruction stream.
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("36bb21a4-629b-d3fe-7cba-97191f007349") DkmILJump : public Evaluation::IL::DkmILInstruction
    {
        // Use DkmILJump::Create to create this object
        private: DkmILJump();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmILJump();
        // This object cannot be copied
        private: DkmILJump& operator=(const DkmILJump&);
        private: DkmILJump(const DkmILJump&);

        private: const UINT32 m_Target;
        private: void* m__pExtendedData;

        // Location in the instruction stream to jump to.
        public: DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE Target(
            );

        // Attempt to cast a 'DkmILInstruction' to a 'DkmILJump'. Return
        // NULL if the path object is not a 'DkmILJump'.
        // pJump : [In,Optional] Object to attempt to cast
        // Return Value : [Optional] Result of the cast.
        public: static DECLSPEC_NOTHROW DkmILJump* TryCast(
            DkmILInstruction* pILInstruction
            )
        {
            if (pILInstruction == NULL || pILInstruction->TagValue() != Tag::Jump)
                return NULL;

            return static_cast<DkmILJump*>(pILInstruction);
        }

        /// <summary>
        /// Create a new DkmILJump object instance.
        /// </summary>
        /// <param name="Target">
        /// [In] Location in the instruction stream to jump to.
        /// </param>
        /// <param name="ppCreatedObject">
        /// [Out] Result of this method call.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ UINT32 Target,
            _Deref_out_ Evaluation::IL::DkmILJump** ppCreatedObject
            );
    }; // end of DkmILJump

    // Pops a value off the IL stack.  Then, jumps to another instruction in the instruction
    // stream only if the value bytes are all zero.
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("80cc8616-ef15-670e-16dc-8d1d852e80b1") DkmILJumpIfFalse : public Evaluation::IL::DkmILInstruction
    {
        // Use DkmILJumpIfFalse::Create to create this object
        private: DkmILJumpIfFalse();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmILJumpIfFalse();
        // This object cannot be copied
        private: DkmILJumpIfFalse& operator=(const DkmILJumpIfFalse&);
        private: DkmILJumpIfFalse(const DkmILJumpIfFalse&);

        private: const UINT32 m_Target;
        private: void* m__pExtendedData;

        // Location in the instruction stream to jump to.
        public: DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE Target(
            );

        // Attempt to cast a 'DkmILInstruction' to a 'DkmILJumpIfFalse'. Return
        // NULL if the path object is not a 'DkmILJumpIfFalse'.
        // pJumpIfFalse : [In,Optional] Object to attempt to cast
        // Return Value : [Optional] Result of the cast.
        public: static DECLSPEC_NOTHROW DkmILJumpIfFalse* TryCast(
            DkmILInstruction* pILInstruction
            )
        {
            if (pILInstruction == NULL || pILInstruction->TagValue() != Tag::JumpIfFalse)
                return NULL;

            return static_cast<DkmILJumpIfFalse*>(pILInstruction);
        }

        /// <summary>
        /// Create a new DkmILJumpIfFalse object instance.
        /// </summary>
        /// <param name="Target">
        /// [In] Location in the instruction stream to jump to.
        /// </param>
        /// <param name="ppCreatedObject">
        /// [Out] Result of this method call.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ UINT32 Target,
            _Deref_out_ Evaluation::IL::DkmILJumpIfFalse** ppCreatedObject
            );
    }; // end of DkmILJumpIfFalse

    // Pops a value off the IL stack.  Then, jumps to another instruction in the instruction
    // stream only if the value bytes are not all zero.
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("01aaf69c-9a98-03d9-2bbd-49b74de78028") DkmILJumpIfTrue : public Evaluation::IL::DkmILInstruction
    {
        // Use DkmILJumpIfTrue::Create to create this object
        private: DkmILJumpIfTrue();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmILJumpIfTrue();
        // This object cannot be copied
        private: DkmILJumpIfTrue& operator=(const DkmILJumpIfTrue&);
        private: DkmILJumpIfTrue(const DkmILJumpIfTrue&);

        private: const UINT32 m_Target;
        private: void* m__pExtendedData;

        // Location in the instruction stream to jump to.
        public: DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE Target(
            );

        // Attempt to cast a 'DkmILInstruction' to a 'DkmILJumpIfTrue'. Return
        // NULL if the path object is not a 'DkmILJumpIfTrue'.
        // pJumpIfTrue : [In,Optional] Object to attempt to cast
        // Return Value : [Optional] Result of the cast.
        public: static DECLSPEC_NOTHROW DkmILJumpIfTrue* TryCast(
            DkmILInstruction* pILInstruction
            )
        {
            if (pILInstruction == NULL || pILInstruction->TagValue() != Tag::JumpIfTrue)
                return NULL;

            return static_cast<DkmILJumpIfTrue*>(pILInstruction);
        }

        /// <summary>
        /// Create a new DkmILJumpIfTrue object instance.
        /// </summary>
        /// <param name="Target">
        /// [In] Location in the instruction stream to jump to.
        /// </param>
        /// <param name="ppCreatedObject">
        /// [Out] Result of this method call.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ UINT32 Target,
            _Deref_out_ Evaluation::IL::DkmILJumpIfTrue** ppCreatedObject
            );
    }; // end of DkmILJumpIfTrue

    // Loads a value from an index previously saved from a DkmSave instruction and pushes the
    // value to the top of the stack.
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("242ede22-4afa-dcb0-6e75-e5b718815bee") DkmILLoad : public Evaluation::IL::DkmILInstruction
    {
        // Use DkmILLoad::Create to create this object
        private: DkmILLoad();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmILLoad();
        // This object cannot be copied
        private: DkmILLoad& operator=(const DkmILLoad&);
        private: DkmILLoad(const DkmILLoad&);

        private: const UINT32 m_Index;
        private: void* m__pExtendedData;

        // The index at which to save the value.
        public: DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE Index(
            );

        // Attempt to cast a 'DkmILInstruction' to a 'DkmILLoad'. Return
        // NULL if the path object is not a 'DkmILLoad'.
        // pLoad : [In,Optional] Object to attempt to cast
        // Return Value : [Optional] Result of the cast.
        public: static DECLSPEC_NOTHROW DkmILLoad* TryCast(
            DkmILInstruction* pILInstruction
            )
        {
            if (pILInstruction == NULL || pILInstruction->TagValue() != Tag::Load)
                return NULL;

            return static_cast<DkmILLoad*>(pILInstruction);
        }

        /// <summary>
        /// Create a new DkmILLoad object instance.
        /// </summary>
        /// <param name="Index">
        /// [In] The index at which to save the value.
        /// </param>
        /// <param name="ppCreatedObject">
        /// [Out] Result of this method call.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ UINT32 Index,
            _Deref_out_ Evaluation::IL::DkmILLoad** ppCreatedObject
            );
    }; // end of DkmILLoad

    // A request to read a sequence of bytes from memory.  The address to read from is popped
    // off the DkmIL stack and must have a size of 4 if the debuggee is 32-bit, or 8 if the
    // debuggee is 64-bit.  The bytes that are read from memory are pushed onto the stack.
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("773a4206-89a8-80c4-a828-6ea6728935aa") DkmILMemoryRead : public Evaluation::IL::DkmILInstruction
    {
        // Use DkmILMemoryRead::Create to create this object
        private: DkmILMemoryRead();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmILMemoryRead();
        // This object cannot be copied
        private: DkmILMemoryRead& operator=(const DkmILMemoryRead&);
        private: DkmILMemoryRead(const DkmILMemoryRead&);

        private: const UINT32 m_Size;
        private: const DkmReadMemoryFlags_t m_Flags;
        private: void* m__pExtendedData;

        // Number of bytes to read.
        public: DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE Size(
            );

        // Flags controlling the behavior of DkmProcess.ReadMemory and
        // DkmProcess.ReadMemoryString.
        public: DECLSPEC_NOTHROW DkmReadMemoryFlags_t STDMETHODCALLTYPE Flags(
            );

        // Attempt to cast a 'DkmILInstruction' to a 'DkmILMemoryRead'. Return
        // NULL if the path object is not a 'DkmILMemoryRead'.
        // pMemoryRead : [In,Optional] Object to attempt to cast
        // Return Value : [Optional] Result of the cast.
        public: static DECLSPEC_NOTHROW DkmILMemoryRead* TryCast(
            DkmILInstruction* pILInstruction
            )
        {
            if (pILInstruction == NULL || pILInstruction->TagValue() != Tag::MemoryRead)
                return NULL;

            return static_cast<DkmILMemoryRead*>(pILInstruction);
        }

        /// <summary>
        /// Create a new DkmILMemoryRead object instance.
        /// </summary>
        /// <param name="Size">
        /// [In] Number of bytes to read.
        /// </param>
        /// <param name="Flags">
        /// [In] Flags controlling the behavior of DkmProcess.ReadMemory and
        /// DkmProcess.ReadMemoryString.
        /// </param>
        /// <param name="ppCreatedObject">
        /// [Out] Result of this method call.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ UINT32 Size,
            _In_ DkmReadMemoryFlags_t Flags,
            _Deref_out_ Evaluation::IL::DkmILMemoryRead** ppCreatedObject
            );
    }; // end of DkmILMemoryRead

    // A request to read a null-terminated string from the target process. The address to
    // read from is popped off the DkmIL stack and must have a size of 4 if the debuggee is
    // 32-bit, or 8 if the debuggee is 64-bit.  The bytes that are read from memory are
    // pushed onto the stack. This will include the null-terminator if this value is read.
    // The null-terminator will be missing when DkmReadMemoryFlags.AllowPartialRead is true,
    // and either the MaxCharacters is hit, or unreadable memory is hit before the null
    // terminator.
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("a64d7c04-4e5a-4a75-936c-5eeeb7121f65") DkmILMemoryStringRead : public Evaluation::IL::DkmILInstruction
    {
        // Use DkmILMemoryStringRead::Create to create this object
        private: DkmILMemoryStringRead();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmILMemoryStringRead();
        // This object cannot be copied
        private: DkmILMemoryStringRead& operator=(const DkmILMemoryStringRead&);
        private: DkmILMemoryStringRead(const DkmILMemoryStringRead&);

        private: const DkmReadMemoryFlags_t m_Flags;
        private: const UINT16 m_CharacterSize;
        private: const UINT32 m_MaxCharacters;
        private: void* m__pExtendedData;

        // Flags controlling the behavior of DkmProcess.ReadMemory and
        // DkmProcess.ReadMemoryString.
        public: DECLSPEC_NOTHROW DkmReadMemoryFlags_t STDMETHODCALLTYPE Flags(
            );

        // Number of bytes in each character. This should be set to 1 (ANSI/UTF-8), 2
        // (UTF-16) or 4 (UTF-32).
        public: DECLSPEC_NOTHROW UINT16 STDMETHODCALLTYPE CharacterSize(
            );

        // The maximum number of characters to read from the target process. When
        // DkmReadMemoryFlags.AllowPartialRead is false, the request will fail if a null
        // terminator isn't found within this range with DkmILFailureReason.StringTooLong.
        public: DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE MaxCharacters(
            );

        // Attempt to cast a 'DkmILInstruction' to a 'DkmILMemoryStringRead'. Return
        // NULL if the path object is not a 'DkmILMemoryStringRead'.
        // pMemoryStringRead : [In,Optional] Object to attempt to cast
        // Return Value : [Optional] Result of the cast.
        public: static DECLSPEC_NOTHROW DkmILMemoryStringRead* TryCast(
            DkmILInstruction* pILInstruction
            )
        {
            if (pILInstruction == NULL || pILInstruction->TagValue() != Tag::MemoryStringRead)
                return NULL;

            return static_cast<DkmILMemoryStringRead*>(pILInstruction);
        }

        /// <summary>
        /// Create a new DkmILMemoryStringRead object instance.
        /// </summary>
        /// <param name="Flags">
        /// [In] Flags controlling the behavior of DkmProcess.ReadMemory and
        /// DkmProcess.ReadMemoryString.
        /// </param>
        /// <param name="CharacterSize">
        /// [In] Number of bytes in each character. This should be set to 1 (ANSI/UTF-8), 2
        /// (UTF-16) or 4 (UTF-32).
        /// </param>
        /// <param name="MaxCharacters">
        /// [In] The maximum number of characters to read from the target process. When
        /// DkmReadMemoryFlags.AllowPartialRead is false, the request will fail if a null
        /// terminator isn't found within this range with DkmILFailureReason.StringTooLong.
        /// </param>
        /// <param name="ppCreatedObject">
        /// [Out] Result of this method call.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ DkmReadMemoryFlags_t Flags,
            _In_ UINT16 CharacterSize,
            _In_ UINT32 MaxCharacters,
            _Deref_out_ Evaluation::IL::DkmILMemoryStringRead** ppCreatedObject
            );
    }; // end of DkmILMemoryStringRead

    // A request to write a sequence of bytes from memory.  Pops a value off the stack.
    // Then, pops an address of the stack.  Writes the value popped off the stack to debuggee
    // memory at the address popped off the stack.
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("9b5f6ebc-fd01-fca2-baec-9d02957bffc4") DkmILMemoryWrite : public Evaluation::IL::DkmILInstruction
    {
        // Use DkmILMemoryWrite::Create to create this object
        private: DkmILMemoryWrite();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmILMemoryWrite();
        // This object cannot be copied
        private: DkmILMemoryWrite& operator=(const DkmILMemoryWrite&);
        private: DkmILMemoryWrite(const DkmILMemoryWrite&);

        private: void* m__pExtendedData;

        // Attempt to cast a 'DkmILInstruction' to a 'DkmILMemoryWrite'. Return
        // NULL if the path object is not a 'DkmILMemoryWrite'.
        // pMemoryWrite : [In,Optional] Object to attempt to cast
        // Return Value : [Optional] Result of the cast.
        public: static DECLSPEC_NOTHROW DkmILMemoryWrite* TryCast(
            DkmILInstruction* pILInstruction
            )
        {
            if (pILInstruction == NULL || pILInstruction->TagValue() != Tag::MemoryWrite)
                return NULL;

            return static_cast<DkmILMemoryWrite*>(pILInstruction);
        }

        /// <summary>
        /// Create a new DkmILMemoryWrite object instance.
        /// </summary>
        /// <param name="ppCreatedObject">
        /// [Out] Result of this method call.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _Deref_out_ Evaluation::IL::DkmILMemoryWrite** ppCreatedObject
            );
    }; // end of DkmILMemoryWrite

    // Pops two values off the evaluation stack, multiplies them, and pushes the product onto
    // the evaluation stack. Both operands popped off the stack must be the size indicated by
    // DkmPrimitiveObjectType. In the event of overflow, the result will be truncated.
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("3fcf6521-45e9-d844-be16-1f0523c98ff3") DkmILMultiply : public Evaluation::IL::DkmILInstruction
    {
        // Use DkmILMultiply::Create to create this object
        private: DkmILMultiply();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmILMultiply();
        // This object cannot be copied
        private: DkmILMultiply& operator=(const DkmILMultiply&);
        private: DkmILMultiply(const DkmILMultiply&);

        private: const Evaluation::IL::DkmPrimitiveObjectType_t m_Type;
        private: void* m__pExtendedData;

        // The type of subtraction to perform (e.g. integer vs. floating-point).
        public: DECLSPEC_NOTHROW Evaluation::IL::DkmPrimitiveObjectType_t STDMETHODCALLTYPE Type(
            );

        // Attempt to cast a 'DkmILInstruction' to a 'DkmILMultiply'. Return
        // NULL if the path object is not a 'DkmILMultiply'.
        // pMultiply : [In,Optional] Object to attempt to cast
        // Return Value : [Optional] Result of the cast.
        public: static DECLSPEC_NOTHROW DkmILMultiply* TryCast(
            DkmILInstruction* pILInstruction
            )
        {
            if (pILInstruction == NULL || pILInstruction->TagValue() != Tag::Multiply)
                return NULL;

            return static_cast<DkmILMultiply*>(pILInstruction);
        }

        /// <summary>
        /// Create a new DkmILMultiply object instance.
        /// </summary>
        /// <param name="Type">
        /// [In] The type of subtraction to perform (e.g. integer vs. floating-point).
        /// </param>
        /// <param name="ppCreatedObject">
        /// [Out] Result of this method call.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ Evaluation::IL::DkmPrimitiveObjectType_t Type,
            _Deref_out_ Evaluation::IL::DkmILMultiply** ppCreatedObject
            );
    }; // end of DkmILMultiply

    // Placeholder instruction that does no operation.
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("54573ae7-a6fa-c7c5-4473-3846e8a76f1f") DkmILNop : public Evaluation::IL::DkmILInstruction
    {
        // Use DkmILNop::Create to create this object
        private: DkmILNop();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmILNop();
        // This object cannot be copied
        private: DkmILNop& operator=(const DkmILNop&);
        private: DkmILNop(const DkmILNop&);

        private: void* m__pExtendedData;

        // Attempt to cast a 'DkmILInstruction' to a 'DkmILNop'. Return
        // NULL if the path object is not a 'DkmILNop'.
        // pNop : [In,Optional] Object to attempt to cast
        // Return Value : [Optional] Result of the cast.
        public: static DECLSPEC_NOTHROW DkmILNop* TryCast(
            DkmILInstruction* pILInstruction
            )
        {
            if (pILInstruction == NULL || pILInstruction->TagValue() != Tag::Nop)
                return NULL;

            return static_cast<DkmILNop*>(pILInstruction);
        }

        /// <summary>
        /// Create a new DkmILNop object instance.
        /// </summary>
        /// <param name="ppCreatedObject">
        /// [Out] Result of this method call.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _Deref_out_ Evaluation::IL::DkmILNop** ppCreatedObject
            );
    }; // end of DkmILNop

    // Pop the value on top of the DkmIL stack.
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("6eb40730-7c81-beb5-91be-bf369d34f741") DkmILPop : public Evaluation::IL::DkmILInstruction
    {
        // Use DkmILPop::Create to create this object
        private: DkmILPop();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmILPop();
        // This object cannot be copied
        private: DkmILPop& operator=(const DkmILPop&);
        private: DkmILPop(const DkmILPop&);

        private: void* m__pExtendedData;

        // Attempt to cast a 'DkmILInstruction' to a 'DkmILPop'. Return
        // NULL if the path object is not a 'DkmILPop'.
        // pPop : [In,Optional] Object to attempt to cast
        // Return Value : [Optional] Result of the cast.
        public: static DECLSPEC_NOTHROW DkmILPop* TryCast(
            DkmILInstruction* pILInstruction
            )
        {
            if (pILInstruction == NULL || pILInstruction->TagValue() != Tag::Pop)
                return NULL;

            return static_cast<DkmILPop*>(pILInstruction);
        }

        /// <summary>
        /// Create a new DkmILPop object instance.
        /// </summary>
        /// <param name="ppCreatedObject">
        /// [Out] Result of this method call.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _Deref_out_ Evaluation::IL::DkmILPop** ppCreatedObject
            );
    }; // end of DkmILPop

    // Pushes a constant value onto the DkmIL stack.
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("debef887-9da9-04e2-fff2-6e510affdffe") DkmILPushConstant : public Evaluation::IL::DkmILInstruction
    {
        // Use DkmILPushConstant::Create to create this object
        private: DkmILPushConstant();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmILPushConstant();
        // This object cannot be copied
        private: DkmILPushConstant& operator=(const DkmILPushConstant&);
        private: DkmILPushConstant(const DkmILPushConstant&);

        private: DkmReadOnlyCollection<BYTE>* const m_pValue;
        private: void* m__pExtendedData;

        // The value to push onto the DkmIL stack.
        public: _Ret_ DECLSPEC_NOTHROW DkmReadOnlyCollection<BYTE>* STDMETHODCALLTYPE Value(
            );

        // Attempt to cast a 'DkmILInstruction' to a 'DkmILPushConstant'. Return
        // NULL if the path object is not a 'DkmILPushConstant'.
        // pPushConstant : [In,Optional] Object to attempt to cast
        // Return Value : [Optional] Result of the cast.
        public: static DECLSPEC_NOTHROW DkmILPushConstant* TryCast(
            DkmILInstruction* pILInstruction
            )
        {
            if (pILInstruction == NULL || pILInstruction->TagValue() != Tag::PushConstant)
                return NULL;

            return static_cast<DkmILPushConstant*>(pILInstruction);
        }

        /// <summary>
        /// Create a new DkmILPushConstant object instance.
        /// </summary>
        /// <param name="pValue">
        /// [In] The value to push onto the DkmIL stack.
        /// </param>
        /// <param name="ppCreatedObject">
        /// [Out] Result of this method call.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ DkmReadOnlyCollection<BYTE>* pValue,
            _Deref_out_ Evaluation::IL::DkmILPushConstant** ppCreatedObject
            );
    }; // end of DkmILPushConstant

    // Pushes a pseudo address on the stack representing the IL local variable and a byte
    // offset within that variable. When popped from the stack as an address, instructions
    // that would ordinarily read or write memory in the debuggee process will instead read
    // or write bytes at the IL local variable and offset specified in the pseudo-address.
    // It is permissible to push a pseudo-address onto the stack corresponding to a local
    // variable that does not exist or has fewer bytes than the specified offset.  However,
    // when the times to actually read or write data at a pseudo-address, the backing local
    // variable must exist and must have enough data to encompass the entire read or write
    // operation.  (Reads may be truncated at the end of the buffer if AllowPartialRead is
    // specified). A pseudo-address may be used as the operand of an arithmetic operation in
    // the following cases: - adding an integer a pseudo-address.  (The integer will be added
    // to the offset) - subtracting an integer from a pseudo-address.  (The integer will be
    // subtracted from the offset). - subtracting two pseudo-addresses from each other,
    // backed by the same local variable.  (The result is the difference in offsets). -
    // comparing a pseudo address with NULL.  (Any pseudo-address is considered greater than
    // NULL.  An operand is considered to be NULL if all bytes are zero.) - comparing two
    // pseudo-addresses for equality. - comparing two pseudo-addresses for inequality, when
    // backed by the same variable.  (The offsets will be compared). Pseudo-addresses may
    // also be used with DkmILDuplicateTop or saved in local variables via DkmILLoad and
    // DkmILSave.  It is illegal to read or write data at a pseudo-address, however, if the
    // backing local variable contains another pseudo-address. Pseudo-addresses may be
    // returned as an IL result via the DkmILReturnTop instruction.  The resulting
    // DkmILEvaluationResult can be identified as a pseudo-address via the IsPseudoAddress
    // property.  The result bytes of a pseudo-address will be set to either the contents of
    // the backing local variable, from the specified offset until the end of the variable,
    // or empty if the backing local variable does not exist, is another pseudo-address, or
    // does not store enough bytes to contain data at the given offset. Pseudo-addresses may
    // also be passed in as a parameter to a DkmCompiledILInspectionQuery by setting IsByRef
    // to true on the DkmILParameterValue. It is illegal to use a pseudo-address in any IL
    // instruction, except as described above.  An attempt to use a pseudo-address in any
    // other manner will result in an IL exception of type
    // DkmILFailureReason::InvalidPseudoAddressOperation.  For example, you cannot multiply
    // or divide with pseudo-addresses or store them anywhere in the debuggee process.
    //
    // This API was introduced in Visual Studio 14 RTM (DkmApiVersion.VS14RTM).
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("56f239a7-cc68-aa1a-8b1a-ee0cb4ff9834") DkmILPushLocalVariablePseudoAddress : public Evaluation::IL::DkmILInstruction
    {
        // Use DkmILPushLocalVariablePseudoAddress::Create to create this object
        private: DkmILPushLocalVariablePseudoAddress();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmILPushLocalVariablePseudoAddress();
        // This object cannot be copied
        private: DkmILPushLocalVariablePseudoAddress& operator=(const DkmILPushLocalVariablePseudoAddress&);
        private: DkmILPushLocalVariablePseudoAddress(const DkmILPushLocalVariablePseudoAddress&);

        private: const UINT32 m_Index;
        private: const UINT32 m_ByteOffset;
        private: void* m__pExtendedData;

        // The index of the IL variable this pseudo-address should be backed by.
        //
        // This API was introduced in Visual Studio 14 RTM (DkmApiVersion.VS14RTM).
        public: DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE Index(
            );

        // The offset, within the backing local variable, that this pseudo-address refers to.
        //
        // This API was introduced in Visual Studio 14 RTM (DkmApiVersion.VS14RTM).
        public: DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE ByteOffset(
            );

        // Attempt to cast a 'DkmILInstruction' to a 'DkmILPushLocalVariablePseudoAddress'. Return
        // NULL if the path object is not a 'DkmILPushLocalVariablePseudoAddress'.
        // pPushLocalVariablePseudoAddress : [In,Optional] Object to attempt to cast
        // Return Value : [Optional] Result of the cast.
        public: static DECLSPEC_NOTHROW DkmILPushLocalVariablePseudoAddress* TryCast(
            DkmILInstruction* pILInstruction
            )
        {
            if (pILInstruction == NULL || pILInstruction->TagValue() != Tag::PushLocalVariablePseudoAddress)
                return NULL;

            return static_cast<DkmILPushLocalVariablePseudoAddress*>(pILInstruction);
        }

        /// <summary>
        /// Create a new DkmILPushLocalVariablePseudoAddress object instance.
        ///
        /// This API was introduced in Visual Studio 14 RTM (DkmApiVersion.VS14RTM).
        /// </summary>
        /// <param name="Index">
        /// [In] The index of the IL variable this pseudo-address should be backed by.
        /// </param>
        /// <param name="ByteOffset">
        /// [In] The offset, within the backing local variable, that this pseudo-address
        /// refers to.
        /// </param>
        /// <param name="ppCreatedObject">
        /// [Out] Result of this method call.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ UINT32 Index,
            _In_ UINT32 ByteOffset,
            _Deref_out_ Evaluation::IL::DkmILPushLocalVariablePseudoAddress** ppCreatedObject
            );
    }; // end of DkmILPushLocalVariablePseudoAddress

    // A request to read the value of a specific register.  The result is pushed on the DkmIL
    // stack.
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("65088917-dd5b-32c3-b300-21da5242d959") DkmILRegisterRead : public Evaluation::IL::DkmILInstruction
    {
        // Use DkmILRegisterRead::Create to create this object
        private: DkmILRegisterRead();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmILRegisterRead();
        // This object cannot be copied
        private: DkmILRegisterRead& operator=(const DkmILRegisterRead&);
        private: DkmILRegisterRead(const DkmILRegisterRead&);

        private: const CV_HREG_e m_RegisterId;
        private: void* m__pExtendedData;

        // The code-view definition of which register to read.  Values are defined in
        // cvconst.h.  This is architecture dependent.
        public: DECLSPEC_NOTHROW CV_HREG_e STDMETHODCALLTYPE RegisterId(
            );

        // Attempt to cast a 'DkmILInstruction' to a 'DkmILRegisterRead'. Return
        // NULL if the path object is not a 'DkmILRegisterRead'.
        // pRegisterRead : [In,Optional] Object to attempt to cast
        // Return Value : [Optional] Result of the cast.
        public: static DECLSPEC_NOTHROW DkmILRegisterRead* TryCast(
            DkmILInstruction* pILInstruction
            )
        {
            if (pILInstruction == NULL || pILInstruction->TagValue() != Tag::RegisterRead)
                return NULL;

            return static_cast<DkmILRegisterRead*>(pILInstruction);
        }

        /// <summary>
        /// Create a new DkmILRegisterRead object instance.
        /// </summary>
        /// <param name="RegisterId">
        /// [In] The code-view definition of which register to read.  Values are defined in
        /// cvconst.h.  This is architecture dependent.
        /// </param>
        /// <param name="ppCreatedObject">
        /// [Out] Result of this method call.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ CV_HREG_e RegisterId,
            _Deref_out_ Evaluation::IL::DkmILRegisterRead** ppCreatedObject
            );
    }; // end of DkmILRegisterRead

    // Pops a value off the IL stack.  Then, writes the value to the given register of the
    // given thread.  The write will be visible to the debuggee from the top frame of that
    // thread.
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("6c08742c-250e-5f2c-98bb-b2a714901eab") DkmILRegisterWrite : public Evaluation::IL::DkmILInstruction
    {
        // Use DkmILRegisterWrite::Create to create this object
        private: DkmILRegisterWrite();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmILRegisterWrite();
        // This object cannot be copied
        private: DkmILRegisterWrite& operator=(const DkmILRegisterWrite&);
        private: DkmILRegisterWrite(const DkmILRegisterWrite&);

        private: const CV_HREG_e m_RegisterId;
        private: void* m__pExtendedData;

        // The code-view definition of which register to write.  Values are defined in
        // cvconst.h.  This is architecture dependent.
        public: DECLSPEC_NOTHROW CV_HREG_e STDMETHODCALLTYPE RegisterId(
            );

        // Attempt to cast a 'DkmILInstruction' to a 'DkmILRegisterWrite'. Return
        // NULL if the path object is not a 'DkmILRegisterWrite'.
        // pRegisterWrite : [In,Optional] Object to attempt to cast
        // Return Value : [Optional] Result of the cast.
        public: static DECLSPEC_NOTHROW DkmILRegisterWrite* TryCast(
            DkmILInstruction* pILInstruction
            )
        {
            if (pILInstruction == NULL || pILInstruction->TagValue() != Tag::RegisterWrite)
                return NULL;

            return static_cast<DkmILRegisterWrite*>(pILInstruction);
        }

        /// <summary>
        /// Create a new DkmILRegisterWrite object instance.
        /// </summary>
        /// <param name="RegisterId">
        /// [In] The code-view definition of which register to write.  Values are defined in
        /// cvconst.h.  This is architecture dependent.
        /// </param>
        /// <param name="ppCreatedObject">
        /// [Out] Result of this method call.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ CV_HREG_e RegisterId,
            _Deref_out_ Evaluation::IL::DkmILRegisterWrite** ppCreatedObject
            );
    }; // end of DkmILRegisterWrite

    // Pops two values off the evaluation stack and computes the second value popped off the
    // stack modulo the first value popped off the stack.
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("2fc16220-cbf9-15e8-f428-84628d374f31") DkmILRemainder : public Evaluation::IL::DkmILInstruction
    {
        // Use DkmILRemainder::Create to create this object
        private: DkmILRemainder();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmILRemainder();
        // This object cannot be copied
        private: DkmILRemainder& operator=(const DkmILRemainder&);
        private: DkmILRemainder(const DkmILRemainder&);

        private: const Evaluation::IL::DkmPrimitiveObjectType_t m_Type;
        private: void* m__pExtendedData;

        // The type of operands to consume (e.g. integer vs. floating-point).
        public: DECLSPEC_NOTHROW Evaluation::IL::DkmPrimitiveObjectType_t STDMETHODCALLTYPE Type(
            );

        // Attempt to cast a 'DkmILInstruction' to a 'DkmILRemainder'. Return
        // NULL if the path object is not a 'DkmILRemainder'.
        // pRemainder : [In,Optional] Object to attempt to cast
        // Return Value : [Optional] Result of the cast.
        public: static DECLSPEC_NOTHROW DkmILRemainder* TryCast(
            DkmILInstruction* pILInstruction
            )
        {
            if (pILInstruction == NULL || pILInstruction->TagValue() != Tag::Remainder)
                return NULL;

            return static_cast<DkmILRemainder*>(pILInstruction);
        }

        /// <summary>
        /// Create a new DkmILRemainder object instance.
        /// </summary>
        /// <param name="Type">
        /// [In] The type of operands to consume (e.g. integer vs. floating-point).
        /// </param>
        /// <param name="ppCreatedObject">
        /// [Out] Result of this method call.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ Evaluation::IL::DkmPrimitiveObjectType_t Type,
            _Deref_out_ Evaluation::IL::DkmILRemainder** ppCreatedObject
            );
    }; // end of DkmILRemainder

    // Pop the value on top of the DkmIL stack and return it as an instance of
    // DkmILEvaluationResult.
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("deb13411-2568-d114-0ab1-ab891ce11a2c") DkmILReturnTop : public Evaluation::IL::DkmILInstruction
    {
        // Use DkmILReturnTop::Create to create this object
        private: DkmILReturnTop();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmILReturnTop();
        // This object cannot be copied
        private: DkmILReturnTop& operator=(const DkmILReturnTop&);
        private: DkmILReturnTop(const DkmILReturnTop&);

        private: void* m__pExtendedData;

        // Attempt to cast a 'DkmILInstruction' to a 'DkmILReturnTop'. Return
        // NULL if the path object is not a 'DkmILReturnTop'.
        // pReturnTop : [In,Optional] Object to attempt to cast
        // Return Value : [Optional] Result of the cast.
        public: static DECLSPEC_NOTHROW DkmILReturnTop* TryCast(
            DkmILInstruction* pILInstruction
            )
        {
            if (pILInstruction == NULL || pILInstruction->TagValue() != Tag::ReturnTop)
                return NULL;

            return static_cast<DkmILReturnTop*>(pILInstruction);
        }

        /// <summary>
        /// Create a new DkmILReturnTop object instance.
        /// </summary>
        /// <param name="ppCreatedObject">
        /// [Out] Result of this method call.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _Deref_out_ Evaluation::IL::DkmILReturnTop** ppCreatedObject
            );
    }; // end of DkmILReturnTop

    // Saves the value at the top of the stack in a temporary slot at the given index, from
    // which it can later be loaded back.
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("60b4a51a-025c-34a3-6b05-284cf64fd50f") DkmILSave : public Evaluation::IL::DkmILInstruction
    {
        // Use DkmILSave::Create to create this object
        private: DkmILSave();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmILSave();
        // This object cannot be copied
        private: DkmILSave& operator=(const DkmILSave&);
        private: DkmILSave(const DkmILSave&);

        private: const UINT32 m_Index;
        private: void* m__pExtendedData;

        // The index at which to save the value.
        public: DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE Index(
            );

        // Attempt to cast a 'DkmILInstruction' to a 'DkmILSave'. Return
        // NULL if the path object is not a 'DkmILSave'.
        // pSave : [In,Optional] Object to attempt to cast
        // Return Value : [Optional] Result of the cast.
        public: static DECLSPEC_NOTHROW DkmILSave* TryCast(
            DkmILInstruction* pILInstruction
            )
        {
            if (pILInstruction == NULL || pILInstruction->TagValue() != Tag::Save)
                return NULL;

            return static_cast<DkmILSave*>(pILInstruction);
        }

        /// <summary>
        /// Create a new DkmILSave object instance.
        /// </summary>
        /// <param name="Index">
        /// [In] The index at which to save the value.
        /// </param>
        /// <param name="ppCreatedObject">
        /// [Out] Result of this method call.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ UINT32 Index,
            _Deref_out_ Evaluation::IL::DkmILSave** ppCreatedObject
            );
    }; // end of DkmILSave

    // Pops a value off the IL stack.  Then pops an offset, followed by a blob of bytes.
    // Modifies the first value so that the segment at the offset is replaced with the blob
    // of bytes provided.  Pushes the resultant value back onto the IL stack.
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("d49f8ec4-1fab-cf70-86c4-6b615460c079") DkmILSetBytesRegion : public Evaluation::IL::DkmILInstruction
    {
        // Use DkmILSetBytesRegion::Create to create this object
        private: DkmILSetBytesRegion();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmILSetBytesRegion();
        // This object cannot be copied
        private: DkmILSetBytesRegion& operator=(const DkmILSetBytesRegion&);
        private: DkmILSetBytesRegion(const DkmILSetBytesRegion&);

        private: void* m__pExtendedData;

        // Attempt to cast a 'DkmILInstruction' to a 'DkmILSetBytesRegion'. Return
        // NULL if the path object is not a 'DkmILSetBytesRegion'.
        // pSetBytesRegion : [In,Optional] Object to attempt to cast
        // Return Value : [Optional] Result of the cast.
        public: static DECLSPEC_NOTHROW DkmILSetBytesRegion* TryCast(
            DkmILInstruction* pILInstruction
            )
        {
            if (pILInstruction == NULL || pILInstruction->TagValue() != Tag::SetBytesRegion)
                return NULL;

            return static_cast<DkmILSetBytesRegion*>(pILInstruction);
        }

        /// <summary>
        /// Create a new DkmILSetBytesRegion object instance.
        /// </summary>
        /// <param name="ppCreatedObject">
        /// [Out] Result of this method call.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _Deref_out_ Evaluation::IL::DkmILSetBytesRegion** ppCreatedObject
            );
    }; // end of DkmILSetBytesRegion

    // Pops two values off the evaluation stack, subtracts them, and pushes the difference
    // onto the evaluation stack. Both operands popped off the stack must be the size
    // indicated by DkmPrimitiveObjectType.  The first value popped from the stack will be
    // subtracted from the second value popped, so to evaluate "a - b", you would push a,
    // then push b, then subtract. The resultant value will have the same size as the
    // operands.  In the event of overflow, the result will be truncated.
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("8dd587d3-eb37-aba6-37b6-b6cae1950c3e") DkmILSubtract : public Evaluation::IL::DkmILInstruction
    {
        // Use DkmILSubtract::Create to create this object
        private: DkmILSubtract();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmILSubtract();
        // This object cannot be copied
        private: DkmILSubtract& operator=(const DkmILSubtract&);
        private: DkmILSubtract(const DkmILSubtract&);

        private: const Evaluation::IL::DkmPrimitiveObjectType_t m_Type;
        private: void* m__pExtendedData;

        // The type of subtraction to perform (e.g. integer vs. floating-point).
        public: DECLSPEC_NOTHROW Evaluation::IL::DkmPrimitiveObjectType_t STDMETHODCALLTYPE Type(
            );

        // Attempt to cast a 'DkmILInstruction' to a 'DkmILSubtract'. Return
        // NULL if the path object is not a 'DkmILSubtract'.
        // pSubtract : [In,Optional] Object to attempt to cast
        // Return Value : [Optional] Result of the cast.
        public: static DECLSPEC_NOTHROW DkmILSubtract* TryCast(
            DkmILInstruction* pILInstruction
            )
        {
            if (pILInstruction == NULL || pILInstruction->TagValue() != Tag::Subtract)
                return NULL;

            return static_cast<DkmILSubtract*>(pILInstruction);
        }

        /// <summary>
        /// Create a new DkmILSubtract object instance.
        /// </summary>
        /// <param name="Type">
        /// [In] The type of subtraction to perform (e.g. integer vs. floating-point).
        /// </param>
        /// <param name="ppCreatedObject">
        /// [Out] Result of this method call.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ Evaluation::IL::DkmPrimitiveObjectType_t Type,
            _Deref_out_ Evaluation::IL::DkmILSubtract** ppCreatedObject
            );
    }; // end of DkmILSubtract

    // Throws a native IL exception within the given failure code.
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("b786a0a1-1605-bbee-238d-dbb759497dfb") DkmILThrow : public Evaluation::IL::DkmILInstruction
    {
        // Use DkmILThrow::Create to create this object
        private: DkmILThrow();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmILThrow();
        // This object cannot be copied
        private: DkmILThrow& operator=(const DkmILThrow&);
        private: DkmILThrow(const DkmILThrow&);

        private: const Evaluation::IL::DkmILFailureReason_t m_FailureCode;
        private: void* m__pExtendedData;

        // Indicates a reason why an IL instruction failed to execute.  In addition to these
        // constants, negative values may be used to indicate customized error conditions
        // resulting from the execution of intrinsic functions.
        public: DECLSPEC_NOTHROW Evaluation::IL::DkmILFailureReason_t STDMETHODCALLTYPE FailureCode(
            );

        // Attempt to cast a 'DkmILInstruction' to a 'DkmILThrow'. Return
        // NULL if the path object is not a 'DkmILThrow'.
        // pThrow : [In,Optional] Object to attempt to cast
        // Return Value : [Optional] Result of the cast.
        public: static DECLSPEC_NOTHROW DkmILThrow* TryCast(
            DkmILInstruction* pILInstruction
            )
        {
            if (pILInstruction == NULL || pILInstruction->TagValue() != Tag::Throw)
                return NULL;

            return static_cast<DkmILThrow*>(pILInstruction);
        }

        /// <summary>
        /// Create a new DkmILThrow object instance.
        /// </summary>
        /// <param name="FailureCode">
        /// [In] Indicates a reason why an IL instruction failed to execute.  In addition to
        /// these constants, negative values may be used to indicate customized error
        /// conditions resulting from the execution of intrinsic functions.
        /// </param>
        /// <param name="ppCreatedObject">
        /// [Out] Result of this method call.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ Evaluation::IL::DkmILFailureReason_t FailureCode,
            _Deref_out_ Evaluation::IL::DkmILThrow** ppCreatedObject
            );
    }; // end of DkmILThrow

    // Pushes an index of a TLS slot off the IL stack.  Reads the value of that TLS slot for
    // the thread of the current stack frame and pushes the result onto the IL stack. If the
    // TLS index is not valid, the result is undefined.  It may read a random value from
    // memory, or fail. The value that is pushed on the stack is a pointer-sized value (4
    // bytes if the debuggee is 32-bit, 8 bytes if the debuggee is 64-bit).
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("a9dbc0f2-c7be-c76b-5cff-9e45cef41a33") DkmILTlsGetValue : public Evaluation::IL::DkmILInstruction
    {
        // Use DkmILTlsGetValue::Create to create this object
        private: DkmILTlsGetValue();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmILTlsGetValue();
        // This object cannot be copied
        private: DkmILTlsGetValue& operator=(const DkmILTlsGetValue&);
        private: DkmILTlsGetValue(const DkmILTlsGetValue&);

        private: void* m__pExtendedData;

        // Attempt to cast a 'DkmILInstruction' to a 'DkmILTlsGetValue'. Return
        // NULL if the path object is not a 'DkmILTlsGetValue'.
        // pTlsGetValue : [In,Optional] Object to attempt to cast
        // Return Value : [Optional] Result of the cast.
        public: static DECLSPEC_NOTHROW DkmILTlsGetValue* TryCast(
            DkmILInstruction* pILInstruction
            )
        {
            if (pILInstruction == NULL || pILInstruction->TagValue() != Tag::TlsGetValue)
                return NULL;

            return static_cast<DkmILTlsGetValue*>(pILInstruction);
        }

        /// <summary>
        /// Create a new DkmILTlsGetValue object instance.
        /// </summary>
        /// <param name="ppCreatedObject">
        /// [Out] Result of this method call.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _Deref_out_ Evaluation::IL::DkmILTlsGetValue** ppCreatedObject
            );
    }; // end of DkmILTlsGetValue

};}; // end namespace Evaluation::IL

// Contains the types used to evaluation the same expression across multiple threads.
namespace Evaluation { namespace Group {
    // The results for a set of threads that match a specific context.
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("2bed0f45-7abe-5710-434c-3a254db68898") DkmContextGroupEvaluationILResult : public IUnknown
    {
        private: ___ReferenceCount_t m_ReferenceCount;
        private: DkmDispatcherObjectFlags_t m_ObjectFlags;
        private: const GUID* m_pTypeId;
        private: size_t m_ObjectGCHandle;
        // Use DkmContextGroupEvaluationILResult::Create to create this object
        private: DkmContextGroupEvaluationILResult();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmContextGroupEvaluationILResult();
        // This object cannot be copied
        private: DkmContextGroupEvaluationILResult& operator=(const DkmContextGroupEvaluationILResult&);
        private: DkmContextGroupEvaluationILResult(const DkmContextGroupEvaluationILResult&);

        private: const HRESULT m_EvaluationResults;
        private: DkmReadOnlyCollection<Evaluation::Group::DkmThreadEvaluationResultCollection*>* const m_pResultData;
        private: void* m__pExtendedData;

        // Result of the evaluation on this set of threads.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE EvaluationResults(
            );

        // An array of result data structures that indicate the source instruction and the
        // data buffer for all threads.
        public: _Ret_ DECLSPEC_NOTHROW DkmReadOnlyCollection<Evaluation::Group::DkmThreadEvaluationResultCollection*>* STDMETHODCALLTYPE ResultData(
            );

        /// <summary>
        /// Create a new DkmContextGroupEvaluationILResult object instance.
        /// </summary>
        /// <param name="EvaluationResults">
        /// [In] Result of the evaluation on this set of threads.
        /// </param>
        /// <param name="pResultData">
        /// [In] An array of result data structures that indicate the source instruction and
        /// the data buffer for all threads.
        /// </param>
        /// <param name="ppCreatedObject">
        /// [Out] Result of this method call.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ HRESULT EvaluationResults,
            _In_ DkmReadOnlyCollection<Evaluation::Group::DkmThreadEvaluationResultCollection*>* pResultData,
            _Deref_out_ Evaluation::Group::DkmContextGroupEvaluationILResult** ppCreatedObject
            );
    }; // end of DkmContextGroupEvaluationILResult

    // The results for a set of threads that match a specific context.
    //
    // Derived classes: DkmFailedContextGroupEvaluationResult,
    // DkmSuccessContextGroupEvaluationResult
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("bb891190-1064-c1b9-132e-f2e637c597e0") DkmContextGroupEvaluationResult : public DkmDataContainer
    {
        // Use DkmContextGroupEvaluationResult::Create to create this object
        private: DkmContextGroupEvaluationResult();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmContextGroupEvaluationResult();
        // This object cannot be copied
        private: DkmContextGroupEvaluationResult& operator=(const DkmContextGroupEvaluationResult&);
        private: DkmContextGroupEvaluationResult(const DkmContextGroupEvaluationResult&);

        // DkmContextGroupEvaluationResult is an abstract base class. This enum indicates
        // which derived class this object is an instance of.
        public: FORWARD_DECLARE_SCOPED_ENUM(Tag);
        DEFINE_SCOPED_ENUM(Tag)
        {
        // Object is an instance of 'DkmSuccessContextGroupEvaluationResult'.
        SuccessContextGroupEvalResult = 0,
        // Object is an instance of 'DkmFailedContextGroupEvaluationResult'.
        FailedContextGroupEvalResult = 1
        };

        private: const Tag_t m_TagValue;
        private: DkmReadOnlyCollection<UINT64>* const m_pThreadIds;
        private: const HRESULT m_EvaluationResults;
        private: DkmString* const m_pName;
        private: OPTIONAL DkmString* const m_pFullName;
        private: const GUID m_UniqueId;
        private: DkmRuntimeInstance* const m_pRuntimeInstance;
        private: void* m__pExtendedData;

        // DkmContextGroupEvaluationResult is an abstract base class. This enum indicates
        // which derived class this object is an instance of.
        public: DECLSPEC_NOTHROW Tag_t STDMETHODCALLTYPE TagValue(
            );

        // The thread IDs for the evaluation results.
        public: _Ret_ DECLSPEC_NOTHROW DkmReadOnlyCollection<UINT64>* STDMETHODCALLTYPE ThreadIds(
            );

        // Result of the evaluation on this set of threads.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE EvaluationResults(
            );

        // The name of the expression this result applies to.
        public: _Ret_ DECLSPEC_NOTHROW DkmString* STDMETHODCALLTYPE Name(
            );

        // [Optional] The full name of the expression this result applies to. This value is
        // used to allow child elements to be added to the watch window (Add Watch from the
        // context menu), and to refresh parts of the evaluation tree. As an example of how
        // FullName differs from name, the name of the 0th element of an array in C++ is
        // '[0]' while the full name would by 'myArrayVariable[0]'.
        public: _Ret_opt_ DECLSPEC_NOTHROW DkmString* STDMETHODCALLTYPE FullName(
            );

        // Guid which uniquely identifies this evaluation result.
        public: DECLSPEC_NOTHROW const GUID& STDMETHODCALLTYPE UniqueId(
            );

        // The DkmRuntimeInstance class represents an execution environment which is loaded
        // into a DkmProcess and which contains code to be debugged.
        public: _Ret_ DECLSPEC_NOTHROW DkmRuntimeInstance* STDMETHODCALLTYPE RuntimeInstance(
            );

        /// <summary>
        /// Closes the compute thread evaluation result object to release the resources
        /// associated with it. This method must be invoked by the component which initiated
        /// the enumeration (ex: called DkmInspectionContext.EvaluateExpression,
        /// DkmEvaluationResultEnumContext.GetItems, etc).
        ///
        /// DkmContextGroupEvaluationResult objects are automatically closed when their
        /// associated DkmRuntimeInstance object is closed.
        /// </summary>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Close(
            );
    }; // end of DkmContextGroupEvaluationResult

    // Result of an asynchronous DkmInspectionContext.EvaluateExpressionOnThreads call.
    struct DkmEvaluateExpressionOnThreadsAsyncResult
    {
        // HRESULT code returned from the caller. This will be
        // DkmExceptionCode.COR_E_OPERATIONCANCELED (0x8013153B) if the operation was
        // canceled before processing was complete. E_PROCESS_DESTROYED indicates that the
        // process exited while attempting to evaluate.
        HRESULT ErrorCode;

        // Object containing the results of the evaluation. This object must be closed by the
        // caller when the caller is done with the object.
        DkmReadOnlyCollection<Evaluation::Group::DkmContextGroupEvaluationResult*>* pResults;
    };

    // Result of an asynchronous DkmCompiledILInspectionQuery.ExecuteQueryOnThreads call.
    struct DkmExecuteQueryOnThreadsAsyncResult
    {
        // HRESULT code returned from the caller. This will be
        // DkmExceptionCode.COR_E_OPERATIONCANCELED (0x8013153B) if the operation was
        // canceled before processing was complete.
        HRESULT ErrorCode;

        // Results of the evaluations.
        Evaluation::Group::DkmContextGroupEvaluationILResult* pResult;
    };

    // A collection of parameters that should be used together.
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("79c52e77-96fa-6709-ca94-85d3a8ae6a5e") DkmILParameterValueCollection : public IUnknown
    {
        private: ___ReferenceCount_t m_ReferenceCount;
        private: DkmDispatcherObjectFlags_t m_ObjectFlags;
        private: const GUID* m_pTypeId;
        private: size_t m_ObjectGCHandle;
        // Use DkmILParameterValueCollection::Create to create this object
        private: DkmILParameterValueCollection();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmILParameterValueCollection();
        // This object cannot be copied
        private: DkmILParameterValueCollection& operator=(const DkmILParameterValueCollection&);
        private: DkmILParameterValueCollection(const DkmILParameterValueCollection&);

        private: OPTIONAL DkmReadOnlyCollection<Evaluation::IL::DkmILParameterValue*>* const m_pParameters;
        private: void* m__pExtendedData;

        // [Optional] The parameter collection.
        public: _Ret_opt_ DECLSPEC_NOTHROW DkmReadOnlyCollection<Evaluation::IL::DkmILParameterValue*>* STDMETHODCALLTYPE Parameters(
            );

        /// <summary>
        /// Create a new DkmILParameterValueCollection object instance.
        /// </summary>
        /// <param name="pParameters">
        /// [In,Optional] The parameter collection.
        /// </param>
        /// <param name="ppCreatedObject">
        /// [Out] Result of this method call.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_opt_ DkmReadOnlyCollection<Evaluation::IL::DkmILParameterValue*>* pParameters,
            _Deref_out_ Evaluation::Group::DkmILParameterValueCollection** ppCreatedObject
            );
    }; // end of DkmILParameterValueCollection

    // The set of results from a single thread.
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("5abed340-3864-41c5-af3c-486f0d0cb101") DkmThreadEvaluationResultCollection : public IUnknown
    {
        private: ___ReferenceCount_t m_ReferenceCount;
        private: DkmDispatcherObjectFlags_t m_ObjectFlags;
        private: const GUID* m_pTypeId;
        private: size_t m_ObjectGCHandle;
        // Use DkmThreadEvaluationResultCollection::Create to create this object
        private: DkmThreadEvaluationResultCollection();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmThreadEvaluationResultCollection();
        // This object cannot be copied
        private: DkmThreadEvaluationResultCollection& operator=(const DkmThreadEvaluationResultCollection&);
        private: DkmThreadEvaluationResultCollection(const DkmThreadEvaluationResultCollection&);

        private: DkmReadOnlyCollection<Evaluation::IL::DkmILEvaluationResult*>* const m_pResults;
        private: const Evaluation::IL::DkmILFailureReason_t m_FailureReason;
        private: void* m__pExtendedData;

        // The set of results from processing the query on the given thread.
        public: _Ret_ DECLSPEC_NOTHROW DkmReadOnlyCollection<Evaluation::IL::DkmILEvaluationResult*>* STDMETHODCALLTYPE Results(
            );

        // If an expected error occurs evaluating the DkmIL, indicates the reason for the
        // failure.
        public: DECLSPEC_NOTHROW Evaluation::IL::DkmILFailureReason_t STDMETHODCALLTYPE FailureReason(
            );

        /// <summary>
        /// Create a new DkmThreadEvaluationResultCollection object instance.
        /// </summary>
        /// <param name="pResults">
        /// [In] The set of results from processing the query on the given thread.
        /// </param>
        /// <param name="FailureReason">
        /// [In] If an expected error occurs evaluating the DkmIL, indicates the reason for
        /// the failure.
        /// </param>
        /// <param name="ppCreatedObject">
        /// [Out] Result of this method call.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ DkmReadOnlyCollection<Evaluation::IL::DkmILEvaluationResult*>* pResults,
            _In_ Evaluation::IL::DkmILFailureReason_t FailureReason,
            _Deref_out_ Evaluation::Group::DkmThreadEvaluationResultCollection** ppCreatedObject
            );
    }; // end of DkmThreadEvaluationResultCollection

    // The formatted result of a failed evaluation, ready to be displayed in an expression
    // evaluation window.
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("bcbf5652-8501-77e0-2256-0e6455e7909a") DkmFailedContextGroupEvaluationResult : public Evaluation::Group::DkmContextGroupEvaluationResult
    {
        // Use DkmFailedContextGroupEvaluationResult::Create to create this object
        private: DkmFailedContextGroupEvaluationResult();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmFailedContextGroupEvaluationResult();
        // This object cannot be copied
        private: DkmFailedContextGroupEvaluationResult& operator=(const DkmFailedContextGroupEvaluationResult&);
        private: DkmFailedContextGroupEvaluationResult(const DkmFailedContextGroupEvaluationResult&);

        private: DkmString* const m_pErrorMessage;
        private: const bool m_HasSideEffects;
        private: void* m__pExtendedData;

        // Specifies the error message to display to the user.
        public: _Ret_ DECLSPEC_NOTHROW DkmString* STDMETHODCALLTYPE ErrorMessage(
            );

        // Specifies the evaluation failed because it would cause side effects and side
        // effects are not allowed.
        public: DECLSPEC_NOTHROW bool STDMETHODCALLTYPE HasSideEffects(
            );

        // Attempt to cast a 'DkmContextGroupEvaluationResult' to a 'DkmFailedContextGroupEvaluationResult'. Return
        // NULL if the path object is not a 'DkmFailedContextGroupEvaluationResult'.
        // pFailedContextGroupEvalResult : [In,Optional] Object to attempt to cast
        // Return Value : [Optional] Result of the cast.
        public: static DECLSPEC_NOTHROW DkmFailedContextGroupEvaluationResult* TryCast(
            DkmContextGroupEvaluationResult* pContextGroupEvalResult
            )
        {
            if (pContextGroupEvalResult == NULL || pContextGroupEvalResult->TagValue() != Tag::FailedContextGroupEvalResult)
                return NULL;

            return static_cast<DkmFailedContextGroupEvaluationResult*>(pContextGroupEvalResult);
        }

        /// <summary>
        /// Create a new DkmFailedContextGroupEvaluationResult object instance.
        /// </summary>
        /// <param name="pThreadIds">
        /// [In] The thread IDs for the evaluation results.
        /// </param>
        /// <param name="EvaluationResults">
        /// [In] Result of the evaluation on this set of threads.
        /// </param>
        /// <param name="pName">
        /// [In] The name of the expression this result applies to.
        /// </param>
        /// <param name="pFullName">
        /// [In,Optional] The full name of the expression this result applies to. This value
        /// is used to allow child elements to be added to the watch window (Add Watch from
        /// the context menu), and to refresh parts of the evaluation tree. As an example of
        /// how FullName differs from name, the name of the 0th element of an array in C++ is
        /// '[0]' while the full name would by 'myArrayVariable[0]'.
        /// </param>
        /// <param name="pRuntimeInstance">
        /// [In] The DkmRuntimeInstance class represents an execution environment which is
        /// loaded into a DkmProcess and which contains code to be debugged.
        /// </param>
        /// <param name="pErrorMessage">
        /// [In] Specifies the error message to display to the user.
        /// </param>
        /// <param name="HasSideEffects">
        /// [In] Specifies the evaluation failed because it would cause side effects and side
        /// effects are not allowed.
        /// </param>
        /// <param name="DataItem">
        /// [In] Data object to add to the new DkmFailedContextGroupEvaluationResult
        /// instance. DkmDataItem::Null() in the case that the caller doesn't need to add a
        /// data item.
        /// </param>
        /// <param name="ppCreatedObject">
        /// [Out] Result of this method call.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ DkmReadOnlyCollection<UINT64>* pThreadIds,
            _In_ HRESULT EvaluationResults,
            _In_ DkmString* pName,
            _In_opt_ DkmString* pFullName,
            _In_ DkmRuntimeInstance* pRuntimeInstance,
            _In_ DkmString* pErrorMessage,
            _In_ bool HasSideEffects,
            _In_ const DkmDataItem& DataItem,
            _Deref_out_ Evaluation::Group::DkmFailedContextGroupEvaluationResult** ppCreatedObject
            );
    }; // end of DkmFailedContextGroupEvaluationResult

    // The formatted result of a successful evaluation, ready to be displayed in an
    // expression evaluation window.
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("0f911a5f-f32c-2647-470c-5524bac4b351") DkmSuccessContextGroupEvaluationResult : public Evaluation::Group::DkmContextGroupEvaluationResult
    {
        // Use DkmSuccessContextGroupEvaluationResult::Create to create this object
        private: DkmSuccessContextGroupEvaluationResult();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmSuccessContextGroupEvaluationResult();
        // This object cannot be copied
        private: DkmSuccessContextGroupEvaluationResult& operator=(const DkmSuccessContextGroupEvaluationResult&);
        private: DkmSuccessContextGroupEvaluationResult(const DkmSuccessContextGroupEvaluationResult&);

        private: const Evaluation::DkmEvaluationResultFlags_t m_Flags;
        private: DkmReadOnlyCollection<DkmString*>* const m_pValues;
        private: OPTIONAL DkmString* const m_pType;
        private: const Evaluation::DkmEvaluationResultCategory_t m_Category;
        private: const Evaluation::DkmEvaluationResultAccessType_t m_Access;
        private: const Evaluation::DkmEvaluationResultStorageType_t m_StorageType;
        private: const Evaluation::DkmEvaluationResultTypeModifierFlags_t m_TypeModifierFlags;
        private: OPTIONAL DkmReadOnlyCollection<Evaluation::DkmCustomUIVisualizerInfo*>* const m_pCustomUIVisualizers;
        private: void* m__pExtendedData;

        // Flags which indicate attributes of an expression evaluation result.
        public: DECLSPEC_NOTHROW Evaluation::DkmEvaluationResultFlags_t STDMETHODCALLTYPE Flags(
            );

        // The formatted values for each thread.
        public: _Ret_ DECLSPEC_NOTHROW DkmReadOnlyCollection<DkmString*>* STDMETHODCALLTYPE Values(
            );

        // [Optional] A string that describes the type of the value.
        public: _Ret_opt_ DECLSPEC_NOTHROW DkmString* STDMETHODCALLTYPE Type(
            );

        // The category (ex: Data, Method, etc) of this evaluation result.
        public: DECLSPEC_NOTHROW Evaluation::DkmEvaluationResultCategory_t STDMETHODCALLTYPE Category(
            );

        // The access control level (public, private, etc) of the evaluation result.
        public: DECLSPEC_NOTHROW Evaluation::DkmEvaluationResultAccessType_t STDMETHODCALLTYPE Access(
            );

        // The storage type (ex: static) of the evaluation result.
        public: DECLSPEC_NOTHROW Evaluation::DkmEvaluationResultStorageType_t STDMETHODCALLTYPE StorageType(
            );

        // Type modifier flags (ex: const) of the evaluation result.
        public: DECLSPEC_NOTHROW Evaluation::DkmEvaluationResultTypeModifierFlags_t STDMETHODCALLTYPE TypeModifierFlags(
            );

        // [Optional] A list of custom viewers for this object.
        public: _Ret_opt_ DECLSPEC_NOTHROW DkmReadOnlyCollection<Evaluation::DkmCustomUIVisualizerInfo*>* STDMETHODCALLTYPE CustomUIVisualizers(
            );

        // Attempt to cast a 'DkmContextGroupEvaluationResult' to a 'DkmSuccessContextGroupEvaluationResult'. Return
        // NULL if the path object is not a 'DkmSuccessContextGroupEvaluationResult'.
        // pSuccessContextGroupEvalResult : [In,Optional] Object to attempt to cast
        // Return Value : [Optional] Result of the cast.
        public: static DECLSPEC_NOTHROW DkmSuccessContextGroupEvaluationResult* TryCast(
            DkmContextGroupEvaluationResult* pContextGroupEvalResult
            )
        {
            if (pContextGroupEvalResult == NULL || pContextGroupEvalResult->TagValue() != Tag::SuccessContextGroupEvalResult)
                return NULL;

            return static_cast<DkmSuccessContextGroupEvaluationResult*>(pContextGroupEvalResult);
        }

        /// <summary>
        /// Create a new DkmSuccessContextGroupEvaluationResult object instance.
        /// </summary>
        /// <param name="pThreadIds">
        /// [In] The thread IDs for the evaluation results.
        /// </param>
        /// <param name="EvaluationResults">
        /// [In] Result of the evaluation on this set of threads.
        /// </param>
        /// <param name="pName">
        /// [In] The name of the expression this result applies to.
        /// </param>
        /// <param name="pFullName">
        /// [In,Optional] The full name of the expression this result applies to. This value
        /// is used to allow child elements to be added to the watch window (Add Watch from
        /// the context menu), and to refresh parts of the evaluation tree. As an example of
        /// how FullName differs from name, the name of the 0th element of an array in C++ is
        /// '[0]' while the full name would by 'myArrayVariable[0]'.
        /// </param>
        /// <param name="pRuntimeInstance">
        /// [In] The DkmRuntimeInstance class represents an execution environment which is
        /// loaded into a DkmProcess and which contains code to be debugged.
        /// </param>
        /// <param name="Flags">
        /// [In] Flags which indicate attributes of an expression evaluation result.
        /// </param>
        /// <param name="pValues">
        /// [In] The formatted values for each thread.
        /// </param>
        /// <param name="pType">
        /// [In,Optional] A string that describes the type of the value.
        /// </param>
        /// <param name="Category">
        /// [In] The category (ex: Data, Method, etc) of this evaluation result.
        /// </param>
        /// <param name="Access">
        /// [In] The access control level (public, private, etc) of the evaluation result.
        /// </param>
        /// <param name="StorageType">
        /// [In] The storage type (ex: static) of the evaluation result.
        /// </param>
        /// <param name="TypeModifierFlags">
        /// [In] Type modifier flags (ex: const) of the evaluation result.
        /// </param>
        /// <param name="pCustomUIVisualizers">
        /// [In,Optional] A list of custom viewers for this object.
        /// </param>
        /// <param name="DataItem">
        /// [In] Data object to add to the new DkmSuccessContextGroupEvaluationResult
        /// instance. DkmDataItem::Null() in the case that the caller doesn't need to add a
        /// data item.
        /// </param>
        /// <param name="ppCreatedObject">
        /// [Out] Result of this method call.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ DkmReadOnlyCollection<UINT64>* pThreadIds,
            _In_ HRESULT EvaluationResults,
            _In_ DkmString* pName,
            _In_opt_ DkmString* pFullName,
            _In_ DkmRuntimeInstance* pRuntimeInstance,
            _In_ Evaluation::DkmEvaluationResultFlags_t Flags,
            _In_ DkmReadOnlyCollection<DkmString*>* pValues,
            _In_opt_ DkmString* pType,
            _In_ Evaluation::DkmEvaluationResultCategory_t Category,
            _In_ Evaluation::DkmEvaluationResultAccessType_t Access,
            _In_ Evaluation::DkmEvaluationResultStorageType_t StorageType,
            _In_ Evaluation::DkmEvaluationResultTypeModifierFlags_t TypeModifierFlags,
            _In_opt_ DkmReadOnlyCollection<Evaluation::DkmCustomUIVisualizerInfo*>* pCustomUIVisualizers,
            _In_ const DkmDataItem& DataItem,
            _Deref_out_ Evaluation::Group::DkmSuccessContextGroupEvaluationResult** ppCreatedObject
            );
    }; // end of DkmSuccessContextGroupEvaluationResult

};}; // end namespace Evaluation::Group

// Contains the types used for dealing with symbolic information in the debugger. This
// includes all types related to handling documents and text ranges. This namespace
// contains only the runtime environment agnostic types, with additional types found in
// the 'Native', 'Clr', 'Script' and 'CustomRuntimes' namespaces.
namespace Symbols {
    // Windows dlls/exes contain a section for debugging information. Inside this section
    // there are zero or more IMAGE_DEBUG_DIRECTORY structures, and inside each of these
    // structures there is a 32-bit 'Type' field which indicates the format of the
    // information within the debug directory. DkmImageDebugDirectoryFormat is used to map
    // from this 'Type' value to the symbol provider which is used to handle this type of
    // debugging information. The debugger initializes a collection of
    // DkmImageDebugDirectoryFormat structs on startup by reading the
    // '%VSRegistryRoot%\Debugger\Image Debug Directory Formats' registry keys.
    struct DECLSPEC_UUID("66bdcf7e-ac43-b629-7205-57cec0699a35") DkmImageDebugDirectoryFormat
    {
        // 'Type' value from the IMAGE_DEBUG_DIRECTORY. For example,
        // IMAGE_DEBUG_TYPE_CODEVIEW (2) is used for PDB files. See winnt.h for a complete
        // listing.
        UINT32 TypeValue;

        // Symbol provider id to use for this.
        GUID SymbolProvider;

        // Release all reference-counted fields within the DkmImageDebugDirectoryFormat structure.
        static DECLSPEC_NOTHROW void STDMETHODCALLTYPE Release(
            _In_ DkmImageDebugDirectoryFormat* pItem
            )
        {
            // structure requires no cleanup
        }
    };

    // Value of a calculated MD5 hash. MD5 hashes are used for the document checksum feature,
    // which is a non-security purpose. MD5 should no longer be used for any security related
    // purpose.
    struct DECLSPEC_UUID("9804843a-3774-8a13-087b-dc688a492af9") DkmMD5HashValue
    {
        // First 32-bits of the calculated hash.
        UINT32 Value0;

        // Second 32-bits of the calculated hash.
        UINT32 Value1;

        // Third 32-bits of the calculated hash.
        UINT32 Value2;

        // Forth 32-bits of the calculated hash.
        UINT32 Value3;

        // Compare an instance of the DkmMD5HashValue struct to another instance.
        // Return value is as follows:
        // Less than zero:     This instance is less than 'other'.
        // Zero:               This instance is equal to 'other'.
        // Greater than zero:  This instance is greater than 'other'.
        DECLSPEC_NOTHROW int STDMETHODCALLTYPE CompareTo(
            const DkmMD5HashValue& other
            ) const;

        bool operator==(const DkmMD5HashValue& rhs) const     { return CompareTo(rhs) == 0; }
        bool operator!=(const DkmMD5HashValue& rhs) const     { return CompareTo(rhs) != 0; }
        bool operator> (const DkmMD5HashValue& rhs) const     { return CompareTo(rhs) > 0;  }
        bool operator< (const DkmMD5HashValue& rhs) const     { return CompareTo(rhs) < 0;  }
        bool operator>=(const DkmMD5HashValue& rhs) const     { return CompareTo(rhs) >= 0; }
        bool operator<=(const DkmMD5HashValue& rhs) const     { return CompareTo(rhs) <= 0; }

        // Release all reference-counted fields within the DkmMD5HashValue structure.
        static DECLSPEC_NOTHROW void STDMETHODCALLTYPE Release(
            _In_ DkmMD5HashValue* pItem
            )
        {
            // structure requires no cleanup
        }
    };

    // Value of a calculated SHA-1 hash. SHA-1 hashes are used for the document checksum
    // feature, which is a non-security purpose. SHA-1 should no longer be used for any
    // security related purpose.
    struct DECLSPEC_UUID("db7a1f38-cb63-d4c8-70aa-b52af7e0b9ed") DkmSHA1HashValue
    {
        // First 32-bits of the calculated hash.
        UINT32 Value0;

        // Second 32-bits of the calculated hash.
        UINT32 Value1;

        // Third 32-bits of the calculated hash.
        UINT32 Value2;

        // Forth 32-bits of the calculated hash.
        UINT32 Value3;

        // Fifth 32-bits of the calculated hash.
        UINT32 Value4;

        // Compare an instance of the DkmSHA1HashValue struct to another instance.
        // Return value is as follows:
        // Less than zero:     This instance is less than 'other'.
        // Zero:               This instance is equal to 'other'.
        // Greater than zero:  This instance is greater than 'other'.
        DECLSPEC_NOTHROW int STDMETHODCALLTYPE CompareTo(
            const DkmSHA1HashValue& other
            ) const;

        bool operator==(const DkmSHA1HashValue& rhs) const     { return CompareTo(rhs) == 0; }
        bool operator!=(const DkmSHA1HashValue& rhs) const     { return CompareTo(rhs) != 0; }
        bool operator> (const DkmSHA1HashValue& rhs) const     { return CompareTo(rhs) > 0;  }
        bool operator< (const DkmSHA1HashValue& rhs) const     { return CompareTo(rhs) < 0;  }
        bool operator>=(const DkmSHA1HashValue& rhs) const     { return CompareTo(rhs) >= 0; }
        bool operator<=(const DkmSHA1HashValue& rhs) const     { return CompareTo(rhs) <= 0; }

        // Release all reference-counted fields within the DkmSHA1HashValue structure.
        static DECLSPEC_NOTHROW void STDMETHODCALLTYPE Release(
            _In_ DkmSHA1HashValue* pItem
            )
        {
            // structure requires no cleanup
        }
    };

    // Guid pair used to uniquely identify a particular DkmModule instance.
    struct DECLSPEC_UUID("67e8ae96-fe88-e528-5190-458bd95dd9f2") DkmModuleId
    {
        // Module version Identifier from the symbol file. This uniquely identifies the
        // symbol file. For Microsoft C++ or Microsoft .NET Framework binaries, this is a
        // unique value which is embedded in an exe/dll by linkers/compilers when the dll/exe
        // is built. A new value is generated each time that the dll/exe is compiled.
        GUID Mvid;

        // Identifies the symbol provider (and therefore symbol format) used to examine these
        // symbols.
        GUID SymbolProvider;

        // Compare an instance of the DkmModuleId struct to another instance.
        // Return value is as follows:
        // Less than zero:     This instance is less than 'other'.
        // Zero:               This instance is equal to 'other'.
        // Greater than zero:  This instance is greater than 'other'.
        DECLSPEC_NOTHROW int STDMETHODCALLTYPE CompareTo(
            const DkmModuleId& other
            ) const;

        bool operator==(const DkmModuleId& rhs) const     { return CompareTo(rhs) == 0; }
        bool operator!=(const DkmModuleId& rhs) const     { return CompareTo(rhs) != 0; }
        bool operator> (const DkmModuleId& rhs) const     { return CompareTo(rhs) > 0;  }
        bool operator< (const DkmModuleId& rhs) const     { return CompareTo(rhs) < 0;  }
        bool operator>=(const DkmModuleId& rhs) const     { return CompareTo(rhs) >= 0; }
        bool operator<=(const DkmModuleId& rhs) const     { return CompareTo(rhs) <= 0; }

        // Release all reference-counted fields within the DkmModuleId structure.
        static DECLSPEC_NOTHROW void STDMETHODCALLTYPE Release(
            _In_ DkmModuleId* pItem
            )
        {
            // structure requires no cleanup
        }
    };

    // The start/end line/column ranges for a contiguous span of text.
    struct DECLSPEC_UUID("5196533e-11e8-53b0-6620-ba454830e33b") DkmTextSpan
    {
        // 1-based integer for the starting source line.
        UINT32 StartLine;

        // 1-based integer for the ending source column.
        UINT32 EndLine;

        // 1-based integer for the starting source column. If column information is missing
        // (ex: language service doesn't support it), this value should be set to 0.
        UINT32 StartColumn;

        // 1-based integer for the ending source column. If column information is missing
        // (ex: language service doesn't support it), this value should be set to 0.
        UINT32 EndColumn;

        // Compare an instance of the DkmTextSpan struct to another instance.
        // Return value is as follows:
        // Less than zero:     This instance is less than 'other'.
        // Zero:               This instance is equal to 'other'.
        // Greater than zero:  This instance is greater than 'other'.
        DECLSPEC_NOTHROW int STDMETHODCALLTYPE CompareTo(
            const DkmTextSpan& other
            ) const;

        bool operator==(const DkmTextSpan& rhs) const     { return CompareTo(rhs) == 0; }
        bool operator!=(const DkmTextSpan& rhs) const     { return CompareTo(rhs) != 0; }
        bool operator> (const DkmTextSpan& rhs) const     { return CompareTo(rhs) > 0;  }
        bool operator< (const DkmTextSpan& rhs) const     { return CompareTo(rhs) < 0;  }
        bool operator>=(const DkmTextSpan& rhs) const     { return CompareTo(rhs) >= 0; }
        bool operator<=(const DkmTextSpan& rhs) const     { return CompareTo(rhs) <= 0; }

        // Release all reference-counted fields within the DkmTextSpan structure.
        static DECLSPEC_NOTHROW void STDMETHODCALLTYPE Release(
            _In_ DkmTextSpan* pItem
            )
        {
            // structure requires no cleanup
        }
    };

    // DkmCodeViewCompilerId is used to translate information that is within the S_COMPILE*
    // code view records into a DkmCompilerId. This allows the debugger to load an
    // appropriate expression evaluator for a stack frame. Symbol providers may obtain this
    // collection through DkmEngineSettings. Expression evaluators may add additional entries
    // to this collection by having their setup add sub key(s) to the
    // '%VSRegistryRoot%\Debugger\CodeView Compilers' registry key.
    struct DECLSPEC_UUID("a47cc33b-5978-a1cb-c006-c1869c6778f0") DkmCodeViewCompilerId
    {
        // Language enumeration value which is in the code view record. For example,
        // CV_CFL_CXX is used for C++.
        BYTE LanguageEnumeration;

        // Name string within the code view record. '*' may be used to match against any name
        // string.
        DkmString* pCompilerName;

        // CompilerId (Vendor/Language Guid pair) to map the LanguageEnumeration/CompilerName
        // to.
        Evaluation::DkmCompilerId CompilerId;

        // Release all reference-counted fields within the DkmCodeViewCompilerId structure.
        static DECLSPEC_NOTHROW void STDMETHODCALLTYPE Release(
            _In_ DkmCodeViewCompilerId* pItem
            );
    };

    // An RVA and size pair representing a symbol returned from DkmModule GetFunctionInfo.
    struct DECLSPEC_UUID("dbeefc90-b141-1a6e-1b47-7b4cd20f6fba") DkmRVASizePair
    {
        // The relative virtual address of a symbol.
        UINT32 RVA;

        // The size of a symbol.
        UINT32 Size;

        // Release all reference-counted fields within the DkmRVASizePair structure.
        static DECLSPEC_NOTHROW void STDMETHODCALLTYPE Release(
            _In_ DkmRVASizePair* pItem
            )
        {
            // structure requires no cleanup
        }
    };

    // A offset/size pair which is returned from the symbol provider to a debug monitor to
    // indicate a range of instructions which the debugger should not stop at.
    struct DECLSPEC_UUID("1707052e-b14e-90df-d96a-82807318f017") DkmSteppingRange
    {
        // The start of a stepping range. The meaning is dependant on the the underlying
        // runtime being stepped. For MSIL, this in the beginning IL offset relative to the
        // start of the method. For native code, this is an RVA.
        UINT32 StartOffset;

        // The length of a stepping range. The meaning is dependant on the the underlying
        // runtime being stepped. For both native code and MSIL, this is a byte count of the
        // number of instructions in the range. For MSIL, UInt32.MaxValue is used to indicate
        // that the range should extend to the end of the method.
        UINT32 Length;

        // The source line number of the stepping range. The meaning is dependant on the the
        // underlying runtime being stepped. For both native code and MSIL, this is the
        // source line number of instructions in the range. For MSIL, UInt32.MaxValue is used
        // to indicate that the range should extend to the end of the method.
        UINT32 LineNumber;

        // Release all reference-counted fields within the DkmSteppingRange structure.
        static DECLSPEC_NOTHROW void STDMETHODCALLTYPE Release(
            _In_ DkmSteppingRange* pItem
            )
        {
            // structure requires no cleanup
        }
    };

    // Indicates how strong of a match there was between the DkmDocumentQuery and the
    // resulting DkmResolvedDocument.
    DEFINE_SCOPED_ENUM(DkmDocumentMatchStrength)
    {
        // Document matched on file name and extension, but not on any part of the path, or
        // on checksum.
        FileName = 0,
        // Document matched on file name and at least one level of directory name, but not
        // the full path nor the checksum.
        SubPath = 1,
        // Document matched on full path but not on checksum.
        FullPath = 2,
        // Document matched on checksum value in addition to at least a filename match.
        Checksum = 3,
        // Input path represented a URL for a dynamic document and the resulting document
        // exactly matched this query. This value is currently never returned from the
        // Microsoft PDB symbol provider but is reserved for future use.
        ExactURL = 4
    };

    // Contains the symbol path collection and the cache path.
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("1e0ac5bb-9169-359d-7689-c1407b244f62") DkmEngineSymbolSettings : public IUnknown
    {
        private: ___ReferenceCount_t m_ReferenceCount;
        private: DkmDispatcherObjectFlags_t m_ObjectFlags;
        private: const GUID* m_pTypeId;
        private: size_t m_ObjectGCHandle;
        // Use DkmEngineSymbolSettings::Create to create this object
        private: DkmEngineSymbolSettings();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmEngineSymbolSettings();
        // This object cannot be copied
        private: DkmEngineSymbolSettings& operator=(const DkmEngineSymbolSettings&);
        private: DkmEngineSymbolSettings(const DkmEngineSymbolSettings&);

        private: DkmReadOnlyCollection<DkmString*>* const m_pSymbolPaths;
        private: DkmString* const m_pSymbolCachePath;
        private: DkmReadOnlyCollection<DkmString*>* const m_pIncludeList;
        private: DkmReadOnlyCollection<DkmString*>* const m_pExcludeList;
        private: const bool m_ManualLoading;
        private: const bool m_LoadAdjacentSymbols;
        private: void* m__pExtendedData;

        // A collection of the paths to search for symbols.
        public: _Ret_ DECLSPEC_NOTHROW DkmReadOnlyCollection<DkmString*>* STDMETHODCALLTYPE SymbolPaths(
            );

        // The path of the symbol cache.
        public: _Ret_ DECLSPEC_NOTHROW DkmString* STDMETHODCALLTYPE SymbolCachePath(
            );

        // A collection of modules to include when manual symbol loading is enabled.
        public: _Ret_ DECLSPEC_NOTHROW DkmReadOnlyCollection<DkmString*>* STDMETHODCALLTYPE IncludeList(
            );

        // A collection of modules to exclude when automatic symbol loading is enabled.
        public: _Ret_ DECLSPEC_NOTHROW DkmReadOnlyCollection<DkmString*>* STDMETHODCALLTYPE ExcludeList(
            );

        // True if manual symbol loading is enabled. False otherwise.
        public: DECLSPEC_NOTHROW bool STDMETHODCALLTYPE ManualLoading(
            );

        // True if all symbols adjacent to the matching module or at the path specified in
        // the binary should be loaded regardless of include/exclude status.
        public: DECLSPEC_NOTHROW bool STDMETHODCALLTYPE LoadAdjacentSymbols(
            );

        /// <summary>
        /// Create a new DkmEngineSymbolSettings object instance.
        /// </summary>
        /// <param name="pSymbolPaths">
        /// [In] A collection of the paths to search for symbols.
        /// </param>
        /// <param name="pSymbolCachePath">
        /// [In] The path of the symbol cache.
        /// </param>
        /// <param name="pIncludeList">
        /// [In] A collection of modules to include when manual symbol loading is enabled.
        /// </param>
        /// <param name="pExcludeList">
        /// [In] A collection of modules to exclude when automatic symbol loading is enabled.
        /// </param>
        /// <param name="ManualLoading">
        /// [In] True if manual symbol loading is enabled. False otherwise.
        /// </param>
        /// <param name="LoadAdjacentSymbols">
        /// [In] True if all symbols adjacent to the matching module or at the path specified
        /// in the binary should be loaded regardless of include/exclude status.
        /// </param>
        /// <param name="ppCreatedObject">
        /// [Out] Result of this method call.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ DkmReadOnlyCollection<DkmString*>* pSymbolPaths,
            _In_ DkmString* pSymbolCachePath,
            _In_ DkmReadOnlyCollection<DkmString*>* pIncludeList,
            _In_ DkmReadOnlyCollection<DkmString*>* pExcludeList,
            _In_ bool ManualLoading,
            _In_ bool LoadAdjacentSymbols,
            _Deref_out_ Symbols::DkmEngineSymbolSettings** ppCreatedObject
            );
    }; // end of DkmEngineSymbolSettings

    // Result of an asynchronous DkmModule.FindDocuments call.
    struct DkmFindDocumentsAsyncResult
    {
        // HRESULT code returned from the caller. This will be
        // DkmExceptionCode.COR_E_OPERATIONCANCELED (0x8013153B) if the operation was
        // canceled before processing was complete.
        HRESULT ErrorCode;

        // [Optional] A collection of the documents that matched the query.
        DkmArray<Symbols::DkmResolvedDocument*> Documents;
    };

    // Result of an asynchronous DkmResolvedDocument.FindSymbols call.
    struct DkmFindSymbolsAsyncResult
    {
        // HRESULT code returned from the caller. This will be
        // DkmExceptionCode.COR_E_OPERATIONCANCELED (0x8013153B) if the operation was
        // canceled before processing was complete. E_TEXT_SPAN_NOT_LOADED indicates that
        // TextSpan is not currently loaded in the specified script document.
        // E_SCRIPT_SPAN_MAPPING_FAILED indicates that TextSpan could not be mapped to a
        // location in the specified script document. E_SCRIPT_FILE_DIFFERENT_CONTENT
        // indicates that the content in the script file loaded by the target process doesn't
        // match the provided Text.
        HRESULT ErrorCode;

        // [Optional] The found instruction symbols which are within the specified text span.
        DkmArray<Symbols::DkmInstructionSymbol*> InstructionSymbols;

        // [Optional] The source location of each returned instruction symbol. The length of
        // this array should be the same of the returned instruction symbol array.
        DkmArray<Symbols::DkmSourcePosition*> SymbolLocation;
    };

    // Result of an asynchronous DkmModule.GetFunctionInfo call.
    struct DkmGetFunctionInfoAsyncResult
    {
        // HRESULT code returned from the caller. This will be
        // DkmExceptionCode.COR_E_OPERATIONCANCELED (0x8013153B) if the operation was
        // canceled before processing was complete.
        HRESULT ErrorCode;

        // The RVA / size pairs from the query.
        DkmArray<Symbols::DkmRVASizePair> Results;
    };

    // Result of an asynchronous DkmModule.GetMethodSymbolStoreData call.
    struct DkmGetMethodSymbolStoreDataAsyncResult
    {
        // HRESULT code returned from the caller. This will be
        // DkmExceptionCode.COR_E_OPERATIONCANCELED (0x8013153B) if the operation was
        // canceled before processing was complete.
        HRESULT ErrorCode;

        // DkmClrMethodScopeData[] describes a scope within a method. These are defined using
        // ISymUnmanagedWriter::OpenScope/CloseScope.
        DkmArray<Clr::DkmClrMethodScopeData> Scopes;
    };

    // Result of an asynchronous DkmModule.GetMethodSymbolStoreDataPreRemap call.
    struct DkmGetMethodSymbolStoreDataPreRemapAsyncResult
    {
        // HRESULT code returned from the caller. This will be
        // DkmExceptionCode.COR_E_OPERATIONCANCELED (0x8013153B) if the operation was
        // canceled before processing was complete.
        HRESULT ErrorCode;

        // Method token after the Remap.
        UINT32 RemapToken;

        // DkmClrMethodScopeData[] describes a scope within a method. These are defined using
        // ISymUnmanagedWriter::OpenScope/CloseScope.
        DkmArray<Clr::DkmClrMethodScopeData> Scopes;
    };

    // Result of an asynchronous DkmInstructionSymbol.GetSourcePosition call.
    struct DkmGetSourcePositionAsyncResult
    {
        // HRESULT code returned from the caller. This will be
        // DkmExceptionCode.COR_E_OPERATIONCANCELED (0x8013153B) if the operation was
        // canceled before processing was complete.
        HRESULT ErrorCode;

        // True if this address is the first address in the line's range. False otherwise.
        bool StartOfLine;

        // [Optional] Source code position which corresponds to a code element. The could
        // represent a location which has been extracted from a symbol (PDB) file, or it
        // could be the location of a breakpoint in the IDE.
        OPTIONAL Symbols::DkmSourcePosition* pSourcePosition;
    };

    // Result of an asynchronous DkmInstructionSymbol.GetSourcePositionCallback call.
    struct DkmGetSourcePositionCallbackAsyncResult
    {
        // HRESULT code returned from the caller. This will be
        // DkmExceptionCode.COR_E_OPERATIONCANCELED (0x8013153B) if the operation was
        // canceled before processing was complete.
        HRESULT ErrorCode;

        // True if this address is the first address in the line's range. False otherwise.
        bool StartOfLine;

        // [Optional] Source code position which corresponds to a code element. The could
        // represent a location which has been extracted from a symbol (PDB) file, or it
        // could be the location of a breakpoint in the IDE.
        OPTIONAL Symbols::DkmSourcePosition* pSourcePosition;
    };

    // Result of an asynchronous DkmModule.GetTokenSymbolStoreAttribute call.
    struct DkmGetTokenSymbolStoreAttributeAsyncResult
    {
        // HRESULT code returned from the caller. This will be
        // DkmExceptionCode.COR_E_OPERATIONCANCELED (0x8013153B) if the operation was
        // canceled before processing was complete.
        HRESULT ErrorCode;

        // The value of the requested symbol store attribute. This will be an empty array if
        // the specified attribute name cannot be found.
        DkmArray<BYTE> Data;
    };

    // Result of an asynchronous DkmInstructionSymbol.GetUserCodeSourcePositionCallback call.
    struct DkmGetUserCodeSourcePositionCallbackAsyncResult
    {
        // HRESULT code returned from the caller. This will be
        // DkmExceptionCode.COR_E_OPERATIONCANCELED (0x8013153B) if the operation was
        // canceled before processing was complete.
        HRESULT ErrorCode;

        // [Optional] Source code position which corresponds to a code element. The could
        // represent a location which has been extracted from a symbol (PDB) file, or it
        // could be the location of a breakpoint in the IDE.
        OPTIONAL Symbols::DkmSourcePosition* pSourcePosition;
    };

    // Result of an asynchronous DkmInstructionSymbol.HasLineInfo call.
    struct DkmHasLineInfoAsyncResult
    {
        // HRESULT code returned from the caller. This will be
        // DkmExceptionCode.COR_E_OPERATIONCANCELED (0x8013153B) if the operation was
        // canceled before processing was complete.
        HRESULT ErrorCode;

        // True if there is line info for this location.
        bool Result;
    };

    // DkmInstructionSymbol represents a method in the target process.
    //
    // Derived classes: DkmClrInstructionSymbol, DkmClrNcInstructionSymbol,
    // DkmCustomInstructionSymbol, DkmNativeInstructionSymbol, DkmScriptInstructionSymbol
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("c55d7b4d-246f-0e5a-e37e-c9d9f2d996c6") DkmInstructionSymbol : public IUnknown
    {
        private: ___ReferenceCount_t m_ReferenceCount;
        private: DkmDispatcherObjectFlags_t m_ObjectFlags;
        private: const GUID* m_pTypeId;
        private: size_t m_ObjectGCHandle;
        // Use DkmInstructionSymbol::Create to create this object
        private: DkmInstructionSymbol();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmInstructionSymbol();
        // This object cannot be copied
        private: DkmInstructionSymbol& operator=(const DkmInstructionSymbol&);
        private: DkmInstructionSymbol(const DkmInstructionSymbol&);

        // DkmInstructionSymbol is an abstract base class. This enum indicates which derived
        // class this object is an instance of.
        public: FORWARD_DECLARE_SCOPED_ENUM(Tag);
        DEFINE_SCOPED_ENUM(Tag)
        {
        // Object is an instance of 'DkmNativeInstructionSymbol'.
        NativeInstruction = 0,
        // Object is an instance of 'DkmClrInstructionSymbol'.
        ClrInstruction = 1,
        // Object is an instance of 'DkmScriptInstructionSymbol'.
        ScriptInstruction = 2,
        // Object is an instance of 'DkmCustomInstructionSymbol'.
        CustomInstruction = 3
        };

        private: const Tag_t m_TagValue;
        private: Symbols::DkmModule* const m_pModule;
        private: const GUID m_RuntimeType;
        private: void* m__pExtendedData;

        // DkmInstructionSymbol is an abstract base class. This enum indicates which derived
        // class this object is an instance of.
        public: DECLSPEC_NOTHROW Tag_t STDMETHODCALLTYPE TagValue(
            );

        // The DkmModule class represents a code bundle (ex: dll or exe) which is or once was
        // loaded into one or more processes. The DkmModule class is the central object to
        // the symbol APIs, and is 1:1 with the symbol handler's notation of what is loaded.
        // If a code bundle loads into three different processes (or the same process but
        // with three different base addresses or three different app domains) but the symbol
        // handler thinks of all of these as being identical, there will be only one module
        // object.
        public: _Ret_ DECLSPEC_NOTHROW Symbols::DkmModule* STDMETHODCALLTYPE Module(
            );

        // The Runtime Id identifies the execution environment for a particular piece of
        // code. Runtime Ids are used by the dispatcher to decide which monitor to dispatch
        // to. Note that the ordering of the runtime ID Guids is somewhat significant as this
        // dictates which runtime gets the first shot during arbitration. Thus, if one wants
        // to declare a new runtime instance which is built on the CLR, the runtime id should
        // be less than DkmRuntimeId.Clr.
        public: DECLSPEC_NOTHROW const GUID& STDMETHODCALLTYPE RuntimeType(
            );

        /// <summary>
        /// Binds an instruction symbol to a particular module instance. An instruction
        /// symbol is connected to a DkmModule rather than a DkmModuleInstance, so it is not
        /// bound to a particular process, app domain, or module base address.
        /// </summary>
        /// <param name="pModuleInstance">
        /// [In] The Module Instance class represent a code bundle (ex: dll or exe) which is
        /// loaded into a particular process at a particular location. Module Instance
        /// objects are 1:1 with the execution environment's notion of a code bundle. For
        /// example, in native code, Module Instance objects are 1:1 with base address.
        /// </param>
        /// <param name="ppAddress">
        /// [Out] Abstract representation of an executable code location (ex: EIP value). If
        /// resolved, an Instruction Address will be within a particular module instance. An
        /// Instruction Address is always within a particular Runtime Instance.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Bind(
            _In_ DkmModuleInstance* pModuleInstance,
            _Deref_out_ DkmInstructionAddress** ppAddress
            );

        /// <summary>
        /// This method returns address information to the GPU debug monitor.
        /// </summary>
        /// <param name="pInstructionAddress">
        /// [In,Optional] Abstract representation of an executable code location (ex: EIP
        /// value). If resolved, an Instruction Address will be within a particular module
        /// instance. An Instruction Address is always within a particular Runtime Instance.
        /// </param>
        /// <param name="pNextInstruction">
        /// [In] The next instruction address which is used to determine inline function
        /// call.
        /// </param>
        /// <param name="pMetadata">
        /// [Out,Optional] The address type information.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetGPUInstructionMetadataCallback(
            _In_opt_ DkmInstructionAddress* pInstructionAddress,
            _In_ Symbols::DkmInstructionSymbol* pNextInstruction,
            _Out_ GPU::DkmGPUAddressType_t* pMetadata
            );

        /// <summary>
        /// Queries the symbol provider to determine the ranges of instructions which do not
        /// correspond to any user source statements and are used by the base debug monitor
        /// to always step through during stepping.
        /// </summary>
        /// <param name="pRanges">
        /// [Out] Array of no source ranges to always step through. This array will be empty
        /// if there are no no-source ranges for the given instruction.
        ///
        /// The memory for the DkmArray members is allocated by the method implementation
        /// using DkmAllocBytes/DkmAllocArray. It is freed by the caller using the
        /// CAutoDkmArray template or with DkmFreeMemory and manual element release.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetNoSourceRanges(
            _Out_ DkmArray<Symbols::DkmSteppingRange>* pRanges
            );

        #ifndef EXCLUDE_MONITOR_ONLY_APIS
        /// <summary>
        /// Returns the source file position (ex: example.cs, line 12) of this instruction
        /// symbol. If this instruction symbol is not associated with a source file or not in
        /// user code then null is returned (E_INSTRUCTION_NO_SOURCE return code).
        ///
        /// Location constraint: API must be called from a Monitor component (component level
        /// &lt; 100,000).
        /// </summary>
        /// <param name="pInspectionSession">
        /// [In,Optional] A reference object describing the current inspection session.
        /// Common usage is for symbol providers to cache lookups using its data container.
        /// </param>
        /// <param name="ppSourcePosition">
        /// [Out,Optional] Source code position which corresponds to a code element. The
        /// could represent a location which has been extracted from a symbol (PDB) file, or
        /// it could be the location of a breakpoint in the IDE.
        /// </param>
        /// <returns>
        /// S_OK is returned if *ppSourcePosition is non-NULL, S_FALSE is returned when
        /// *ppSourcePosition is NULL, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetUserCodeSourcePositionCallback(
            _In_opt_ Evaluation::DkmInspectionSession* pInspectionSession,
            _Deref_out_opt_ Symbols::DkmSourcePosition** ppSourcePosition
            );
        #endif // #ifndef EXCLUDE_MONITOR_ONLY_APIS

        #ifndef EXCLUDE_MONITOR_ONLY_APIS
        /// <summary>
        /// Returns the source file position (ex: example.cs, line 12) of this instruction
        /// symbol. If this instruction symbol is not associated with a source file or not in
        /// user code then null is returned (E_INSTRUCTION_NO_SOURCE return code).
        ///
        /// This method will append a new work item to the specified work list, and return
        /// once the work item has been appended. The actual processing of the work item is
        /// asynchronous. The caller will be notified that the request is complete through
        /// the completion routine.
        ///
        /// Location constraint: API must be called from a Monitor component (component level
        /// &lt; 100,000).
        /// </summary>
        /// <param name="pWorkList">
        /// WorkList to append the new work item to.
        /// </param>
        /// <param name="pInspectionSession">
        /// [In,Optional] A reference object describing the current inspection session.
        /// Common usage is for symbol providers to cache lookups using its data container.
        /// </param>
        /// <param name="pCompletionRoutine">
        /// Routine to fire when the request is complete. If the request is successfully
        /// appended to the work list, this will always fire (including when the operation is
        /// canceled). This will never fire if appending the work item fails.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetUserCodeSourcePositionCallback(
            _In_ DkmWorkList* pWorkList,
            _In_opt_ Evaluation::DkmInspectionSession* pInspectionSession,
            _In_ IDkmCompletionRoutine<Symbols::DkmGetUserCodeSourcePositionCallbackAsyncResult>* pCompletionRoutine
            );
        #endif // #ifndef EXCLUDE_MONITOR_ONLY_APIS

        #ifndef EXCLUDE_IDE_ONLY_APIS
        /// <summary>
        /// Return the name of the symbol as it should appear in the disassembly window. For
        /// Microsoft C++ code, this is based on the public symbol name.
        ///
        /// Location constraint: API must be called from an IDE component (component level
        /// &gt; 100,000).
        /// </summary>
        /// <param name="pInspectionSession">
        /// [In,Optional] A reference object describing the current inspection session.
        /// Common usage is for symbol providers to cache lookups using its data container.
        /// </param>
        /// <param name="ppLabel">
        /// [Out,Optional] The label to use for this instruction.
        /// </param>
        /// <returns>
        /// S_OK is returned if *ppLabel is non-NULL, S_FALSE is returned when *ppLabel is
        /// NULL, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetDisassemblyLabel(
            _In_opt_ Evaluation::DkmInspectionSession* pInspectionSession,
            _Deref_out_opt_ DkmString** ppLabel
            );
        #endif // #ifndef EXCLUDE_IDE_ONLY_APIS

        /// <summary>
        /// Returns the compiler id (LanguageId/VendorId) of a given symbol.
        ///
        /// For the Microsoft PDB reader, if the PDB was created by a compiler which used
        /// ISymUnmanagedWriter, then the PDB reader will be able to determine the correct
        /// DkmCompilerId from the LanguageId/VendorId pair passed from
        /// ISymUnmanagedWriter.DefineDocument.
        ///
        /// If the PDB was created by a compiler which did not use ISymUnmanagedWriter, the
        /// PDB reader may be able to obtain the DkmCompilerId from the S_COMPILE* PDB
        /// records. For this to work, the compiler must first emit the S_COMPILE* record for
        /// each compiland. The compiler needs to be sure to correctly fill out the language
        /// enumeration value, and the compiler string. The compiler should ensure that the
        /// compiler string is sufficiently specific to use for selecting an expression
        /// evaluator; it is recommended to include a company name. After emitting the
        /// Enum/Name pair, the setup for the expression evaluator should then register this
        /// pair with the debugger. To do so, the expression evaluator should set this
        /// registry key: %VSRegistryRoot%\Debugger\CodeView
        /// Compilers\%CodeViewLanguageCode%:%CompilerName% and define the
        /// VendorId/LanguageId.
        /// </summary>
        /// <param name="pInspectionSession">
        /// [In,Optional] A reference object describing the current inspection session.
        /// Common usage is for symbol providers to cache lookups using its data container.
        /// </param>
        /// <param name="pCompilerId">
        /// [Out] LanguageId/VendorId for the compiler which produced the code for this
        /// symbol. If this is unknown (ex: no symbols info for this block), both values will
        /// be Guid.Empty. Otherwise, both values should be non-zero.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetCompilerId(
            _In_opt_ Evaluation::DkmInspectionSession* pInspectionSession,
            _Out_ Evaluation::DkmCompilerId* pCompilerId
            );

        #ifndef EXCLUDE_IDE_ONLY_APIS
        /// <summary>
        /// Returns if this instruction symbol is in hidden code. For instance, in managed
        /// code, the line number 0xfeefee marks a source line as hidden.
        ///
        /// This method will append a new work item to the specified work list, and return
        /// once the work item has been appended. The actual processing of the work item is
        /// asynchronous. The caller will be notified that the request is complete through
        /// the completion routine.
        ///
        /// Location constraint: API must be called from an IDE component (component level
        /// &gt; 100,000).
        /// </summary>
        /// <param name="pWorkList">
        /// WorkList to append the new work item to.
        /// </param>
        /// <param name="pInspectionSession">
        /// [In] DkmInspectionSession allows the various components which inspect data to
        /// store private data which is associated with a group of evaluations.
        /// </param>
        /// <param name="pInstructionAddress">
        /// [In] Abstract representation of an executable code location (ex: EIP value). If
        /// resolved, an Instruction Address will be within a particular module instance. An
        /// Instruction Address is always within a particular Runtime Instance.
        /// </param>
        /// <param name="pCompletionRoutine">
        /// Routine to fire when the request is complete. If the request is successfully
        /// appended to the work list, this will always fire (including when the operation is
        /// canceled). This will never fire if appending the work item fails.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE IsHiddenCode(
            _In_ DkmWorkList* pWorkList,
            _In_ Evaluation::DkmInspectionSession* pInspectionSession,
            _In_ DkmInstructionAddress* pInstructionAddress,
            _In_ IDkmCompletionRoutine<Symbols::DkmIsHiddenCodeAsyncResult>* pCompletionRoutine
            );
        #endif // #ifndef EXCLUDE_IDE_ONLY_APIS

        #ifndef EXCLUDE_MONITOR_ONLY_APIS
        /// <summary>
        /// Queries the symbol provider to determine the ranges of instructions which the
        /// base debug monitor should step through to implement a step.
        ///
        /// Location constraint: API must be called from a Monitor component (component level
        /// &lt; 100,000).
        /// </summary>
        /// <param name="RangeBoundary">
        /// [In] Indicates to the symbol provider the type of instructions to include in the
        /// 'no-step' regions.
        /// </param>
        /// <param name="IncludeInline">
        /// [In] True if the symbol provider should stop the stepping range when it
        /// encounters an inline functions. False otherwise. The Native DM will pass true for
        /// a step in so steps will stop in inline functions. It will pass false when doing a
        /// step-over so the stepper will not stop in inline functions.
        /// </param>
        /// <param name="pRanges">
        /// [Out] Array of ranges to step through. This array will be empty if there is no
        /// source information for the given instruction.
        ///
        /// The memory for the DkmArray members is allocated by the method implementation
        /// using DkmAllocBytes/DkmAllocArray. It is freed by the caller using the
        /// CAutoDkmArray template or with DkmFreeMemory and manual element release.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetSteppingRanges(
            _In_ Symbols::DkmSteppingRangeBoundary_t RangeBoundary,
            _In_ bool IncludeInline,
            _Out_ DkmArray<Symbols::DkmSteppingRange>* pRanges
            );
        #endif // #ifndef EXCLUDE_MONITOR_ONLY_APIS

        /// <summary>
        /// Queries the symbol provider to determine if we have line info. Used by debug
        /// monitor to decide if location can be considered user code.
        ///
        /// Location constraint: For ordinary symbols, can be called from any component.  For
        /// dynamic symbols, can only be called on the server side.
        /// </summary>
        /// <param name="pResult">
        /// [Out] True if there is line info for this location.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE HasLineInfo(
            _Out_ bool* pResult
            );

        /// <summary>
        /// Queries the symbol provider to determine if we have line info. Used by debug
        /// monitor to decide if location can be considered user code.
        ///
        /// This method will append a new work item to the specified work list, and return
        /// once the work item has been appended. The actual processing of the work item is
        /// asynchronous. The caller will be notified that the request is complete through
        /// the completion routine.
        ///
        /// Location constraint: For ordinary symbols, can be called from any component.  For
        /// dynamic symbols, can only be called on the server side.
        /// </summary>
        /// <param name="pWorkList">
        /// WorkList to append the new work item to.
        /// </param>
        /// <param name="pCompletionRoutine">
        /// Routine to fire when the request is complete. If the request is successfully
        /// appended to the work list, this will always fire (including when the operation is
        /// canceled). This will never fire if appending the work item fails.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE HasLineInfo(
            _In_ DkmWorkList* pWorkList,
            _In_ IDkmCompletionRoutine<Symbols::DkmHasLineInfoAsyncResult>* pCompletionRoutine
            );

        #ifndef EXCLUDE_MONITOR_ONLY_APIS
        /// <summary>
        /// This method returns the IL offset range that contains the current IL offset as
        /// specified in the instruction address.
        ///
        /// Location constraint: API must be called from a Monitor component (component level
        /// &lt; 100,000).
        /// </summary>
        /// <param name="pResult">
        /// [Out] A offset/size pair which is returned from the symbol provider to a debug
        /// monitor to indicate a range of instructions which the debugger should not stop
        /// at.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetCurrentStatementRange(
            _Out_ Symbols::DkmSteppingRange* pResult
            );
        #endif // #ifndef EXCLUDE_MONITOR_ONLY_APIS

        #ifndef EXCLUDE_IDE_ONLY_APIS
        /// <summary>
        /// Returns the source file position (ex: example.cs, line 12) of this instruction
        /// symbol. If this instruction symbol is not associated with a source file then null
        /// is returned (S_FALSE return code in native).
        ///
        /// Location constraint: API must be called from an IDE component (component level
        /// &gt; 100,000).
        /// </summary>
        /// <param name="Flags">
        /// [In] Flags which affect the behavior of 'GetSourcePosition'.
        /// </param>
        /// <param name="pInspectionSession">
        /// [In,Optional] A reference object describing the current inspection session.
        /// Common usage is for symbol providers to cache lookups using its data container.
        /// </param>
        /// <param name="pStartOfLine">
        /// [Out] True if this address is the first address in the line's range. False
        /// otherwise.
        /// </param>
        /// <param name="ppSourcePosition">
        /// [Out,Optional] Source code position which corresponds to a code element. The
        /// could represent a location which has been extracted from a symbol (PDB) file, or
        /// it could be the location of a breakpoint in the IDE.
        /// </param>
        /// <returns>
        /// S_OK is returned if *ppSourcePosition is non-NULL, S_FALSE is returned when
        /// *ppSourcePosition is NULL, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetSourcePosition(
            _In_ Symbols::DkmSourcePositionFlags_t Flags,
            _In_opt_ Evaluation::DkmInspectionSession* pInspectionSession,
            _Out_ bool* pStartOfLine,
            _Deref_out_opt_ Symbols::DkmSourcePosition** ppSourcePosition
            );
        #endif // #ifndef EXCLUDE_IDE_ONLY_APIS

        #ifndef EXCLUDE_IDE_ONLY_APIS
        /// <summary>
        /// Returns the source file position (ex: example.cs, line 12) of this instruction
        /// symbol. If this instruction symbol is not associated with a source file then null
        /// is returned (S_FALSE return code in native).
        ///
        /// This method will append a new work item to the specified work list, and return
        /// once the work item has been appended. The actual processing of the work item is
        /// asynchronous. The caller will be notified that the request is complete through
        /// the completion routine.
        ///
        /// Location constraint: API must be called from an IDE component (component level
        /// &gt; 100,000).
        /// </summary>
        /// <param name="pWorkList">
        /// WorkList to append the new work item to.
        /// </param>
        /// <param name="Flags">
        /// [In] Flags which affect the behavior of 'GetSourcePosition'.
        /// </param>
        /// <param name="pInspectionSession">
        /// [In,Optional] A reference object describing the current inspection session.
        /// Common usage is for symbol providers to cache lookups using its data container.
        /// </param>
        /// <param name="pCompletionRoutine">
        /// Routine to fire when the request is complete. If the request is successfully
        /// appended to the work list, this will always fire (including when the operation is
        /// canceled). This will never fire if appending the work item fails.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetSourcePosition(
            _In_ DkmWorkList* pWorkList,
            _In_ Symbols::DkmSourcePositionFlags_t Flags,
            _In_opt_ Evaluation::DkmInspectionSession* pInspectionSession,
            _In_ IDkmCompletionRoutine<Symbols::DkmGetSourcePositionAsyncResult>* pCompletionRoutine
            );
        #endif // #ifndef EXCLUDE_IDE_ONLY_APIS

        #ifndef EXCLUDE_MONITOR_ONLY_APIS
        /// <summary>
        /// Returns the source file position (ex: example.cs, line 12) of this instruction
        /// symbol. If this instruction symbol is not associated with a source file then null
        /// is returned (S_FALSE return code in native).
        ///
        /// Location constraint: API must be called from a Monitor component (component level
        /// &lt; 100,000).
        /// </summary>
        /// <param name="Flags">
        /// [In] Flags which affect the behavior of 'GetSourcePosition'.
        /// </param>
        /// <param name="pInspectionSession">
        /// [In,Optional] A reference object describing the current inspection session.
        /// Common usage is for symbol providers to cache lookups using its data container.
        /// </param>
        /// <param name="pStartOfLine">
        /// [Out] True if this address is the first address in the line's range. False
        /// otherwise.
        /// </param>
        /// <param name="ppSourcePosition">
        /// [Out,Optional] Source code position which corresponds to a code element. The
        /// could represent a location which has been extracted from a symbol (PDB) file, or
        /// it could be the location of a breakpoint in the IDE.
        /// </param>
        /// <returns>
        /// S_OK is returned if *ppSourcePosition is non-NULL, S_FALSE is returned when
        /// *ppSourcePosition is NULL, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetSourcePositionCallback(
            _In_ Symbols::DkmSourcePositionFlags_t Flags,
            _In_opt_ Evaluation::DkmInspectionSession* pInspectionSession,
            _Out_ bool* pStartOfLine,
            _Deref_out_opt_ Symbols::DkmSourcePosition** ppSourcePosition
            );
        #endif // #ifndef EXCLUDE_MONITOR_ONLY_APIS

        #ifndef EXCLUDE_MONITOR_ONLY_APIS
        /// <summary>
        /// Returns the source file position (ex: example.cs, line 12) of this instruction
        /// symbol. If this instruction symbol is not associated with a source file then null
        /// is returned (S_FALSE return code in native).
        ///
        /// This method will append a new work item to the specified work list, and return
        /// once the work item has been appended. The actual processing of the work item is
        /// asynchronous. The caller will be notified that the request is complete through
        /// the completion routine.
        ///
        /// Location constraint: API must be called from a Monitor component (component level
        /// &lt; 100,000).
        /// </summary>
        /// <param name="pWorkList">
        /// WorkList to append the new work item to.
        /// </param>
        /// <param name="Flags">
        /// [In] Flags which affect the behavior of 'GetSourcePosition'.
        /// </param>
        /// <param name="pInspectionSession">
        /// [In,Optional] A reference object describing the current inspection session.
        /// Common usage is for symbol providers to cache lookups using its data container.
        /// </param>
        /// <param name="pCompletionRoutine">
        /// Routine to fire when the request is complete. If the request is successfully
        /// appended to the work list, this will always fire (including when the operation is
        /// canceled). This will never fire if appending the work item fails.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetSourcePositionCallback(
            _In_ DkmWorkList* pWorkList,
            _In_ Symbols::DkmSourcePositionFlags_t Flags,
            _In_opt_ Evaluation::DkmInspectionSession* pInspectionSession,
            _In_ IDkmCompletionRoutine<Symbols::DkmGetSourcePositionCallbackAsyncResult>* pCompletionRoutine
            );
        #endif // #ifndef EXCLUDE_MONITOR_ONLY_APIS

        #ifndef EXCLUDE_IDE_ONLY_APIS
        /// <summary>
        /// Returns an alternate source file position (ex: example.cs, line 12) for this
        /// instruction symbol. This is currently used in source map scenarios to return the
        /// original (unmapped) source location. This API will be called by the debugger UI
        /// in cases where the primary source location cannot be found.
        ///
        /// Location constraint: API must be called from an IDE component (component level
        /// &gt; 100,000).
        ///
        /// This API was introduced in Visual Studio 12 Update 3 (DkmApiVersion.VS12Update3).
        /// </summary>
        /// <param name="Flags">
        /// [In] Flags which affect the behavior of 'GetSourcePosition'.
        /// </param>
        /// <param name="ppSourcePosition">
        /// [Out] Associated source location for the instruction.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error. Symbol
        /// provider doesn't support mapping this specified instruction to an alternate
        /// location.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetAlternateSourcePosition(
            _In_ Symbols::DkmSourcePositionFlags_t Flags,
            _Deref_out_ Symbols::DkmSourcePosition** ppSourcePosition
            );
        #endif // #ifndef EXCLUDE_IDE_ONLY_APIS
    }; // end of DkmInstructionSymbol

    // Result of an asynchronous DkmInstructionSymbol.IsHiddenCode call.
    struct DkmIsHiddenCodeAsyncResult
    {
        // HRESULT code returned from the caller. This will be
        // DkmExceptionCode.COR_E_OPERATIONCANCELED (0x8013153B) if the operation was
        // canceled before processing was complete.
        HRESULT ErrorCode;

        // Flags for DebuggerStepThrough DebuggerHidden, and/or DebuggerNonUserCode
        // attributes set on method or class or marked hidden due to the 0xfeefee sequence
        // point.
        Clr::DkmNonUserCodeFlags_t NonUserCodeFlags;

        // [Optional] The symbol for the next non-hidden source line. This is null if the
        // current line is not hidden.
        OPTIONAL Symbols::DkmInstructionSymbol* pNextLine;
    };

    // Result of an asynchronous DkmInstructionAddress.IsUserCode call.
    struct DkmIsUserCodeAsyncResult
    {
        // HRESULT code returned from the caller. This will be
        // DkmExceptionCode.COR_E_OPERATIONCANCELED (0x8013153B) if the operation was
        // canceled before processing was complete.
        HRESULT ErrorCode;

        // True if the provided instruction address is user code.
        bool UserCode;
    };

    // The DkmModule class represents a code bundle (ex: dll or exe) which is or once was
    // loaded into one or more processes. The DkmModule class is the central object to the
    // symbol APIs, and is 1:1 with the symbol handler's notation of what is loaded. If a
    // code bundle loads into three different processes (or the same process but with three
    // different base addresses or three different app domains) but the symbol handler thinks
    // of all of these as being identical, there will be only one module object.
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("9fdf7d9f-e5ab-b363-6282-1da170173343") DkmModule : public DkmDataContainer
    {
        // Use DkmModule::Create to create this object
        private: DkmModule();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmModule();
        // This object cannot be copied
        private: DkmModule& operator=(const DkmModule&);
        private: DkmModule(const DkmModule&);

        private: const Symbols::DkmModuleId m_Id;
        private: DkmString* const m_pName;
        private: const Evaluation::DkmCompilerId m_CompilerId;
        private: OPTIONAL DefaultPort::DkmTransportConnection* const m_pConnection;
        private: void* m__pExtendedData;
        private: void* m_pResolvedDocumentCollection0;
        private: void* m_pScriptDocumentCollection0;

        // Guid pair used to uniquely identify a particular DkmModule instance.
        public: DECLSPEC_NOTHROW const Symbols::DkmModuleId& STDMETHODCALLTYPE Id(
            );

        // Name of the module.
        public: _Ret_ DECLSPEC_NOTHROW DkmString* STDMETHODCALLTYPE Name(
            );

        // LanguageId/VendorId for the compiler which produced all of the code in this
        // module. This is Guid.Empty/Guid.Empty if the module may contain a mixture of
        // languages. This will almost always be Guid.Empty/Guid.Empty for PDB-based modules.
        // It generally used by dynamic languages to avoid network round trips to discover
        // the language of each symbol.
        public: DECLSPEC_NOTHROW const Evaluation::DkmCompilerId& STDMETHODCALLTYPE CompilerId(
            );

        // [Optional] For modules where symbols are loaded remotely, the connection property
        // is used to determine where the Connection originated from. Otherwise this will be
        // NULL.
        public: _Ret_opt_ DECLSPEC_NOTHROW DefaultPort::DkmTransportConnection* STDMETHODCALLTYPE Connection(
            );

        /// <summary>
        /// Find a DkmModule object. If no object with the given input key is present,
        /// FindModule will fail.
        /// </summary>
        /// <param name="Id">
        /// [In] Search key used to find the element.
        /// </param>
        /// <param name="ppModule">
        /// [Out] Result of the search.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// E_XAPI_OBJECT_NOT_FOUND indicates that the search key cannot be found.
        /// </returns>
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE FindModule(
            _In_ const Symbols::DkmModuleId& Id,
            _Deref_out_ Symbols::DkmModule** ppModule
            );

        /// <summary>
        /// GetModules enumerates all the created DkmModule objects.
        /// </summary>
        /// <param name="pModules">
        /// [Out] Array containing the enumerated elements.
        ///
        /// The memory for the DkmArray members is allocated by the method implementation
        /// using DkmAllocBytes/DkmAllocArray. It is freed by the caller using the
        /// CAutoDkmArray template or with DkmFreeMemory and manual element release.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetModules(
            _Out_ DkmArray<Symbols::DkmModule*>* pModules
            );

        /// <summary>
        /// Creates a new DkmModule object, which represents the symbols for one or more
        /// loaded modules (module instances). These objects are created by symbol providers.
        /// After the DkmModule object is created, symbol providers should call
        /// DkmModuleInstance.SetModule to associate the DkmModuleInstance and DkmModule
        /// together.
        ///
        /// This method will send a ModuleCreate event.
        /// </summary>
        /// <param name="Id">
        /// [In] Guid pair used to uniquely identify a particular DkmModule instance.
        /// </param>
        /// <param name="pName">
        /// [In] Name of the module.
        /// </param>
        /// <param name="CompilerId">
        /// [In] LanguageId/VendorId for the compiler which produced all of the code in this
        /// module. This is Guid.Empty/Guid.Empty if the module may contain a mixture of
        /// languages. This will almost always be Guid.Empty/Guid.Empty for PDB-based
        /// modules. It generally used by dynamic languages to avoid network round trips to
        /// discover the language of each symbol.
        /// </param>
        /// <param name="pConnection">
        /// [In,Optional] For modules where symbols are loaded remotely, the connection
        /// property is used to determine where the Connection originated from. Otherwise
        /// this will be NULL.
        /// </param>
        /// <param name="DataItem">
        /// [In] Data object to add to the new DkmModule instance. DkmDataItem::Null() in the
        /// case that the caller doesn't need to add a data item.
        /// </param>
        /// <param name="ppCreatedObject">
        /// [Out] Result of this method call.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ const Symbols::DkmModuleId& Id,
            _In_ DkmString* pName,
            _In_ const Evaluation::DkmCompilerId& CompilerId,
            _In_opt_ DefaultPort::DkmTransportConnection* pConnection,
            _In_ const DkmDataItem& DataItem,
            _Deref_out_ Symbols::DkmModule** ppCreatedObject
            );

        /// <summary>
        /// GetScriptDocuments enumerates the DkmScriptDocument elements of this DkmModule
        /// object.
        /// </summary>
        /// <param name="pScriptDocuments">
        /// [Out] Array containing the enumerated elements.
        ///
        /// The memory for the DkmArray members is allocated by the method implementation
        /// using DkmAllocBytes/DkmAllocArray. It is freed by the caller using the
        /// CAutoDkmArray template or with DkmFreeMemory and manual element release.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetScriptDocuments(
            _Out_ DkmArray<Script::DkmScriptDocument*>* pScriptDocuments
            );

        /// <summary>
        /// Returns the scopes within a method. There will always be at least one scope.
        /// </summary>
        /// <param name="MethodId">
        /// [In] DkmClrMethodId is a token/version pair which is used to uniquely identify
        /// the symbol store's understanding of a particular CLR method within a module.
        /// </param>
        /// <param name="pScopes">
        /// [Out] DkmClrMethodScopeData[] describes a scope within a method. These are
        /// defined using ISymUnmanagedWriter::OpenScope/CloseScope.
        ///
        /// The memory for the DkmArray members is allocated by the method implementation
        /// using DkmAllocBytes/DkmAllocArray. It is freed by the caller using the
        /// CAutoDkmArray template or with DkmFreeMemory and manual element release.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetMethodSymbolStoreData(
            _In_ const Clr::DkmClrMethodId& MethodId,
            _Out_ DkmArray<Clr::DkmClrMethodScopeData>* pScopes
            );

        /// <summary>
        /// Returns the scopes within a method. There will always be at least one scope.
        ///
        /// This method will append a new work item to the specified work list, and return
        /// once the work item has been appended. The actual processing of the work item is
        /// asynchronous. The caller will be notified that the request is complete through
        /// the completion routine.
        /// </summary>
        /// <param name="pWorkList">
        /// WorkList to append the new work item to.
        /// </param>
        /// <param name="MethodId">
        /// [In] DkmClrMethodId is a token/version pair which is used to uniquely identify
        /// the symbol store's understanding of a particular CLR method within a module.
        /// </param>
        /// <param name="pCompletionRoutine">
        /// Routine to fire when the request is complete. If the request is successfully
        /// appended to the work list, this will always fire (including when the operation is
        /// canceled). This will never fire if appending the work item fails.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetMethodSymbolStoreData(
            _In_ DkmWorkList* pWorkList,
            _In_ const Clr::DkmClrMethodId& MethodId,
            _In_ IDkmCompletionRoutine<Symbols::DkmGetMethodSymbolStoreDataAsyncResult>* pCompletionRoutine
            );

        /// <summary>
        /// Returns the first method in the first document.
        /// </summary>
        /// <param name="pMethod">
        /// [Out] DkmClrMethodId is a token/version pair which is used to uniquely identify
        /// the symbol store's understanding of a particular CLR method within a module.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetFirstMethodInFirstDocument(
            _Out_ Clr::DkmClrMethodId* pMethod
            );

        /// <summary>
        /// Returns the scopes within a method. There will always be at least one scope.
        /// </summary>
        /// <param name="MethodId">
        /// [In] Method Id PreRemap.
        /// </param>
        /// <param name="pRemapToken">
        /// [Out] Method token after the Remap.
        /// </param>
        /// <param name="pScopes">
        /// [Out] DkmClrMethodScopeData[] describes a scope within a method. These are
        /// defined using ISymUnmanagedWriter::OpenScope/CloseScope.
        ///
        /// The memory for the DkmArray members is allocated by the method implementation
        /// using DkmAllocBytes/DkmAllocArray. It is freed by the caller using the
        /// CAutoDkmArray template or with DkmFreeMemory and manual element release.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetMethodSymbolStoreDataPreRemap(
            _In_ const Clr::DkmClrMethodId& MethodId,
            _Out_ UINT32* pRemapToken,
            _Out_ DkmArray<Clr::DkmClrMethodScopeData>* pScopes
            );

        /// <summary>
        /// Returns the scopes within a method. There will always be at least one scope.
        ///
        /// This method will append a new work item to the specified work list, and return
        /// once the work item has been appended. The actual processing of the work item is
        /// asynchronous. The caller will be notified that the request is complete through
        /// the completion routine.
        /// </summary>
        /// <param name="pWorkList">
        /// WorkList to append the new work item to.
        /// </param>
        /// <param name="MethodId">
        /// [In] Method Id PreRemap.
        /// </param>
        /// <param name="pCompletionRoutine">
        /// Routine to fire when the request is complete. If the request is successfully
        /// appended to the work list, this will always fire (including when the operation is
        /// canceled). This will never fire if appending the work item fails.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetMethodSymbolStoreDataPreRemap(
            _In_ DkmWorkList* pWorkList,
            _In_ const Clr::DkmClrMethodId& MethodId,
            _In_ IDkmCompletionRoutine<Symbols::DkmGetMethodSymbolStoreDataPreRemapAsyncResult>* pCompletionRoutine
            );

        /// <summary>
        /// Gets a custom attribute based upon its name. Not to be confused with Metadata
        /// custom attributes, these attributes are held in the symbol store.
        /// </summary>
        /// <param name="ParentToken">
        /// [In] The token of the method where the symbol store attribute is stored.
        /// </param>
        /// <param name="IsPreRemap">
        /// [In] True if the specified token value is not a real method token but rather was
        /// internally computed by the compiler before the method was emitted using the CLR
        /// image creation APIs.
        /// </param>
        /// <param name="pAttributeName">
        /// [In] The name of the attribute to find.
        /// </param>
        /// <param name="pData">
        /// [Out] The value of the requested symbol store attribute. This will be an empty
        /// array if the specified attribute name cannot be found.
        ///
        /// The memory for the DkmArray members is allocated by the method implementation
        /// using DkmAllocBytes/DkmAllocArray. It is freed by the caller using the
        /// CAutoDkmArray template or with DkmFreeMemory and manual element release.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetTokenSymbolStoreAttribute(
            _In_ UINT32 ParentToken,
            _In_ bool IsPreRemap,
            _In_ DkmString* pAttributeName,
            _Out_ DkmArray<BYTE>* pData
            );

        /// <summary>
        /// Gets a custom attribute based upon its name. Not to be confused with Metadata
        /// custom attributes, these attributes are held in the symbol store.
        ///
        /// This method will append a new work item to the specified work list, and return
        /// once the work item has been appended. The actual processing of the work item is
        /// asynchronous. The caller will be notified that the request is complete through
        /// the completion routine.
        /// </summary>
        /// <param name="pWorkList">
        /// WorkList to append the new work item to.
        /// </param>
        /// <param name="ParentToken">
        /// [In] The token of the method where the symbol store attribute is stored.
        /// </param>
        /// <param name="IsPreRemap">
        /// [In] True if the specified token value is not a real method token but rather was
        /// internally computed by the compiler before the method was emitted using the CLR
        /// image creation APIs.
        /// </param>
        /// <param name="pAttributeName">
        /// [In] The name of the attribute to find.
        /// </param>
        /// <param name="pCompletionRoutine">
        /// Routine to fire when the request is complete. If the request is successfully
        /// appended to the work list, this will always fire (including when the operation is
        /// canceled). This will never fire if appending the work item fails.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetTokenSymbolStoreAttribute(
            _In_ DkmWorkList* pWorkList,
            _In_ UINT32 ParentToken,
            _In_ bool IsPreRemap,
            _In_ DkmString* pAttributeName,
            _In_ IDkmCompletionRoutine<Symbols::DkmGetTokenSymbolStoreAttributeAsyncResult>* pCompletionRoutine
            );

        /// <summary>
        /// Translate accelerator pointer tag into HLSL register attributes.
        /// </summary>
        /// <param name="InputTag">
        /// [In] Accelerator pointer tag found in symbols.
        /// </param>
        /// <param name="InstructionPointer">
        /// [In] current instruction pointer used to get scope for pointer translation.
        /// </param>
        /// <param name="pRegisterType">
        /// [Out] HLSL register type.
        /// </param>
        /// <param name="pRegisterIndex">
        /// [Out] HLSL register index.
        /// </param>
        /// <param name="pFirstElement">
        /// [Out] Index of first vector element.
        /// </param>
        /// <param name="pVectorElements">
        /// [Out] Number of vector elements.
        /// </param>
        /// <param name="pByteOffset">
        /// [Out] Offset in bytes.
        /// </param>
        /// <param name="pVectorElementSize">
        /// [Out] Size of each vector element.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE TranslateAcceleratorTagByIP(
            _In_ UINT32 InputTag,
            _In_ UINT32 InstructionPointer,
            _Out_ UINT32* pRegisterType,
            _Out_ UINT32* pRegisterIndex,
            _Out_ UINT32* pFirstElement,
            _Out_ UINT32* pVectorElements,
            _Out_ UINT32* pByteOffset,
            _Out_ UINT32* pVectorElementSize
            );

        /// <summary>
        /// This method returns compiler flags of the given GPU module.
        /// </summary>
        /// <param name="ppCompilerOptions">
        /// [Out,Optional] returns the compiler flags.
        /// </param>
        /// <returns>
        /// S_OK is returned if *ppCompilerOptions is non-NULL, S_FALSE is returned when
        /// *ppCompilerOptions is NULL, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetCompilerOptions(
            _Deref_out_opt_ DkmString** ppCompilerOptions
            );

        #ifndef EXCLUDE_IDE_ONLY_APIS
        /// <summary>
        /// Translate accelerator pointer tag into HLSL register attributes using relative
        /// virtual address.
        ///
        /// Location constraint: API must be called from an IDE component (component level
        /// &gt; 100,000).
        /// </summary>
        /// <param name="InputTag">
        /// [In] Accelerator pointer tag found in symbols.
        /// </param>
        /// <param name="Rva">
        /// [In] RVA to use for filtering; ignored if zero.
        /// </param>
        /// <param name="pRegisterType">
        /// [Out] HLSL register type.
        /// </param>
        /// <param name="pRegisterIndex">
        /// [Out] HLSL register index.
        /// </param>
        /// <param name="pFirstElement">
        /// [Out] Index of first vector element.
        /// </param>
        /// <param name="pVectorElements">
        /// [Out] Number of vector elements.
        /// </param>
        /// <param name="pByteOffset">
        /// [Out] Offset in bytes.
        /// </param>
        /// <param name="pVectorElementSize">
        /// [Out] Size of each vector element.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE TranslateAcceleratorTagByRva(
            _In_ UINT32 InputTag,
            _In_ UINT32 Rva,
            _Out_ UINT32* pRegisterType,
            _Out_ UINT32* pRegisterIndex,
            _Out_ UINT32* pFirstElement,
            _Out_ UINT32* pVectorElements,
            _Out_ UINT32* pByteOffset,
            _Out_ UINT32* pVectorElementSize
            );
        #endif // #ifndef EXCLUDE_IDE_ONLY_APIS

        #ifndef EXCLUDE_IDE_ONLY_APIS
        /// <summary>
        /// Verify if the accelerator pointer tag is valid.
        ///
        /// Location constraint: API must be called from an IDE component (component level
        /// &gt; 100,000).
        /// </summary>
        /// <param name="InputTag">
        /// [In] Accelerator pointer tag found in symbols.
        /// </param>
        /// <param name="Rva">
        /// [In] RVA to use for filtering; ignored if zero.
        /// </param>
        /// <param name="pIsValid">
        /// [Out] True if the given accelerator tag is valid at the given RVA.  If RVA is
        /// zero, checks if the tag is valid anywhere including as a dynamically created tag.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE IsValidAcceleratorTag(
            _In_ UINT32 InputTag,
            _In_ UINT32 Rva,
            _Out_ bool* pIsValid
            );
        #endif // #ifndef EXCLUDE_IDE_ONLY_APIS

        #ifndef EXCLUDE_IDE_ONLY_APIS
        /// <summary>
        /// Gets a C++ AMP address for a register.
        ///
        /// Location constraint: API must be called from an IDE component (component level
        /// &gt; 100,000).
        /// </summary>
        /// <param name="RegisterType">
        /// [In] Type of HLSL register.
        /// </param>
        /// <param name="RegisterIndex">
        /// [In] Index of HLSL register.
        /// </param>
        /// <param name="FirstElement">
        /// [In] Index of first vector element.
        /// </param>
        /// <param name="VectorElements">
        /// [In] Number of vector elements.
        /// </param>
        /// <param name="ByteOffset">
        /// [In] Offset from beginning of register.
        /// </param>
        /// <param name="VectorElementSize">
        /// [In] Size of vector element.
        /// </param>
        /// <param name="Rva">
        /// [In] RVA to use for mapping register information and tag address.
        /// </param>
        /// <param name="StartLiveRange">
        /// [In] Start of live range for the symbol.
        /// </param>
        /// <param name="EndLiveRange">
        /// [In] End of live range for the symbol.
        /// </param>
        /// <param name="pAddress">
        /// [Out] Address for register.
        /// </param>
        /// <param name="pIsNewDynamicTag">
        /// [Out] Is the address newly generated using dynamic tag.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetPointerToHLSLRegister(
            _In_ CV_HREG_e RegisterType,
            _In_ UINT32 RegisterIndex,
            _In_ UINT32 FirstElement,
            _In_ UINT32 VectorElements,
            _In_ UINT32 ByteOffset,
            _In_ UINT32 VectorElementSize,
            _In_ UINT32 Rva,
            _In_ UINT32 StartLiveRange,
            _In_ UINT32 EndLiveRange,
            _Out_ UINT64* pAddress,
            _Out_ bool* pIsNewDynamicTag
            );
        #endif // #ifndef EXCLUDE_IDE_ONLY_APIS

        #ifndef EXCLUDE_IDE_ONLY_APIS
        /// <summary>
        /// Sets a C++ AMP address for a register.
        ///
        /// Location constraint: API must be called from an IDE component (component level
        /// &gt; 100,000).
        /// </summary>
        /// <param name="Address">
        /// [In] Address for register.
        /// </param>
        /// <param name="RegisterType">
        /// [In] Type of HLSL register.
        /// </param>
        /// <param name="RegisterIndex">
        /// [In] Index of HLSL register.
        /// </param>
        /// <param name="FirstElement">
        /// [In] Index of first vector element.
        /// </param>
        /// <param name="VectorElements">
        /// [In] Number of vector elements.
        /// </param>
        /// <param name="ByteOffset">
        /// [In] Offset from beginning of register.
        /// </param>
        /// <param name="VectorElementSize">
        /// [In] Size of vector element.
        /// </param>
        /// <param name="StartLiveRange">
        /// [In] Start of live range for the symbol.
        /// </param>
        /// <param name="EndLiveRange">
        /// [In] End of live range for the symbol.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE SetPointerToHLSLRegister(
            _In_ UINT64 Address,
            _In_ CV_HREG_e RegisterType,
            _In_ UINT32 RegisterIndex,
            _In_ UINT32 FirstElement,
            _In_ UINT32 VectorElements,
            _In_ UINT32 ByteOffset,
            _In_ UINT32 VectorElementSize,
            _In_ UINT32 StartLiveRange,
            _In_ UINT32 EndLiveRange
            );
        #endif // #ifndef EXCLUDE_IDE_ONLY_APIS

        #ifndef EXCLUDE_IDE_ONLY_APIS
        /// <summary>
        /// Gets a C++ AMP address for a register.
        ///
        /// Location constraint: API must be called from an IDE component (component level
        /// &gt; 100,000).
        /// </summary>
        /// <param name="pSize">
        /// [Out] Maximum tag value found in actual C++ AMP pointers plus one.
        /// </param>
        /// <param name="pSizeOfForwardedTags">
        /// [Out] Maximum tag value that may be subject to buffer forwarding plus one.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetAcceleratorTagTableSize(
            _Out_ UINT32* pSize,
            _Out_ UINT32* pSizeOfForwardedTags
            );
        #endif // #ifndef EXCLUDE_IDE_ONLY_APIS

        #ifndef EXCLUDE_IDE_ONLY_APIS
        /// <summary>
        /// GetInstructionOffsetForRva is used by components to query symbol provider to
        /// perform instruction offset and RVA translation for DPC++.
        ///
        /// Location constraint: API must be called from an IDE component (component level
        /// &gt; 100,000).
        /// </summary>
        /// <param name="RVA">
        /// [In] The RVA within a module.
        /// </param>
        /// <param name="pInstructionOffset">
        /// [Out] The instruction offset from stub function.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetInstructionOffsetForRva(
            _In_ UINT32 RVA,
            _Out_ UINT32* pInstructionOffset
            );
        #endif // #ifndef EXCLUDE_IDE_ONLY_APIS

        /// <summary>
        /// A DkmModule is the symbol handler's representation of a module, and is not bound
        /// to any process, connection or runtime instance. This method returns all the
        /// DkmModuleInstances which map to this DkmModule. A DkmModule can be bound to zero
        /// instances in the case that all of the modules are now unloaded. In this case,
        /// GetModuleInstances will return an empty array (S_FALSE return code in native).
        /// </summary>
        /// <param name="pModules">
        /// [Out] The Module Instance class represent a code bundle (ex: dll or exe) which is
        /// loaded into a particular process at a particular location. Module Instance
        /// objects are 1:1 with the execution environment's notion of a code bundle. For
        /// example, in native code, Module Instance objects are 1:1 with base address.
        ///
        /// The memory for the DkmArray members is allocated by the method implementation
        /// using DkmAllocBytes/DkmAllocArray. It is freed by the caller using the
        /// CAutoDkmArray template or with DkmFreeMemory and manual element release.
        /// </param>
        /// <returns>
        /// S_OK is returned if pModules contains any elements, S_FALSE is indicates the
        /// array is empty, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetModuleInstances(
            _Out_ DkmArray<DkmModuleInstance*>* pModules
            );

        #ifndef EXCLUDE_IDE_ONLY_APIS
        /// <summary>
        /// Undecorates a symbol name.
        ///
        /// Location constraint: API must be called from an IDE component (component level
        /// &gt; 100,000).
        /// </summary>
        /// <param name="pDecoratedName">
        /// [In] The name to be undecorated.
        /// </param>
        /// <param name="Options">
        /// [In] Options to change the undecorated name. These are specific to the
        /// implementation being used. For Microsoft PDB, pass one or more of the values
        /// described in the documentation for DbgHelp.dll UnDecorateSymbolName or one of
        /// these three extended options: UNDNAME2_STRIP_ILT  0x10000  - to remove the
        /// leading ILT from Incremental Linking Thunks UNDNAME2_STRIP_CONST 0x20000 - to
        /// remove leading "const" from the front of the string UNDNAME2_STRINGS  0x30000 -
        /// to use pooled strings by name.
        /// </param>
        /// <param name="ppUndecoratedName">
        /// [Out] The undecorated name.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE UndecorateName(
            _In_ DkmString* pDecoratedName,
            _In_ UINT32 Options,
            _Deref_out_ DkmString** ppUndecoratedName
            );
        #endif // #ifndef EXCLUDE_IDE_ONLY_APIS

        /// <summary>
        /// Return the RVA for an S_PUBLIC32 for a particular name by string.
        /// </summary>
        /// <param name="pPublicName">
        /// [In] The name of the public symbol to lookup.
        /// </param>
        /// <param name="ppAddress">
        /// [Out,Optional] The native instruction symbol for this public symbol.
        /// </param>
        /// <returns>
        /// S_OK is returned if *ppAddress is non-NULL, S_FALSE is returned when *ppAddress
        /// is NULL, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetPublicSymbolByNameCallback(
            _In_ DkmString* pPublicName,
            _Deref_out_opt_ Native::DkmNativeInstructionSymbol** ppAddress
            );

        #ifndef EXCLUDE_IDE_ONLY_APIS
        /// <summary>
        /// Returns the contents of the source server stream data for a module if the stream
        /// exists.
        ///
        /// Location constraint: API must be called from an IDE component (component level
        /// &gt; 100,000).
        /// </summary>
        /// <param name="pModuleInstance">
        /// [In] The module instance for which symbol server data is being requested.
        /// </param>
        /// <param name="pStreamData">
        /// [Out] True if this address is the first address in the line's range. False
        /// otherwise.
        ///
        /// The memory for the DkmArray members is allocated by the method implementation
        /// using DkmAllocBytes/DkmAllocArray. It is freed by the caller using the
        /// CAutoDkmArray template or with DkmFreeMemory and manual element release.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetSourceServerData(
            _In_ DkmModuleInstance* pModuleInstance,
            _Out_ DkmArray<BYTE>* pStreamData
            );
        #endif // #ifndef EXCLUDE_IDE_ONLY_APIS

        #ifndef EXCLUDE_IDE_ONLY_APIS
        /// <summary>
        /// Returns document objects from search parameters contained in the document query.
        /// If the symbol file does not contain a reference to this document the returned
        /// document object will be NULL (S_FALSE return code in native). The returned
        /// document objects must be explicitly closed by the caller when the caller is done
        /// with the document.
        ///
        /// Location constraint: API must be called from an IDE component (component level
        /// &gt; 100,000).
        /// </summary>
        /// <param name="pSourceFileId">
        /// [In] Identifies a source file and provides the information which a symbol handler
        /// could use to search a symbol file (PDB) for information on this source file.
        /// </param>
        /// <param name="pDocuments">
        /// [Out] A collection of the documents that matched the query.
        ///
        /// The memory for the DkmArray members is allocated by the method implementation
        /// using DkmAllocBytes/DkmAllocArray. It is freed by the caller using the
        /// CAutoDkmArray template or with DkmFreeMemory and manual element release.
        /// </param>
        /// <returns>
        /// S_OK is returned if pDocuments contains any elements, S_FALSE is indicates the
        /// array is empty, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE FindDocuments(
            _In_ Symbols::DkmSourceFileId* pSourceFileId,
            _Out_ DkmArray<Symbols::DkmResolvedDocument*>* pDocuments
            );
        #endif // #ifndef EXCLUDE_IDE_ONLY_APIS

        #ifndef EXCLUDE_IDE_ONLY_APIS
        /// <summary>
        /// Returns document objects from search parameters contained in the document query.
        /// If the symbol file does not contain a reference to this document the returned
        /// document object will be NULL (S_FALSE return code in native). The returned
        /// document objects must be explicitly closed by the caller when the caller is done
        /// with the document.
        ///
        /// This method will append a new work item to the specified work list, and return
        /// once the work item has been appended. The actual processing of the work item is
        /// asynchronous. The caller will be notified that the request is complete through
        /// the completion routine.
        ///
        /// Location constraint: API must be called from an IDE component (component level
        /// &gt; 100,000).
        /// </summary>
        /// <param name="pWorkList">
        /// WorkList to append the new work item to.
        /// </param>
        /// <param name="pSourceFileId">
        /// [In] Identifies a source file and provides the information which a symbol handler
        /// could use to search a symbol file (PDB) for information on this source file.
        /// </param>
        /// <param name="pCompletionRoutine">
        /// Routine to fire when the request is complete. If the request is successfully
        /// appended to the work list, this will always fire (including when the operation is
        /// canceled). This will never fire if appending the work item fails.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE FindDocuments(
            _In_ DkmWorkList* pWorkList,
            _In_ Symbols::DkmSourceFileId* pSourceFileId,
            _In_ IDkmCompletionRoutine<Symbols::DkmFindDocumentsAsyncResult>* pCompletionRoutine
            );
        #endif // #ifndef EXCLUDE_IDE_ONLY_APIS

        #ifndef EXCLUDE_IDE_ONLY_APIS
        /// <summary>
        /// Returns the path to the symbol file which backs a DkmModule object.
        ///
        /// Location constraint: API must be called from an IDE component (component level
        /// &gt; 100,000).
        /// </summary>
        /// <param name="ppFilePath">
        /// [Out] Full path to the symbol file (ex: c:\myproj\bin\debug\myproj.pdb).
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetSymbolFilePath(
            _Deref_out_ DkmString** ppFilePath
            );
        #endif // #ifndef EXCLUDE_IDE_ONLY_APIS

        #ifndef EXCLUDE_MONITOR_ONLY_APIS
        /// <summary>
        /// GetEntryPointSymbols is used by the breakpoint manager to find the entry point
        /// symbol(s) in the launching executable. For managed code, this symbol is defined
        /// using ISymUnmanagedWriter::SetUserEntryPoint. For native code, this symbol is
        /// found by looking for the various 'main' function (main, WinMain, etc). A third
        /// can override the entry point either by implementing their own symbol provider or
        /// by implementing IDkmEntryPointQuery.
        ///
        /// Location constraint: API must be called from a Monitor component (component level
        /// &lt; 100,000).
        /// </summary>
        /// <param name="pPossibleEntryPoints">
        /// [Out] DkmInstructionSymbol[] represents a method in the target process.
        ///
        /// The memory for the DkmArray members is allocated by the method implementation
        /// using DkmAllocBytes/DkmAllocArray. It is freed by the caller using the
        /// CAutoDkmArray template or with DkmFreeMemory and manual element release.
        /// </param>
        /// <returns>
        /// S_OK is returned if pPossibleEntryPoints contains any elements, S_FALSE is
        /// indicates the array is empty, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetEntryPointSymbols(
            _Out_ DkmArray<Symbols::DkmInstructionSymbol*>* pPossibleEntryPoints
            );
        #endif // #ifndef EXCLUDE_MONITOR_ONLY_APIS

        #ifndef EXCLUDE_MONITOR_ONLY_APIS
        /// <summary>
        /// Search a module's symbols for a function with the specified name. Returns the RVA
        /// and size if it is found.
        ///
        /// Location constraint: API must be called from a Monitor component (component level
        /// &lt; 100,000).
        /// </summary>
        /// <param name="pFunctionName">
        /// [In] The name of the function to search for.
        /// </param>
        /// <param name="pResults">
        /// [Out] The RVA / size pairs from the query.
        ///
        /// The memory for the DkmArray members is allocated by the method implementation
        /// using DkmAllocBytes/DkmAllocArray. It is freed by the caller using the
        /// CAutoDkmArray template or with DkmFreeMemory and manual element release.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetFunctionInfo(
            _In_ DkmString* pFunctionName,
            _Out_ DkmArray<Symbols::DkmRVASizePair>* pResults
            );
        #endif // #ifndef EXCLUDE_MONITOR_ONLY_APIS

        #ifndef EXCLUDE_MONITOR_ONLY_APIS
        /// <summary>
        /// Search a module's symbols for a function with the specified name. Returns the RVA
        /// and size if it is found.
        ///
        /// This method will append a new work item to the specified work list, and return
        /// once the work item has been appended. The actual processing of the work item is
        /// asynchronous. The caller will be notified that the request is complete through
        /// the completion routine.
        ///
        /// Location constraint: API must be called from a Monitor component (component level
        /// &lt; 100,000).
        /// </summary>
        /// <param name="pWorkList">
        /// WorkList to append the new work item to.
        /// </param>
        /// <param name="pFunctionName">
        /// [In] The name of the function to search for.
        /// </param>
        /// <param name="pCompletionRoutine">
        /// Routine to fire when the request is complete. If the request is successfully
        /// appended to the work list, this will always fire (including when the operation is
        /// canceled). This will never fire if appending the work item fails.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetFunctionInfo(
            _In_ DkmWorkList* pWorkList,
            _In_ DkmString* pFunctionName,
            _In_ IDkmCompletionRoutine<Symbols::DkmGetFunctionInfoAsyncResult>* pCompletionRoutine
            );
        #endif // #ifndef EXCLUDE_MONITOR_ONLY_APIS

        /// <summary>
        /// GetSymbolInterface is used to obtain a raw COM interface to a symbol store. This
        /// is useful to either callers that find the symbol abstraction presented by the
        /// debugger to be either too restrictive for their needs, or simply undesirable due
        /// to how their component is implemented.
        ///
        /// Location constraint: With the exception of managed symbols, this method must be
        /// called from the same process where the symbol provider has opened the symbol
        /// file. For Native PDB files, this means that the API must be called from the IDE
        /// process. For Managed symbols, a subset of the symbol provider API is provided on
        /// both sides of the remote connection.
        /// </summary>
        /// <param name="InterfaceID">
        /// [In] The GUID of the desired interface. Microsoft supports IID_IDiaSession for
        /// Native DkmModule's, and IID_ISymUnmanagedReader for Managed modules.
        /// </param>
        /// <param name="ppSymbolInterface">
        /// [Out] Returned symbol interface. This may be cast to the interface pointer
        /// corresponding to 'InterfaceID'.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetSymbolInterface(
            _In_ const GUID& InterfaceID,
            _Deref_out_ IUnknown** ppSymbolInterface
            );
    }; // end of DkmModule

    // Object which represents the result of a source file query against a symbol file (PDB).
    // The resolved document object might encapsulate multiple document records with the
    // symbol file. For example, in C++ compilation, each time that a header file is included
    // there is another reference within the PDB. However, there is only one
    // DkmResolvedDocument object for the header file.
    //
    // Derived classes: DkmResolvedMappedDocument
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("79baa60b-1e97-ac96-0d95-996e6b997c33") DkmResolvedDocument : public DkmDataContainer
    {
        // Use DkmResolvedDocument::Create to create this object
        private: DkmResolvedDocument();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmResolvedDocument();
        // This object cannot be copied
        private: DkmResolvedDocument& operator=(const DkmResolvedDocument&);
        private: DkmResolvedDocument(const DkmResolvedDocument&);

        private: Symbols::DkmModule* const m_pModule;
        private: const GUID m_UniqueId;
        private: DkmString* const m_pDocumentName;
        private: OPTIONAL Script::DkmScriptDocument* const m_pScriptDocument;
        private: const Symbols::DkmDocumentMatchStrength_t m_MatchStrength;
        private: const Symbols::DkmResolvedDocumentWarning_t m_Warning;
        private: const bool m_TextRequested;
        private: void* m__pExtendedData;

        // The DkmModule class represents a code bundle (ex: dll or exe) which is or once was
        // loaded into one or more processes. The DkmModule class is the central object to
        // the symbol APIs, and is 1:1 with the symbol handler's notation of what is loaded.
        // If a code bundle loads into three different processes (or the same process but
        // with three different base addresses or three different app domains) but the symbol
        // handler thinks of all of these as being identical, there will be only one module
        // object.
        public: _Ret_ DECLSPEC_NOTHROW Symbols::DkmModule* STDMETHODCALLTYPE Module(
            );

        // Guid which uniquely identifies this object.
        public: DECLSPEC_NOTHROW const GUID& STDMETHODCALLTYPE UniqueId(
            );

        // Name of the source file. This is generally a full path, but in some scenarios it
        // make be a partial path or just a name with extension (ex: example.cpp). In the
        // case of a dynamic document (ex: running script from internet explorer) 'Path'
        // could be a URL rather than a local file path.
        public: _Ret_ DECLSPEC_NOTHROW DkmString* STDMETHODCALLTYPE DocumentName(
            );

        // [Optional] Script document which this resolved document represents. This should be
        // null for non script-based symbol providers.
        public: _Ret_opt_ DECLSPEC_NOTHROW Script::DkmScriptDocument* STDMETHODCALLTYPE ScriptDocument(
            );

        // Indicates how strong of a match there was between the DkmDocumentQuery and the
        // resulting DkmResolvedDocument.
        public: DECLSPEC_NOTHROW Symbols::DkmDocumentMatchStrength_t STDMETHODCALLTYPE MatchStrength(
            );

        // Warning that occurred during the match. Depending on context, these may need to be
        // surfaced to the user.
        public: DECLSPEC_NOTHROW Symbols::DkmResolvedDocumentWarning_t STDMETHODCALLTYPE Warning(
            );

        // If true, return the source text.
        public: DECLSPEC_NOTHROW bool STDMETHODCALLTYPE TextRequested(
            );

        /// <summary>
        /// Closes the resolved document object. This method must be invoked when the
        /// component which requested the resolved document is done with the object.
        ///
        /// DkmResolvedDocument objects are automatically closed when their associated
        /// DkmModule object is closed.
        /// </summary>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Close(
            );

        /// <summary>
        /// Creates a new resolved document object. Resolved document objects are created by
        /// a symbol provider. They are a data container so that a symbol provider may back
        /// the resolved document with their own internal state.
        /// </summary>
        /// <param name="pModule">
        /// [In] The DkmModule class represents a code bundle (ex: dll or exe) which is or
        /// once was loaded into one or more processes. The DkmModule class is the central
        /// object to the symbol APIs, and is 1:1 with the symbol handler's notation of what
        /// is loaded. If a code bundle loads into three different processes (or the same
        /// process but with three different base addresses or three different app domains)
        /// but the symbol handler thinks of all of these as being identical, there will be
        /// only one module object.
        /// </param>
        /// <param name="pDocumentName">
        /// [In] Name of the source file. This is generally a full path, but in some
        /// scenarios it make be a partial path or just a name with extension (ex:
        /// example.cpp). In the case of a dynamic document (ex: running script from internet
        /// explorer) 'Path' could be a URL rather than a local file path.
        /// </param>
        /// <param name="pScriptDocument">
        /// [In,Optional] Script document which this resolved document represents. This
        /// should be null for non script-based symbol providers.
        /// </param>
        /// <param name="MatchStrength">
        /// [In] Indicates how strong of a match there was between the DkmDocumentQuery and
        /// the resulting DkmResolvedDocument.
        /// </param>
        /// <param name="Warning">
        /// [In] Warning that occurred during the match. Depending on context, these may need
        /// to be surfaced to the user.
        /// </param>
        /// <param name="TextRequested">
        /// [In] If true, return the source text.
        /// </param>
        /// <param name="DataItem">
        /// [In] Data object to add to the new DkmResolvedDocument instance.
        /// DkmDataItem::Null() in the case that the caller doesn't need to add a data item.
        /// </param>
        /// <param name="ppCreatedObject">
        /// [Out] Result of this method call.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ Symbols::DkmModule* pModule,
            _In_ DkmString* pDocumentName,
            _In_opt_ Script::DkmScriptDocument* pScriptDocument,
            _In_ Symbols::DkmDocumentMatchStrength_t MatchStrength,
            _In_ Symbols::DkmResolvedDocumentWarning_t Warning,
            _In_ bool TextRequested,
            _In_ const DkmDataItem& DataItem,
            _Deref_out_ Symbols::DkmResolvedDocument** ppCreatedObject
            );

        #ifndef EXCLUDE_IDE_ONLY_APIS
        /// <summary>
        /// Finds the symbols within the document which best match the input text span.
        ///
        /// For IL-based languages, the symbol handler always return the DkmInstructionSymbol
        /// for sequence points. It will prefer sequence points which exactly match the text
        /// span followed by the sequence point or points which is left-most and which is
        /// inside the input span.
        ///
        /// Location constraint: API must be called from an IDE component (component level
        /// &gt; 100,000).
        /// </summary>
        /// <param name="TextSpan">
        /// [In] The text range (lines/column) to search for.
        /// </param>
        /// <param name="pText">
        /// [In,Optional] The text to search for. When available, this will be provided if
        /// ResolvedDocument.TextRequested is set.
        /// </param>
        /// <param name="pInstructionSymbols">
        /// [Out] The found instruction symbols which are within the specified text span.
        ///
        /// The memory for the DkmArray members is allocated by the method implementation
        /// using DkmAllocBytes/DkmAllocArray. It is freed by the caller using the
        /// CAutoDkmArray template or with DkmFreeMemory and manual element release.
        /// </param>
        /// <param name="pSymbolLocation">
        /// [Out] The source location of each returned instruction symbol. The length of this
        /// array should be the same of the returned instruction symbol array.
        ///
        /// The memory for the DkmArray members is allocated by the method implementation
        /// using DkmAllocBytes/DkmAllocArray. It is freed by the caller using the
        /// CAutoDkmArray template or with DkmFreeMemory and manual element release.
        /// </param>
        /// <returns>
        /// S_OK is returned if pInstructionSymbols contains any elements, S_FALSE is
        /// indicates the array is empty, and failure codes are used for any error.
        /// E_TEXT_SPAN_NOT_LOADED indicates that TextSpan is not currently loaded in the
        /// specified script document. E_SCRIPT_SPAN_MAPPING_FAILED indicates that TextSpan
        /// could not be mapped to a location in the specified script document.
        /// E_SCRIPT_FILE_DIFFERENT_CONTENT indicates that the content in the script file
        /// loaded by the target process doesn't match the provided Text.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE FindSymbols(
            _In_ const Symbols::DkmTextSpan& TextSpan,
            _In_opt_ DkmString* pText,
            _Out_ DkmArray<Symbols::DkmInstructionSymbol*>* pInstructionSymbols,
            _Out_ DkmArray<Symbols::DkmSourcePosition*>* pSymbolLocation
            );
        #endif // #ifndef EXCLUDE_IDE_ONLY_APIS

        #ifndef EXCLUDE_IDE_ONLY_APIS
        /// <summary>
        /// Finds the symbols within the document which best match the input text span.
        ///
        /// For IL-based languages, the symbol handler always return the DkmInstructionSymbol
        /// for sequence points. It will prefer sequence points which exactly match the text
        /// span followed by the sequence point or points which is left-most and which is
        /// inside the input span.
        ///
        /// This method will append a new work item to the specified work list, and return
        /// once the work item has been appended. The actual processing of the work item is
        /// asynchronous. The caller will be notified that the request is complete through
        /// the completion routine.
        ///
        /// Location constraint: API must be called from an IDE component (component level
        /// &gt; 100,000).
        /// </summary>
        /// <param name="pWorkList">
        /// WorkList to append the new work item to.
        /// </param>
        /// <param name="TextSpan">
        /// [In] The text range (lines/column) to search for.
        /// </param>
        /// <param name="pText">
        /// [In,Optional] The text to search for. When available, this will be provided if
        /// ResolvedDocument.TextRequested is set.
        /// </param>
        /// <param name="pCompletionRoutine">
        /// Routine to fire when the request is complete. If the request is successfully
        /// appended to the work list, this will always fire (including when the operation is
        /// canceled). This will never fire if appending the work item fails.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE FindSymbols(
            _In_ DkmWorkList* pWorkList,
            _In_ const Symbols::DkmTextSpan& TextSpan,
            _In_opt_ DkmString* pText,
            _In_ IDkmCompletionRoutine<Symbols::DkmFindSymbolsAsyncResult>* pCompletionRoutine
            );
        #endif // #ifndef EXCLUDE_IDE_ONLY_APIS
    }; // end of DkmResolvedDocument

    // Warning that occurred during the match. Depending on context, these may need to be
    // surfaced to the user.
    DEFINE_SCOPED_ENUM(DkmResolvedDocumentWarning)
    {
        // No warning occurred during the match.
        None = 0,
        // Both the symbol file and input request contained a source file checksum, however
        // the checksum values did not match each other.
        ChecksumMismatch = 1,
        // Both the symbol file and input request contained a source file checksum, and the
        // symbol file contained a match to this checksum value. However, the symbol file
        // also contained information about an identically named document with a different
        // checksum value. This can occur in partial rebuild scenarios and may result in
        // strange behavior.
        MultipleChecksums = 2
    };

    // Identifies a source file and provides the information which a symbol handler could use
    // to search a symbol file (PDB) for information on this source file.
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("a892d8cf-b6fd-7e20-e0da-6ceca6a7c0c4") DkmSourceFileId : public IUnknown
    {
        private: ___ReferenceCount_t m_ReferenceCount;
        private: DkmDispatcherObjectFlags_t m_ObjectFlags;
        private: const GUID* m_pTypeId;
        private: size_t m_ObjectGCHandle;
        // Use DkmSourceFileId::Create to create this object
        private: DkmSourceFileId();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmSourceFileId();
        // This object cannot be copied
        private: DkmSourceFileId& operator=(const DkmSourceFileId&);
        private: DkmSourceFileId(const DkmSourceFileId&);

        // MD5 hash value for this document.
        public: struct MD5Hash
        {
            // Value of a calculated MD5 hash. MD5 hashes are used for the document checksum
            // feature, which is a non-security purpose. MD5 should no longer be used for any
            // security related purpose.
            Symbols::DkmMD5HashValue Value;
        };

        // SHA-1 hash value for this document.
        public: struct SHA1Hash
        {
            // Value of a calculated SHA-1 hash. SHA-1 hashes are used for the document
            // checksum feature, which is a non-security purpose. SHA-1 should no longer be
            // used for any security related purpose.
            Symbols::DkmSHA1HashValue Value;
        };

        private: OPTIONAL const Symbols::DkmSourceFileId::MD5Hash* const m_pMD5Hash;
        private: OPTIONAL const Symbols::DkmSourceFileId::SHA1Hash* const m_pSHA1Hash;
        private: DkmString* const m_pDocumentName;
        private: OPTIONAL Script::DkmScriptDocument* const m_pScriptDocument;
        private: void* m__pExtendedData;

        // [Optional] MD5 hash value for this document.
        public: _Ret_opt_ DECLSPEC_NOTHROW const Symbols::DkmSourceFileId::MD5Hash* STDMETHODCALLTYPE MD5HashPart(
            );

        // [Optional] SHA-1 hash value for this document.
        public: _Ret_opt_ DECLSPEC_NOTHROW const Symbols::DkmSourceFileId::SHA1Hash* STDMETHODCALLTYPE SHA1HashPart(
            );

        // Name of the source file. This is generally a full path, but in some scenarios it
        // make be a partial path or just a name with extension (ex: example.cpp). In the
        // case of a dynamic document (ex: running script from internet explorer) 'Path'
        // could be a URL rather than a local file path.
        public: _Ret_ DECLSPEC_NOTHROW DkmString* STDMETHODCALLTYPE DocumentName(
            );

        // [Optional] Script document object which this DkmSourceFileId wraps. For requests
        // to find document requests, this can be non-NULL when the text position to search
        // for is from the dynamic view of a document. For address->text position requests,
        // this will be non-null when the the address is in a script document.
        public: _Ret_opt_ DECLSPEC_NOTHROW Script::DkmScriptDocument* STDMETHODCALLTYPE ScriptDocument(
            );

        /// <summary>
        /// Create a new DkmSourceFileId object instance.
        /// </summary>
        /// <param name="pDocumentName">
        /// [In] Name of the source file. This is generally a full path, but in some
        /// scenarios it make be a partial path or just a name with extension (ex:
        /// example.cpp). In the case of a dynamic document (ex: running script from internet
        /// explorer) 'Path' could be a URL rather than a local file path.
        /// </param>
        /// <param name="pScriptDocument">
        /// [In,Optional] Script document object which this DkmSourceFileId wraps. For
        /// requests to find document requests, this can be non-NULL when the text position
        /// to search for is from the dynamic view of a document. For address-&gt;text
        /// position requests, this will be non-null when the the address is in a script
        /// document.
        /// </param>
        /// <param name="pMD5Hash">
        /// [In,Optional] MD5 hash value for this document.
        /// </param>
        /// <param name="pSHA1Hash">
        /// [In,Optional] SHA-1 hash value for this document.
        /// </param>
        /// <param name="ppCreatedObject">
        /// [Out] Result of this method call.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ DkmString* pDocumentName,
            _In_opt_ Script::DkmScriptDocument* pScriptDocument,
            _In_opt_ const Symbols::DkmSourceFileId::MD5Hash* pMD5Hash,
            _In_opt_ const Symbols::DkmSourceFileId::SHA1Hash* pSHA1Hash,
            _Deref_out_ Symbols::DkmSourceFileId** ppCreatedObject
            );
    }; // end of DkmSourceFileId

    // Source code position which corresponds to a code element. The could represent a
    // location which has been extracted from a symbol (PDB) file, or it could be the
    // location of a breakpoint in the IDE.
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("7995b6c8-93dc-ac77-d59b-b99ce6ec9e48") DkmSourcePosition : public IUnknown
    {
        private: ___ReferenceCount_t m_ReferenceCount;
        private: DkmDispatcherObjectFlags_t m_ObjectFlags;
        private: const GUID* m_pTypeId;
        private: size_t m_ObjectGCHandle;
        // Use DkmSourcePosition::Create to create this object
        private: DkmSourcePosition();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmSourcePosition();
        // This object cannot be copied
        private: DkmSourcePosition& operator=(const DkmSourcePosition&);
        private: DkmSourcePosition(const DkmSourcePosition&);

        private: Symbols::DkmSourceFileId* const m_pSourceFileId;
        private: const Symbols::DkmTextSpan m_TextSpan;
        private: void* m__pExtendedData;

        // Identifies a source file and provides the information which a symbol handler could
        // use to search a symbol file (PDB) for information on this source file.
        public: _Ret_ DECLSPEC_NOTHROW Symbols::DkmSourceFileId* STDMETHODCALLTYPE SourceFileId(
            );

        // The start/end line/column ranges for a contiguous span of text.
        public: DECLSPEC_NOTHROW const Symbols::DkmTextSpan& STDMETHODCALLTYPE TextSpan(
            );

        // Name of the source file. This is generally a full path, but in some scenarios it
        // make be a partial path or just a name with extension (ex: example.cpp). In the
        // case of a dynamic document (ex: running script from internet explorer) 'Path'
        // could be a URL rather than a local file path.
        public: _Ret_ DECLSPEC_NOTHROW DkmString* STDMETHODCALLTYPE DocumentName(
            );

        /// <summary>
        /// Create a new DkmSourcePosition object instance.
        /// </summary>
        /// <param name="pSourceFileId">
        /// [In] Identifies a source file and provides the information which a symbol handler
        /// could use to search a symbol file (PDB) for information on this source file.
        /// </param>
        /// <param name="TextSpan">
        /// [In] The start/end line/column ranges for a contiguous span of text.
        /// </param>
        /// <param name="ppCreatedObject">
        /// [Out] Result of this method call.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ Symbols::DkmSourceFileId* pSourceFileId,
            _In_ const Symbols::DkmTextSpan& TextSpan,
            _Deref_out_ Symbols::DkmSourcePosition** ppCreatedObject
            );
    }; // end of DkmSourcePosition

    // Flags which affect the behavior of 'GetSourcePosition'.
    DEFINE_SCOPED_ENUM(DkmSourcePositionFlags)
    {
        // Instructs the symbol provider to use the default behavior of GetSourcePosition.
        None = 0x0,
        // Instructs the symbol provider to extend the source range to include surrounding
        // source code in addition to the source statement which corresponds to the
        // instruction symbol. This option is used in the disassembly window.
        ExtendedSourceRange = 0x1
    };
    DEFINE_SCOPED_ENUM_FLAG_OPERATORS(DkmSourcePositionFlags_t);

    // Indicates to the symbol provider the type of instructions to include in the 'no-step'
    // regions.
    DEFINE_SCOPED_ENUM(DkmSteppingRangeBoundary)
    {
        // Step should complete at the first non-hidden instruction in the method. This value
        // is used when stepping into a new function.
        FunctionStart = 0,
        // Step should complete on the next statement.
        NextStatement = 1,
        // Step should complete on the next line.
        NextLine = 2,
        // Step should complete at the first instruction after the inline method. This value
        // is used when stepping out an inline function.
        InlineFunctionOut = 3
    };

    // Contains information needed to locate symbols for this module. On Win32, this
    // information is contained within the IMAGE_DEBUG_DIRECTORY.
    //
    // Derived classes: DkmCustomSymbolFileId, DkmDynamicSymbolFileId, DkmPdbFileId
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("950eb6d7-86fd-e311-6d68-d8b12705fa7e") DkmSymbolFileId : public IUnknown
    {
        private: ___ReferenceCount_t m_ReferenceCount;
        private: DkmDispatcherObjectFlags_t m_ObjectFlags;
        private: const GUID* m_pTypeId;
        private: size_t m_ObjectGCHandle;
        // Use DkmSymbolFileId::Create to create this object
        private: DkmSymbolFileId();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmSymbolFileId();
        // This object cannot be copied
        private: DkmSymbolFileId& operator=(const DkmSymbolFileId&);
        private: DkmSymbolFileId(const DkmSymbolFileId&);

        // DkmSymbolFileId is an abstract base class. This enum indicates which derived class
        // this object is an instance of.
        public: FORWARD_DECLARE_SCOPED_ENUM(Tag);
        DEFINE_SCOPED_ENUM(Tag)
        {
        // Object is an instance of 'DkmPdbFileId'.
        PdbFileId = 0,
        // Object is an instance of 'DkmDynamicSymbolFileId'.
        DynamicSymbolFileId = 1,
        // Object is an instance of 'DkmCustomSymbolFileId'.
        CustomSymbolFileId = 2
        };

        private: const Tag_t m_TagValue;
        private: const GUID m_SymbolProviderId;
        private: void* m__pExtendedData;

        // DkmSymbolFileId is an abstract base class. This enum indicates which derived class
        // this object is an instance of.
        public: DECLSPEC_NOTHROW Tag_t STDMETHODCALLTYPE TagValue(
            );

        // Unique identifier for symbol files/symbol providers.
        public: DECLSPEC_NOTHROW const GUID& STDMETHODCALLTYPE SymbolProviderId(
            );
    }; // end of DkmSymbolFileId

    // Unique identifier for symbol files/symbol providers.
    struct DkmSymbolProviderId
    {
        // Reads symbol information from PDB/DBG files to decode native binaries.
        // NativePDB is defined as {49d083cd-f393-4383-ad44-a47eb2bc828d}.
        static const GUID NativePDB;
        // Reads symbol information from PDB files to decode .NET Framework (CLR) binaries.
        // ClrPDB is defined as {65d1b391-203b-447f-b728-8ef09afd0700}.
        static const GUID ClrPDB;
        // Provides symbol resolution from Metadata and a remote symbol store for .NET
        // Framework (CLR) binaries. This is used for dynamically compiled managed code. It
        // is also used for ASP.NET scenario where code is compiled on server side.
        // ClrRemoteSymbolStore is defined as {44c755dc-5352-4cb4-b2a3-e191a830e4c2}.
        static const GUID ClrRemoteSymbolStore;
        // Provides symbol resolution for Microsoft ActiveScript based dynamic code.
        // ActiveScript is defined as {19f50567-6366-44eb-8cde-17b4aed587f8}.
        static const GUID ActiveScript;
        // Reads symbol information from PDB in D3D blob to decode HLSL binaries.
        // HlslPDB is defined as {2257dd93-7ecc-4188-8b6b-c28eb4eb150b}.
        static const GUID HlslPDB;
        // Reads symbol information from PDB files to decode DPC++ binaries.
        // DpcppPDB is defined as {343c264f-ea05-497b-b6c5-467d7d2f449c}.
        static const GUID DpcppPDB;
        // Provides symbol resolution for Microsoft ActiveScript based dynamic code.  This is
        // the symbol provider used when interop debugging Script code with other runtimes.
        // ActiveScriptInterop is defined as {92c7681f-2316-4ff6-bd6c-5b771ba9418a}.
        static const GUID ActiveScriptInterop;
        // Reads symbol information from a native-compiled CLR PDB file.
        // ClrNcPDB is defined as {ea0c854b-5b02-45f6-9d05-73218267c89d}.
        static const GUID ClrNcPDB;
        // Reads symbol information from PDB files to decode DPC++ binaries. This is
        // associated with GPU interop D3D runtime.
        // DpcppInteropPDB is defined as {4cd19a22-4496-4357-ad5b-ff10856d62d9}.
        static const GUID DpcppInteropPDB;
    };
    __declspec(selectany) const GUID DkmSymbolProviderId::NativePDB = { 0x49d083cd, 0xf393, 0x4383, { 0xad, 0x44, 0xa4, 0x7e, 0xb2, 0xbc, 0x82, 0x8d } };
    __declspec(selectany) const GUID DkmSymbolProviderId::ClrPDB = { 0x65d1b391, 0x203b, 0x447f, { 0xb7, 0x28, 0x8e, 0xf0, 0x9a, 0xfd, 0x7, 0x0 } };
    __declspec(selectany) const GUID DkmSymbolProviderId::ClrRemoteSymbolStore = { 0x44c755dc, 0x5352, 0x4cb4, { 0xb2, 0xa3, 0xe1, 0x91, 0xa8, 0x30, 0xe4, 0xc2 } };
    __declspec(selectany) const GUID DkmSymbolProviderId::ActiveScript = { 0x19f50567, 0x6366, 0x44eb, { 0x8c, 0xde, 0x17, 0xb4, 0xae, 0xd5, 0x87, 0xf8 } };
    __declspec(selectany) const GUID DkmSymbolProviderId::HlslPDB = { 0x2257dd93, 0x7ecc, 0x4188, { 0x8b, 0x6b, 0xc2, 0x8e, 0xb4, 0xeb, 0x15, 0xb } };
    __declspec(selectany) const GUID DkmSymbolProviderId::DpcppPDB = { 0x343c264f, 0xea05, 0x497b, { 0xb6, 0xc5, 0x46, 0x7d, 0x7d, 0x2f, 0x44, 0x9c } };
    __declspec(selectany) const GUID DkmSymbolProviderId::ActiveScriptInterop = { 0x92c7681f, 0x2316, 0x4ff6, { 0xbd, 0x6c, 0x5b, 0x77, 0x1b, 0xa9, 0x41, 0x8a } };
    __declspec(selectany) const GUID DkmSymbolProviderId::ClrNcPDB = { 0xea0c854b, 0x5b02, 0x45f6, { 0x9d, 0x5, 0x73, 0x21, 0x82, 0x67, 0xc8, 0x9d } };
    __declspec(selectany) const GUID DkmSymbolProviderId::DpcppInteropPDB = { 0x4cd19a22, 0x4496, 0x4357, { 0xad, 0x5b, 0xff, 0x10, 0x85, 0x6d, 0x62, 0xd9 } };

    // The custom debug info is populated when a module loads and the debug monitor does not
    // understand the content of the debug directory.
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("c25228a7-de43-2abc-1da8-5cb744e0e75e") DkmCustomSymbolFileId : public Symbols::DkmSymbolFileId
    {
        // Use DkmCustomSymbolFileId::Create to create this object
        private: DkmCustomSymbolFileId();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmCustomSymbolFileId();
        // This object cannot be copied
        private: DkmCustomSymbolFileId& operator=(const DkmCustomSymbolFileId&);
        private: DkmCustomSymbolFileId(const DkmCustomSymbolFileId&);

        private: const UINT32 m_Type;
        private: DkmReadOnlyCollection<BYTE>* const m_pData;
        private: void* m__pExtendedData;

        // 'Type' value from the IMAGE_DEBUG_DIRECTORY. For example,
        // IMAGE_DEBUG_TYPE_CODEVIEW (2) is used for PDB files. See winnt.h for a complete
        // listing.
        public: DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE Type(
            );

        // Raw bytes from the PE file header.
        public: _Ret_ DECLSPEC_NOTHROW DkmReadOnlyCollection<BYTE>* STDMETHODCALLTYPE Data(
            );

        // Attempt to cast a 'DkmSymbolFileId' to a 'DkmCustomSymbolFileId'. Return
        // NULL if the path object is not a 'DkmCustomSymbolFileId'.
        // pCustomSymbolFileId : [In,Optional] Object to attempt to cast
        // Return Value : [Optional] Result of the cast.
        public: static DECLSPEC_NOTHROW DkmCustomSymbolFileId* TryCast(
            DkmSymbolFileId* pSymbolFileId
            )
        {
            if (pSymbolFileId == NULL || pSymbolFileId->TagValue() != Tag::CustomSymbolFileId)
                return NULL;

            return static_cast<DkmCustomSymbolFileId*>(pSymbolFileId);
        }

        /// <summary>
        /// Create a new DkmCustomSymbolFileId object instance.
        /// </summary>
        /// <param name="SymbolProviderId">
        /// [In] Unique identifier for symbol files/symbol providers.
        /// </param>
        /// <param name="Type">
        /// [In] 'Type' value from the IMAGE_DEBUG_DIRECTORY. For example,
        /// IMAGE_DEBUG_TYPE_CODEVIEW (2) is used for PDB files. See winnt.h for a complete
        /// listing.
        /// </param>
        /// <param name="pData">
        /// [In] Raw bytes from the PE file header.
        /// </param>
        /// <param name="ppCreatedObject">
        /// [Out] Result of this method call.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ const GUID& SymbolProviderId,
            _In_ UINT32 Type,
            _In_ DkmReadOnlyCollection<BYTE>* pData,
            _Deref_out_ Symbols::DkmCustomSymbolFileId** ppCreatedObject
            );
    }; // end of DkmCustomSymbolFileId

    // This is used for in-memory dynamic modules when doing managed debugging.
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("22e890de-40f9-2415-edf0-d3b5014acd22") DkmDynamicSymbolFileId : public Symbols::DkmSymbolFileId
    {
        // Use DkmDynamicSymbolFileId::Create to create this object
        private: DkmDynamicSymbolFileId();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmDynamicSymbolFileId();
        // This object cannot be copied
        private: DkmDynamicSymbolFileId& operator=(const DkmDynamicSymbolFileId&);
        private: DkmDynamicSymbolFileId(const DkmDynamicSymbolFileId&);

        private: void* m__pExtendedData;

        // Attempt to cast a 'DkmSymbolFileId' to a 'DkmDynamicSymbolFileId'. Return
        // NULL if the path object is not a 'DkmDynamicSymbolFileId'.
        // pDynamicSymbolFileId : [In,Optional] Object to attempt to cast
        // Return Value : [Optional] Result of the cast.
        public: static DECLSPEC_NOTHROW DkmDynamicSymbolFileId* TryCast(
            DkmSymbolFileId* pSymbolFileId
            )
        {
            if (pSymbolFileId == NULL || pSymbolFileId->TagValue() != Tag::DynamicSymbolFileId)
                return NULL;

            return static_cast<DkmDynamicSymbolFileId*>(pSymbolFileId);
        }

        /// <summary>
        /// Create a new DkmDynamicSymbolFileId object instance.
        /// </summary>
        /// <param name="SymbolProviderId">
        /// [In] Unique identifier for symbol files/symbol providers.
        /// </param>
        /// <param name="ppCreatedObject">
        /// [Out] Result of this method call.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ const GUID& SymbolProviderId,
            _Deref_out_ Symbols::DkmDynamicSymbolFileId** ppCreatedObject
            );
    }; // end of DkmDynamicSymbolFileId

    // Contains the information which is in the 'RSDS' section of the module's debug
    // directory. The Mvid portion of this information is in the Mvid immutable.
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("3c1bf10d-a25c-9c9f-3f20-27ad8165d1df") DkmPdbFileId : public Symbols::DkmSymbolFileId
    {
        // Use DkmPdbFileId::Create to create this object
        private: DkmPdbFileId();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmPdbFileId();
        // This object cannot be copied
        private: DkmPdbFileId& operator=(const DkmPdbFileId&);
        private: DkmPdbFileId(const DkmPdbFileId&);

        private: const GUID m_Mvid;
        private: const UINT32 m_Age;
        private: DkmString* const m_pPdbName;
        private: void* m__pExtendedData;

        // Module Version Identifier from the loaded module. This is a unique value which is
        // embedded in an exe/dll by linkers/compilers when the dll/exe is built. A new value
        // is generated each time that the dll/exe is compiled.
        public: DECLSPEC_NOTHROW const GUID& STDMETHODCALLTYPE Mvid(
            );

        // Age of the PDB. This is essentially a timestamp value which is embedded in an
        // exe/dll by linkers/compilers when the dll/exe is built.
        public: DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE Age(
            );

        // The name of the PDB file containing the debug information. This value is often a
        // file path (ex: c:\myproject\bin\debug\myproject.pdb), but in some build
        // environments it may be shortened to just a file name (ex: kernel32.pdb).
        public: _Ret_ DECLSPEC_NOTHROW DkmString* STDMETHODCALLTYPE PdbName(
            );

        // Attempt to cast a 'DkmSymbolFileId' to a 'DkmPdbFileId'. Return
        // NULL if the path object is not a 'DkmPdbFileId'.
        // pPdbFileId : [In,Optional] Object to attempt to cast
        // Return Value : [Optional] Result of the cast.
        public: static DECLSPEC_NOTHROW DkmPdbFileId* TryCast(
            DkmSymbolFileId* pSymbolFileId
            )
        {
            if (pSymbolFileId == NULL || pSymbolFileId->TagValue() != Tag::PdbFileId)
                return NULL;

            return static_cast<DkmPdbFileId*>(pSymbolFileId);
        }

        /// <summary>
        /// Create a new DkmPdbFileId object instance.
        /// </summary>
        /// <param name="SymbolProviderId">
        /// [In] Unique identifier for symbol files/symbol providers.
        /// </param>
        /// <param name="Mvid">
        /// [In] Module Version Identifier from the loaded module. This is a unique value
        /// which is embedded in an exe/dll by linkers/compilers when the dll/exe is built. A
        /// new value is generated each time that the dll/exe is compiled.
        /// </param>
        /// <param name="Age">
        /// [In] Age of the PDB. This is essentially a timestamp value which is embedded in
        /// an exe/dll by linkers/compilers when the dll/exe is built.
        /// </param>
        /// <param name="pPdbName">
        /// [In] The name of the PDB file containing the debug information. This value is
        /// often a file path (ex: c:\myproject\bin\debug\myproject.pdb), but in some build
        /// environments it may be shortened to just a file name (ex: kernel32.pdb).
        /// </param>
        /// <param name="ppCreatedObject">
        /// [Out] Result of this method call.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ const GUID& SymbolProviderId,
            _In_ const GUID& Mvid,
            _In_ UINT32 Age,
            _In_ DkmString* pPdbName,
            _Deref_out_ Symbols::DkmPdbFileId** ppCreatedObject
            );
    }; // end of DkmPdbFileId

    // Resolved document object which is created from a successful call to
    // DkmModule.FindMappedDocuments or DkmScriptDocument.TryMappedResolve. This contains the
    // information to map requests in server-side documents into requests on the client-side
    // document.
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("a2390517-8273-fd47-12dc-fc0d945fa1a1") DkmResolvedMappedDocument : public Symbols::DkmResolvedDocument
    {
        // Use DkmResolvedMappedDocument::Create to create this object
        private: DkmResolvedMappedDocument();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmResolvedMappedDocument();
        // This object cannot be copied
        private: DkmResolvedMappedDocument& operator=(const DkmResolvedMappedDocument&);
        private: DkmResolvedMappedDocument(const DkmResolvedMappedDocument&);

        private: OPTIONAL DkmReadOnlyCollection<Script::DkmScriptBlockMappingInfo*>* const m_pScriptBlocks;
        private: void* m__pExtendedData;

        // [Optional] Collection of script blocks in the project item document.
        public: _Ret_opt_ DECLSPEC_NOTHROW DkmReadOnlyCollection<Script::DkmScriptBlockMappingInfo*>* STDMETHODCALLTYPE ScriptBlocks(
            );

        /// <summary>
        /// Creates a new resolved mapped document object. This API is typically called by
        /// the script local agent.
        /// </summary>
        /// <param name="pModule">
        /// [In] The DkmModule class represents a code bundle (ex: dll or exe) which is or
        /// once was loaded into one or more processes. The DkmModule class is the central
        /// object to the symbol APIs, and is 1:1 with the symbol handler's notation of what
        /// is loaded. If a code bundle loads into three different processes (or the same
        /// process but with three different base addresses or three different app domains)
        /// but the symbol handler thinks of all of these as being identical, there will be
        /// only one module object.
        /// </param>
        /// <param name="pDocumentName">
        /// [In] Name of the source file. This is generally a full path, but in some
        /// scenarios it make be a partial path or just a name with extension (ex:
        /// example.cpp). In the case of a dynamic document (ex: running script from internet
        /// explorer) 'Path' could be a URL rather than a local file path.
        /// </param>
        /// <param name="pScriptDocument">
        /// [In,Optional] Script document which this resolved document represents. This
        /// should be null for non script-based symbol providers.
        /// </param>
        /// <param name="MatchStrength">
        /// [In] Indicates how strong of a match there was between the DkmDocumentQuery and
        /// the resulting DkmResolvedDocument.
        /// </param>
        /// <param name="Warning">
        /// [In] Warning that occurred during the match. Depending on context, these may need
        /// to be surfaced to the user.
        /// </param>
        /// <param name="TextRequested">
        /// [In] If true, return the source text.
        /// </param>
        /// <param name="pScriptBlocks">
        /// [In,Optional] Collection of script blocks in the project item document.
        /// </param>
        /// <param name="DataItem">
        /// [In] Data object to add to the new DkmResolvedMappedDocument instance.
        /// DkmDataItem::Null() in the case that the caller doesn't need to add a data item.
        /// </param>
        /// <param name="ppCreatedObject">
        /// [Out] Result of this method call.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ Symbols::DkmModule* pModule,
            _In_ DkmString* pDocumentName,
            _In_opt_ Script::DkmScriptDocument* pScriptDocument,
            _In_ Symbols::DkmDocumentMatchStrength_t MatchStrength,
            _In_ Symbols::DkmResolvedDocumentWarning_t Warning,
            _In_ bool TextRequested,
            _In_opt_ DkmReadOnlyCollection<Script::DkmScriptBlockMappingInfo*>* pScriptBlocks,
            _In_ const DkmDataItem& DataItem,
            _Deref_out_ Symbols::DkmResolvedMappedDocument** ppCreatedObject
            );
    }; // end of DkmResolvedMappedDocument

}; // end namespace Symbols

// Contains types used for resolving function names to instruction addresses/symbols such
// as for setting function breakpoints.
namespace FunctionResolution {
    // Flags which affect how a search should be performed.
    DEFINE_SCOPED_ENUM(DkmAddressSearchFlags)
    {
        // Input expression contains a wildcard search to bind.
        UseWildcard = 0x1
    };
    DEFINE_SCOPED_ENUM_FLAG_OPERATORS(DkmAddressSearchFlags_t);

    // Result of an asynchronous DkmRuntimeFunctionResolutionRequest.OnFunctionResolved call.
    struct DkmOnFunctionResolvedAsyncResult
    {
        // HRESULT code returned from the caller. This will be
        // DkmExceptionCode.COR_E_OPERATIONCANCELED (0x8013153B) if the operation was
        // canceled before processing was complete.
        HRESULT ErrorCode;
    };

    // Result of an asynchronous DkmRuntimeFunctionResolutionRequest.OnResolverMessage call.
    struct DkmOnResolverMessageAsyncResult
    {
        // HRESULT code returned from the caller. This will be
        // DkmExceptionCode.COR_E_OPERATIONCANCELED (0x8013153B) if the operation was
        // canceled before processing was complete.
        HRESULT ErrorCode;
    };

    // DkmRuntimeFunctionResolutionRequest represents an expression to be parsed and
    // evaluated by a runtime based expression evaluator and is bound to a particular
    // process. Resolutions will send DkmModuleInstance::FunctionResolved events.
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("b102c225-ea38-8242-7787-f48cda1e12e9") DkmRuntimeFunctionResolutionRequest : public DkmDataContainer
    {
        // Use DkmRuntimeFunctionResolutionRequest::Create to create this object
        private: DkmRuntimeFunctionResolutionRequest();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmRuntimeFunctionResolutionRequest();
        // This object cannot be copied
        private: DkmRuntimeFunctionResolutionRequest& operator=(const DkmRuntimeFunctionResolutionRequest&);
        private: DkmRuntimeFunctionResolutionRequest(const DkmRuntimeFunctionResolutionRequest&);

        private: const GUID m_UniqueId;
        private: DkmProcess* const m_pProcess;
        private: const Evaluation::DkmCompilerId m_CompilerId;
        private: DkmString* const m_pFunctionName;
        private: const UINT32 m_LineOffset;
        private: DkmString* const m_pModuleName;
        private: const FunctionResolution::DkmAddressSearchFlags_t m_SearchFlags;
        private: void* m__pExtendedData;

        // Uniquely identifies the DkmRuntimeFunctionResolutionRequest object.
        public: DECLSPEC_NOTHROW const GUID& STDMETHODCALLTYPE UniqueId(
            );

        // DkmProcess represents a target process which is being debugged. The debugger
        // debugs processes, so this is the basic unit of debugging. A DkmProcess can
        // represent a system process or a virtual process such as minidumps.
        public: _Ret_ DECLSPEC_NOTHROW DkmProcess* STDMETHODCALLTYPE Process(
            );

        // Language/Vendor of the request. Vendor is usually set to Guid.Empty. Language and
        // vendor will be set to Guid.Empty for function breakpoints set with an 'Unknown'
        // language.
        public: DECLSPEC_NOTHROW const Evaluation::DkmCompilerId& STDMETHODCALLTYPE CompilerId(
            );

        // The name of the function to resolve to.
        public: _Ret_ DECLSPEC_NOTHROW DkmString* STDMETHODCALLTYPE FunctionName(
            );

        // The line offset from the start of the function to bind to.
        public: DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE LineOffset(
            );

        // The name of the module to resolve to.
        public: _Ret_ DECLSPEC_NOTHROW DkmString* STDMETHODCALLTYPE ModuleName(
            );

        // Flags which affect how a search should be performed.
        public: DECLSPEC_NOTHROW FunctionResolution::DkmAddressSearchFlags_t STDMETHODCALLTYPE SearchFlags(
            );

        /// <summary>
        /// Closes the DkmRuntimeFunctionResolutionRequest object. Once this is closed, no
        /// new resolutions will be sent.
        ///
        /// DkmRuntimeFunctionResolutionRequest objects are automatically closed when their
        /// associated DkmProcess object is closed.
        ///
        /// This method may only be called by the component which created the object.
        /// </summary>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Close(
            );

        /// <summary>
        /// Create a new DkmRuntimeFunctionResolutionRequest object instance. The caller is
        /// responsible for closing the created object after they are done.
        /// </summary>
        /// <param name="pProcess">
        /// [In] DkmProcess represents a target process which is being debugged. The debugger
        /// debugs processes, so this is the basic unit of debugging. A DkmProcess can
        /// represent a system process or a virtual process such as minidumps.
        /// </param>
        /// <param name="CompilerId">
        /// [In] Language/Vendor of the request. Vendor is usually set to Guid.Empty.
        /// Language and vendor will be set to Guid.Empty for function breakpoints set with
        /// an 'Unknown' language.
        /// </param>
        /// <param name="pFunctionName">
        /// [In] The name of the function to resolve to.
        /// </param>
        /// <param name="LineOffset">
        /// [In] The line offset from the start of the function to bind to.
        /// </param>
        /// <param name="pModuleName">
        /// [In] The name of the module to resolve to.
        /// </param>
        /// <param name="SearchFlags">
        /// [In] Flags which affect how a search should be performed.
        /// </param>
        /// <param name="DataItem">
        /// [In] Data object to add to the new DkmRuntimeFunctionResolutionRequest instance.
        /// DkmDataItem::Null() in the case that the caller doesn't need to add a data item.
        /// </param>
        /// <param name="ppCreatedObject">
        /// [Out] Result of this method call.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ DkmProcess* pProcess,
            _In_ const Evaluation::DkmCompilerId& CompilerId,
            _In_ DkmString* pFunctionName,
            _In_ UINT32 LineOffset,
            _In_ DkmString* pModuleName,
            _In_ FunctionResolution::DkmAddressSearchFlags_t SearchFlags,
            _In_ const DkmDataItem& DataItem,
            _Deref_out_ FunctionResolution::DkmRuntimeFunctionResolutionRequest** ppCreatedObject
            );

        /// <summary>
        /// Called by the breakpoint manager to add a pending resolve request. Expression
        /// evaluators, or other components will immediately try to bind the breakpoint
        /// against current modules, and will bind the breakpoint to additional locations as
        /// modules load. The caller of this interface should implement
        /// IDkmRuntimeFunctionResolverClient to obtain the results of the resolution.
        ///
        /// Implementations of this interface should stop attempting to bind the breakpoint
        /// when the DkmRuntimeFunctionResolutionRequest object is closed.
        ///
        /// This method will append a new work item to the specified work list, and return
        /// once the work item has been appended. The actual processing of the work item is
        /// asynchronous. The caller will be notified that the request is complete through
        /// the completion routine.
        /// </summary>
        /// <param name="pWorkList">
        /// WorkList to append the new work item to.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE EnableResolution(
            _In_ DkmWorkList* pWorkList
            );

        #ifndef EXCLUDE_MONITOR_ONLY_APIS
        /// <summary>
        /// Called by runtime function resolvers when a new resolution has been discovered
        /// for a DkmRuntimeFunctionResolutionRequest instance.
        ///
        /// Location constraint: API must be called from a Monitor component (component level
        /// &lt; 100,000).
        /// </summary>
        /// <param name="pAddress">
        /// [In] The address the request bound to. Multiple addresses will result in multiple
        /// calls to this function.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE OnFunctionResolved(
            _In_ DkmInstructionAddress* pAddress
            );
        #endif // #ifndef EXCLUDE_MONITOR_ONLY_APIS

        #ifndef EXCLUDE_MONITOR_ONLY_APIS
        /// <summary>
        /// Called by runtime function resolvers when a new resolution has been discovered
        /// for a DkmRuntimeFunctionResolutionRequest instance.
        ///
        /// This method will append a new work item to the specified work list, and return
        /// once the work item has been appended. The actual processing of the work item is
        /// asynchronous. The caller will be notified that the request is complete through
        /// the completion routine.
        ///
        /// Location constraint: API must be called from a Monitor component (component level
        /// &lt; 100,000).
        /// </summary>
        /// <param name="pWorkList">
        /// WorkList to append the new work item to.
        /// </param>
        /// <param name="pAddress">
        /// [In] The address the request bound to. Multiple addresses will result in multiple
        /// calls to this function.
        /// </param>
        /// <param name="pCompletionRoutine">
        /// Routine to fire when the request is complete. If the request is successfully
        /// appended to the work list, this will always fire (including when the operation is
        /// canceled). This will never fire if appending the work item fails.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE OnFunctionResolved(
            _In_ DkmWorkList* pWorkList,
            _In_ DkmInstructionAddress* pAddress,
            _In_ IDkmCompletionRoutine<FunctionResolution::DkmOnFunctionResolvedAsyncResult>* pCompletionRoutine
            );
        #endif // #ifndef EXCLUDE_MONITOR_ONLY_APIS

        #ifndef EXCLUDE_MONITOR_ONLY_APIS
        /// <summary>
        /// Called by runtime function resolvers when the resolver wishes to notify its
        /// client an error/warning occurred while attempting to resolve the breakpoint.
        ///
        /// Location constraint: API must be called from a Monitor component (component level
        /// &lt; 100,000).
        /// </summary>
        /// <param name="Level">
        /// [In] Describes the severity of a message sent from a breakpoint manager back to
        /// the source component. This list is sorted in order of priority, as the UI will
        /// only display the most important warning. All warnings are ignored if the
        /// breakpoint is bound.
        /// </param>
        /// <param name="pMessage">
        /// [In] Message string to display to the user.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE OnResolverMessage(
            _In_ Breakpoints::DkmBreakpointMessageLevel_t Level,
            _In_ DkmString* pMessage
            );
        #endif // #ifndef EXCLUDE_MONITOR_ONLY_APIS

        #ifndef EXCLUDE_MONITOR_ONLY_APIS
        /// <summary>
        /// Called by runtime function resolvers when the resolver wishes to notify its
        /// client an error/warning occurred while attempting to resolve the breakpoint.
        ///
        /// This method will append a new work item to the specified work list, and return
        /// once the work item has been appended. The actual processing of the work item is
        /// asynchronous. The caller will be notified that the request is complete through
        /// the completion routine.
        ///
        /// Location constraint: API must be called from a Monitor component (component level
        /// &lt; 100,000).
        /// </summary>
        /// <param name="pWorkList">
        /// WorkList to append the new work item to.
        /// </param>
        /// <param name="Level">
        /// [In] Describes the severity of a message sent from a breakpoint manager back to
        /// the source component. This list is sorted in order of priority, as the UI will
        /// only display the most important warning. All warnings are ignored if the
        /// breakpoint is bound.
        /// </param>
        /// <param name="pMessage">
        /// [In] Message string to display to the user.
        /// </param>
        /// <param name="pCompletionRoutine">
        /// Routine to fire when the request is complete. If the request is successfully
        /// appended to the work list, this will always fire (including when the operation is
        /// canceled). This will never fire if appending the work item fails.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE OnResolverMessage(
            _In_ DkmWorkList* pWorkList,
            _In_ Breakpoints::DkmBreakpointMessageLevel_t Level,
            _In_ DkmString* pMessage,
            _In_ IDkmCompletionRoutine<FunctionResolution::DkmOnResolverMessageAsyncResult>* pCompletionRoutine
            );
        #endif // #ifndef EXCLUDE_MONITOR_ONLY_APIS
    }; // end of DkmRuntimeFunctionResolutionRequest

    // DkmSymbolFunctionResolutionRequest represents an expression to be parsed and evaluated
    // by a symbol based expression evaluator and is not bound to a particular process. Used
    // to perform function breakpoint binds.
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("365bd4a2-61ab-b70d-48f4-ed41bfdf9a87") DkmSymbolFunctionResolutionRequest : public IUnknown
    {
        private: ___ReferenceCount_t m_ReferenceCount;
        private: DkmDispatcherObjectFlags_t m_ObjectFlags;
        private: const GUID* m_pTypeId;
        private: size_t m_ObjectGCHandle;
        // Use DkmSymbolFunctionResolutionRequest::Create to create this object
        private: DkmSymbolFunctionResolutionRequest();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmSymbolFunctionResolutionRequest();
        // This object cannot be copied
        private: DkmSymbolFunctionResolutionRequest& operator=(const DkmSymbolFunctionResolutionRequest&);
        private: DkmSymbolFunctionResolutionRequest(const DkmSymbolFunctionResolutionRequest&);

        private: DkmProcess* const m_pProcess;
        private: OPTIONAL Symbols::DkmModule* const m_pModule;
        private: Evaluation::DkmLanguage* const m_pLanguage;
        private: DkmString* const m_pFunctionName;
        private: const UINT32 m_LineOffset;
        private: DkmString* const m_pModuleName;
        private: const FunctionResolution::DkmAddressSearchFlags_t m_SearchFlags;
        private: void* m__pExtendedData;

        // DkmProcess represents a target process which is being debugged. The debugger
        // debugs processes, so this is the basic unit of debugging. A DkmProcess can
        // represent a system process or a virtual process such as minidumps.
        public: _Ret_ DECLSPEC_NOTHROW DkmProcess* STDMETHODCALLTYPE Process(
            );

        // [Optional] The module to bind against. If null, then all modules should be
        // checked. If the module's name does not match the module name parameter, no bind
        // will occur.
        public: _Ret_opt_ DECLSPEC_NOTHROW Symbols::DkmModule* STDMETHODCALLTYPE Module(
            );

        // Describes a programming language.
        public: _Ret_ DECLSPEC_NOTHROW Evaluation::DkmLanguage* STDMETHODCALLTYPE Language(
            );

        // Source text of the parsed expression.
        public: _Ret_ DECLSPEC_NOTHROW DkmString* STDMETHODCALLTYPE FunctionName(
            );

        // The line offset from the start of the function to bind to.
        public: DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE LineOffset(
            );

        // Module name to bind in.
        public: _Ret_ DECLSPEC_NOTHROW DkmString* STDMETHODCALLTYPE ModuleName(
            );

        // Flags which affect how a search should be performed.
        public: DECLSPEC_NOTHROW FunctionResolution::DkmAddressSearchFlags_t STDMETHODCALLTYPE SearchFlags(
            );

        /// <summary>
        /// Create a new DkmSymbolFunctionResolutionRequest object instance.
        /// </summary>
        /// <param name="pProcess">
        /// [In] DkmProcess represents a target process which is being debugged. The debugger
        /// debugs processes, so this is the basic unit of debugging. A DkmProcess can
        /// represent a system process or a virtual process such as minidumps.
        /// </param>
        /// <param name="pModule">
        /// [In,Optional] The module to bind against. If null, then all modules should be
        /// checked. If the module's name does not match the module name parameter, no bind
        /// will occur.
        /// </param>
        /// <param name="pLanguage">
        /// [In] Describes a programming language.
        /// </param>
        /// <param name="pFunctionName">
        /// [In] Source text of the parsed expression.
        /// </param>
        /// <param name="LineOffset">
        /// [In] The line offset from the start of the function to bind to.
        /// </param>
        /// <param name="pModuleName">
        /// [In] Module name to bind in.
        /// </param>
        /// <param name="SearchFlags">
        /// [In] Flags which affect how a search should be performed.
        /// </param>
        /// <param name="ppCreatedObject">
        /// [Out] Result of this method call.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ DkmProcess* pProcess,
            _In_opt_ Symbols::DkmModule* pModule,
            _In_ Evaluation::DkmLanguage* pLanguage,
            _In_ DkmString* pFunctionName,
            _In_ UINT32 LineOffset,
            _In_ DkmString* pModuleName,
            _In_ FunctionResolution::DkmAddressSearchFlags_t SearchFlags,
            _Deref_out_ FunctionResolution::DkmSymbolFunctionResolutionRequest** ppCreatedObject
            );

        #ifndef EXCLUDE_IDE_ONLY_APIS
        /// <summary>
        /// Resolve an address string to zero or more address symbols. This is used to bind
        /// function breakpoints.
        ///
        /// Location constraint: API must be called from an IDE component (component level
        /// &gt; 100,000).
        /// </summary>
        /// <param name="pAddresses">
        /// [Out] DkmInstructionSymbol[] represents a method in the target process.
        ///
        /// The memory for the DkmArray members is allocated by the method implementation
        /// using DkmAllocBytes/DkmAllocArray. It is freed by the caller using the
        /// CAutoDkmArray template or with DkmFreeMemory and manual element release.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Resolve(
            _Out_ DkmArray<Symbols::DkmInstructionSymbol*>* pAddresses
            );
        #endif // #ifndef EXCLUDE_IDE_ONLY_APIS
    }; // end of DkmSymbolFunctionResolutionRequest

}; // end namespace FunctionResolution

// Contains the types used for call stack walking and call stack frame formatting. This
// also includes types related to processor registers, as registers are tracked per-stack
// frame.
namespace CallStack {
    // Collection of settings that affect how the stack provider formats a DkmStackFrame.
    struct DECLSPEC_UUID("b65c8b37-5df0-a9ca-4492-eda38962e5b0") DkmFrameFormatOptions
    {
        // Flags that indicate what information is requested for a variable.
        Evaluation::DkmVariableInfoFlags_t ArgumentFlags;

        // Flags which affect how the stack provider create DkmStackFrame objects.
        CallStack::DkmFrameNameFormatOptions_t FrameNameFormat;

        // Flags which effect how an input expression should be parsed, compiled or
        // displayed.
        Evaluation::DkmEvaluationFlags_t EvaluationFlags;

        // This is the timeout to be used for potentially slow operations such as a function
        // evaluation. This value is in milliseconds.
        UINT32 Timeout;

        // The radix to use when formatting integer data. Currently supported values are '16'
        // and '10'.
        UINT32 Radix;

        // Release all reference-counted fields within the DkmFrameFormatOptions structure.
        static DECLSPEC_NOTHROW void STDMETHODCALLTYPE Release(
            _In_ DkmFrameFormatOptions* pItem
            )
        {
            // structure requires no cleanup
        }
    };

    // Return result from IDkmMonitorStackWalk.
    struct DECLSPEC_UUID("d4dd7f13-e45e-1045-821a-45827846ead6") DkmMonitorStackWalkResult
    {
        // Status code for the walk.
        CallStack::DkmStackWalkStatus_t Status;

        // [Optional] NextRegisters is required when 'Status' is 'FrameFound'. NextRegisters
        // is used to inform other walkers where the previous walker left off. If an walker
        // fails to return the next registers then the walk will be truncated.
        OPTIONAL CallStack::DkmFrameRegisters* pNextRegisters;

        // [Optional] FrameObject is required when 'Status' is 'FrameFound'. This object
        // contains information about the stack frame.
        OPTIONAL CallStack::DkmStackWalkFrame* pFrameObject;

        // NextStackPointer is required when 'Status' is 'OutsideOfRuntime'. This is used by
        // the stack frame merger to advance the stack walk when frames are encountered which
        // cannot be monitor walked (walking requires symbols). The stack frame merger will
        // not invoke the walker again until it has progressed to this stack pointer value,
        // and the walker should update its state so that the next call to 'WalkNextFrame'
        // retrieves the frame at this position.
        UINT64 NextStackPointer;

        // Release all reference-counted fields within the DkmMonitorStackWalkResult structure.
        static DECLSPEC_NOTHROW void STDMETHODCALLTYPE Release(
            _In_ DkmMonitorStackWalkResult* pItem
            );
    };

    // The limit/base address for the memory containing a thread's stack.
    struct DECLSPEC_UUID("25b9f321-da7e-7b52-ac8c-381d9cbbc176") DkmStackMemoryRange
    {
        // The address where this thread's stack began. Since stacks grow down in Windows,
        // these value will be larger than the limit.
        UINT64 StackBase;

        // The minimum address which is allocated in the stack's range.
        UINT64 StackLimit;

        // Compare an instance of the DkmStackMemoryRange struct to another instance.
        // Return value is as follows:
        // Less than zero:     This instance is less than 'other'.
        // Zero:               This instance is equal to 'other'.
        // Greater than zero:  This instance is greater than 'other'.
        DECLSPEC_NOTHROW int STDMETHODCALLTYPE CompareTo(
            const DkmStackMemoryRange& other
            ) const;

        bool operator==(const DkmStackMemoryRange& rhs) const     { return CompareTo(rhs) == 0; }
        bool operator!=(const DkmStackMemoryRange& rhs) const     { return CompareTo(rhs) != 0; }
        bool operator> (const DkmStackMemoryRange& rhs) const     { return CompareTo(rhs) > 0;  }
        bool operator< (const DkmStackMemoryRange& rhs) const     { return CompareTo(rhs) < 0;  }
        bool operator>=(const DkmStackMemoryRange& rhs) const     { return CompareTo(rhs) >= 0; }
        bool operator<=(const DkmStackMemoryRange& rhs) const     { return CompareTo(rhs) <= 0; }

        // Release all reference-counted fields within the DkmStackMemoryRange structure.
        static DECLSPEC_NOTHROW void STDMETHODCALLTYPE Release(
            _In_ DkmStackMemoryRange* pItem
            )
        {
            // structure requires no cleanup
        }
    };

    // Provides a context for walking async return stacks and task creation stacks.
    //
    // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("be372de0-27f8-fcb3-6a35-27128111cd17") DkmAsyncStackWalkContext : public DkmDataContainer
    {
        // Use DkmAsyncStackWalkContext::Create to create this object
        private: DkmAsyncStackWalkContext();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmAsyncStackWalkContext();
        // This object cannot be copied
        private: DkmAsyncStackWalkContext& operator=(const DkmAsyncStackWalkContext&);
        private: DkmAsyncStackWalkContext(const DkmAsyncStackWalkContext&);

        private: Evaluation::DkmInspectionSession* const m_pInspectionSession;
        private: const GUID m_TaskProviderId;
        private: OPTIONAL CallStack::DkmStackWalkFrame* const m_pTaskIdentityStackFrame;
        private: OPTIONAL CallStack::DkmStackWalkFrame* const m_pInternalStackFrame;
        private: OPTIONAL Evaluation::DkmSuccessEvaluationResult* const m_pFrameObject;
        private: OPTIONAL ParallelTasks::DkmTask* const m_pTask;
        private: OPTIONAL DkmReadOnlyCollection<Evaluation::DkmSuccessEvaluationResult*>* const m_pReturnStackFunctions;
        private: DkmRuntimeInstance* const m_pRuntimeInstance;
        private: const GUID m_UniqueId;
        private: void* m__pExtendedData;

        // The inspection session that owns this task object.
        //
        // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
        public: _Ret_ DECLSPEC_NOTHROW Evaluation::DkmInspectionSession* STDMETHODCALLTYPE InspectionSession(
            );

        // Extensible GUID indicating the task provider which a task is from.
        //
        // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
        public: DECLSPEC_NOTHROW const GUID& STDMETHODCALLTYPE TaskProviderId(
            );

        // [Optional] If this stack walk context refers to a task that is associated with a
        // particular stack frame, specifies the stack frame that this task object is
        // associated with.
        //
        // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
        public: _Ret_opt_ DECLSPEC_NOTHROW CallStack::DkmStackWalkFrame* STDMETHODCALLTYPE TaskIdentityStackFrame(
            );

        // [Optional] Internal stack frame used to perform inspection operations on async
        // frames in the return stack, for example, the CLR requires an ICorDebugFrame to
        // read static fields.
        //
        // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
        public: _Ret_opt_ DECLSPEC_NOTHROW CallStack::DkmStackWalkFrame* STDMETHODCALLTYPE InternalStackFrame(
            );

        // [Optional] Optional evaluation result representing the frame that this stack walk
        // context refers to.  When C++ debugging, this is used to support inspection inside
        // of return stack frames.
        //
        // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
        public: _Ret_opt_ DECLSPEC_NOTHROW Evaluation::DkmSuccessEvaluationResult* STDMETHODCALLTYPE FrameObject(
            );

        // [Optional] Optional task to use for inspection of async frames.
        //
        // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
        public: _Ret_opt_ DECLSPEC_NOTHROW ParallelTasks::DkmTask* STDMETHODCALLTYPE Task(
            );

        // [Optional] For native async frames, specifies an list of available functions in
        // the return stack, from which captured local variables may be extracted from.  Null
        // for managed and JavaScript.
        //
        // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
        public: _Ret_opt_ DECLSPEC_NOTHROW DkmReadOnlyCollection<Evaluation::DkmSuccessEvaluationResult*>* STDMETHODCALLTYPE ReturnStackFunctions(
            );

        // The runtime instance associated with this task object.
        //
        // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
        public: _Ret_ DECLSPEC_NOTHROW DkmRuntimeInstance* STDMETHODCALLTYPE RuntimeInstance(
            );

        // Guid which uniquely identifies this evaluation result.
        //
        // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
        public: DECLSPEC_NOTHROW const GUID& STDMETHODCALLTYPE UniqueId(
            );

        /// <summary>
        /// Create a new DkmAsyncStackWalkContext object instance.
        ///
        /// This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
        /// </summary>
        /// <param name="pInspectionSession">
        /// [In] The inspection session that owns this task object.
        /// </param>
        /// <param name="TaskProviderId">
        /// [In] Extensible GUID indicating the task provider which a task is from.
        /// </param>
        /// <param name="pTaskIdentityStackFrame">
        /// [In,Optional] If this stack walk context refers to a task that is associated with
        /// a particular stack frame, specifies the stack frame that this task object is
        /// associated with.
        /// </param>
        /// <param name="pInternalStackFrame">
        /// [In,Optional] Internal stack frame used to perform inspection operations on async
        /// frames in the return stack, for example, the CLR requires an ICorDebugFrame to
        /// read static fields.
        /// </param>
        /// <param name="pFrameObject">
        /// [In,Optional] Optional evaluation result representing the frame that this stack
        /// walk context refers to.  When C++ debugging, this is used to support inspection
        /// inside of return stack frames.
        /// </param>
        /// <param name="pTask">
        /// [In,Optional] Optional task to use for inspection of async frames.
        /// </param>
        /// <param name="pReturnStackFunctions">
        /// [In,Optional] For native async frames, specifies an list of available functions
        /// in the return stack, from which captured local variables may be extracted from.
        /// Null for managed and JavaScript.
        /// </param>
        /// <param name="pRuntimeInstance">
        /// [In] The runtime instance associated with this task object.
        /// </param>
        /// <param name="DataItem">
        /// [In] Data object to add to the new DkmAsyncStackWalkContext instance.
        /// DkmDataItem::Null() in the case that the caller doesn't need to add a data item.
        /// </param>
        /// <param name="ppCreatedObject">
        /// [Out] Result of this method call.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ Evaluation::DkmInspectionSession* pInspectionSession,
            _In_ const GUID& TaskProviderId,
            _In_opt_ CallStack::DkmStackWalkFrame* pTaskIdentityStackFrame,
            _In_opt_ CallStack::DkmStackWalkFrame* pInternalStackFrame,
            _In_opt_ Evaluation::DkmSuccessEvaluationResult* pFrameObject,
            _In_opt_ ParallelTasks::DkmTask* pTask,
            _In_opt_ DkmReadOnlyCollection<Evaluation::DkmSuccessEvaluationResult*>* pReturnStackFunctions,
            _In_ DkmRuntimeInstance* pRuntimeInstance,
            _In_ const DkmDataItem& DataItem,
            _Deref_out_ CallStack::DkmAsyncStackWalkContext** ppCreatedObject
            );

        #ifndef EXCLUDE_IDE_ONLY_APIS
        /// <summary>
        /// Gets the logged creation stack of this task.
        ///
        /// This method will append a new work item to the specified work list, and return
        /// once the work item has been appended. The actual processing of the work item is
        /// asynchronous. The caller will be notified that the request is complete through
        /// the completion routine.
        ///
        /// Location constraint: API must be called from an IDE component (component level
        /// &gt; 100,000).
        ///
        /// This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
        /// </summary>
        /// <param name="pWorkList">
        /// WorkList to append the new work item to.
        /// </param>
        /// <param name="pThread">
        /// [In] The thread that the resultant frames should belong to.
        /// </param>
        /// <param name="pCompletionRoutine">
        /// Routine to fire when the request is complete. If the request is successfully
        /// appended to the work list, this will always fire (including when the operation is
        /// canceled). This will never fire if appending the work item fails.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetTaskCreationStack(
            _In_ DkmWorkList* pWorkList,
            _In_ DkmThread* pThread,
            _In_ IDkmCompletionRoutine<CallStack::DkmGetTaskCreationStackAsyncResult>* pCompletionRoutine
            );
        #endif // #ifndef EXCLUDE_IDE_ONLY_APIS

        #ifndef EXCLUDE_IDE_ONLY_APIS
        /// <summary>
        /// Returns a list of frames that will execute when this task completes.  The order
        /// that the frames will execute in is arbitrary and might not be the order returned
        /// here.  Only frames that will execute as a direct result of this task are
        /// included, not frames that will execute as a result of another task that will
        /// execute after this task completes.
        ///
        /// This method will append a new work item to the specified work list, and return
        /// once the work item has been appended. The actual processing of the work item is
        /// asynchronous. The caller will be notified that the request is complete through
        /// the completion routine.
        ///
        /// Location constraint: API must be called from an IDE component (component level
        /// &gt; 100,000).
        ///
        /// This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
        /// </summary>
        /// <param name="pWorkList">
        /// WorkList to append the new work item to.
        /// </param>
        /// <param name="pThread">
        /// [In] The thread that the resultant frames should belong to.
        /// </param>
        /// <param name="pCompletionRoutine">
        /// Routine to fire when the request is complete. If the request is successfully
        /// appended to the work list, this will always fire (including when the operation is
        /// canceled). This will never fire if appending the work item fails.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetTaskContinuationFrames(
            _In_ DkmWorkList* pWorkList,
            _In_ DkmThread* pThread,
            _In_ IDkmCompletionRoutine<CallStack::DkmGetTaskContinuationFramesAsyncResult>* pCompletionRoutine
            );
        #endif // #ifndef EXCLUDE_IDE_ONLY_APIS

        /// <summary>
        /// Gets the async call stack of this thread.
        ///
        /// This method will append a new work item to the specified work list, and return
        /// once the work item has been appended. The actual processing of the work item is
        /// asynchronous. The caller will be notified that the request is complete through
        /// the completion routine.
        ///
        /// Location constraint: This API can normally only be called on the client side
        /// normally.  It can be called on the remote side for script.
        ///
        /// This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
        /// </summary>
        /// <param name="pWorkList">
        /// WorkList to append the new work item to.
        /// </param>
        /// <param name="pThread">
        /// [In] The thread that the resultant frames should belong to.
        /// </param>
        /// <param name="pCompletionRoutine">
        /// Routine to fire when the request is complete. If the request is successfully
        /// appended to the work list, this will always fire (including when the operation is
        /// canceled). This will never fire if appending the work item fails.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetAsyncCallStack(
            _In_ DkmWorkList* pWorkList,
            _In_ DkmThread* pThread,
            _In_ IDkmCompletionRoutine<CallStack::DkmGetAsyncCallStackAsyncResult>* pCompletionRoutine
            );
    }; // end of DkmAsyncStackWalkContext

    // Holds the list of implementations of the IDkmCallStackFilter interface which may be
    // called by a component. This object is used to call these stack frame filters.
    class DkmCallStackFilterList : public IUnknown
    {
        private: ___ReferenceCount_t m_ReferenceCount;
        private: const DWORD m_count;

        // Use DkmCallStackFilterList::Create to create this object
        private: DkmCallStackFilterList();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmCallStackFilterList();
        // This object cannot be copied
        private: DkmCallStackFilterList& operator=(const DkmCallStackFilterList&);
        private: DkmCallStackFilterList(const DkmCallStackFilterList&);

        // Returns the number of implemantions of the IDkmCallStackFilter interface which
        // may be called through this object.
        public: inline DECLSPEC_NOTHROW DWORD STDMETHODCALLTYPE Count(
            )
        {
            return m_count;
        }

        #ifndef EXCLUDE_IDE_ONLY_APIS
        /// <summary>
        /// Provides a filter with the next stack frame. A filter can simply pass this frame
        /// on through, it can suppress the frame by returning nothing, or it can provide its
        /// own set of annotated frames. The stack provider will ignore
        /// NotImplementedException (E_NOTIMPL). All other errors will truncate stack walk.
        ///
        /// Location constraint: API must be called from an IDE component (component level
        /// &gt; 100,000).
        /// </summary>
        /// <param name="ImplementationIndex">
        /// [In] Zero-based index into the collection of {0} implementations that the caller
        /// wishes to be invoked. This should be less than the 'Count' property.
        /// </param>
        /// <param name="pStackContext">
        /// [In] DkmStackContext objects are created by components that wish to request the
        /// stack from the stack provider. A component needs to close the context after they
        /// have completed the stack walk. To obtain the stack a component should create this
        /// object and then call GetNextFrames.
        /// </param>
        /// <param name="pInput">
        /// [In,Optional] Input is the next frame to examine. After all frame have been
        /// filtered, this function will be called one last time with a null input frame.
        /// This lets the filter know that the call stack is fully processed.
        /// </param>
        /// <param name="pResult">
        /// [Out] DkmStackWalkFrame[] represents a frame on a call stack which has been
        /// walked, but may not have been formatted or filtered. Formatted frames are
        /// represented by DkmStackFrame instead.
        ///
        /// The memory for the DkmArray members is allocated by the method implementation
        /// using DkmAllocBytes/DkmAllocArray. It is freed by the caller using the
        /// CAutoDkmArray template or with DkmFreeMemory and manual element release.
        /// </param>
        /// <returns>
        /// S_OK is returned if pResult contains any elements, S_FALSE is indicates the array
        /// is empty, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE FilterNextFrame(
            _In_ UINT32 ImplementationIndex,
            _In_ CallStack::DkmStackContext* pStackContext,
            _In_opt_ CallStack::DkmStackWalkFrame* pInput,
            _Out_ DkmArray<CallStack::DkmStackWalkFrame*>* pResult
            );
        #endif // #ifndef EXCLUDE_IDE_ONLY_APIS

        #ifndef EXCLUDE_IDE_ONLY_APIS
        /// <summary>
        /// Create a new DkmCallStackFilterList object instance.
        ///
        /// Location constraint: API must be called from an IDE component (component level
        /// &gt; 100,000).
        /// </summary>
        /// <param name="ppCreatedObject">
        /// [Out] Result of this method call.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _Deref_out_ CallStack::DkmCallStackFilterList** ppCreatedObject
            );
        #endif // #ifndef EXCLUDE_IDE_ONLY_APIS
    };

    // Options for how the call stack should be filtered.
    DEFINE_SCOPED_ENUM(DkmCallStackFilterOptions)
    {
        // No filter option flags are set.
        None = 0x0,
        // Remove frames from the call stack which are in hidden code.
        FilterHiddenFrames = 0x1,
        // Remove non-user code from the call stack.
        FilterNonuserCode = 0x2,
        // Indicates that async frames should be included in the call stack.
        IncludeAsyncFrames = 0x4,
        // If JustMyCode is enabled, indicates that the frames on the topmost block of
        // nonuser code should still be shown.
        ShowTopNonUserBlock = 0x8,
        // If JustMyCode is enabled and ShowTopNonUserBlock is also specified, indicates that
        // frames involved with the implementation of throwing an exception should still be
        // collapsed.
        HideNonUserExceptionImplementationFrames = 0x10
    };
    DEFINE_SCOPED_ENUM_FLAG_OPERATORS(DkmCallStackFilterOptions_t);

    // Flags which affect how the stack provider create DkmStackFrame objects.
    DEFINE_SCOPED_ENUM(DkmFrameNameFormatOptions)
    {
        // No additional information is included in the frame name.
        None = 0x0,
        // Include the module name in the frame name.
        Module = 0x1,
        // Include the number of lines at the end of the frame name.
        Lines = 0x2,
        // Include the byte offset at the end of the frame name.
        ByteOffsets = 0x4,
        // Include the return type in the frame name.
        ReturnType = 0x8,
        // Include the return type field in the frame object.
        ReturnTypeField = 0x10,
        // Include the document position in the frame object.
        DocumentPositionField = 0x20
    };
    DEFINE_SCOPED_ENUM_FLAG_OPERATORS(DkmFrameNameFormatOptions_t);

    // DkmFrameRegisters represents the registers of a stack frame.
    //
    // Derived classes: DkmArmFrameRegisters, DkmX64FrameRegisters, DkmX86FrameRegisters
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("bb64ab72-8d4e-6997-9f89-79436f38133e") DkmFrameRegisters : public IUnknown
    {
        private: ___ReferenceCount_t m_ReferenceCount;
        private: DkmDispatcherObjectFlags_t m_ObjectFlags;
        private: const GUID* m_pTypeId;
        private: size_t m_ObjectGCHandle;
        // Use DkmFrameRegisters::Create to create this object
        private: DkmFrameRegisters();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmFrameRegisters();
        // This object cannot be copied
        private: DkmFrameRegisters& operator=(const DkmFrameRegisters&);
        private: DkmFrameRegisters(const DkmFrameRegisters&);

        // DkmFrameRegisters is an abstract base class. This enum indicates which derived
        // class this object is an instance of.
        public: FORWARD_DECLARE_SCOPED_ENUM(Tag);
        DEFINE_SCOPED_ENUM(Tag)
        {
        // Object is an instance of 'DkmArmFrameRegisters'.
        ArmRegisters = 0,
        // Object is an instance of 'DkmX86FrameRegisters'.
        X86Registers = 1,
        // Object is an instance of 'DkmX64FrameRegisters'.
        X64Registers = 2
        };

        private: const Tag_t m_TagValue;
        private: DkmReadOnlyCollection<CallStack::DkmUnwoundRegister*>* const m_pUnwoundRegisters;
        private: void* m__pExtendedData;

        // DkmFrameRegisters is an abstract base class. This enum indicates which derived
        // class this object is an instance of.
        public: DECLSPEC_NOTHROW Tag_t STDMETHODCALLTYPE TagValue(
            );

        // The register set that was actually unwound by the unwinder.
        public: _Ret_ DECLSPEC_NOTHROW DkmReadOnlyCollection<CallStack::DkmUnwoundRegister*>* STDMETHODCALLTYPE UnwoundRegisters(
            );

        /// <summary>
        /// Returns the processor-independent instruction pointer which is stored in this
        /// frame register object.
        /// </summary>
        /// <param name="pValue">
        /// [Out] Instruction pointer value which is stored in the specified registers
        /// structure (ex: EIP on x86, RIP on x64).
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetInstructionPointer(
            _Out_ UINT64* pValue
            );

        /// <summary>
        /// Returns the processor-independent stack pointer which is stored in this frame
        /// register object.
        /// </summary>
        /// <param name="pValue">
        /// [Out] Stack pointer value which is stored in the specified registers structure
        /// (ex: ESP on x86, RSP on x64).
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetStackPointer(
            _Out_ UINT64* pValue
            );

        /// <summary>
        /// A helper function for searching the array of unwound register values for a
        /// DkmStackWalkFrame. If the register was not unwound, a failed HRESULT is returned.
        /// </summary>
        /// <param name="Id">
        /// [In] The unique constant for the requested register. Normally, this is a cvconst
        /// value such as CV_REG_EIP.
        /// </param>
        /// <param name="pBuffer">
        /// [In,Out] A buffer that receives the value of the register.
        /// </param>
        /// <param name="Size">
        /// [In] The size of the value in bytes.
        /// </param>
        /// <param name="pBytesRead">
        /// [Out,Optional] The caller allocated buffer that receives the contents of the
        /// requested register.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetRegisterValue(
            _In_ UINT32 Id,
            _Out_capcount_(Size) void* pBuffer,
            _In_ UINT32 Size,
            _Out_ UINT32* pBytesRead
            );
    }; // end of DkmFrameRegisters

    // Result of an asynchronous DkmAsyncStackWalkContext.GetAsyncCallStack call.
    struct DkmGetAsyncCallStackAsyncResult
    {
        // HRESULT code returned from the caller. This will be
        // DkmExceptionCode.COR_E_OPERATIONCANCELED (0x8013153B) if the operation was
        // canceled before processing was complete.
        HRESULT ErrorCode;

        // The frames that will display in the call stack window.  May be any combination of
        // creation stack frames, return stack frames, or annotated frames.
        DkmArray<CallStack::DkmStackWalkFrame*> Frames;
    };

    // Result of an asynchronous DkmStackWalkFrame.GetClrGenericParameters call.
    struct DkmGetClrGenericParametersAsyncResult
    {
        // HRESULT code returned from the caller. This will be
        // DkmExceptionCode.COR_E_OPERATIONCANCELED (0x8013153B) if the operation was
        // canceled before processing was complete.
        HRESULT ErrorCode;

        // The list of assembly qualified names for the type parameters, if any, followed by
        // the method parameters, if any.
        DkmArray<DkmString*> ParameterTypeNames;
    };

    #ifndef EXCLUDE_MONITOR_ONLY_APIS
    // Result of an asynchronous DkmAsyncStackWalkContext.GetContinuationFramesFromTaskObject
    // call.
    struct DkmGetContinuationFramesFromTaskObjectAsyncResult
    {
        // HRESULT code returned from the caller. This will be
        // DkmExceptionCode.COR_E_OPERATIONCANCELED (0x8013153B) if the operation was
        // canceled before processing was complete.
        HRESULT ErrorCode;

        // The frames that will execute when this task completes.
        DkmArray<Clr::DkmManagedReturnStackFrame*> ContinuationFrames;
    };
    #endif // #ifndef EXCLUDE_MONITOR_ONLY_APIS

    #ifndef EXCLUDE_IDE_ONLY_APIS
    // Result of an asynchronous DkmThread.GetCurrentLocation call.
    struct DkmGetCurrentLocationAsyncResult
    {
        // HRESULT code returned from the caller. This will be
        // DkmExceptionCode.COR_E_OPERATIONCANCELED (0x8013153B) if the operation was
        // canceled before processing was complete.
        HRESULT ErrorCode;

        // The name of the current location.
        DkmString* pLocationName;
    };
    #endif // #ifndef EXCLUDE_IDE_ONLY_APIS

    // Result of an asynchronous DkmAsyncStackWalkContext.GetManagedTaskContinuationFrames
    // call.
    struct DkmGetManagedTaskContinuationFramesAsyncResult
    {
        // HRESULT code returned from the caller. This will be
        // DkmExceptionCode.COR_E_OPERATIONCANCELED (0x8013153B) if the operation was
        // canceled before processing was complete.
        HRESULT ErrorCode;

        // The frames that will execute when this task completes.
        DkmArray<Clr::DkmManagedReturnStackFrame*> ContinuationFrames;
    };

    #ifndef EXCLUDE_IDE_ONLY_APIS
    // Result of an asynchronous DkmStackContext.GetNextFrames call.
    struct DkmGetNextFramesAsyncResult
    {
        // HRESULT code returned from the caller. This will be
        // DkmExceptionCode.COR_E_OPERATIONCANCELED (0x8013153B) if the operation was
        // canceled before processing was complete.
        HRESULT ErrorCode;

        // [Optional] DkmStackFrame[] represents a frame on the call stack after filtering
        // and translation.
        DkmArray<CallStack::DkmStackFrame*> Frames;
    };
    #endif // #ifndef EXCLUDE_IDE_ONLY_APIS

    // Result of an asynchronous DkmAsyncStackWalkContext.GetTaskContinuationFrames call.
    struct DkmGetTaskContinuationFramesAsyncResult
    {
        // HRESULT code returned from the caller. This will be
        // DkmExceptionCode.COR_E_OPERATIONCANCELED (0x8013153B) if the operation was
        // canceled before processing was complete.
        HRESULT ErrorCode;

        // The frames that will execute when this task completes.
        DkmArray<CallStack::DkmStackWalkFrame*> ContinuationFrames;
    };

    // Result of an asynchronous DkmAsyncStackWalkContext.GetTaskCreationStack call.
    struct DkmGetTaskCreationStackAsyncResult
    {
        // HRESULT code returned from the caller. This will be
        // DkmExceptionCode.COR_E_OPERATIONCANCELED (0x8013153B) if the operation was
        // canceled before processing was complete.
        HRESULT ErrorCode;

        // The creation stack of this task.
        DkmArray<CallStack::DkmStackWalkFrame*> CreationStack;
    };

    // Result of an asynchronous DkmStackWalkContext.HeuristicWalkFrames call.
    struct DkmHeuristicWalkFramesAsyncResult
    {
        // HRESULT code returned from the caller. This will be
        // DkmExceptionCode.COR_E_OPERATIONCANCELED (0x8013153B) if the operation was
        // canceled before processing was complete.
        HRESULT ErrorCode;

        // DkmStackWalkFrame[] represents a frame on a call stack which has been walked, but
        // may not have been formatted or filtered. Formatted frames are represented by
        // DkmStackFrame instead.
        DkmArray<CallStack::DkmStackWalkFrame*> Frames;

        // [Optional] NextRegisters indicates the registers of the next frame (the caller of
        // 'FrameObject'). This will be null if the stack is complete, or if the
        // EndStackPointer was reached.
        OPTIONAL CallStack::DkmFrameRegisters* pNextRegisters;

        // Returns true if the monitor reached the end of the stack.
        bool EndOfStack;
    };

    #ifndef EXCLUDE_MONITOR_ONLY_APIS
    // DkmMonitorStackWalkContext allows the various components DkmSymbolStackWalkContext
    // with this call stack.
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("4ce2f85d-5b40-4a4c-5eba-79e9228e48b1") DkmMonitorStackWalkContext : public DkmDataContainer
    {
        // Use DkmMonitorStackWalkContext::Create to create this object
        private: DkmMonitorStackWalkContext();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmMonitorStackWalkContext();
        // This object cannot be copied
        private: DkmMonitorStackWalkContext& operator=(const DkmMonitorStackWalkContext&);
        private: DkmMonitorStackWalkContext(const DkmMonitorStackWalkContext&);

        private: DkmRuntimeInstance* const m_pRuntimeInstance;
        private: DkmThread* const m_pThread;
        private: OPTIONAL DkmReadOnlyCollection<BYTE>* const m_pThreadContext;
        private: const GUID m_UniqueId;
        private: void* m__pExtendedData;

        // The DkmRuntimeInstance class represents an execution environment which is loaded
        // into a DkmProcess and which contains code to be debugged.
        public: _Ret_ DECLSPEC_NOTHROW DkmRuntimeInstance* STDMETHODCALLTYPE RuntimeInstance(
            );

        // DkmThread represents a thread running in the target process.
        public: _Ret_ DECLSPEC_NOTHROW DkmThread* STDMETHODCALLTYPE Thread(
            );

        // [Optional] The initial Win32 CONTEXT to use when performing the stack walk. This
        // value is normally 'null' but can be set in order to view another call stack (ex:
        // .cxr).
        public: _Ret_opt_ DECLSPEC_NOTHROW DkmReadOnlyCollection<BYTE>* STDMETHODCALLTYPE ThreadContext(
            );

        // Guid which uniquely identifies this DkmMonitorStackWalkContext.
        public: DECLSPEC_NOTHROW const GUID& STDMETHODCALLTYPE UniqueId(
            );

        /// <summary>
        /// Closes a DkmMonitorStackWalkContext object instance. This will release any
        /// resources associated with this object across all components. This includes
        /// resources across computer or managed/native marshalling boundaries.
        ///
        /// DkmMonitorStackWalkContext objects are automatically closed when their associated
        /// DkmThread object is closed.
        ///
        /// This method may only be called by the component which created the object.
        ///
        /// Location constraint: API must be called from a Monitor component (component level
        /// &lt; 100,000).
        /// </summary>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Close(
            );

        /// <summary>
        /// Create a new DkmMonitorStackWalkContext object instance. The caller is
        /// responsible for closing the created object after they are done.
        ///
        /// Location constraint: API must be called from a Monitor component (component level
        /// &lt; 100,000).
        /// </summary>
        /// <param name="pRuntimeInstance">
        /// [In] The DkmRuntimeInstance class represents an execution environment which is
        /// loaded into a DkmProcess and which contains code to be debugged.
        /// </param>
        /// <param name="pThread">
        /// [In] DkmThread represents a thread running in the target process.
        /// </param>
        /// <param name="pThreadContext">
        /// [In,Optional] The initial Win32 CONTEXT to use when performing the stack walk.
        /// This value is normally 'null' but can be set in order to view another call stack
        /// (ex: .cxr).
        /// </param>
        /// <param name="DataItem">
        /// [In] Data object to add to the new DkmMonitorStackWalkContext instance.
        /// DkmDataItem::Null() in the case that the caller doesn't need to add a data item.
        /// </param>
        /// <param name="ppCreatedObject">
        /// [Out] Result of this method call.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ DkmRuntimeInstance* pRuntimeInstance,
            _In_ DkmThread* pThread,
            _In_opt_ DkmReadOnlyCollection<BYTE>* pThreadContext,
            _In_ const DkmDataItem& DataItem,
            _Deref_out_ CallStack::DkmMonitorStackWalkContext** ppCreatedObject
            );

        /// <summary>
        /// Initialize is invoked on each walker exactly once at the beginning of the walk
        /// process. This gives each walker a chance to initialize any state.
        ///
        /// Location constraint: API must be called from a Monitor component (component level
        /// &lt; 100,000).
        /// </summary>
        /// <param name="pRegisters">
        /// [In] Registers to attempt to walk from.
        /// </param>
        /// <param name="StackRangeSize">
        /// [In] Size of the stack range that the debugger will attempt to walk through.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Initialize(
            _In_ CallStack::DkmFrameRegisters* pRegisters,
            _In_ UINT32 StackRangeSize
            );

        /// <summary>
        /// UpdatePosition is invoked by the stack merger after another walker has walked one
        /// or more frames, and so this walker must be updated before invoking WalkNextFrame.
        /// Runtimes that maintain their own internal stack range state within in the target
        /// process will likely have nothing to do within this method.
        ///
        /// Location constraint: API must be called from a Monitor component (component level
        /// &lt; 100,000).
        /// </summary>
        /// <param name="pRegisters">
        /// [In] Registers to attempt to walk from.
        /// </param>
        /// <param name="StackRangeSize">
        /// [In] Size of the stack range that the debugger will attempt to walk through.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE UpdatePosition(
            _In_ CallStack::DkmFrameRegisters* pRegisters,
            _In_ UINT32 StackRangeSize
            );

        /// <summary>
        /// Attempt to walk the next stack frame. The DkmMonitorStackWalkResult structure
        /// indicates if this monitor was able to walk the frame.
        ///
        /// Location constraint: API must be called from a Monitor component (component level
        /// &lt; 100,000).
        /// </summary>
        /// <param name="pResult">
        /// [Out] Return result from IDkmMonitorStackWalk.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE WalkNextFrame(
            _Out_ CallStack::DkmMonitorStackWalkResult* pResult
            );
    }; // end of DkmMonitorStackWalkContext
    #endif // #ifndef EXCLUDE_MONITOR_ONLY_APIS

    // Result of an asynchronous DkmStackWalkContext.RuntimeWalkNextFramesAndCheckCache call.
    struct DkmRuntimeWalkNextFramesAndCheckCacheAsyncResult
    {
        // HRESULT code returned from the caller. This will be
        // DkmExceptionCode.COR_E_OPERATIONCANCELED (0x8013153B) if the operation was
        // canceled before processing was complete.
        HRESULT ErrorCode;

        // Array of walked frames. For, unresolved frames, both InstructionAddress and
        // Description will be null.
        DkmArray<CallStack::DkmStackWalkFrame*> Frames;

        // Returns true if the monitor reached the end of the stack.
        bool EndOfStack;

        // [Optional] The actual hash of the call stack.  This may be NULL for runtimes that
        // don't support call stack hashing.
        OPTIONAL CallStack::DkmStackHash* pActualStackHash;

        // The DkmStackWalkContext object that can used later to continue the walk. If the
        // cache is valid, this is the original context.  If the cache is invalid, this will
        // be a new DkmStackWalkContext object.
        CallStack::DkmStackWalkContext* pActualStackWalkContext;

        // True if the cache was valid, false if not.
        bool IsCacheValid;
    };

    // Result of an asynchronous DkmStackWalkContext.RuntimeWalkNextFrames call.
    struct DkmRuntimeWalkNextFramesAsyncResult
    {
        // HRESULT code returned from the caller. This will be
        // DkmExceptionCode.COR_E_OPERATIONCANCELED (0x8013153B) if the operation was
        // canceled before processing was complete.
        HRESULT ErrorCode;

        // Array of walked frames. For, unresolved frames, both InstructionAddress and
        // Description will be null.
        DkmArray<CallStack::DkmStackWalkFrame*> Frames;

        // Returns true if the monitor reached the end of the stack.
        bool EndOfStack;
    };

    #ifndef EXCLUDE_IDE_ONLY_APIS
    // DkmStackContext objects are created by components that wish to request the stack from
    // the stack provider. A component needs to close the context after they have completed
    // the stack walk. To obtain the stack a component should create this object and then
    // call GetNextFrames.
    //
    // Derived classes: DkmStackTraceContext
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("90f8ca28-617f-0b13-f421-fa6f1159973e") DkmStackContext : public DkmDataContainer
    {
        // Use DkmStackContext::Create to create this object
        private: DkmStackContext();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmStackContext();
        // This object cannot be copied
        private: DkmStackContext& operator=(const DkmStackContext&);
        private: DkmStackContext(const DkmStackContext&);

        // Contains additional fields of DkmStackContext which were added after the class was
        // initally introduced.
        private: struct ___ExtendedData
        {
            ___ExtendedData();

            // [Optional] If we are fetching the continuation frames or task creation frames,
            // specifies the context for the async stack walk operation.
            OPTIONAL CallStack::DkmAsyncStackWalkContext* const pAsyncContext;

            // Which type of stack walk we are doing.  If the operation is
            // AsyncReturnStackWalk or AsyncTaskCreationStackWalk, "Task" must be non-null.
            // Otherwise, "AsyncContext" must be NULL.
            const CallStack::DkmStackWalkOperation_t Operation;
        };

        private: Evaluation::DkmInspectionSession* const m_pInspectionSession;
        private: DkmThread* const m_pThread;
        private: const CallStack::DkmCallStackFilterOptions_t m_FilterOptions;
        private: const CallStack::DkmFrameFormatOptions m_FormatOptions;
        private: OPTIONAL DkmReadOnlyCollection<BYTE>* const m_pThreadContext;
        private: const GUID m_UniqueId;
        private: ___ExtendedData* const m__pExtendedData;

        // DkmInspectionSession allows the various components which inspect data to store
        // private data which is associated with a group of evaluations.
        public: _Ret_ DECLSPEC_NOTHROW Evaluation::DkmInspectionSession* STDMETHODCALLTYPE InspectionSession(
            );

        // DkmThread represents a thread running in the target process.
        public: _Ret_ DECLSPEC_NOTHROW DkmThread* STDMETHODCALLTYPE Thread(
            );

        // Options for how the call stack should be filtered.
        public: DECLSPEC_NOTHROW CallStack::DkmCallStackFilterOptions_t STDMETHODCALLTYPE FilterOptions(
            );

        // Collection of settings that affect how the stack provider formats a DkmStackFrame.
        public: DECLSPEC_NOTHROW const CallStack::DkmFrameFormatOptions& STDMETHODCALLTYPE FormatOptions(
            );

        // [Optional] The initial thread context to use when performing the stack walk. This
        // value is normally 'null' but can be set in order to view another call stack (ex:
        // .cxr).
        public: _Ret_opt_ DECLSPEC_NOTHROW DkmReadOnlyCollection<BYTE>* STDMETHODCALLTYPE ThreadContext(
            );

        // Guid which uniquely identifies this DkmStackContext.
        public: DECLSPEC_NOTHROW const GUID& STDMETHODCALLTYPE UniqueId(
            );

        // [Optional] If we are fetching the continuation frames or task creation frames,
        // specifies the context for the async stack walk operation.
        //
        // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
        public: _Ret_opt_ DECLSPEC_NOTHROW CallStack::DkmAsyncStackWalkContext* STDMETHODCALLTYPE AsyncContext(
            );

        // Which type of stack walk we are doing.  If the operation is AsyncReturnStackWalk
        // or AsyncTaskCreationStackWalk, "Task" must be non-null.  Otherwise, "AsyncContext"
        // must be NULL.
        //
        // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
        public: DECLSPEC_NOTHROW CallStack::DkmStackWalkOperation_t STDMETHODCALLTYPE Operation(
            );

        /// <summary>
        /// Closes a DkmStackContext object instance. This will release any resources
        /// associated with this object across all components. This includes resources across
        /// computer or managed/native marshalling boundaries.
        ///
        /// DkmStackContext objects are automatically closed when their associated
        /// DkmInspectionSession object is closed.
        ///
        /// This method may only be called by the component which created the object.
        ///
        /// Location constraint: API must be called from an IDE component (component level
        /// &gt; 100,000).
        /// </summary>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Close(
            );

        /// <summary>
        /// Create a new DkmStackContext object instance. The caller is responsible for
        /// closing the created object after they are done.
        ///
        /// Location constraint: API must be called from an IDE component (component level
        /// &gt; 100,000).
        /// </summary>
        /// <param name="pInspectionSession">
        /// [In] DkmInspectionSession allows the various components which inspect data to
        /// store private data which is associated with a group of evaluations.
        /// </param>
        /// <param name="pThread">
        /// [In] DkmThread represents a thread running in the target process.
        /// </param>
        /// <param name="FilterOptions">
        /// [In] Options for how the call stack should be filtered.
        /// </param>
        /// <param name="FormatOptions">
        /// [In] Collection of settings that affect how the stack provider formats a
        /// DkmStackFrame.
        /// </param>
        /// <param name="pThreadContext">
        /// [In,Optional] The initial thread context to use when performing the stack walk.
        /// This value is normally 'null' but can be set in order to view another call stack
        /// (ex: .cxr).
        /// </param>
        /// <param name="DataItem">
        /// [In] Data object to add to the new DkmStackContext instance. DkmDataItem::Null()
        /// in the case that the caller doesn't need to add a data item.
        /// </param>
        /// <param name="ppCreatedObject">
        /// [Out] Result of this method call.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ Evaluation::DkmInspectionSession* pInspectionSession,
            _In_ DkmThread* pThread,
            _In_ CallStack::DkmCallStackFilterOptions_t FilterOptions,
            _In_ const CallStack::DkmFrameFormatOptions& FormatOptions,
            _In_opt_ DkmReadOnlyCollection<BYTE>* pThreadContext,
            _In_ const DkmDataItem& DataItem,
            _Deref_out_ CallStack::DkmStackContext** ppCreatedObject
            );

        /// <summary>
        /// Create a new DkmStackContext object instance. The caller is responsible for
        /// closing the created object after they are done.
        ///
        /// Location constraint: API must be called from an IDE component (component level
        /// &gt; 100,000).
        ///
        /// This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
        /// </summary>
        /// <param name="pInspectionSession">
        /// [In] DkmInspectionSession allows the various components which inspect data to
        /// store private data which is associated with a group of evaluations.
        /// </param>
        /// <param name="pThread">
        /// [In] DkmThread represents a thread running in the target process.
        /// </param>
        /// <param name="FilterOptions">
        /// [In] Options for how the call stack should be filtered.
        /// </param>
        /// <param name="FormatOptions">
        /// [In] Collection of settings that affect how the stack provider formats a
        /// DkmStackFrame.
        /// </param>
        /// <param name="pThreadContext">
        /// [In,Optional] The initial thread context to use when performing the stack walk.
        /// This value is normally 'null' but can be set in order to view another call stack
        /// (ex: .cxr).
        /// </param>
        /// <param name="pAsyncContext">
        /// [In,Optional] If we are fetching the continuation frames or task creation frames,
        /// specifies the context for the async stack walk operation.
        /// </param>
        /// <param name="Operation">
        /// [In] Which type of stack walk we are doing.  If the operation is
        /// AsyncReturnStackWalk or AsyncTaskCreationStackWalk, "Task" must be non-null.
        /// Otherwise, "AsyncContext" must be NULL.
        /// </param>
        /// <param name="DataItem">
        /// [In] Data object to add to the new DkmStackContext instance. DkmDataItem::Null()
        /// in the case that the caller doesn't need to add a data item.
        /// </param>
        /// <param name="ppCreatedObject">
        /// [Out] Result of this method call.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ Evaluation::DkmInspectionSession* pInspectionSession,
            _In_ DkmThread* pThread,
            _In_ CallStack::DkmCallStackFilterOptions_t FilterOptions,
            _In_ const CallStack::DkmFrameFormatOptions& FormatOptions,
            _In_opt_ DkmReadOnlyCollection<BYTE>* pThreadContext,
            _In_opt_ CallStack::DkmAsyncStackWalkContext* pAsyncContext,
            _In_ CallStack::DkmStackWalkOperation_t Operation,
            _In_ const DkmDataItem& DataItem,
            _Deref_out_ CallStack::DkmStackContext** ppCreatedObject
            );

        /// <summary>
        /// Obtain the next frames from the call stack. If this is the first call on a
        /// particular DkmStackContext then this will return the first frames. This method is
        /// the recommended way to obtain the call stack because the stack provider maintains
        /// a cache of the physical stack.
        ///
        /// This method will append a new work item to the specified work list, and return
        /// once the work item has been appended. The actual processing of the work item is
        /// asynchronous. The caller will be notified that the request is complete through
        /// the completion routine.
        ///
        /// Location constraint: API must be called from an IDE component (component level
        /// &gt; 100,000).
        /// </summary>
        /// <param name="pWorkList">
        /// WorkList to append the new work item to.
        /// </param>
        /// <param name="RequestSize">
        /// [In] RequestSize is the number of frames that the caller would like returned. The
        /// implementation of GetNextFrames may return fewer frames in the case that stack
        /// does not contain that many frames. Negative values, or request to read more than
        /// MaxFrames (currently 5,000) will be capped to MaxFrames.
        /// </param>
        /// <param name="pCompletionRoutine">
        /// Routine to fire when the request is complete. If the request is successfully
        /// appended to the work list, this will always fire (including when the operation is
        /// canceled). This will never fire if appending the work item fails.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetNextFrames(
            _In_ DkmWorkList* pWorkList,
            _In_ UINT32 RequestSize,
            _In_ IDkmCompletionRoutine<CallStack::DkmGetNextFramesAsyncResult>* pCompletionRoutine
            );
    }; // end of DkmStackContext
    #endif // #ifndef EXCLUDE_IDE_ONLY_APIS

    // Information used to determine whether a cache of a call stack is valid.
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("de840e2b-b1b5-f981-88aa-b9de5940c762") DkmStackHash : public IUnknown
    {
        private: ___ReferenceCount_t m_ReferenceCount;
        private: DkmDispatcherObjectFlags_t m_ObjectFlags;
        private: const GUID* m_pTypeId;
        private: size_t m_ObjectGCHandle;
        // Use DkmStackHash::Create to create this object
        private: DkmStackHash();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmStackHash();
        // This object cannot be copied
        private: DkmStackHash& operator=(const DkmStackHash&);
        private: DkmStackHash(const DkmStackHash&);

        private: DkmThread* const m_pThread;
        private: const CallStack::DkmStackMemoryRange m_StackMemoryRange;
        private: const Symbols::DkmMD5HashValue m_RegisterHash;
        private: const Symbols::DkmMD5HashValue m_MemoryHash;
        private: void* m__pExtendedData;

        // The thread the cache applies to.
        public: _Ret_ DECLSPEC_NOTHROW DkmThread* STDMETHODCALLTYPE Thread(
            );

        // The range of the thread's stack.
        public: DECLSPEC_NOTHROW const CallStack::DkmStackMemoryRange& STDMETHODCALLTYPE StackMemoryRange(
            );

        // MD5 hash of the thread's CONTEXT structure at the point in which the cache was
        // created.
        public: DECLSPEC_NOTHROW const Symbols::DkmMD5HashValue& STDMETHODCALLTYPE RegisterHash(
            );

        // MD5 hash of the stack memory of the thread at the point in which the cache was
        // created.
        public: DECLSPEC_NOTHROW const Symbols::DkmMD5HashValue& STDMETHODCALLTYPE MemoryHash(
            );

        /// <summary>
        /// Create a new DkmStackHash object instance.
        /// </summary>
        /// <param name="pThread">
        /// [In] The thread the cache applies to.
        /// </param>
        /// <param name="StackMemoryRange">
        /// [In] The range of the thread's stack.
        /// </param>
        /// <param name="RegisterHash">
        /// [In] MD5 hash of the thread's CONTEXT structure at the point in which the cache
        /// was created.
        /// </param>
        /// <param name="MemoryHash">
        /// [In] MD5 hash of the stack memory of the thread at the point in which the cache
        /// was created.
        /// </param>
        /// <param name="ppCreatedObject">
        /// [Out] Result of this method call.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ DkmThread* pThread,
            _In_ const CallStack::DkmStackMemoryRange& StackMemoryRange,
            _In_ const Symbols::DkmMD5HashValue& RegisterHash,
            _In_ const Symbols::DkmMD5HashValue& MemoryHash,
            _Deref_out_ CallStack::DkmStackHash** ppCreatedObject
            );
    }; // end of DkmStackHash

    // DkmStackWalkContext allows the various components which walk, filter, or examine call
    // stacks to store private data which is associated with this call stack.
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("33ebb282-734b-c2f3-66cd-c42eb8a3d490") DkmStackWalkContext : public DkmDataContainer
    {
        // Use DkmStackWalkContext::Create to create this object
        private: DkmStackWalkContext();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmStackWalkContext();
        // This object cannot be copied
        private: DkmStackWalkContext& operator=(const DkmStackWalkContext&);
        private: DkmStackWalkContext(const DkmStackWalkContext&);

        private: DkmThread* const m_pThread;
        private: OPTIONAL DkmReadOnlyCollection<BYTE>* const m_pThreadContext;
        private: const GUID m_UniqueId;
        private: void* m__pExtendedData;
        private: void* m_pSymbolStackWalkContextCollection0;

        // DkmThread represents a thread running in the target process.
        public: _Ret_ DECLSPEC_NOTHROW DkmThread* STDMETHODCALLTYPE Thread(
            );

        // [Optional] The initial Win32 CONTEXT to use when performing the stack walk. This
        // value is normally 'null' but can be set in order to view another call stack (ex:
        // .cxr).
        public: _Ret_opt_ DECLSPEC_NOTHROW DkmReadOnlyCollection<BYTE>* STDMETHODCALLTYPE ThreadContext(
            );

        // Guid which uniquely identifies this DkmStackWalkContext.
        public: DECLSPEC_NOTHROW const GUID& STDMETHODCALLTYPE UniqueId(
            );

        // DkmProcess represents a target process which is being debugged. The debugger
        // debugs processes, so this is the basic unit of debugging. A DkmProcess can
        // represent a system process or a virtual process such as minidumps.
        public: _Ret_ DECLSPEC_NOTHROW DkmProcess* STDMETHODCALLTYPE Process(
            );

        /// <summary>
        /// Closes a DkmStackWalkContext object instance. This will release any resources
        /// associated with this object across all components. This includes resources across
        /// computer or managed/native marshalling boundaries.
        ///
        /// DkmStackWalkContext objects are automatically closed when their associated
        /// DkmThread object is closed.
        /// </summary>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Close(
            );

        /// <summary>
        /// Create a new DkmStackWalkContext object instance.
        /// </summary>
        /// <param name="pThread">
        /// [In] DkmThread represents a thread running in the target process.
        /// </param>
        /// <param name="pThreadContext">
        /// [In,Optional] The initial Win32 CONTEXT to use when performing the stack walk.
        /// This value is normally 'null' but can be set in order to view another call stack
        /// (ex: .cxr).
        /// </param>
        /// <param name="DataItem">
        /// [In] Data object to add to the new DkmStackWalkContext instance.
        /// DkmDataItem::Null() in the case that the caller doesn't need to add a data item.
        /// </param>
        /// <param name="ppCreatedObject">
        /// [Out] Result of this method call.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ DkmThread* pThread,
            _In_opt_ DkmReadOnlyCollection<BYTE>* pThreadContext,
            _In_ const DkmDataItem& DataItem,
            _Deref_out_ CallStack::DkmStackWalkContext** ppCreatedObject
            );

        /// <summary>
        /// Find a DkmSymbolStackWalkContext element within this DkmStackWalkContext. If no
        /// element with the given input key is present, FindSymbolStackWalkContext will
        /// fail.
        /// </summary>
        /// <param name="SymbolProviderId">
        /// [In] Search key used to find the element.
        /// </param>
        /// <param name="ppSymbolStackWalkContext">
        /// [Out] Result of the search.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// E_XAPI_OBJECT_NOT_FOUND indicates that the search key cannot be found.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE FindSymbolStackWalkContext(
            _In_ const GUID& SymbolProviderId,
            _Deref_out_ CallStack::DkmSymbolStackWalkContext** ppSymbolStackWalkContext
            );

        /// <summary>
        /// Attempt to walk through a region of the stack using a heuristic stack walk
        /// algorithm. This is used in x86 when no symbols are available. It is not
        /// implemented on other platforms as PDATA allows walking of all frames.
        /// </summary>
        /// <param name="pRegisters">
        /// [In] Registers to attempt to walk from.
        /// </param>
        /// <param name="RequestSize">
        /// [In] RequestSize is the number of frames that the caller would like returned. The
        /// implementation of HeuristicWalkFrames may return fewer frames in the case that
        /// stack does not contain that many frames.
        /// </param>
        /// <param name="EndStackPointer">
        /// [In] Stack address to stop the unwinding at. This value is UInt64.MaxValue if the
        /// no end stack pointer is present.
        /// </param>
        /// <param name="pFrames">
        /// [Out] DkmStackWalkFrame[] represents a frame on a call stack which has been
        /// walked, but may not have been formatted or filtered. Formatted frames are
        /// represented by DkmStackFrame instead.
        ///
        /// The memory for the DkmArray members is allocated by the method implementation
        /// using DkmAllocBytes/DkmAllocArray. It is freed by the caller using the
        /// CAutoDkmArray template or with DkmFreeMemory and manual element release.
        /// </param>
        /// <param name="ppNextRegisters">
        /// [Out,Optional] NextRegisters indicates the registers of the next frame (the
        /// caller of 'FrameObject'). This will be null if the stack is complete, or if the
        /// EndStackPointer was reached.
        /// </param>
        /// <param name="pEndOfStack">
        /// [Out] Returns true if the monitor reached the end of the stack.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE HeuristicWalkFrames(
            _In_ CallStack::DkmFrameRegisters* pRegisters,
            _In_ UINT32 RequestSize,
            _In_ UINT64 EndStackPointer,
            _Out_ DkmArray<CallStack::DkmStackWalkFrame*>* pFrames,
            _Deref_out_opt_ CallStack::DkmFrameRegisters** ppNextRegisters,
            _Out_ bool* pEndOfStack
            );

        /// <summary>
        /// Attempt to walk through a region of the stack using a heuristic stack walk
        /// algorithm. This is used in x86 when no symbols are available. It is not
        /// implemented on other platforms as PDATA allows walking of all frames.
        ///
        /// This method will append a new work item to the specified work list, and return
        /// once the work item has been appended. The actual processing of the work item is
        /// asynchronous. The caller will be notified that the request is complete through
        /// the completion routine.
        /// </summary>
        /// <param name="pWorkList">
        /// WorkList to append the new work item to.
        /// </param>
        /// <param name="pRegisters">
        /// [In] Registers to attempt to walk from.
        /// </param>
        /// <param name="RequestSize">
        /// [In] RequestSize is the number of frames that the caller would like returned. The
        /// implementation of HeuristicWalkFrames may return fewer frames in the case that
        /// stack does not contain that many frames.
        /// </param>
        /// <param name="EndStackPointer">
        /// [In] Stack address to stop the unwinding at. This value is UInt64.MaxValue if the
        /// no end stack pointer is present.
        /// </param>
        /// <param name="pCompletionRoutine">
        /// Routine to fire when the request is complete. If the request is successfully
        /// appended to the work list, this will always fire (including when the operation is
        /// canceled). This will never fire if appending the work item fails.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE HeuristicWalkFrames(
            _In_ DkmWorkList* pWorkList,
            _In_ CallStack::DkmFrameRegisters* pRegisters,
            _In_ UINT32 RequestSize,
            _In_ UINT64 EndStackPointer,
            _In_ IDkmCompletionRoutine<CallStack::DkmHeuristicWalkFramesAsyncResult>* pCompletionRoutine
            );

        /// <summary>
        /// Version of RuntimeWalkNextFrames() that also checks if a cached copy of the call
        /// stack is still valid.
        /// </summary>
        /// <param name="RequestSizeHintIfCacheIsValid">
        /// [In] RequestSizeHintIfCacheIsValid is a hint as to the number of frame that the
        /// caller needs. This value is treated as a hint because this API can return frames
        /// which are not yet walked, so this API may return more or less than the hint
        /// value.  A request size hint of 0 means not to do any stack walking at all if the
        /// cache is valid.
        /// </param>
        /// <param name="RequestSizeHintIfCacheIsInvalid">
        /// [In] RequestSizeHintIfCacheIsInvalid is a hint as to the number of frame that the
        /// caller needs. This value is treated as a hint because this API can return frames
        /// which are not yet walked, so this API may return more or less than the hint
        /// value.
        /// </param>
        /// <param name="pCachedHash">
        /// [In,Optional] Cached call stack hash, will not walk the stack if cache is still
        /// valid.  This parameter is optional.  If null, we will still compute the actual
        /// hash and do the stack walk, but will skip the comparing of the actual hash
        /// against the cached hash to suppress the stack walk.
        /// </param>
        /// <param name="pFrames">
        /// [Out] Array of walked frames. For, unresolved frames, both InstructionAddress and
        /// Description will be null.
        ///
        /// The memory for the DkmArray members is allocated by the method implementation
        /// using DkmAllocBytes/DkmAllocArray. It is freed by the caller using the
        /// CAutoDkmArray template or with DkmFreeMemory and manual element release.
        /// </param>
        /// <param name="pEndOfStack">
        /// [Out] Returns true if the monitor reached the end of the stack.
        /// </param>
        /// <param name="ppActualStackHash">
        /// [Out,Optional] The actual hash of the call stack.  This may be NULL for runtimes
        /// that don't support call stack hashing.
        /// </param>
        /// <param name="ppActualStackWalkContext">
        /// [Out] The DkmStackWalkContext object that can used later to continue the walk. If
        /// the cache is valid, this is the original context.  If the cache is invalid, this
        /// will be a new DkmStackWalkContext object.
        /// </param>
        /// <param name="pIsCacheValid">
        /// [Out] True if the cache was valid, false if not.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE RuntimeWalkNextFramesAndCheckCache(
            _In_ UINT32 RequestSizeHintIfCacheIsValid,
            _In_ UINT32 RequestSizeHintIfCacheIsInvalid,
            _In_opt_ CallStack::DkmStackHash* pCachedHash,
            _Out_ DkmArray<CallStack::DkmStackWalkFrame*>* pFrames,
            _Out_ bool* pEndOfStack,
            _Deref_out_opt_ CallStack::DkmStackHash** ppActualStackHash,
            _Deref_out_ CallStack::DkmStackWalkContext** ppActualStackWalkContext,
            _Out_ bool* pIsCacheValid
            );

        /// <summary>
        /// Version of RuntimeWalkNextFrames() that also checks if a cached copy of the call
        /// stack is still valid.
        ///
        /// This method will append a new work item to the specified work list, and return
        /// once the work item has been appended. The actual processing of the work item is
        /// asynchronous. The caller will be notified that the request is complete through
        /// the completion routine.
        /// </summary>
        /// <param name="pWorkList">
        /// WorkList to append the new work item to.
        /// </param>
        /// <param name="RequestSizeHintIfCacheIsValid">
        /// [In] RequestSizeHintIfCacheIsValid is a hint as to the number of frame that the
        /// caller needs. This value is treated as a hint because this API can return frames
        /// which are not yet walked, so this API may return more or less than the hint
        /// value.  A request size hint of 0 means not to do any stack walking at all if the
        /// cache is valid.
        /// </param>
        /// <param name="RequestSizeHintIfCacheIsInvalid">
        /// [In] RequestSizeHintIfCacheIsInvalid is a hint as to the number of frame that the
        /// caller needs. This value is treated as a hint because this API can return frames
        /// which are not yet walked, so this API may return more or less than the hint
        /// value.
        /// </param>
        /// <param name="pCachedHash">
        /// [In,Optional] Cached call stack hash, will not walk the stack if cache is still
        /// valid.  This parameter is optional.  If null, we will still compute the actual
        /// hash and do the stack walk, but will skip the comparing of the actual hash
        /// against the cached hash to suppress the stack walk.
        /// </param>
        /// <param name="pCompletionRoutine">
        /// Routine to fire when the request is complete. If the request is successfully
        /// appended to the work list, this will always fire (including when the operation is
        /// canceled). This will never fire if appending the work item fails.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE RuntimeWalkNextFramesAndCheckCache(
            _In_ DkmWorkList* pWorkList,
            _In_ UINT32 RequestSizeHintIfCacheIsValid,
            _In_ UINT32 RequestSizeHintIfCacheIsInvalid,
            _In_opt_ CallStack::DkmStackHash* pCachedHash,
            _In_ IDkmCompletionRoutine<CallStack::DkmRuntimeWalkNextFramesAndCheckCacheAsyncResult>* pCompletionRoutine
            );

        /// <summary>
        /// Attempt to walk the stack without the use of symbols. This will call into various
        /// components that know how to walk portions of the stack (ex: CLR frames will be
        /// walked by the CLR debug monitor). An 'unresolved' frame will be left for portions
        /// of the stack which cannot be walked without information stored within the symbol
        /// file. These 'unresolved' frames have no InstructionAddress or Description.
        /// </summary>
        /// <param name="RequestSizeHint">
        /// [In] RequestSizeHint is a hint as to the number of frame that the caller needs.
        /// This value is treated as a hint because this API can return frames which are not
        /// yet walked, so this API may return more or less than the hint value.
        /// </param>
        /// <param name="pFrames">
        /// [Out] Array of walked frames. For, unresolved frames, both InstructionAddress and
        /// Description will be null.
        ///
        /// The memory for the DkmArray members is allocated by the method implementation
        /// using DkmAllocBytes/DkmAllocArray. It is freed by the caller using the
        /// CAutoDkmArray template or with DkmFreeMemory and manual element release.
        /// </param>
        /// <param name="pEndOfStack">
        /// [Out] Returns true if the monitor reached the end of the stack.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE RuntimeWalkNextFrames(
            _In_ UINT32 RequestSizeHint,
            _Out_ DkmArray<CallStack::DkmStackWalkFrame*>* pFrames,
            _Out_ bool* pEndOfStack
            );

        /// <summary>
        /// Attempt to walk the stack without the use of symbols. This will call into various
        /// components that know how to walk portions of the stack (ex: CLR frames will be
        /// walked by the CLR debug monitor). An 'unresolved' frame will be left for portions
        /// of the stack which cannot be walked without information stored within the symbol
        /// file. These 'unresolved' frames have no InstructionAddress or Description.
        ///
        /// This method will append a new work item to the specified work list, and return
        /// once the work item has been appended. The actual processing of the work item is
        /// asynchronous. The caller will be notified that the request is complete through
        /// the completion routine.
        /// </summary>
        /// <param name="pWorkList">
        /// WorkList to append the new work item to.
        /// </param>
        /// <param name="RequestSizeHint">
        /// [In] RequestSizeHint is a hint as to the number of frame that the caller needs.
        /// This value is treated as a hint because this API can return frames which are not
        /// yet walked, so this API may return more or less than the hint value.
        /// </param>
        /// <param name="pCompletionRoutine">
        /// Routine to fire when the request is complete. If the request is successfully
        /// appended to the work list, this will always fire (including when the operation is
        /// canceled). This will never fire if appending the work item fails.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE RuntimeWalkNextFrames(
            _In_ DkmWorkList* pWorkList,
            _In_ UINT32 RequestSizeHint,
            _In_ IDkmCompletionRoutine<CallStack::DkmRuntimeWalkNextFramesAsyncResult>* pCompletionRoutine
            );
    }; // end of DkmStackWalkContext

    // DkmStackWalkFrame represents a frame on a call stack which has been walked, but may
    // not have been formatted or filtered. Formatted frames are represented by DkmStackFrame
    // instead.
    //
    // Derived classes: DkmStackFrame
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("48b55030-ecac-2387-4e63-bfdc3c172598") DkmStackWalkFrame : public IUnknown
    {
        private: ___ReferenceCount_t m_ReferenceCount;
        private: DkmDispatcherObjectFlags_t m_ObjectFlags;
        private: const GUID* m_pTypeId;
        private: size_t m_ObjectGCHandle;
        // Use DkmStackWalkFrame::Create to create this object
        private: DkmStackWalkFrame();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmStackWalkFrame();
        // This object cannot be copied
        private: DkmStackWalkFrame& operator=(const DkmStackWalkFrame&);
        private: DkmStackWalkFrame(const DkmStackWalkFrame&);

        // Contains additional fields of DkmStackWalkFrame which were added after the class
        // was initally introduced.
        private: struct ___ExtendedData
        {
            ___ExtendedData();

            // [Optional] If we have an annotated frame, specifies an optional module
            // instance to associate with this frame.  If present, the user will be able to
            // load binaries or symbols for this module by right-clicking on this frame in
            // the call stack window.  This is NULL for non-annotated frames.
            OPTIONAL DkmModuleInstance* const pAnnotatedModule;

            // [Optional] Optional context for walking async return stacks and task creation
            // stacks.
            OPTIONAL CallStack::DkmAsyncStackWalkContext* const pAsyncContext;

            // [Optional] Optional object to attach to a DkmStackWalkFrame, allowing
            // components to associate additional private data with the frame.
            OPTIONAL CallStack::DkmStackWalkFrameData* const pData;
        };

        private: DkmThread* const m_pThread;
        private: OPTIONAL DkmInstructionAddress* const m_pInstructionAddress;
        private: const UINT64 m_FrameBase;
        private: const UINT32 m_FrameSize;
        private: const CallStack::DkmStackWalkFrameFlags_t m_Flags;
        private: OPTIONAL DkmString* const m_pDescription;
        private: OPTIONAL CallStack::DkmFrameRegisters* const m_pRegisters;
        private: OPTIONAL DkmReadOnlyCollection<CallStack::DkmStackWalkFrameAnnotation*>* const m_pAnnotations;
        private: ___ExtendedData* const m__pExtendedData;

        // The thread that this stack frame is on.
        public: _Ret_ DECLSPEC_NOTHROW DkmThread* STDMETHODCALLTYPE Thread(
            );

        // [Optional] The instruction of this frame. This can be omitted for annotated
        // frames.
        public: _Ret_opt_ DECLSPEC_NOTHROW DkmInstructionAddress* STDMETHODCALLTYPE InstructionAddress(
            );

        // Base stack pointer of the frame. This is used by the SDM to sort the frame, and it
        // is used by the stack merger to assess walk progress, so this value is required
        // even for annotated frames. This value should only be invalid in the case that the
        // debuggee's stack is corrupt.
        public: DECLSPEC_NOTHROW UINT64 STDMETHODCALLTYPE FrameBase(
            );

        // Number of bytes of the stack consumed by this frame. This value will be zero for
        // annotated frames, or if the value is unknown.
        public: DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE FrameSize(
            );

        // Flags properties of a DkmStackWalkFrame.
        public: DECLSPEC_NOTHROW CallStack::DkmStackWalkFrameFlags_t STDMETHODCALLTYPE Flags(
            );

        // [Optional] Description of the frame which will be displayed in the call stack
        // window. This should be provided for annotated frames.
        public: _Ret_opt_ DECLSPEC_NOTHROW DkmString* STDMETHODCALLTYPE Description(
            );

        // [Optional] Registers of the walked frame. These should be provided for
        // non-annotated frames.
        public: _Ret_opt_ DECLSPEC_NOTHROW CallStack::DkmFrameRegisters* STDMETHODCALLTYPE Registers(
            );

        // [Optional] A read only collection of stack frame annotations. These are defined by
        // an unwinder and are specific to that unwinder. An example usage is how inline
        // frame data is passed from inline stack filter to the formatter.
        public: _Ret_opt_ DECLSPEC_NOTHROW DkmReadOnlyCollection<CallStack::DkmStackWalkFrameAnnotation*>* STDMETHODCALLTYPE Annotations(
            );

        // [Optional] If we have an annotated frame, specifies an optional module instance to
        // associate with this frame.  If present, the user will be able to load binaries or
        // symbols for this module by right-clicking on this frame in the call stack window.
        // This is NULL for non-annotated frames.
        //
        // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
        public: _Ret_opt_ DECLSPEC_NOTHROW DkmModuleInstance* STDMETHODCALLTYPE AnnotatedModule(
            );

        // [Optional] Optional context for walking async return stacks and task creation
        // stacks.
        //
        // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
        public: _Ret_opt_ DECLSPEC_NOTHROW CallStack::DkmAsyncStackWalkContext* STDMETHODCALLTYPE AsyncContext(
            );

        // [Optional] Optional object to attach to a DkmStackWalkFrame, allowing components
        // to associate additional private data with the frame.
        //
        // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
        public: _Ret_opt_ DECLSPEC_NOTHROW CallStack::DkmStackWalkFrameData* STDMETHODCALLTYPE Data(
            );

        // [Optional] The DkmRuntimeInstance class represents an execution environment which
        // is loaded into a DkmProcess and which contains code to be debugged.
        public: _Ret_opt_ DECLSPEC_NOTHROW DkmRuntimeInstance* STDMETHODCALLTYPE RuntimeInstance(
            );

        // [Optional] The module containing this address. Addresses without a module cannot
        // have symbols (even for custom addresses). CLR addresses will always have a module.
        // Native addresses will not have a module if either the CPU jumped to an invalid
        // address (ex: NULL), or if the CPU is executing dynamically-emitted code.
        public: _Ret_opt_ DECLSPEC_NOTHROW DkmModuleInstance* STDMETHODCALLTYPE ModuleInstance(
            );

        // DkmProcess represents a target process which is being debugged. The debugger
        // debugs processes, so this is the basic unit of debugging. A DkmProcess can
        // represent a system process or a virtual process such as minidumps.
        public: _Ret_ DECLSPEC_NOTHROW DkmProcess* STDMETHODCALLTYPE Process(
            );

        // This represents a connection between the monitor and the IDE. It can either be a
        // local connection if the monitor is running in the same process as the IDE, or it
        // can be a remote connection. In the monitor process, there is only one connection.
        public: _Ret_ DECLSPEC_NOTHROW DefaultPort::DkmTransportConnection* STDMETHODCALLTYPE Connection(
            );

        /// <summary>
        /// Create a new DkmStackWalkFrame object instance.
        /// </summary>
        /// <param name="pThread">
        /// [In] The thread that this stack frame is on.
        /// </param>
        /// <param name="pInstructionAddress">
        /// [In,Optional] The instruction of this frame. This can be omitted for annotated
        /// frames.
        /// </param>
        /// <param name="FrameBase">
        /// [In] Base stack pointer of the frame. This is used by the SDM to sort the frame,
        /// and it is used by the stack merger to assess walk progress, so this value is
        /// required even for annotated frames. This value should only be invalid in the case
        /// that the debuggee's stack is corrupt.
        /// </param>
        /// <param name="FrameSize">
        /// [In] Number of bytes of the stack consumed by this frame. This value will be zero
        /// for annotated frames, or if the value is unknown.
        /// </param>
        /// <param name="Flags">
        /// [In] Flags properties of a DkmStackWalkFrame.
        /// </param>
        /// <param name="pDescription">
        /// [In,Optional] Description of the frame which will be displayed in the call stack
        /// window. This should be provided for annotated frames.
        /// </param>
        /// <param name="pRegisters">
        /// [In,Optional] Registers of the walked frame. These should be provided for
        /// non-annotated frames.
        /// </param>
        /// <param name="pAnnotations">
        /// [In,Optional] A read only collection of stack frame annotations. These are
        /// defined by an unwinder and are specific to that unwinder. An example usage is how
        /// inline frame data is passed from inline stack filter to the formatter.
        /// </param>
        /// <param name="ppCreatedObject">
        /// [Out] Result of this method call.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ DkmThread* pThread,
            _In_opt_ DkmInstructionAddress* pInstructionAddress,
            _In_ UINT64 FrameBase,
            _In_ UINT32 FrameSize,
            _In_ CallStack::DkmStackWalkFrameFlags_t Flags,
            _In_opt_ DkmString* pDescription,
            _In_opt_ CallStack::DkmFrameRegisters* pRegisters,
            _In_opt_ DkmReadOnlyCollection<CallStack::DkmStackWalkFrameAnnotation*>* pAnnotations,
            _Deref_out_ CallStack::DkmStackWalkFrame** ppCreatedObject
            );

        /// <summary>
        /// Create a new DkmStackWalkFrame object instance.
        ///
        /// This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
        /// </summary>
        /// <param name="pThread">
        /// [In] The thread that this stack frame is on.
        /// </param>
        /// <param name="pInstructionAddress">
        /// [In,Optional] The instruction of this frame. This can be omitted for annotated
        /// frames.
        /// </param>
        /// <param name="FrameBase">
        /// [In] Base stack pointer of the frame. This is used by the SDM to sort the frame,
        /// and it is used by the stack merger to assess walk progress, so this value is
        /// required even for annotated frames. This value should only be invalid in the case
        /// that the debuggee's stack is corrupt.
        /// </param>
        /// <param name="FrameSize">
        /// [In] Number of bytes of the stack consumed by this frame. This value will be zero
        /// for annotated frames, or if the value is unknown.
        /// </param>
        /// <param name="Flags">
        /// [In] Flags properties of a DkmStackWalkFrame.
        /// </param>
        /// <param name="pDescription">
        /// [In,Optional] Description of the frame which will be displayed in the call stack
        /// window. This should be provided for annotated frames.
        /// </param>
        /// <param name="pRegisters">
        /// [In,Optional] Registers of the walked frame. These should be provided for
        /// non-annotated frames.
        /// </param>
        /// <param name="pAnnotations">
        /// [In,Optional] A read only collection of stack frame annotations. These are
        /// defined by an unwinder and are specific to that unwinder. An example usage is how
        /// inline frame data is passed from inline stack filter to the formatter.
        /// </param>
        /// <param name="pAnnotatedModule">
        /// [In,Optional] If we have an annotated frame, specifies an optional module
        /// instance to associate with this frame.  If present, the user will be able to load
        /// binaries or symbols for this module by right-clicking on this frame in the call
        /// stack window.  This is NULL for non-annotated frames.
        /// </param>
        /// <param name="pAsyncContext">
        /// [In,Optional] Optional context for walking async return stacks and task creation
        /// stacks.
        /// </param>
        /// <param name="pData">
        /// [In,Optional] Optional object to attach to a DkmStackWalkFrame, allowing
        /// components to associate additional private data with the frame.
        /// </param>
        /// <param name="ppCreatedObject">
        /// [Out] Result of this method call.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ DkmThread* pThread,
            _In_opt_ DkmInstructionAddress* pInstructionAddress,
            _In_ UINT64 FrameBase,
            _In_ UINT32 FrameSize,
            _In_ CallStack::DkmStackWalkFrameFlags_t Flags,
            _In_opt_ DkmString* pDescription,
            _In_opt_ CallStack::DkmFrameRegisters* pRegisters,
            _In_opt_ DkmReadOnlyCollection<CallStack::DkmStackWalkFrameAnnotation*>* pAnnotations,
            _In_opt_ DkmModuleInstance* pAnnotatedModule,
            _In_opt_ CallStack::DkmAsyncStackWalkContext* pAsyncContext,
            _In_opt_ CallStack::DkmStackWalkFrameData* pData,
            _Deref_out_ CallStack::DkmStackWalkFrame** ppCreatedObject
            );

        /// <summary>
        /// OnSetNextStatementCompleted is a general purpose method to allow components to
        /// clear state after a set next statement completed. The DkmStackWalkFrame will be
        /// the frame prior to to the SetNextStatement call.
        ///
        /// Location constraint: This API should generally be called only from client-side
        /// components. However, it is safe for a monitor-side component to call this API if
        /// the set next statement is being called from an event handler.
        /// </summary>
        /// <param name="pNewStatement">
        /// [In] Abstract representation of an executable code location (ex: EIP value). If
        /// resolved, an Instruction Address will be within a particular module instance. An
        /// Instruction Address is always within a particular Runtime Instance.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE OnSetNextStatementCompleted(
            _In_ DkmInstructionAddress* pNewStatement
            );

        /// <summary>
        /// InterceptCurrentException is used to unwind to this frame as if there was an
        /// exception handler at that frame.
        /// </summary>
        /// <param name="InterceptAction">
        /// [In] Specifies exception interception actions.
        /// </param>
        /// <param name="pCookie">
        /// [Out] Cookie that represents this intercept request. The value is returned when
        /// an exception interception completed event is sent.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE InterceptCurrentException(
            _In_ Exceptions::DkmExceptionInterceptActionFlags_t InterceptAction,
            _Out_ UINT64* pCookie
            );

        /// <summary>
        /// Returns the address that represents the location if an exception were to be
        /// intercepted to this frame.
        /// </summary>
        /// <param name="ppNewAddress">
        /// [Out] Possible new address if an exception was unwound to this frame.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetUnwindAddress(
            _Deref_out_ DkmInstructionAddress** ppNewAddress
            );

        /// <summary>
        /// SetNextStatement moves the IP of a stack frame. The stack frame is always the
        /// leaf stack frame on a particular thread.
        /// </summary>
        /// <param name="pNewStatement">
        /// [In] Abstract representation of an executable code location (ex: EIP value). If
        /// resolved, an Instruction Address will be within a particular module instance. An
        /// Instruction Address is always within a particular Runtime Instance.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE SetNextStatement(
            _In_ DkmInstructionAddress* pNewStatement
            );

        #ifndef EXCLUDE_IDE_ONLY_APIS
        /// <summary>
        /// CanSetNextStatement determines if it is possible to move the IP of a stack frame.
        /// The stack frame is always the leaf stack frame on a particular thread. This API
        /// may only be implemented within the engine process. The Result out parameter
        /// should be S_OK or the value of a failed HRESULT that the UI can map to an error
        /// message.
        ///
        /// Location constraint: API must be called from an IDE component (component level
        /// &gt; 100,000).
        /// </summary>
        /// <param name="pNewStatement">
        /// [In] Abstract representation of an executable code location (ex: EIP value). If
        /// resolved, an Instruction Address will be within a particular module instance. An
        /// Instruction Address is always within a particular Runtime Instance.
        /// </param>
        /// <param name="pResult">
        /// [Out] The error code to return to the UI. This should be S_OK or the value of a
        /// failed HRESULT that the UI can map to an error message.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE CanSetNextStatement(
            _In_ DkmInstructionAddress* pNewStatement,
            _Out_ UINT32* pResult
            );
        #endif // #ifndef EXCLUDE_IDE_ONLY_APIS

        #ifndef EXCLUDE_IDE_ONLY_APIS
        /// <summary>
        /// Format a DkmStackWalkFrame into a DkmStackFrame. Formatting a frame is one step
        /// of what the stack provider does during GetNextFrames. This method can be used to
        /// format a frame in a different way than was originally performed by the stack
        /// provider in GetNextFrames.
        ///
        /// Location constraint: API must be called from an IDE component (component level
        /// &gt; 100,000).
        /// </summary>
        /// <param name="pInspectionSession">
        /// [In] DkmInspectionSession allows the various components which inspect data to
        /// store private data which is associated with a group of evaluations.
        /// </param>
        /// <param name="Options">
        /// [In] Collection of settings that affect how the stack provider formats a
        /// DkmStackFrame.
        /// </param>
        /// <param name="ppFormattedFrame">
        /// [Out] DkmStackFrame represents a frame on the call stack after filtering and
        /// translation.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Format(
            _In_ Evaluation::DkmInspectionSession* pInspectionSession,
            _In_ const CallStack::DkmFrameFormatOptions& Options,
            _Deref_out_ CallStack::DkmStackFrame** ppFormattedFrame
            );
        #endif // #ifndef EXCLUDE_IDE_ONLY_APIS

        /// <summary>
        /// Return a DkmInstructionSymbol for a stack frame. If the stack frame has no
        /// instruction address (annotated frame) or the instruction address has no
        /// associated DkmModule, then GetInstructionSymbol will return null (S_FALSE in
        /// native code).
        /// </summary>
        /// <param name="ppSymbol">
        /// [Out,Optional] DkmInstructionSymbol represents a method in the target process.
        /// </param>
        /// <returns>
        /// S_OK is returned if *ppSymbol is non-NULL, S_FALSE is returned when *ppSymbol is
        /// NULL, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetInstructionSymbol(
            _Deref_out_opt_ Symbols::DkmInstructionSymbol** ppSymbol
            );

        /// <summary>
        /// GetInspectionInterface is used to obtain a ICorDebugFrame or other
        /// implementation-specific interfaces which a component can use to deeply inspect
        /// the stack frame.
        ///
        /// The returned interface may ONLY be used to inspect the target process, and should
        /// NEVER be used to control execution (no stepping, no breakpoints, no continue,
        /// etc). Doing so is unsupported and will result in undefined behavior. NOTE: Using
        /// this method from managed code is not recommended for performance reasons.
        /// Marshalling of DkmStackWalkFrame between native and managed code is expensive.
        /// Use DkmRuntimeInstance.GetFrameInspectionInterface instead.
        ///
        /// Location constraint: This API must be called from the same process where the
        /// target runtime implements stack walk. For managed debugging, this means that when
        /// debugging 64-bit or remote processes, this API must be called from a debug
        /// monitor component.
        /// </summary>
        /// <param name="pSession">
        /// [In] DkmInspectionSession allows the various components which inspect data to
        /// store private data which is associated with a group of evaluations.
        /// </param>
        /// <param name="InterfaceID">
        /// [In] The GUID of the desired interface. IID_ICorDebugFrame can be used to obtain
        /// the CorDebug frame interface for a managed frame. Other debug monitors or stack
        /// walkers may provide their own interface.
        /// </param>
        /// <param name="ppFrameInterface">
        /// [Out] Returned frame interface. This may be cast to the interface pointer
        /// corresponding to 'InterfaceID'.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetInspectionInterface(
            _In_ Evaluation::DkmInspectionSession* pSession,
            _In_ const GUID& InterfaceID,
            _Deref_out_ IUnknown** ppFrameInterface
            );

        #ifndef EXCLUDE_IDE_ONLY_APIS
        /// <summary>
        /// Determines whether or not a frame is user code.
        ///
        /// Location constraint: API must be called from an IDE component (component level
        /// &gt; 100,000).
        ///
        /// This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
        /// </summary>
        /// <param name="pInspectionSession">
        /// [In,Optional] Optional inspection session which may be used for caching purposes.
        /// The same inspection session is reused when computing the user status of multiple
        /// frames in succession.
        /// </param>
        /// <param name="pUser">
        /// [Out] True if the frame is user code, false if the frame is nonuser code.
        /// </param>
        /// <param name="pExceptionImplementation">
        /// [Out] True if the frame is library code that implements the throwing of
        /// exceptions.  This will cause the frame to be collapsed if we are stopped here in
        /// response to an exception being thrown.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ComputeUserStatus(
            _In_opt_ Evaluation::DkmInspectionSession* pInspectionSession,
            _Out_ bool* pUser,
            _Out_ bool* pExceptionImplementation
            );
        #endif // #ifndef EXCLUDE_IDE_ONLY_APIS

        /// <summary>
        /// Gets the generic parameters for the current stack frame as a list of assembly
        /// qualified names.
        ///
        /// This API was introduced in Visual Studio 14 RTM (DkmApiVersion.VS14RTM).
        /// </summary>
        /// <param name="pParameterTypeNames">
        /// [Out] The list of assembly qualified names for the type parameters, if any,
        /// followed by the method parameters, if any.
        ///
        /// The memory for the DkmArray members is allocated by the method implementation
        /// using DkmAllocBytes/DkmAllocArray. It is freed by the caller using the
        /// CAutoDkmArray template or with DkmFreeMemory and manual element release.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetClrGenericParameters(
            _Out_ DkmArray<DkmString*>* pParameterTypeNames
            );

        /// <summary>
        /// Gets the generic parameters for the current stack frame as a list of assembly
        /// qualified names.
        ///
        /// This method will append a new work item to the specified work list, and return
        /// once the work item has been appended. The actual processing of the work item is
        /// asynchronous. The caller will be notified that the request is complete through
        /// the completion routine.
        ///
        /// This API was introduced in Visual Studio 14 RTM (DkmApiVersion.VS14RTM).
        /// </summary>
        /// <param name="pWorkList">
        /// WorkList to append the new work item to.
        /// </param>
        /// <param name="pCompletionRoutine">
        /// Routine to fire when the request is complete. If the request is successfully
        /// appended to the work list, this will always fire (including when the operation is
        /// canceled). This will never fire if appending the work item fails.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetClrGenericParameters(
            _In_ DkmWorkList* pWorkList,
            _In_ IDkmCompletionRoutine<CallStack::DkmGetClrGenericParametersAsyncResult>* pCompletionRoutine
            );
    }; // end of DkmStackWalkFrame

    // A Guid / Value pair set by a frame filter or unwinder. Can be used to pass custom
    // flags about the frame from one component to another.
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("b3b38131-4bcb-4dba-a409-4bdba19e7323") DkmStackWalkFrameAnnotation : public IUnknown
    {
        private: ___ReferenceCount_t m_ReferenceCount;
        private: DkmDispatcherObjectFlags_t m_ObjectFlags;
        private: const GUID* m_pTypeId;
        private: size_t m_ObjectGCHandle;
        // Use DkmStackWalkFrameAnnotation::Create to create this object
        private: DkmStackWalkFrameAnnotation();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmStackWalkFrameAnnotation();
        // This object cannot be copied
        private: DkmStackWalkFrameAnnotation& operator=(const DkmStackWalkFrameAnnotation&);
        private: DkmStackWalkFrameAnnotation(const DkmStackWalkFrameAnnotation&);

        private: const GUID m_Id;
        private: const UINT64 m_Value;
        private: void* m__pExtendedData;

        // The Guid that uniquely identifies this annotation flag. This is specific to the
        // creator of the stack walk frame.
        public: DECLSPEC_NOTHROW const GUID& STDMETHODCALLTYPE Id(
            );

        // The value of this annotation. The meaning of this value is specific to the
        // creator.
        public: DECLSPEC_NOTHROW UINT64 STDMETHODCALLTYPE Value(
            );

        /// <summary>
        /// Create a new DkmStackWalkFrameAnnotation object instance.
        /// </summary>
        /// <param name="Id">
        /// [In] The Guid that uniquely identifies this annotation flag. This is specific to
        /// the creator of the stack walk frame.
        /// </param>
        /// <param name="Value">
        /// [In] The value of this annotation. The meaning of this value is specific to the
        /// creator.
        /// </param>
        /// <param name="ppCreatedObject">
        /// [Out] Result of this method call.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ const GUID& Id,
            _In_ UINT64 Value,
            _Deref_out_ CallStack::DkmStackWalkFrameAnnotation** ppCreatedObject
            );
    }; // end of DkmStackWalkFrameAnnotation

    // Optional reference object that can be used to attach data items to a
    // DkmStackWalkFrame.
    //
    // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("15ea147e-b48b-2d5c-b52a-a2fee87713b2") DkmStackWalkFrameData : public DkmDataContainer
    {
        // Use DkmStackWalkFrameData::Create to create this object
        private: DkmStackWalkFrameData();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmStackWalkFrameData();
        // This object cannot be copied
        private: DkmStackWalkFrameData& operator=(const DkmStackWalkFrameData&);
        private: DkmStackWalkFrameData(const DkmStackWalkFrameData&);

        private: Evaluation::DkmInspectionSession* const m_pInspectionSession;
        private: const GUID m_UniqueId;
        private: void* m__pExtendedData;

        // The inspection session that owns this frame data object.
        //
        // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
        public: _Ret_ DECLSPEC_NOTHROW Evaluation::DkmInspectionSession* STDMETHODCALLTYPE InspectionSession(
            );

        // Guid which uniquely identifies this evaluation result.
        //
        // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
        public: DECLSPEC_NOTHROW const GUID& STDMETHODCALLTYPE UniqueId(
            );

        /// <summary>
        /// Create a new DkmStackWalkFrameData object instance.
        ///
        /// This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
        /// </summary>
        /// <param name="pInspectionSession">
        /// [In] The inspection session that owns this frame data object.
        /// </param>
        /// <param name="DataItem">
        /// [In] Data object to add to the new DkmStackWalkFrameData instance.
        /// DkmDataItem::Null() in the case that the caller doesn't need to add a data item.
        /// </param>
        /// <param name="ppCreatedObject">
        /// [Out] Result of this method call.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ Evaluation::DkmInspectionSession* pInspectionSession,
            _In_ const DkmDataItem& DataItem,
            _Deref_out_ CallStack::DkmStackWalkFrameData** ppCreatedObject
            );
    }; // end of DkmStackWalkFrameData

    // Flags properties of a DkmStackWalkFrame.
    DEFINE_SCOPED_ENUM(DkmStackWalkFrameFlags)
    {
        // No flags are set on this stack frame.
        None = 0x0,
        // Stack frame is the top frame in the call stack. This is used to detect the top
        // frame when the full stack frame collection is not available. Unwinders should set
        // this on top frame when doing an unwind. Unwinders must decide if it makes sense
        // for logical frames (such as inline frames) that appear above physical frame should
        // also be marked. Doing so would result in multiple frames being marked as a top
        // frame.
        TopFrame = 0x1,
        // Stack frame is located within hidden code.
        Hidden = 0x2,
        // Stack frame is located within non-user code.
        NonuserCode = 0x4,
        // Stack frame is an inlined optimized frame, not a physical frame.
        InlineOptimized = 0x8,
        // Stack frame is used to indicate that the maximum number of walked stack frame has
        // been exceeded.
        MaxFramesExceeded = 0x10,
        // Stack frame can be unwound to after an exception has been thrown.
        ExceptionUnwindTarget = 0x20,
        // Stack frame is an annotated frame that shows what is being evaluated example
        // 'Evaluation of: xyz'.
        FuncEvalFrame = 0x40,
        // Indicates that this frame is part of an async return stack and is not actually
        // executing on the current thread.
        ReturnStackFrame = 0x80,
        // Indicates that this frame was logged from the call stack of the creation of an
        // async task and is not actually executing on the current thread at this time.
        TaskCreationStackFrame = 0x100,
        // Indicates that it is not yet known whether or not the frame is user code or
        // non-user code.  The stack provider will call back to find out.
        UserStatusNotDetermined = 0x200,
        // Indicates that we are an annotated frame indicating that frames below may be
        // missing or incorrect due binaries or symbols not being loaded for a module.
        SymbolsNotLoadedAnnotation = 0x400,
        // Indicates that we are in nonuser code that is known to be part of the
        // implementation of throwing exceptions.
        NonUserExceptionImplementation = 0x800,
        // Indicates that this is an annotated frame denoting an async call (i.e. [Async
        // Call]).
        AsyncCallAnnotatedFrame = 0x1000,
        // Indicates that this is an annotated frame denoting resuming an async method (i.e.
        // [Resuming async method]).
        AsyncContinuationAnnotatedFrame = 0x2000,
        // Indicates that this frame is fake and not backed by a real frame in the target.
        // This flag will never be used for stack frames obtained from stack walk, but can be
        // used for pseudo-frames used to allow inspection.
        FakeFrame = 0x4000,
        // Indicates that we are an annotated frame and frames below may be missing due to
        // binary not being loaded for a module.
        BinaryNotLoadedAnnotation = 0x8000
    };
    DEFINE_SCOPED_ENUM_FLAG_OPERATORS(DkmStackWalkFrameFlags_t);

    // Indicates a type of stack walking operation.
    //
    // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
    DEFINE_SCOPED_ENUM(DkmStackWalkOperation)
    {
        // A regular stack walk of a thread.
        Standard = 0,
        // A walk of a task's async return stack.
        TaskContinuations = 1,
        // A walk of the logged stack from when a task was created.
        TaskCreation = 2,
        // A walk of the logic async frames related to a thread that should be displayed in
        // the call stack window.
        Async = 3,
        // A walk of a stack trace consisting of a caller-defined list of frames.
        StackTrace = 4
    };

    // Return status from a monitor walk operation.
    DEFINE_SCOPED_ENUM(DkmStackWalkStatus)
    {
        // The walker found a frame within its runtime.
        FrameFound = 0,
        // The walker determined that the current frame is outside of it's runtime. Lower
        // priority walkers will be given a chance to walk.
        OutsideOfRuntime = 1,
        // The walker determined that the end of the stack has been reached. StackWalking
        // should stop.
        EndOfStack = 2
    };

    #ifndef EXCLUDE_IDE_ONLY_APIS
    // DkmSymbolStackWalkContext allows the various symbol providers which walk the call
    // stack to store private data which is associated with this call stack.
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("ca6905ca-dfde-bacc-31e6-fef0ad7fee7e") DkmSymbolStackWalkContext : public DkmDataContainer
    {
        // Use DkmSymbolStackWalkContext::Create to create this object
        private: DkmSymbolStackWalkContext();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmSymbolStackWalkContext();
        // This object cannot be copied
        private: DkmSymbolStackWalkContext& operator=(const DkmSymbolStackWalkContext&);
        private: DkmSymbolStackWalkContext(const DkmSymbolStackWalkContext&);

        private: CallStack::DkmStackWalkContext* const m_pStackWalkContext;
        private: const GUID m_SymbolProviderId;
        private: void* m__pExtendedData;

        // DkmStackWalkContext allows the various components which walk, filter, or examine
        // call stacks to store private data which is associated with this call stack.
        public: _Ret_ DECLSPEC_NOTHROW CallStack::DkmStackWalkContext* STDMETHODCALLTYPE StackWalkContext(
            );

        // Unique identifier for symbol files/symbol providers.
        public: DECLSPEC_NOTHROW const GUID& STDMETHODCALLTYPE SymbolProviderId(
            );

        // DkmThread represents a thread running in the target process.
        public: _Ret_ DECLSPEC_NOTHROW DkmThread* STDMETHODCALLTYPE Thread(
            );

        // [Optional] The initial Win32 CONTEXT to use when performing the stack walk. This
        // value is normally 'null' but can be set in order to view another call stack (ex:
        // .cxr).
        public: _Ret_opt_ DECLSPEC_NOTHROW DkmReadOnlyCollection<BYTE>* STDMETHODCALLTYPE ThreadContext(
            );

        /// <summary>
        /// Closes a DkmSymbolStackWalkContext object instance. This will release any
        /// resources associated with this object across all components. This includes
        /// resources across computer or managed/native marshalling boundaries.
        ///
        /// DkmSymbolStackWalkContext objects are automatically closed when their associated
        /// DkmStackWalkContext object is closed.
        ///
        /// This method may only be called by the component which created the object.
        ///
        /// Location constraint: API must be called from an IDE component (component level
        /// &gt; 100,000).
        /// </summary>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Close(
            );

        /// <summary>
        /// Create a new DkmSymbolStackWalkContext object instance. The caller is responsible
        /// for closing the created object after they are done.
        ///
        /// Location constraint: API must be called from an IDE component (component level
        /// &gt; 100,000).
        /// </summary>
        /// <param name="pStackWalkContext">
        /// [In] DkmStackWalkContext allows the various components which walk, filter, or
        /// examine call stacks to store private data which is associated with this call
        /// stack.
        /// </param>
        /// <param name="SymbolProviderId">
        /// [In] Unique identifier for symbol files/symbol providers.
        /// </param>
        /// <param name="DataItem">
        /// [In] Data object to add to the new DkmSymbolStackWalkContext instance.
        /// DkmDataItem::Null() in the case that the caller doesn't need to add a data item.
        /// </param>
        /// <param name="ppCreatedObject">
        /// [Out] Result of this method call.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ CallStack::DkmStackWalkContext* pStackWalkContext,
            _In_ const GUID& SymbolProviderId,
            _In_ const DkmDataItem& DataItem,
            _Deref_out_ CallStack::DkmSymbolStackWalkContext** ppCreatedObject
            );

        /// <summary>
        /// Initialize is invoked on each walker exactly once at the beginning of the walk
        /// process. This gives each walker a chance to initialize any state.
        ///
        /// Location constraint: API must be called from an IDE component (component level
        /// &gt; 100,000).
        /// </summary>
        /// <param name="pRegisters">
        /// [In] Registers to attempt to walk from.
        /// </param>
        /// <param name="StackRangeSize">
        /// [In] Size of the stack range that the debugger will attempt to walk through.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Initialize(
            _In_ CallStack::DkmFrameRegisters* pRegisters,
            _In_ UINT32 StackRangeSize
            );

        /// <summary>
        /// UpdatePosition is invoked by the stack provider after another walker has walked
        /// one or more frames, and so this walker must be updated before invoking
        /// WalkNextFrame.
        ///
        /// Location constraint: API must be called from an IDE component (component level
        /// &gt; 100,000).
        /// </summary>
        /// <param name="pRegisters">
        /// [In] Registers to attempt to walk from.
        /// </param>
        /// <param name="StackRangeSize">
        /// [In] Size of the stack range that the debugger will attempt to walk through.
        /// </param>
        /// <param name="pInstructionAddress">
        /// [In] Address from the instruction pointer in the registers. This will be either a
        /// 'Native' or 'Unresolved' address.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE UpdatePosition(
            _In_ CallStack::DkmFrameRegisters* pRegisters,
            _In_ UINT32 StackRangeSize,
            _In_ DkmInstructionAddress* pInstructionAddress
            );

        /// <summary>
        /// Walk the next stack frame from the call stack.
        ///
        /// Location constraint: API must be called from an IDE component (component level
        /// &gt; 100,000).
        /// </summary>
        /// <param name="ppNextRegisters">
        /// [Out,Optional] NextRegisters indicates the registers of the next frame (the
        /// caller of 'FrameObject'). It is used to invoke UpdatePosition if the next frame
        /// is owned by a different symbol provider. A null NextRegisters value indicates
        /// that the returned frame is the last frame of the call stack, so the stack walk
        /// will end here.
        /// </param>
        /// <param name="ppFrameObject">
        /// [Out,Optional] Created frame object for the current registers.
        /// </param>
        /// <returns>
        /// S_OK is returned if *ppFrameObject is non-NULL, S_FALSE is returned when
        /// *ppFrameObject is NULL, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE WalkNextFrame(
            _Deref_out_opt_ CallStack::DkmFrameRegisters** ppNextRegisters,
            _Deref_out_opt_ CallStack::DkmStackWalkFrame** ppFrameObject
            );
    }; // end of DkmSymbolStackWalkContext
    #endif // #ifndef EXCLUDE_IDE_ONLY_APIS

    // DkmUnwoundRegister represents a register of a stack frame that was unwound by an
    // unwinder.
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("00abc6e8-c394-faef-ccf4-e3180221cc60") DkmUnwoundRegister : public IUnknown
    {
        private: ___ReferenceCount_t m_ReferenceCount;
        private: DkmDispatcherObjectFlags_t m_ObjectFlags;
        private: const GUID* m_pTypeId;
        private: size_t m_ObjectGCHandle;
        // Use DkmUnwoundRegister::Create to create this object
        private: DkmUnwoundRegister();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmUnwoundRegister();
        // This object cannot be copied
        private: DkmUnwoundRegister& operator=(const DkmUnwoundRegister&);
        private: DkmUnwoundRegister(const DkmUnwoundRegister&);

        private: const CV_HREG_e m_Identifier;
        private: DkmReadOnlyCollection<BYTE>* const m_pValue;
        private: void* m__pExtendedData;

        // the code-view register constant for this value.
        public: DECLSPEC_NOTHROW CV_HREG_e STDMETHODCALLTYPE Identifier(
            );

        // A byte array representing the contents of the register. The size of the register
        // in bytes can be found by the length of this array.
        public: _Ret_ DECLSPEC_NOTHROW DkmReadOnlyCollection<BYTE>* STDMETHODCALLTYPE Value(
            );

        /// <summary>
        /// Create a new DkmUnwoundRegister object instance.
        /// </summary>
        /// <param name="Identifier">
        /// [In] the code-view register constant for this value.
        /// </param>
        /// <param name="pValue">
        /// [In] A byte array representing the contents of the register. The size of the
        /// register in bytes can be found by the length of this array.
        /// </param>
        /// <param name="ppCreatedObject">
        /// [Out] Result of this method call.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ CV_HREG_e Identifier,
            _In_ DkmReadOnlyCollection<BYTE>* pValue,
            _Deref_out_ CallStack::DkmUnwoundRegister** ppCreatedObject
            );
    }; // end of DkmUnwoundRegister

    // Arm registers.
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("991eff54-4b89-fc8e-3d59-f6b8dae67265") DkmArmFrameRegisters : public CallStack::DkmFrameRegisters
    {
        // Use DkmArmFrameRegisters::Create to create this object
        private: DkmArmFrameRegisters();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmArmFrameRegisters();
        // This object cannot be copied
        private: DkmArmFrameRegisters& operator=(const DkmArmFrameRegisters&);
        private: DkmArmFrameRegisters(const DkmArmFrameRegisters&);

        private: const UINT32 m_Pc;
        private: const UINT32 m_Sp;
        private: void* m__pExtendedData;

        // Instruction Pointer.
        public: DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE Pc(
            );

        // Stack Pointer.
        public: DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE Sp(
            );

        // Attempt to cast a 'DkmFrameRegisters' to a 'DkmArmFrameRegisters'. Return
        // NULL if the path object is not a 'DkmArmFrameRegisters'.
        // pArmRegisters : [In,Optional] Object to attempt to cast
        // Return Value : [Optional] Result of the cast.
        public: static DECLSPEC_NOTHROW DkmArmFrameRegisters* TryCast(
            DkmFrameRegisters* pRegisters
            )
        {
            if (pRegisters == NULL || pRegisters->TagValue() != Tag::ArmRegisters)
                return NULL;

            return static_cast<DkmArmFrameRegisters*>(pRegisters);
        }
    }; // end of DkmArmFrameRegisters

    #ifndef EXCLUDE_IDE_ONLY_APIS
    // DkmStackFrame represents a frame on the call stack after filtering and translation.
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("9e32fe11-196e-a0ec-b83c-0792427e91a2") DkmStackFrame : public CallStack::DkmStackWalkFrame
    {
        // Use DkmStackFrame::Create to create this object
        private: DkmStackFrame();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmStackFrame();
        // This object cannot be copied
        private: DkmStackFrame& operator=(const DkmStackFrame&);
        private: DkmStackFrame(const DkmStackFrame&);

        private: const CallStack::DkmFrameFormatOptions m_Options;
        private: const Evaluation::DkmCompilerId m_CompilerId;
        private: DkmString* const m_pFrameName;
        private: OPTIONAL DkmString* const m_pReturnType;
        private: OPTIONAL Symbols::DkmSourcePosition* const m_pSourcePosition;
        private: void* m__pExtendedData;

        // Collection of settings that affect how the stack provider formats a DkmStackFrame.
        public: DECLSPEC_NOTHROW const CallStack::DkmFrameFormatOptions& STDMETHODCALLTYPE Options(
            );

        // LanguageId/VendorId for the compiler which produced the code for this stack frame.
        // If this is unknown (ex: no symbols loaded for this module), both values will be
        // Guid.Empty. Otherwise, both values should be non-zero.
        public: DECLSPEC_NOTHROW const Evaluation::DkmCompilerId& STDMETHODCALLTYPE CompilerId(
            );

        // Name of the stack frame. DkmStackFrame.FormatOptions determines the format of the
        // function name.
        public: _Ret_ DECLSPEC_NOTHROW DkmString* STDMETHODCALLTYPE FrameName(
            );

        // [Optional] Name of the stack frame's return type. This is only provided when
        // DkmFrameNameFormatOptions.ReturnTypeField is set.
        public: _Ret_opt_ DECLSPEC_NOTHROW DkmString* STDMETHODCALLTYPE ReturnType(
            );

        // [Optional] Source code location for this stack frame. This is only provided when
        // DkmFrameNameFormatOptions.DocumentPositionField is set.
        public: _Ret_opt_ DECLSPEC_NOTHROW Symbols::DkmSourcePosition* STDMETHODCALLTYPE SourcePosition(
            );

        /// <summary>
        /// Create a new DkmStackFrame object instance.
        ///
        /// Location constraint: API must be called from an IDE component (component level
        /// &gt; 100,000).
        /// </summary>
        /// <param name="pFrame">
        /// [In] Frame represents a frame on the call stack after filtering and translation.
        /// </param>
        /// <param name="Options">
        /// [In] Collection of settings that affect how the stack provider formats a
        /// DkmStackFrame.
        /// </param>
        /// <param name="CompilerId">
        /// [In] LanguageId/VendorId for the compiler which produced the code for this stack
        /// frame. If this is unknown (ex: no symbols loaded for this module), both values
        /// will be Guid.Empty. Otherwise, both values should be non-zero.
        /// </param>
        /// <param name="pFrameName">
        /// [In] Name of the stack frame. DkmStackFrame.FormatOptions determines the format
        /// of the function name.
        /// </param>
        /// <param name="pReturnType">
        /// [In,Optional] Name of the stack frame's return type. This is only provided when
        /// DkmFrameNameFormatOptions.ReturnTypeField is set.
        /// </param>
        /// <param name="pSourcePosition">
        /// [In,Optional] Source code location for this stack frame. This is only provided
        /// when DkmFrameNameFormatOptions.DocumentPositionField is set.
        /// </param>
        /// <param name="ppCreatedObject">
        /// [Out] Result of this method call.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ CallStack::DkmStackWalkFrame* pFrame,
            _In_ const CallStack::DkmFrameFormatOptions& Options,
            _In_ const Evaluation::DkmCompilerId& CompilerId,
            _In_ DkmString* pFrameName,
            _In_opt_ DkmString* pReturnType,
            _In_opt_ Symbols::DkmSourcePosition* pSourcePosition,
            _Deref_out_ CallStack::DkmStackFrame** ppCreatedObject
            );

        /// <summary>
        /// A method that calculates and returns the effective addresses for the requested
        /// address. The effective address is the calculated address that an instruction
        /// operand represents. For instance, on x86, an instruction may be of the form
        /// dwordptr [esp-12]. The effective address of this operand will be the result of
        /// subtracting 12 from esp. The number of operands and effective addresses are
        /// architecture specific.
        ///
        /// Location constraint: API must be called from an IDE component (component level
        /// &gt; 100,000).
        /// </summary>
        /// <param name="pAddress">
        /// [In] The address for which to obtain the effective addresses.
        /// </param>
        /// <param name="ppEffectiveAddresses">
        /// [Out] The collection of effective addresses for this instruction if any.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetEffectiveAddresses(
            _In_ DkmInstructionAddress* pAddress,
            _Deref_out_ DkmReadOnlyCollection<Disassembly::DkmEffectiveAddress>** ppEffectiveAddresses
            );
    }; // end of DkmStackFrame
    #endif // #ifndef EXCLUDE_IDE_ONLY_APIS

    #ifndef EXCLUDE_IDE_ONLY_APIS
    // A stack context backed by an explicit list of frames, for example, a captured stack
    // trace from an exception.
    //
    // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("b79ed48e-5eee-89c8-d677-883341894619") DkmStackTraceContext : public CallStack::DkmStackContext
    {
        // Use DkmStackTraceContext::Create to create this object
        private: DkmStackTraceContext();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmStackTraceContext();
        // This object cannot be copied
        private: DkmStackTraceContext& operator=(const DkmStackTraceContext&);
        private: DkmStackTraceContext(const DkmStackTraceContext&);

        private: DkmReadOnlyCollection<DkmInstructionAddress*>* const m_pFrames;
        private: void* m__pExtendedData;

        // The captured frames to use.
        //
        // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
        public: _Ret_ DECLSPEC_NOTHROW DkmReadOnlyCollection<DkmInstructionAddress*>* STDMETHODCALLTYPE Frames(
            );

        /// <summary>
        /// Create a new DkmStackTraceContext object instance. The caller is responsible for
        /// closing the created object after they are done.
        ///
        /// Location constraint: API must be called from an IDE component (component level
        /// &gt; 100,000).
        ///
        /// This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
        /// </summary>
        /// <param name="pInspectionSession">
        /// [In] DkmInspectionSession allows the various components which inspect data to
        /// store private data which is associated with a group of evaluations.
        /// </param>
        /// <param name="pThread">
        /// [In] DkmThread represents a thread running in the target process.
        /// </param>
        /// <param name="FilterOptions">
        /// [In] Options for how the call stack should be filtered.
        /// </param>
        /// <param name="FormatOptions">
        /// [In] Collection of settings that affect how the stack provider formats a
        /// DkmStackFrame.
        /// </param>
        /// <param name="pThreadContext">
        /// [In,Optional] The initial thread context to use when performing the stack walk.
        /// This value is normally 'null' but can be set in order to view another call stack
        /// (ex: .cxr).
        /// </param>
        /// <param name="pAsyncContext">
        /// [In,Optional] If we are fetching the continuation frames or task creation frames,
        /// specifies the context for the async stack walk operation.
        /// </param>
        /// <param name="Operation">
        /// [In] Which type of stack walk we are doing.  If the operation is
        /// AsyncReturnStackWalk or AsyncTaskCreationStackWalk, "Task" must be non-null.
        /// Otherwise, "AsyncContext" must be NULL.
        /// </param>
        /// <param name="pFrames">
        /// [In] The captured frames to use.
        /// </param>
        /// <param name="DataItem">
        /// [In] Data object to add to the new DkmStackTraceContext instance.
        /// DkmDataItem::Null() in the case that the caller doesn't need to add a data item.
        /// </param>
        /// <param name="ppCreatedObject">
        /// [Out] Result of this method call.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ Evaluation::DkmInspectionSession* pInspectionSession,
            _In_ DkmThread* pThread,
            _In_ CallStack::DkmCallStackFilterOptions_t FilterOptions,
            _In_ const CallStack::DkmFrameFormatOptions& FormatOptions,
            _In_opt_ DkmReadOnlyCollection<BYTE>* pThreadContext,
            _In_opt_ CallStack::DkmAsyncStackWalkContext* pAsyncContext,
            _In_ CallStack::DkmStackWalkOperation_t Operation,
            _In_ DkmReadOnlyCollection<DkmInstructionAddress*>* pFrames,
            _In_ const DkmDataItem& DataItem,
            _Deref_out_ CallStack::DkmStackTraceContext** ppCreatedObject
            );
    }; // end of DkmStackTraceContext
    #endif // #ifndef EXCLUDE_IDE_ONLY_APIS

    // X64 registers. For leaf frames, all registers will be available. For non-leaf frames,
    // only the registers actually unwound by the unwinder will be available. Unwound
    // registers can be found in the DkmFrameRegisters' UnwoundRegisters collection. Rip and
    // Rsp are provided because they are always unwound and accessed often.
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("23cfb317-a11e-4213-b192-2da6a78f5a9a") DkmX64FrameRegisters : public CallStack::DkmFrameRegisters
    {
        // Use DkmX64FrameRegisters::Create to create this object
        private: DkmX64FrameRegisters();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmX64FrameRegisters();
        // This object cannot be copied
        private: DkmX64FrameRegisters& operator=(const DkmX64FrameRegisters&);
        private: DkmX64FrameRegisters(const DkmX64FrameRegisters&);

        private: const UINT64 m_Rip;
        private: const UINT64 m_Rsp;
        private: void* m__pExtendedData;

        // Instruction pointer.
        public: DECLSPEC_NOTHROW UINT64 STDMETHODCALLTYPE Rip(
            );

        // Stack pointer.
        public: DECLSPEC_NOTHROW UINT64 STDMETHODCALLTYPE Rsp(
            );

        // Attempt to cast a 'DkmFrameRegisters' to a 'DkmX64FrameRegisters'. Return
        // NULL if the path object is not a 'DkmX64FrameRegisters'.
        // pX64Registers : [In,Optional] Object to attempt to cast
        // Return Value : [Optional] Result of the cast.
        public: static DECLSPEC_NOTHROW DkmX64FrameRegisters* TryCast(
            DkmFrameRegisters* pRegisters
            )
        {
            if (pRegisters == NULL || pRegisters->TagValue() != Tag::X64Registers)
                return NULL;

            return static_cast<DkmX64FrameRegisters*>(pRegisters);
        }
    }; // end of DkmX64FrameRegisters

    // X86 registers. For leaf frames, all registers will be available. For non-leaf frames,
    // only the registers actually unwound by the unwinder will be available. Unwound
    // registers can be found in the DkmFrameRegisters' UnwoundRegisters collection. Eip and
    // Esp are provided because they are always unwound and accessed often.
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("6e768c76-d179-e13b-d745-e4bb2b687e16") DkmX86FrameRegisters : public CallStack::DkmFrameRegisters
    {
        // Use DkmX86FrameRegisters::Create to create this object
        private: DkmX86FrameRegisters();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmX86FrameRegisters();
        // This object cannot be copied
        private: DkmX86FrameRegisters& operator=(const DkmX86FrameRegisters&);
        private: DkmX86FrameRegisters(const DkmX86FrameRegisters&);

        private: const UINT32 m_Eip;
        private: const UINT32 m_Esp;
        private: const UINT32 m_VFrame;
        private: void* m__pExtendedData;

        // Instruction pointer.
        public: DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE Eip(
            );

        // Stack pointer.
        public: DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE Esp(
            );

        // VFrame virtual register.
        public: DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE VFrame(
            );

        // Attempt to cast a 'DkmFrameRegisters' to a 'DkmX86FrameRegisters'. Return
        // NULL if the path object is not a 'DkmX86FrameRegisters'.
        // pX86Registers : [In,Optional] Object to attempt to cast
        // Return Value : [Optional] Result of the cast.
        public: static DECLSPEC_NOTHROW DkmX86FrameRegisters* TryCast(
            DkmFrameRegisters* pRegisters
            )
        {
            if (pRegisters == NULL || pRegisters->TagValue() != Tag::X86Registers)
                return NULL;

            return static_cast<DkmX86FrameRegisters*>(pRegisters);
        }
    }; // end of DkmX86FrameRegisters

}; // end namespace CallStack

// Contains types related to processing exceptions coming from the target process. This
// includes both setting triggers to be notified when specific exceptions are raised as
// well as describing exceptions coming out of the target. This namespace contains only
// the runtime environment agnostic types, with additional types found in the 'Native',
// 'Clr', 'Script' and 'CustomRuntimes' namespaces.
namespace Exceptions {
    // Result of an asynchronous DkmProcess.AddExceptionTrigger call.
    struct DkmAddExceptionTriggerAsyncResult
    {
        // HRESULT code returned from the caller. This will be
        // DkmExceptionCode.COR_E_OPERATIONCANCELED (0x8013153B) if the operation was
        // canceled before processing was complete.
        HRESULT ErrorCode;
    };

    // Indicates the type of exception.
    struct DkmExceptionCategory
    {
        // C++ Exception.
        // Cpp is defined as {3a12d0b7-c26c-11d0-b442-00a0244a1dd2}.
        static const GUID Cpp;
        // Win32 Exception.
        // Win32 is defined as {3b476d35-a401-11d2-aad4-00c04f990171}.
        static const GUID Win32;
        // Common Language Runtime Exception.
        // Clr is defined as {449ec4cc-30d2-4032-9256-ee18eb41b62b}.
        static const GUID Clr;
        // Native Run-Time Check.
        // NativeRuntimeCheck is defined as {63a08714-fc37-11d2-904c-00c04fa302a1}.
        static const GUID NativeRuntimeCheck;
        // Managed Debugging Assistant (MDA). These are notifications that come of the CLR to
        // notify the user of problems.
        // ManagedDebuggingAssistant is defined as {6ece07a9-0ede-45c4-8296-818d8fc401d4}.
        static const GUID ManagedDebuggingAssistant;
        // ActiveScript Exception.
        // ActiveScript is defined as {9e32aeae-0a90-49d4-9e2a-041c812eb0cc}.
        static const GUID ActiveScript;
        // GPU Exception.
        // Gpu is defined as {d7b0137a-4054-41fc-aa2f-a4c1c8b72138}.
        static const GUID Gpu;
    };
    __declspec(selectany) const GUID DkmExceptionCategory::Cpp = { 0x3a12d0b7, 0xc26c, 0x11d0, { 0xb4, 0x42, 0x0, 0xa0, 0x24, 0x4a, 0x1d, 0xd2 } };
    __declspec(selectany) const GUID DkmExceptionCategory::Win32 = { 0x3b476d35, 0xa401, 0x11d2, { 0xaa, 0xd4, 0x0, 0xc0, 0x4f, 0x99, 0x1, 0x71 } };
    __declspec(selectany) const GUID DkmExceptionCategory::Clr = { 0x449ec4cc, 0x30d2, 0x4032, { 0x92, 0x56, 0xee, 0x18, 0xeb, 0x41, 0xb6, 0x2b } };
    __declspec(selectany) const GUID DkmExceptionCategory::NativeRuntimeCheck = { 0x63a08714, 0xfc37, 0x11d2, { 0x90, 0x4c, 0x0, 0xc0, 0x4f, 0xa3, 0x2, 0xa1 } };
    __declspec(selectany) const GUID DkmExceptionCategory::ManagedDebuggingAssistant = { 0x6ece07a9, 0xede, 0x45c4, { 0x82, 0x96, 0x81, 0x8d, 0x8f, 0xc4, 0x1, 0xd4 } };
    __declspec(selectany) const GUID DkmExceptionCategory::ActiveScript = { 0x9e32aeae, 0xa90, 0x49d4, { 0x9e, 0x2a, 0x4, 0x1c, 0x81, 0x2e, 0xb0, 0xcc } };
    __declspec(selectany) const GUID DkmExceptionCategory::Gpu = { 0xd7b0137a, 0x4054, 0x41fc, { 0xaa, 0x2f, 0xa4, 0xc1, 0xc8, 0xb7, 0x21, 0x38 } };

    // Provides information about an exception which was raised in the target process. This
    // information includes details of what exception was raised and the current stage of
    // exception processing.
    //
    // Derived classes: DkmClrExceptionInformation, DkmCppExceptionInformation,
    // DkmCustomExceptionInformation, DkmGPUMemoryAccessExceptionInformation,
    // DkmWin32ExceptionInformation
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("02e0d36d-e7ec-ebb8-105e-1b6ac73701ff") DkmExceptionInformation : public IUnknown
    {
        private: ___ReferenceCount_t m_ReferenceCount;
        private: DkmDispatcherObjectFlags_t m_ObjectFlags;
        private: const GUID* m_pTypeId;
        private: size_t m_ObjectGCHandle;
        // Use DkmExceptionInformation::Create to create this object
        private: DkmExceptionInformation();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmExceptionInformation();
        // This object cannot be copied
        private: DkmExceptionInformation& operator=(const DkmExceptionInformation&);
        private: DkmExceptionInformation(const DkmExceptionInformation&);

        // DkmExceptionInformation is an abstract base class. This enum indicates which
        // derived class this object is an instance of.
        public: FORWARD_DECLARE_SCOPED_ENUM(Tag);
        DEFINE_SCOPED_ENUM(Tag)
        {
        // Object is an instance of 'DkmWin32ExceptionInformation'.
        Win32Exception = 0,
        // Object is an instance of 'DkmClrExceptionInformation'.
        ClrException = 1,
        // Object is an instance of 'DkmCppExceptionInformation'.
        CppException = 2,
        // Object is an instance of 'DkmGPUMemoryAccessExceptionInformation'.
        GPUMemoryAccessException = 3,
        // Object is an instance of 'DkmCustomExceptionInformation'.
        CustomException = 4
        };

        private: const Tag_t m_TagValue;
        private: DkmRuntimeInstance* const m_pRuntimeInstance;
        private: const GUID m_ExceptionCategory;
        private: DkmThread* const m_pThread;
        private: OPTIONAL DkmInstructionAddress* const m_pInstructionAddress;
        private: OPTIONAL DkmString* const m_pName;
        private: const UINT32 m_Code;
        private: const Exceptions::DkmExceptionProcessingStage_t m_ProcessingStage;
        private: OPTIONAL Exceptions::DkmExceptionInformation* const m_pImplementationException;
        private: void* m__pExtendedData;

        // DkmExceptionInformation is an abstract base class. This enum indicates which
        // derived class this object is an instance of.
        public: DECLSPEC_NOTHROW Tag_t STDMETHODCALLTYPE TagValue(
            );

        // The DkmRuntimeInstance class represents an execution environment which is loaded
        // into a DkmProcess and which contains code to be debugged.
        public: _Ret_ DECLSPEC_NOTHROW DkmRuntimeInstance* STDMETHODCALLTYPE RuntimeInstance(
            );

        // Indicates the type of exception.
        public: DECLSPEC_NOTHROW const GUID& STDMETHODCALLTYPE ExceptionCategory(
            );

        // DkmThread represents a thread running in the target process.
        public: _Ret_ DECLSPEC_NOTHROW DkmThread* STDMETHODCALLTYPE Thread(
            );

        // [Optional] Address where the exception occurred. This will always be present for
        // C++ and Win32 exceptions. It may be missing from CLR exceptions or MDAs as these
        // may originate from inside the runtime.
        public: _Ret_opt_ DECLSPEC_NOTHROW DkmInstructionAddress* STDMETHODCALLTYPE InstructionAddress(
            );

        // [Optional] Name of the exception. For C++ or CLR exceptions, this is the type
        // name. This value will be null for exception categories that identify exceptions by
        // code (ex: Win32).
        public: _Ret_opt_ DECLSPEC_NOTHROW DkmString* STDMETHODCALLTYPE Name(
            );

        // 32-bit integer code for the exception. For Win32 exceptions, this is the code
        // passed to RaiseException (ex:EXCEPTION_ACCESS_VIOLATION). This value is zero for
        // exception categories that identify exceptions by string (ex: CLR).
        public: DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE Code(
            );

        // The debugger receives notifications from the target process at various stages
        // within exception processing (ex: exception thrown, exception unhandled). This
        // enumeration indicates the stage(s) for a notification.
        public: DECLSPEC_NOTHROW Exceptions::DkmExceptionProcessingStage_t STDMETHODCALLTYPE ProcessingStage(
            );

        // [Optional] Information about the underlying exception used to implement a higher
        // level exception. For example, CLR and C++ exceptions may be implemented on top of
        // Win32 exceptions. So this may store the DkmWin32ExceptionInformation for CLR or
        // C++ exceptions.
        public: _Ret_opt_ DECLSPEC_NOTHROW Exceptions::DkmExceptionInformation* STDMETHODCALLTYPE ImplementationException(
            );

        // DkmProcess represents a target process which is being debugged. The debugger
        // debugs processes, so this is the basic unit of debugging. A DkmProcess can
        // represent a system process or a virtual process such as minidumps.
        public: _Ret_ DECLSPEC_NOTHROW DkmProcess* STDMETHODCALLTYPE Process(
            );

        #ifndef EXCLUDE_MONITOR_ONLY_APIS
        /// <summary>
        /// Raise a DebugMonitorException event. Components which implement the event sync
        /// interface will receive the event notification. Control will return once all
        /// components have been notified.
        ///
        /// Location constraint: API must be called from a Monitor component (component level
        /// &lt; 100,000).
        /// </summary>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE OnDebugMonitorException(
            );
        #endif // #ifndef EXCLUDE_MONITOR_ONLY_APIS

        #ifndef EXCLUDE_MONITOR_ONLY_APIS
        /// <summary>
        /// Raise a ExceptionContinued event. Components which implement the event sync
        /// interface will receive the event notification. Control will return once all
        /// components have been notified.
        ///
        /// Location constraint: API must be called from a Monitor component (component level
        /// &lt; 100,000).
        /// </summary>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE OnContinued(
            );
        #endif // #ifndef EXCLUDE_MONITOR_ONLY_APIS

        /// <summary>
        /// Determines if processing for this exception may be modified by the debugger. For
        /// example, if this user has performed an action (such as set next statement) that
        /// required the exception to be implicitly squashed, this may return false. This
        /// method may also return false if the runtime does not permit the exception from
        /// being squashed.
        /// </summary>
        /// <param name="pResult">
        /// [Out] True if the debug monitor is able to modify the processing of this
        /// exceptions.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE CanModifyProcessing(
            _Out_ bool* pResult
            );

        /// <summary>
        /// Updates the state of the target process so that when execution is resumed, the
        /// target process will not continue standard exception processing (ex: handler
        /// search, stack unwinding). This method needs to be called before resuming
        /// execution.
        /// </summary>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE SquashProcessing(
            );

        #ifndef EXCLUDE_MONITOR_ONLY_APIS
        /// <summary>
        /// Provides a string description for an exception. This is used when tracing the
        /// exception to the output window.
        ///
        /// Location constraint: API must be called from a Monitor component (component level
        /// &lt; 100,000).
        /// </summary>
        /// <param name="ppValue">
        /// [Out] String description of the exception.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetDescription(
            _Deref_out_ DkmString** ppValue
            );
        #endif // #ifndef EXCLUDE_MONITOR_ONLY_APIS

        #ifndef EXCLUDE_MONITOR_ONLY_APIS
        /// <summary>
        /// Provides additional information about an exception which will appear when Visual
        /// Studio stops on the exception. For CLR exceptions, this contains the 'Message'
        /// property from the System.Exception which was thrown.
        ///
        /// Location constraint: API must be called from a Monitor component (component level
        /// &lt; 100,000).
        /// </summary>
        /// <param name="ppValue">
        /// [Out,Optional] String description of the exception. If no other information is
        /// available, null is returned.
        /// </param>
        /// <returns>
        /// S_OK is returned if *ppValue is non-NULL, S_FALSE is returned when *ppValue is
        /// NULL, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetAdditionalInformation(
            _Deref_out_opt_ DkmString** ppValue
            );
        #endif // #ifndef EXCLUDE_MONITOR_ONLY_APIS

        #ifndef EXCLUDE_MONITOR_ONLY_APIS
        /// <summary>
        /// Provides developer-oriented additional information about the exception.  This
        /// info should be displayed along with GetDescription and GetAdditionalInformation
        /// to clarify the cause of the error.
        ///
        /// Location constraint: API must be called from a Monitor component (component level
        /// &lt; 100,000).
        /// </summary>
        /// <param name="ppRestrictedDescription">
        /// [Out,Optional] RestrictedErrorInfo description of the exception. Due to security
        /// restrictions, this may not be available even if RestrictedErrorInfo is available
        /// for the exception.
        /// </param>
        /// <param name="ppRestrictedErrorReference">
        /// [Out,Optional] If present, used to retrieve IRestrictedErrorInfo via the
        /// RoResolvedRestrictedErrorInfoReference API.
        /// </param>
        /// <param name="ppRestrictedCapabilitySid">
        /// [Out,Optional] If present specifies the missing capability.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetWinRTErrorInfo(
            _Deref_out_opt_ DkmString** ppRestrictedDescription,
            _Deref_out_opt_ DkmString** ppRestrictedErrorReference,
            _Deref_out_opt_ DkmString** ppRestrictedCapabilitySid
            );
        #endif // #ifndef EXCLUDE_MONITOR_ONLY_APIS

        #ifndef EXCLUDE_MONITOR_ONLY_APIS
        /// <summary>
        /// Raise a OutOfBandException event. Components which implement the event sync
        /// interface will receive the event notification. Control will return once all
        /// components have been notified.
        ///
        /// Location constraint: API must be called from a Monitor component (component level
        /// &lt; 100,000).
        ///
        /// This API was introduced in Visual Studio 11 Update 1
        /// (DkmApiVersion.VS11FeaturePack1).
        /// </summary>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE OnOutOfBandException(
            );
        #endif // #ifndef EXCLUDE_MONITOR_ONLY_APIS

        /// <summary>
        /// Obtains the captured stack trace associated with the exception, if one is
        /// available.
        ///
        /// This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
        /// </summary>
        /// <param name="ppStackTrace">
        /// [Out,Optional] An array of frames that were running at the time the exception got
        /// thrown.
        /// </param>
        /// <returns>
        /// S_OK is returned if *ppStackTrace is non-NULL, S_FALSE is returned when
        /// *ppStackTrace is NULL, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetExceptionStackTrace(
            _Deref_out_opt_ DkmReadOnlyCollection<DkmInstructionAddress*>** ppStackTrace
            );
    }; // end of DkmExceptionInformation

    // Specifies exception interception actions.
    DEFINE_SCOPED_ENUM(DkmExceptionInterceptActionFlags)
    {
        // No flags set.
        None = 0x0,
        // Intercept exception.
        Intercept = 0x1,
        // Cancel intercept request.
        CancelIntercept = 0x2
    };
    DEFINE_SCOPED_ENUM_FLAG_OPERATORS(DkmExceptionInterceptActionFlags_t);

    // The debugger receives notifications from the target process at various stages within
    // exception processing (ex: exception thrown, exception unhandled). This enumeration
    // indicates the stage(s) for a notification.
    DEFINE_SCOPED_ENUM(DkmExceptionProcessingStage)
    {
        // An exception was thrown. This notification occurs for all types of exceptions.
        Thrown = 0x1,
        // The target process has begun searching for an exception handler and this search
        // has entered user code. This notification is provided only for exception categories
        // which support Just My Code. Currently, only the CLR & Script exception categories
        // support Just My Code.
        //
        // In CLR devices scenarios or when Just My Code stepping is disabled in the UI, the
        // back end will not have support for Just My Code. In this case, when an exception
        // is thrown, both the 'Thrown' and 'UserCodeSearch' flags will be set.
        UserCodeSearch = 0x2,
        // The target process is about to swallow the exception at an app domain transition.
        AppDomainTransition = 0x4,
        // The target process is about to pass the exception from managed code into unmanaged
        // code.
        ManagedUnmanagedTransition = 0x8,
        // An exception handler has been found outside of user code. This notification is
        // provided only for exception categories which support Just My Code. Currently, only
        // the CLR exception category supports Just My Code.\n.
        UserUnhandled = 0x10,
        // No handler was found for this exception.
        Unhandled = 0x20,
        // Exception should be visible to users. When set, the exception will be sent to the
        // output window if the user doesn't wish to stop at the exception.
        UserVisible = 0x40
    };
    DEFINE_SCOPED_ENUM_FLAG_OPERATORS(DkmExceptionProcessingStage_t);

    // Describes an exception or collection of exceptions which a component wants to break
    // on. When a higher level components wants to be notified about certain exceptions, it
    // should create one or more exception triggers, and then enable these triggers
    // (DkmProcess.EnableExceptionTriggers). After this, when the exception occurs, a
    // ExceptionTriggerHit exception will be fired whenever this trigger is met.
    //
    // Derived classes: DkmExceptionCategoryTrigger, DkmExceptionCodeTrigger,
    // DkmExceptionGlobalTrigger, DkmExceptionNameTrigger
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("736be8c2-b44a-3d59-24b1-e132fbe225fc") DkmExceptionTrigger : public IUnknown
    {
        private: ___ReferenceCount_t m_ReferenceCount;
        private: DkmDispatcherObjectFlags_t m_ObjectFlags;
        private: const GUID* m_pTypeId;
        private: size_t m_ObjectGCHandle;
        // Use DkmExceptionTrigger::Create to create this object
        private: DkmExceptionTrigger();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmExceptionTrigger();
        // This object cannot be copied
        private: DkmExceptionTrigger& operator=(const DkmExceptionTrigger&);
        private: DkmExceptionTrigger(const DkmExceptionTrigger&);

        // DkmExceptionTrigger is an abstract base class. This enum indicates which derived
        // class this object is an instance of.
        public: FORWARD_DECLARE_SCOPED_ENUM(Tag);
        DEFINE_SCOPED_ENUM(Tag)
        {
        // Object is an instance of 'DkmExceptionGlobalTrigger'.
        GlobalTrigger = 0,
        // Object is an instance of 'DkmExceptionCategoryTrigger'.
        CategoryTrigger = 1,
        // Object is an instance of 'DkmExceptionNameTrigger'.
        NameTrigger = 2,
        // Object is an instance of 'DkmExceptionCodeTrigger'.
        CodeTrigger = 3
        };

        private: const Tag_t m_TagValue;
        private: const Exceptions::DkmExceptionProcessingStage_t m_ProcessingStage;
        private: OPTIONAL DkmThread* const m_pThread;
        private: void* m__pExtendedData;

        // DkmExceptionTrigger is an abstract base class. This enum indicates which derived
        // class this object is an instance of.
        public: DECLSPEC_NOTHROW Tag_t STDMETHODCALLTYPE TagValue(
            );

        // The debugger receives notifications from the target process at various stages
        // within exception processing (ex: exception thrown, exception unhandled). This
        // enumeration is a bit mask of which of these stages the trigger should fire for.
        public: DECLSPEC_NOTHROW Exceptions::DkmExceptionProcessingStage_t STDMETHODCALLTYPE ProcessingStage(
            );

        // [Optional] Thread on which this trigger applies. If null, the trigger will be
        // examined for all threads.
        public: _Ret_opt_ DECLSPEC_NOTHROW DkmThread* STDMETHODCALLTYPE Thread(
            );
    }; // end of DkmExceptionTrigger

    // Provides information about an exception trigger which was satisfied (hit) by an
    // exception coming from the target process.
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("4d7aee60-dc8d-794c-98c2-7f4704eeb5d1") DkmExceptionTriggerHit : public IUnknown
    {
        private: ___ReferenceCount_t m_ReferenceCount;
        private: DkmDispatcherObjectFlags_t m_ObjectFlags;
        private: const GUID* m_pTypeId;
        private: size_t m_ObjectGCHandle;
        // Use DkmExceptionTriggerHit::Create to create this object
        private: DkmExceptionTriggerHit();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmExceptionTriggerHit();
        // This object cannot be copied
        private: DkmExceptionTriggerHit& operator=(const DkmExceptionTriggerHit&);
        private: DkmExceptionTriggerHit(const DkmExceptionTriggerHit&);

        // Contains additional fields of DkmExceptionTriggerHit which were added after the
        // class was initally introduced.
        private: struct ___ExtendedData
        {
            ___ExtendedData();

            // [Optional] The stack trace of the exception, if available.
            OPTIONAL DkmReadOnlyCollection<DkmInstructionAddress*>* const pStackTrace;
        };

        private: Exceptions::DkmExceptionInformation* const m_pException;
        private: DkmString* const m_pDescription;
        private: OPTIONAL DkmString* const m_pRestrictedErrorDescription;
        private: OPTIONAL DkmString* const m_pCapabilitySid;
        private: OPTIONAL DkmString* const m_pRestrictedReference;
        private: OPTIONAL DkmString* const m_pAdditionalInformation;
        private: const GUID m_SourceId;
        private: ___ExtendedData* const m__pExtendedData;

        // Provides information about an exception which was raised in the target process.
        // This information includes details of what exception was raised and the current
        // stage of exception processing.
        public: _Ret_ DECLSPEC_NOTHROW Exceptions::DkmExceptionInformation* STDMETHODCALLTYPE Exception(
            );

        // Description string for the exception. This is obtained from
        // IDkmExceptionFormatter.GetDescription.
        public: _Ret_ DECLSPEC_NOTHROW DkmString* STDMETHODCALLTYPE Description(
            );

        // [Optional] Optional WinRT Restricted Description for the error, obtained from the
        // IDkmExceptionFormatterCallback.GetRestrictedErrorInfo.
        public: _Ret_opt_ DECLSPEC_NOTHROW DkmString* STDMETHODCALLTYPE RestrictedErrorDescription(
            );

        // [Optional] Specifies the missing capability if there is one which resulted in a
        // runtime exception.
        public: _Ret_opt_ DECLSPEC_NOTHROW DkmString* STDMETHODCALLTYPE CapabilitySid(
            );

        // [Optional] Specifies the restricted reference. This is provided instead of the
        // RestrictedDescription and any CapabilitySid. A scenario for this is when the
        // debuggee process is not running in same session as debugger process. Components
        // above will need to use this to work out the restricted description and any missing
        // capability.
        public: _Ret_opt_ DECLSPEC_NOTHROW DkmString* STDMETHODCALLTYPE RestrictedReference(
            );

        // [Optional] Optional additional information about this exception. For CLR
        // exceptions, this contains the 'Message' property from the System.Exception which
        // was thrown. This information is obtained from
        // IDkmExceptionFormatter.GetAdditionalInformation.
        public: _Ret_opt_ DECLSPEC_NOTHROW DkmString* STDMETHODCALLTYPE AdditionalInformation(
            );

        // Identifies the source of an object. SourceIds are used to enable filtering in
        // scenarios when multiple components may be creating instances of a class. For
        // example, source ids can be used to determine if a breakpoint comes from the AD7 AL
        // (ex: user breakpoint, or other breakpoint visible at the SDM level) instead of a
        // breakpoint which may be created by another component (for example an internal
        // breakpoint used for stepping).
        public: DECLSPEC_NOTHROW const GUID& STDMETHODCALLTYPE SourceId(
            );

        // [Optional] The stack trace of the exception, if available.
        //
        // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
        public: _Ret_opt_ DECLSPEC_NOTHROW DkmReadOnlyCollection<DkmInstructionAddress*>* STDMETHODCALLTYPE StackTrace(
            );

        // DkmProcess represents a target process which is being debugged. The debugger
        // debugs processes, so this is the basic unit of debugging. A DkmProcess can
        // represent a system process or a virtual process such as minidumps.
        public: _Ret_ DECLSPEC_NOTHROW DkmProcess* STDMETHODCALLTYPE Process(
            );

        // DkmThread represents a thread running in the target process.
        public: _Ret_ DECLSPEC_NOTHROW DkmThread* STDMETHODCALLTYPE Thread(
            );

        // The DkmRuntimeInstance class represents an execution environment which is loaded
        // into a DkmProcess and which contains code to be debugged.
        public: _Ret_ DECLSPEC_NOTHROW DkmRuntimeInstance* STDMETHODCALLTYPE RuntimeInstance(
            );

        /// <summary>
        /// Create a new DkmExceptionTriggerHit object instance.
        /// </summary>
        /// <param name="pException">
        /// [In] Provides information about an exception which was raised in the target
        /// process. This information includes details of what exception was raised and the
        /// current stage of exception processing.
        /// </param>
        /// <param name="pDescription">
        /// [In] Description string for the exception. This is obtained from
        /// IDkmExceptionFormatter.GetDescription.
        /// </param>
        /// <param name="pRestrictedErrorDescription">
        /// [In,Optional] Optional WinRT Restricted Description for the error, obtained from
        /// the IDkmExceptionFormatterCallback.GetRestrictedErrorInfo.
        /// </param>
        /// <param name="pCapabilitySid">
        /// [In,Optional] Specifies the missing capability if there is one which resulted in
        /// a runtime exception.
        /// </param>
        /// <param name="pRestrictedReference">
        /// [In,Optional] Specifies the restricted reference. This is provided instead of the
        /// RestrictedDescription and any CapabilitySid. A scenario for this is when the
        /// debuggee process is not running in same session as debugger process. Components
        /// above will need to use this to work out the restricted description and any
        /// missing capability.
        /// </param>
        /// <param name="pAdditionalInformation">
        /// [In,Optional] Optional additional information about this exception. For CLR
        /// exceptions, this contains the 'Message' property from the System.Exception which
        /// was thrown. This information is obtained from
        /// IDkmExceptionFormatter.GetAdditionalInformation.
        /// </param>
        /// <param name="SourceId">
        /// [In] Identifies the source of an object. SourceIds are used to enable filtering
        /// in scenarios when multiple components may be creating instances of a class. For
        /// example, source ids can be used to determine if a breakpoint comes from the AD7
        /// AL (ex: user breakpoint, or other breakpoint visible at the SDM level) instead of
        /// a breakpoint which may be created by another component (for example an internal
        /// breakpoint used for stepping).
        /// </param>
        /// <param name="ppCreatedObject">
        /// [Out] Result of this method call.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ Exceptions::DkmExceptionInformation* pException,
            _In_ DkmString* pDescription,
            _In_opt_ DkmString* pRestrictedErrorDescription,
            _In_opt_ DkmString* pCapabilitySid,
            _In_opt_ DkmString* pRestrictedReference,
            _In_opt_ DkmString* pAdditionalInformation,
            _In_ const GUID& SourceId,
            _Deref_out_ Exceptions::DkmExceptionTriggerHit** ppCreatedObject
            );

        /// <summary>
        /// Create a new DkmExceptionTriggerHit object instance.
        ///
        /// This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
        /// </summary>
        /// <param name="pException">
        /// [In] Provides information about an exception which was raised in the target
        /// process. This information includes details of what exception was raised and the
        /// current stage of exception processing.
        /// </param>
        /// <param name="pDescription">
        /// [In] Description string for the exception. This is obtained from
        /// IDkmExceptionFormatter.GetDescription.
        /// </param>
        /// <param name="pRestrictedErrorDescription">
        /// [In,Optional] Optional WinRT Restricted Description for the error, obtained from
        /// the IDkmExceptionFormatterCallback.GetRestrictedErrorInfo.
        /// </param>
        /// <param name="pCapabilitySid">
        /// [In,Optional] Specifies the missing capability if there is one which resulted in
        /// a runtime exception.
        /// </param>
        /// <param name="pRestrictedReference">
        /// [In,Optional] Specifies the restricted reference. This is provided instead of the
        /// RestrictedDescription and any CapabilitySid. A scenario for this is when the
        /// debuggee process is not running in same session as debugger process. Components
        /// above will need to use this to work out the restricted description and any
        /// missing capability.
        /// </param>
        /// <param name="pAdditionalInformation">
        /// [In,Optional] Optional additional information about this exception. For CLR
        /// exceptions, this contains the 'Message' property from the System.Exception which
        /// was thrown. This information is obtained from
        /// IDkmExceptionFormatter.GetAdditionalInformation.
        /// </param>
        /// <param name="SourceId">
        /// [In] Identifies the source of an object. SourceIds are used to enable filtering
        /// in scenarios when multiple components may be creating instances of a class. For
        /// example, source ids can be used to determine if a breakpoint comes from the AD7
        /// AL (ex: user breakpoint, or other breakpoint visible at the SDM level) instead of
        /// a breakpoint which may be created by another component (for example an internal
        /// breakpoint used for stepping).
        /// </param>
        /// <param name="pStackTrace">
        /// [In,Optional] The stack trace of the exception, if available.
        /// </param>
        /// <param name="ppCreatedObject">
        /// [Out] Result of this method call.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ Exceptions::DkmExceptionInformation* pException,
            _In_ DkmString* pDescription,
            _In_opt_ DkmString* pRestrictedErrorDescription,
            _In_opt_ DkmString* pCapabilitySid,
            _In_opt_ DkmString* pRestrictedReference,
            _In_opt_ DkmString* pAdditionalInformation,
            _In_ const GUID& SourceId,
            _In_opt_ DkmReadOnlyCollection<DkmInstructionAddress*>* pStackTrace,
            _Deref_out_ Exceptions::DkmExceptionTriggerHit** ppCreatedObject
            );

        /// <summary>
        /// Raise a ExceptionTriggerHit event. Components which implement the event sync
        /// interface will receive the event notification. This method will enqueue the event
        /// and control will immediately return to the caller.
        /// </summary>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Send(
            );
    }; // end of DkmExceptionTriggerHit

    // Result of an asynchronous DkmProcess.RemoveExceptionTrigger call.
    struct DkmRemoveExceptionTriggerAsyncResult
    {
        // HRESULT code returned from the caller. This will be
        // DkmExceptionCode.COR_E_OPERATIONCANCELED (0x8013153B) if the operation was
        // canceled before processing was complete.
        HRESULT ErrorCode;
    };

    // Provides information about a stowed exception. In modern apps, when an exception is
    // thrown, it is caught by COM Interop and another exception is thrown by the framework.
    // The original exception is captured as a stowed exception.
    //
    // This API was introduced in Visual Studio 12 Update 3 (DkmApiVersion.VS12Update3).
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("8e224fd7-6b35-29e2-119b-020d4df4dcac") DkmStowedExceptionInformation : public IUnknown
    {
        private: ___ReferenceCount_t m_ReferenceCount;
        private: DkmDispatcherObjectFlags_t m_ObjectFlags;
        private: const GUID* m_pTypeId;
        private: size_t m_ObjectGCHandle;
        // Use DkmStowedExceptionInformation::Create to create this object
        private: DkmStowedExceptionInformation();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmStowedExceptionInformation();
        // This object cannot be copied
        private: DkmStowedExceptionInformation& operator=(const DkmStowedExceptionInformation&);
        private: DkmStowedExceptionInformation(const DkmStowedExceptionInformation&);

        // Stowed Exceptions can contain a nested exception. If this is non-null, the Stowed
        // exception contains additional information in the NestedException.
        //
        // This API was introduced in Visual Studio 12 Update 3 (DkmApiVersion.VS12Update3).
        public: struct NestedException
        {
            // A pointer to the Nested Exception record.
            UINT64 NestedExceptionAddress;

            // The type of Exception that NestedExceptionAddress is pointing to.
            Exceptions::DkmStowedExceptionNestedType_t NestedExceptionType;
        };

        private: OPTIONAL const Exceptions::DkmStowedExceptionInformation::NestedException* const m_pNestedException;
        private: const HRESULT m_ResultCode;
        private: const UINT32 m_ThreadId;
        private: OPTIONAL DkmString* const m_pErrorText;
        private: const UINT64 m_ExceptionAddress;
        private: const UINT32 m_StackTraceWordSize;
        private: const UINT32 m_StackTraceWords;
        private: const UINT64 m_StackTrace;
        private: void* m__pExtendedData;

        // [Optional] Stowed Exceptions can contain a nested exception. If this is non-null,
        // the Stowed exception contains additional information in the NestedException.
        //
        // This API was introduced in Visual Studio 12 Update 3 (DkmApiVersion.VS12Update3).
        public: _Ret_opt_ DECLSPEC_NOTHROW const Exceptions::DkmStowedExceptionInformation::NestedException* STDMETHODCALLTYPE NestedExceptionPart(
            );

        // The HRESULT of the original thrown exception.
        //
        // This API was introduced in Visual Studio 12 Update 3 (DkmApiVersion.VS12Update3).
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ResultCode(
            );

        // The ID of the thread that the exception was thrown on. This is just an ID and not
        // a DkmThread because the thread may have exited before the dump is taken.
        //
        // This API was introduced in Visual Studio 12 Update 3 (DkmApiVersion.VS12Update3).
        public: DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE ThreadId(
            );

        // [Optional] The error text from the Stowed Exception. If this is non null, it is a
        // Text Stowed Exception (as opposed to binary), and the ExceptionAddress,
        // StackTraceWordSize, StackTraceWords, and StackTrace fields will be invalid.
        //
        // This API was introduced in Visual Studio 12 Update 3 (DkmApiVersion.VS12Update3).
        public: _Ret_opt_ DECLSPEC_NOTHROW DkmString* STDMETHODCALLTYPE ErrorText(
            );

        // The address of the exception.
        //
        // This API was introduced in Visual Studio 12 Update 3 (DkmApiVersion.VS12Update3).
        public: DECLSPEC_NOTHROW UINT64 STDMETHODCALLTYPE ExceptionAddress(
            );

        // Size, in bytes, of each word in the stack trace that the StackTrace member points
        // to. This value is set to 4 for 32-bit platforms and 8 for 64-bit platforms.
        //
        // This API was introduced in Visual Studio 12 Update 3 (DkmApiVersion.VS12Update3).
        public: DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE StackTraceWordSize(
            );

        // The number of words in the stack trace that the StackTrace member points to. The
        // number of words is equal to the number of elements in the array.
        //
        // This API was introduced in Visual Studio 12 Update 3 (DkmApiVersion.VS12Update3).
        public: DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE StackTraceWords(
            );

        // A pointer to a memory block that contains the stack trace.
        //
        // This API was introduced in Visual Studio 12 Update 3 (DkmApiVersion.VS12Update3).
        public: DECLSPEC_NOTHROW UINT64 STDMETHODCALLTYPE StackTrace(
            );

        /// <summary>
        /// Create a new DkmStowedExceptionInformation object instance.
        ///
        /// This API was introduced in Visual Studio 12 Update 3 (DkmApiVersion.VS12Update3).
        /// </summary>
        /// <param name="ResultCode">
        /// [In] The HRESULT of the original thrown exception.
        /// </param>
        /// <param name="ThreadId">
        /// [In] The ID of the thread that the exception was thrown on. This is just an ID
        /// and not a DkmThread because the thread may have exited before the dump is taken.
        /// </param>
        /// <param name="pErrorText">
        /// [In,Optional] The error text from the Stowed Exception. If this is non null, it
        /// is a Text Stowed Exception (as opposed to binary), and the ExceptionAddress,
        /// StackTraceWordSize, StackTraceWords, and StackTrace fields will be invalid.
        /// </param>
        /// <param name="ExceptionAddress">
        /// [In] The address of the exception.
        /// </param>
        /// <param name="StackTraceWordSize">
        /// [In] Size, in bytes, of each word in the stack trace that the StackTrace member
        /// points to. This value is set to 4 for 32-bit platforms and 8 for 64-bit
        /// platforms.
        /// </param>
        /// <param name="StackTraceWords">
        /// [In] The number of words in the stack trace that the StackTrace member points to.
        /// The number of words is equal to the number of elements in the array.
        /// </param>
        /// <param name="StackTrace">
        /// [In] A pointer to a memory block that contains the stack trace.
        /// </param>
        /// <param name="pNestedException">
        /// [In,Optional] Stowed Exceptions can contain a nested exception. If this is
        /// non-null, the Stowed exception contains additional information in the
        /// NestedException.
        /// </param>
        /// <param name="ppCreatedObject">
        /// [Out] Result of this method call.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ HRESULT ResultCode,
            _In_ UINT32 ThreadId,
            _In_opt_ DkmString* pErrorText,
            _In_ UINT64 ExceptionAddress,
            _In_ UINT32 StackTraceWordSize,
            _In_ UINT32 StackTraceWords,
            _In_ UINT64 StackTrace,
            _In_opt_ const Exceptions::DkmStowedExceptionInformation::NestedException* pNestedException,
            _Deref_out_ Exceptions::DkmStowedExceptionInformation** ppCreatedObject
            );
    }; // end of DkmStowedExceptionInformation

    // DkmStowedExceptionNestedType describes the type of
    // DkmStowedExceptionInformation.NestedException.NestedExceptionAddress.
    //
    // This API was introduced in Visual Studio 12 Update 3 (DkmApiVersion.VS12Update3).
    DEFINE_SCOPED_ENUM(DkmStowedExceptionNestedType)
    {
        // This value specifies that there is no nested exception object.
        None = 0,
        // This value specifies that the NestedException member points to an EXCEPTION_RECORD
        // object.
        Win32 = 1,
        // This value specifies that the NestedException member points to another stowed
        // exception object.
        Stowed = 2,
        // This value specifies that the NestedException member points to a language
        // exception object.
        LEO = 3
    };

    // Describes an entire category (ex: .NET exceptions, Win32 exceptions) that a component
    // wants to break on.
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("64994a94-4363-dfda-0dc1-00f49cc6ff43") DkmExceptionCategoryTrigger : public Exceptions::DkmExceptionTrigger
    {
        // Use DkmExceptionCategoryTrigger::Create to create this object
        private: DkmExceptionCategoryTrigger();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmExceptionCategoryTrigger();
        // This object cannot be copied
        private: DkmExceptionCategoryTrigger& operator=(const DkmExceptionCategoryTrigger&);
        private: DkmExceptionCategoryTrigger(const DkmExceptionCategoryTrigger&);

        private: const GUID m_ExceptionCategory;
        private: void* m__pExtendedData;

        // Indicates the type of exception.
        public: DECLSPEC_NOTHROW const GUID& STDMETHODCALLTYPE ExceptionCategory(
            );

        // Attempt to cast a 'DkmExceptionTrigger' to a 'DkmExceptionCategoryTrigger'. Return
        // NULL if the path object is not a 'DkmExceptionCategoryTrigger'.
        // pCategoryTrigger : [In,Optional] Object to attempt to cast
        // Return Value : [Optional] Result of the cast.
        public: static DECLSPEC_NOTHROW DkmExceptionCategoryTrigger* TryCast(
            DkmExceptionTrigger* pTrigger
            )
        {
            if (pTrigger == NULL || pTrigger->TagValue() != Tag::CategoryTrigger)
                return NULL;

            return static_cast<DkmExceptionCategoryTrigger*>(pTrigger);
        }

        /// <summary>
        /// Create a new DkmExceptionCategoryTrigger object instance.
        /// </summary>
        /// <param name="ProcessingStage">
        /// [In] The debugger receives notifications from the target process at various
        /// stages within exception processing (ex: exception thrown, exception unhandled).
        /// This enumeration is a bit mask of which of these stages the trigger should fire
        /// for.
        /// </param>
        /// <param name="pThread">
        /// [In,Optional] Thread on which this trigger applies. If null, the trigger will be
        /// examined for all threads.
        /// </param>
        /// <param name="ExceptionCategory">
        /// [In] Indicates the type of exception.
        /// </param>
        /// <param name="ppCreatedObject">
        /// [Out] Result of this method call.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ Exceptions::DkmExceptionProcessingStage_t ProcessingStage,
            _In_opt_ DkmThread* pThread,
            _In_ const GUID& ExceptionCategory,
            _Deref_out_ Exceptions::DkmExceptionCategoryTrigger** ppCreatedObject
            );
    }; // end of DkmExceptionCategoryTrigger

    // Describe an exception that a component wants to break on by its exception code. Code
    // triggers are used for exception categories which use exception codes to identify
    // exceptions (ex: Win32 exceptions). Code triggers will not fire for exception
    // categories which use a name string to identify exceptions (ex: CLR exceptions).
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("4862250b-5bf2-b9f9-4da6-6fdd7e39b841") DkmExceptionCodeTrigger : public Exceptions::DkmExceptionTrigger
    {
        // Use DkmExceptionCodeTrigger::Create to create this object
        private: DkmExceptionCodeTrigger();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmExceptionCodeTrigger();
        // This object cannot be copied
        private: DkmExceptionCodeTrigger& operator=(const DkmExceptionCodeTrigger&);
        private: DkmExceptionCodeTrigger(const DkmExceptionCodeTrigger&);

        private: const GUID m_ExceptionCategory;
        private: const UINT32 m_Code;
        private: void* m__pExtendedData;

        // Indicates the type of exception.
        public: DECLSPEC_NOTHROW const GUID& STDMETHODCALLTYPE ExceptionCategory(
            );

        // 32-bit integer code for the exception. For Win32 exceptions, this is the code
        // passed to RaiseException (ex:EXCEPTION_ACCESS_VIOLATION). This value is zero for
        // exception categories that identify exceptions by string (ex: CLR).
        public: DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE Code(
            );

        // Attempt to cast a 'DkmExceptionTrigger' to a 'DkmExceptionCodeTrigger'. Return
        // NULL if the path object is not a 'DkmExceptionCodeTrigger'.
        // pCodeTrigger : [In,Optional] Object to attempt to cast
        // Return Value : [Optional] Result of the cast.
        public: static DECLSPEC_NOTHROW DkmExceptionCodeTrigger* TryCast(
            DkmExceptionTrigger* pTrigger
            )
        {
            if (pTrigger == NULL || pTrigger->TagValue() != Tag::CodeTrigger)
                return NULL;

            return static_cast<DkmExceptionCodeTrigger*>(pTrigger);
        }

        /// <summary>
        /// Create a new DkmExceptionCodeTrigger object instance.
        /// </summary>
        /// <param name="ProcessingStage">
        /// [In] The debugger receives notifications from the target process at various
        /// stages within exception processing (ex: exception thrown, exception unhandled).
        /// This enumeration is a bit mask of which of these stages the trigger should fire
        /// for.
        /// </param>
        /// <param name="pThread">
        /// [In,Optional] Thread on which this trigger applies. If null, the trigger will be
        /// examined for all threads.
        /// </param>
        /// <param name="ExceptionCategory">
        /// [In] Indicates the type of exception.
        /// </param>
        /// <param name="Code">
        /// [In] 32-bit integer code for the exception. For Win32 exceptions, this is the
        /// code passed to RaiseException (ex:EXCEPTION_ACCESS_VIOLATION). This value is zero
        /// for exception categories that identify exceptions by string (ex: CLR).
        /// </param>
        /// <param name="ppCreatedObject">
        /// [Out] Result of this method call.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ Exceptions::DkmExceptionProcessingStage_t ProcessingStage,
            _In_opt_ DkmThread* pThread,
            _In_ const GUID& ExceptionCategory,
            _In_ UINT32 Code,
            _Deref_out_ Exceptions::DkmExceptionCodeTrigger** ppCreatedObject
            );
    }; // end of DkmExceptionCodeTrigger

    // An exception trigger which will fire regardless of exception category, exception name,
    // or exception code. Thus, this type of exception trigger can only be conditioned based
    // on processing stage or thread.
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("7e756301-6822-678f-4fdf-ebfe25bdc021") DkmExceptionGlobalTrigger : public Exceptions::DkmExceptionTrigger
    {
        // Use DkmExceptionGlobalTrigger::Create to create this object
        private: DkmExceptionGlobalTrigger();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmExceptionGlobalTrigger();
        // This object cannot be copied
        private: DkmExceptionGlobalTrigger& operator=(const DkmExceptionGlobalTrigger&);
        private: DkmExceptionGlobalTrigger(const DkmExceptionGlobalTrigger&);

        private: void* m__pExtendedData;

        // Attempt to cast a 'DkmExceptionTrigger' to a 'DkmExceptionGlobalTrigger'. Return
        // NULL if the path object is not a 'DkmExceptionGlobalTrigger'.
        // pGlobalTrigger : [In,Optional] Object to attempt to cast
        // Return Value : [Optional] Result of the cast.
        public: static DECLSPEC_NOTHROW DkmExceptionGlobalTrigger* TryCast(
            DkmExceptionTrigger* pTrigger
            )
        {
            if (pTrigger == NULL || pTrigger->TagValue() != Tag::GlobalTrigger)
                return NULL;

            return static_cast<DkmExceptionGlobalTrigger*>(pTrigger);
        }

        /// <summary>
        /// Create a new DkmExceptionGlobalTrigger object instance.
        /// </summary>
        /// <param name="ProcessingStage">
        /// [In] The debugger receives notifications from the target process at various
        /// stages within exception processing (ex: exception thrown, exception unhandled).
        /// This enumeration is a bit mask of which of these stages the trigger should fire
        /// for.
        /// </param>
        /// <param name="pThread">
        /// [In,Optional] Thread on which this trigger applies. If null, the trigger will be
        /// examined for all threads.
        /// </param>
        /// <param name="ppCreatedObject">
        /// [Out] Result of this method call.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ Exceptions::DkmExceptionProcessingStage_t ProcessingStage,
            _In_opt_ DkmThread* pThread,
            _Deref_out_ Exceptions::DkmExceptionGlobalTrigger** ppCreatedObject
            );
    }; // end of DkmExceptionGlobalTrigger

    // Describes an exception that a component wants to break on by its name. NameTriggers
    // are used for exception categories that use names to identify exceptions. For example,
    // CLR exceptions and C++ exceptions are identified by type name. Name triggers will not
    // fire for code-based exception categories (ex: Win32 exceptions).
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("dcffa6ae-e45d-fd4f-a23e-82779a332801") DkmExceptionNameTrigger : public Exceptions::DkmExceptionTrigger
    {
        // Use DkmExceptionNameTrigger::Create to create this object
        private: DkmExceptionNameTrigger();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmExceptionNameTrigger();
        // This object cannot be copied
        private: DkmExceptionNameTrigger& operator=(const DkmExceptionNameTrigger&);
        private: DkmExceptionNameTrigger(const DkmExceptionNameTrigger&);

        private: const GUID m_ExceptionCategory;
        private: DkmString* const m_pName;
        private: void* m__pExtendedData;

        // Indicates the type of exception.
        public: DECLSPEC_NOTHROW const GUID& STDMETHODCALLTYPE ExceptionCategory(
            );

        // Name of the exception. For C++ or CLR exceptions, this is the type name. This
        // value will be null for exception categories that identify exceptions by code (ex:
        // Win32 exceptions).
        public: _Ret_ DECLSPEC_NOTHROW DkmString* STDMETHODCALLTYPE Name(
            );

        // Attempt to cast a 'DkmExceptionTrigger' to a 'DkmExceptionNameTrigger'. Return
        // NULL if the path object is not a 'DkmExceptionNameTrigger'.
        // pNameTrigger : [In,Optional] Object to attempt to cast
        // Return Value : [Optional] Result of the cast.
        public: static DECLSPEC_NOTHROW DkmExceptionNameTrigger* TryCast(
            DkmExceptionTrigger* pTrigger
            )
        {
            if (pTrigger == NULL || pTrigger->TagValue() != Tag::NameTrigger)
                return NULL;

            return static_cast<DkmExceptionNameTrigger*>(pTrigger);
        }

        /// <summary>
        /// Create a new DkmExceptionNameTrigger object instance.
        /// </summary>
        /// <param name="ProcessingStage">
        /// [In] The debugger receives notifications from the target process at various
        /// stages within exception processing (ex: exception thrown, exception unhandled).
        /// This enumeration is a bit mask of which of these stages the trigger should fire
        /// for.
        /// </param>
        /// <param name="pThread">
        /// [In,Optional] Thread on which this trigger applies. If null, the trigger will be
        /// examined for all threads.
        /// </param>
        /// <param name="ExceptionCategory">
        /// [In] Indicates the type of exception.
        /// </param>
        /// <param name="pName">
        /// [In] Name of the exception. For C++ or CLR exceptions, this is the type name.
        /// This value will be null for exception categories that identify exceptions by code
        /// (ex: Win32 exceptions).
        /// </param>
        /// <param name="ppCreatedObject">
        /// [Out] Result of this method call.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ Exceptions::DkmExceptionProcessingStage_t ProcessingStage,
            _In_opt_ DkmThread* pThread,
            _In_ const GUID& ExceptionCategory,
            _In_ DkmString* pName,
            _Deref_out_ Exceptions::DkmExceptionNameTrigger** ppCreatedObject
            );
    }; // end of DkmExceptionNameTrigger

}; // end namespace Exceptions

// Contains the types related to setting breakpoints. This includes both the high-level
// breakpoint classes (DkmPendingBreakpoint, etc) that offer the same capabilities as
// user-set breakpoints, as well as the lower-level DkmRuntimeBreakpoint classes that the
// high-level breakpoints are implemented upon.
namespace Breakpoints {
    // Represents a breakpoint which has been bound (resolved) to a particular code
    // instruction address or a particular data element. For example, in C++ templates one
    // could create a DkmPendingBreakpoint for a source line. The breakpoint manager would
    // resolve it to zero (ex: module not loaded), one (ex: template is only used on 'int')
    // or many (ex: template is used with many template arguments) location. Each location
    // would have a DkmBoundBreakpoint object.
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("91c8952c-4e18-00f7-ac71-8d0d38694e4c") DkmBoundBreakpoint : public DkmDataContainer
    {
        // Use DkmBoundBreakpoint::Create to create this object
        private: DkmBoundBreakpoint();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmBoundBreakpoint();
        // This object cannot be copied
        private: DkmBoundBreakpoint& operator=(const DkmBoundBreakpoint&);
        private: DkmBoundBreakpoint(const DkmBoundBreakpoint&);

        private: Breakpoints::DkmPendingBreakpoint* const m_pPendingBreakpoint;
        private: const GUID m_UniqueId;
        private: OPTIONAL Breakpoints::DkmRuntimeBreakpoint* const m_pTarget;
        private: OPTIONAL Symbols::DkmSourcePosition* const m_pSourcePosition;
        private: void* m__pExtendedData;

        // High level breakpoint object which is tied to a user-level construct (ex: source
        // file, function name) which may map to zero or more code-level constructs
        // (DkmBoundBreakpoint) and which may be tracked over time.
        public: _Ret_ DECLSPEC_NOTHROW Breakpoints::DkmPendingBreakpoint* STDMETHODCALLTYPE PendingBreakpoint(
            );

        // Guid which uniquely identifies this bound breakpoint object.
        public: DECLSPEC_NOTHROW const GUID& STDMETHODCALLTYPE UniqueId(
            );

        // [Optional] The low-level runtime breakpoint which backs this high-level bound
        // breakpoint.
        public: _Ret_opt_ DECLSPEC_NOTHROW Breakpoints::DkmRuntimeBreakpoint* STDMETHODCALLTYPE Target(
            );

        // [Optional] An optional reference to the document and text position this breakpoint
        // bound to. This should be set unless the bound location does not have source
        // information.
        public: _Ret_opt_ DECLSPEC_NOTHROW Symbols::DkmSourcePosition* STDMETHODCALLTYPE SourcePosition(
            );

        // Identifies the source of an object. SourceIds are used to enable filtering in
        // scenarios when multiple components may be creating instances of a class. For
        // example, source ids can be used to determine if a breakpoint comes from the AD7 AL
        // (ex: user breakpoint, or other breakpoint visible at the SDM level) instead of a
        // breakpoint which may be created by another component (for example an internal
        // breakpoint used for stepping).
        public: DECLSPEC_NOTHROW const GUID& STDMETHODCALLTYPE SourceId(
            );

        // Identifies the source language (ex: C#) and compiler vendor (ex: Microsoft) that
        // the breakpoint should bind against. 'LanguageId' may be left as Guid.Empty to
        // indicate that the breakpoint should bind against all languages. 'VendorId' is
        // nearly always left as Guid.Empty, which indicates that only the language is known
        // (not the compiler).
        public: DECLSPEC_NOTHROW const Evaluation::DkmCompilerId& STDMETHODCALLTYPE CompilerId(
            );

        // DkmProcess represents a target process which is being debugged. The debugger
        // debugs processes, so this is the basic unit of debugging. A DkmProcess can
        // represent a system process or a virtual process such as minidumps.
        public: _Ret_ DECLSPEC_NOTHROW DkmProcess* STDMETHODCALLTYPE Process(
            );

        /// <summary>
        /// Closes the bound breakpoint. This is done by breakpoint manager.
        ///
        /// DkmBoundBreakpoint objects are automatically closed when their associated
        /// DkmPendingBreakpoint object is closed.
        /// </summary>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Close(
            );

        /// <summary>
        /// Called by a breakpoint manager to create a DkmBoundBreakpoint object for each
        /// location that a DkmPendingBreakpoint binds to.
        /// </summary>
        /// <param name="pPendingBreakpoint">
        /// [In] High level breakpoint object which is tied to a user-level construct (ex:
        /// source file, function name) which may map to zero or more code-level constructs
        /// (DkmBoundBreakpoint) and which may be tracked over time.
        /// </param>
        /// <param name="pTarget">
        /// [In,Optional] The low-level runtime breakpoint which backs this high-level bound
        /// breakpoint.
        /// </param>
        /// <param name="pSourcePosition">
        /// [In,Optional] An optional reference to the document and text position this
        /// breakpoint bound to. This should be set unless the bound location does not have
        /// source information.
        /// </param>
        /// <param name="DataItem">
        /// [In] Data object to add to the new DkmBoundBreakpoint instance.
        /// DkmDataItem::Null() in the case that the caller doesn't need to add a data item.
        /// </param>
        /// <param name="ppCreatedObject">
        /// [Out] Result of this method call.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ Breakpoints::DkmPendingBreakpoint* pPendingBreakpoint,
            _In_opt_ Breakpoints::DkmRuntimeBreakpoint* pTarget,
            _In_opt_ Symbols::DkmSourcePosition* pSourcePosition,
            _In_ const DkmDataItem& DataItem,
            _Deref_out_ Breakpoints::DkmBoundBreakpoint** ppCreatedObject
            );

        /// <summary>
        /// Raise a BoundBreakpointHit event. Components which implement the event sync
        /// interface will receive the event notification. This method will enqueue the event
        /// and control will immediately return to the caller.
        ///
        /// This method may only be called by the component which created the object.
        /// </summary>
        /// <param name="pThread">
        /// [In] DkmThread represents a thread running in the target process.
        /// </param>
        /// <param name="HasException">
        /// [In] Contains true if the source runtime instance can determine that an exception
        /// is in flight on the thread which hit the breakpoint. Currently, only managed
        /// runtime instances ever set this. This is used to quickly determine if exception
        /// specific logic should apply without making another network round-trip.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE OnHit(
            _In_ DkmThread* pThread,
            _In_ bool HasException
            );

        #ifndef EXCLUDE_IDE_ONLY_APIS
        /// <summary>
        /// Enables the bound breakpoint so that it can be hit. If the bound breakpoint is
        /// already enabled, this operation has no effect.
        ///
        /// This method will append a new work item to the specified work list, and return
        /// once the work item has been appended. The actual processing of the work item is
        /// asynchronous. The caller will be notified that the request is complete through
        /// the completion routine.
        ///
        /// Location constraint: API must be called from an IDE component (component level
        /// &gt; 100,000).
        /// </summary>
        /// <param name="pWorkList">
        /// WorkList to append the new work item to.
        /// </param>
        /// <param name="pCompletionRoutine">
        /// Routine to fire when the request is complete. If the request is successfully
        /// appended to the work list, this will always fire (including when the operation is
        /// canceled). This will never fire if appending the work item fails.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Enable(
            _In_ DkmWorkList* pWorkList,
            _In_ IDkmCompletionRoutine<Breakpoints::DkmEnableBoundBreakpointAsyncResult>* pCompletionRoutine
            );
        #endif // #ifndef EXCLUDE_IDE_ONLY_APIS

        #ifndef EXCLUDE_IDE_ONLY_APIS
        /// <summary>
        /// Disable the bound breakpoint so that it will no longer hit. If the bound
        /// breakpoint is already disabled, this operation has no effect.
        ///
        /// This method will append a new work item to the specified work list, and return
        /// once the work item has been appended. The actual processing of the work item is
        /// asynchronous. The caller will be notified that the request is complete through
        /// the completion routine.
        ///
        /// Location constraint: API must be called from an IDE component (component level
        /// &gt; 100,000).
        /// </summary>
        /// <param name="pWorkList">
        /// WorkList to append the new work item to.
        /// </param>
        /// <param name="pCompletionRoutine">
        /// Routine to fire when the request is complete. If the request is successfully
        /// appended to the work list, this will always fire (including when the operation is
        /// canceled). This will never fire if appending the work item fails.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Disable(
            _In_ DkmWorkList* pWorkList,
            _In_ IDkmCompletionRoutine<Breakpoints::DkmDisableBoundBreakpointAsyncResult>* pCompletionRoutine
            );
        #endif // #ifndef EXCLUDE_IDE_ONLY_APIS

        #ifndef EXCLUDE_IDE_ONLY_APIS
        /// <summary>
        /// Query to determine if the bound breakpoint is enabled.
        ///
        /// Location constraint: API must be called from an IDE component (component level
        /// &gt; 100,000).
        /// </summary>
        /// <param name="pResult">
        /// [Out] 'true' if the breakpoint is enabled.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE IsEnabled(
            _Out_ bool* pResult
            );
        #endif // #ifndef EXCLUDE_IDE_ONLY_APIS

        #ifndef EXCLUDE_IDE_ONLY_APIS
        /// <summary>
        /// Initialize or update or clear the condition on a breakpoint.  If the same
        /// breakpoint has both a language-level condition, and a hit count condition, the
        /// language-level condition is applied first.
        ///
        /// Location constraint: API must be called from an IDE component (component level
        /// &gt; 100,000).
        /// </summary>
        /// <param name="pCondition">
        /// [In,Optional] Condition to apply to this breakpoint. This value may be 'null' if
        /// the caller wishes to remove the condition.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE SetCondition(
            _In_opt_ Breakpoints::DkmBreakpointCondition* pCondition
            );
        #endif // #ifndef EXCLUDE_IDE_ONLY_APIS

        #ifndef EXCLUDE_IDE_ONLY_APIS
        /// <summary>
        /// Initialize, update or clear the hit count condition on a breakpoint. If the same
        /// breakpoint has both a language-level condition, and a hit count condition, the
        /// language-level condition is applied first.
        ///
        /// Location constraint: API must be called from an IDE component (component level
        /// &gt; 100,000).
        /// </summary>
        /// <param name="pCondition">
        /// [In,Optional] Condition to apply to this breakpoint. This value may be 'null' if
        /// the caller wishes to remove the condition.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE SetHitCountCondition(
            _In_opt_ Breakpoints::DkmBreakpointHitCountCondition* pCondition
            );
        #endif // #ifndef EXCLUDE_IDE_ONLY_APIS

        #ifndef EXCLUDE_IDE_ONLY_APIS
        /// <summary>
        /// Modifies the value for a breakpoint hit count.
        ///
        /// Location constraint: API must be called from an IDE component (component level
        /// &gt; 100,000).
        /// </summary>
        /// <param name="NewValue">
        /// [In] New value for the hit count.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE SetHitCountValue(
            _In_ UINT32 NewValue
            );
        #endif // #ifndef EXCLUDE_IDE_ONLY_APIS

        #ifndef EXCLUDE_IDE_ONLY_APIS
        /// <summary>
        /// Returns the number of times that a bound breakpoint has been hit. This value
        /// should not include any times when the breakpoint's instruction was executed, but
        /// the breakpoint's condition indicated that the debugger should not stop.
        ///
        /// This method will append a new work item to the specified work list, and return
        /// once the work item has been appended. The actual processing of the work item is
        /// asynchronous. The caller will be notified that the request is complete through
        /// the completion routine.
        ///
        /// Location constraint: API must be called from an IDE component (component level
        /// &gt; 100,000).
        /// </summary>
        /// <param name="pWorkList">
        /// WorkList to append the new work item to.
        /// </param>
        /// <param name="pCompletionRoutine">
        /// Routine to fire when the request is complete. If the request is successfully
        /// appended to the work list, this will always fire (including when the operation is
        /// canceled). This will never fire if appending the work item fails.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetHitCountValue(
            _In_ DkmWorkList* pWorkList,
            _In_ IDkmCompletionRoutine<Breakpoints::DkmGetBoundBreakpointHitCountValueAsyncResult>* pCompletionRoutine
            );
        #endif // #ifndef EXCLUDE_IDE_ONLY_APIS
    }; // end of DkmBoundBreakpoint

    // Conditions under which a breakpoint should fire.
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("6f47e50b-85ef-ba6d-e36a-8121fa195bb2") DkmBreakpointCondition : public IUnknown
    {
        private: ___ReferenceCount_t m_ReferenceCount;
        private: DkmDispatcherObjectFlags_t m_ObjectFlags;
        private: const GUID* m_pTypeId;
        private: size_t m_ObjectGCHandle;
        // Use DkmBreakpointCondition::Create to create this object
        private: DkmBreakpointCondition();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmBreakpointCondition();
        // This object cannot be copied
        private: DkmBreakpointCondition& operator=(const DkmBreakpointCondition&);
        private: DkmBreakpointCondition(const DkmBreakpointCondition&);

        private: const Breakpoints::DkmBreakpointConditionOperator_t m_Operator;
        private: const Evaluation::DkmCompilerId m_CompilerId;
        private: const Evaluation::DkmEvaluationFlags_t m_CompilationFlags;
        private: DkmString* const m_pText;
        private: const UINT32 m_Timeout;
        private: void* m__pExtendedData;

        // Indicates how the breakpoint text should be used ('BreakWhenTrue' or
        // 'BreakWhenChanged').
        public: DECLSPEC_NOTHROW Breakpoints::DkmBreakpointConditionOperator_t STDMETHODCALLTYPE Operator(
            );

        // Language of the breakpoint condition. May be Guid.Empty/Guid.Empty to indicate
        // that the language of the stack frame should be used. If present, the vendor id
        // must be defined.
        public: DECLSPEC_NOTHROW const Evaluation::DkmCompilerId& STDMETHODCALLTYPE CompilerId(
            );

        // Flags which effect how the condition text should be compiled by the expression
        // evaluator.
        public: DECLSPEC_NOTHROW Evaluation::DkmEvaluationFlags_t STDMETHODCALLTYPE CompilationFlags(
            );

        // Source text of the parsed expression.
        public: _Ret_ DECLSPEC_NOTHROW DkmString* STDMETHODCALLTYPE Text(
            );

        // This is the timeout to be used for potentially slow operations such as a function
        // evaluation. This value is in milliseconds.
        public: DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE Timeout(
            );

        /// <summary>
        /// Create a new DkmBreakpointCondition object instance.
        /// </summary>
        /// <param name="Operator">
        /// [In] Indicates how the breakpoint text should be used ('BreakWhenTrue' or
        /// 'BreakWhenChanged').
        /// </param>
        /// <param name="CompilerId">
        /// [In] Language of the breakpoint condition. May be Guid.Empty/Guid.Empty to
        /// indicate that the language of the stack frame should be used. If present, the
        /// vendor id must be defined.
        /// </param>
        /// <param name="CompilationFlags">
        /// [In] Flags which effect how the condition text should be compiled by the
        /// expression evaluator.
        /// </param>
        /// <param name="pText">
        /// [In] Source text of the parsed expression.
        /// </param>
        /// <param name="Timeout">
        /// [In] This is the timeout to be used for potentially slow operations such as a
        /// function evaluation. This value is in milliseconds.
        /// </param>
        /// <param name="ppCreatedObject">
        /// [Out] Result of this method call.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ Breakpoints::DkmBreakpointConditionOperator_t Operator,
            _In_ const Evaluation::DkmCompilerId& CompilerId,
            _In_ Evaluation::DkmEvaluationFlags_t CompilationFlags,
            _In_ DkmString* pText,
            _In_ UINT32 Timeout,
            _Deref_out_ Breakpoints::DkmBreakpointCondition** ppCreatedObject
            );
    }; // end of DkmBreakpointCondition

    // Indicates how the breakpoint text should be used ('BreakWhenTrue' or
    // 'BreakWhenChanged').
    DEFINE_SCOPED_ENUM(DkmBreakpointConditionOperator)
    {
        // Breakpoint should fire when the expression evaluates to Boolean 'true'.
        BreakWhenTrue = 0,
        // Breakpoint should fire when the value of the input expression changes.
        BreakWhenChanged = 1
    };

    // Object used to send file update notifications to breakpoint managers.
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("2dde565b-c382-7dbb-2841-647a7322b64e") DkmBreakpointFileUpdateNotification : public IUnknown
    {
        private: ___ReferenceCount_t m_ReferenceCount;
        private: DkmDispatcherObjectFlags_t m_ObjectFlags;
        private: const GUID* m_pTypeId;
        private: size_t m_ObjectGCHandle;
        // Use DkmBreakpointFileUpdateNotification::Create to create this object
        private: DkmBreakpointFileUpdateNotification();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmBreakpointFileUpdateNotification();
        // This object cannot be copied
        private: DkmBreakpointFileUpdateNotification& operator=(const DkmBreakpointFileUpdateNotification&);
        private: DkmBreakpointFileUpdateNotification(const DkmBreakpointFileUpdateNotification&);

        private: DkmReadOnlyCollection<DkmString*>* const m_pFilePaths;
        private: void* m__pExtendedData;

        // File path to the various files which have been updated.
        public: _Ret_ DECLSPEC_NOTHROW DkmReadOnlyCollection<DkmString*>* STDMETHODCALLTYPE FilePaths(
            );

        /// <summary>
        /// Create a new DkmBreakpointFileUpdateNotification object instance.
        /// </summary>
        /// <param name="pFilePaths">
        /// [In] File path to the various files which have been updated.
        /// </param>
        /// <param name="ppCreatedObject">
        /// [Out] Result of this method call.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ DkmReadOnlyCollection<DkmString*>* pFilePaths,
            _Deref_out_ Breakpoints::DkmBreakpointFileUpdateNotification** ppCreatedObject
            );

        #ifndef EXCLUDE_IDE_ONLY_APIS
        /// <summary>
        /// Provides notification that one or more files containing breakpoints have been
        /// updated.
        ///
        /// This method will append a new work item to the specified work list, and return
        /// once the work item has been appended. The actual processing of the work item is
        /// asynchronous. The caller will be notified that the request is complete through
        /// the completion routine.
        ///
        /// Location constraint: API must be called from an IDE component (component level
        /// &gt; 100,000).
        /// </summary>
        /// <param name="pWorkList">
        /// WorkList to append the new work item to.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Send(
            _In_ DkmWorkList* pWorkList
            );
        #endif // #ifndef EXCLUDE_IDE_ONLY_APIS
    }; // end of DkmBreakpointFileUpdateNotification

    // Values of the breakpoints hit count which should cause the breakpoint to fire.
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("2a0d19d5-b8ad-6fbe-5dec-a918f083ca4b") DkmBreakpointHitCountCondition : public IUnknown
    {
        private: ___ReferenceCount_t m_ReferenceCount;
        private: DkmDispatcherObjectFlags_t m_ObjectFlags;
        private: const GUID* m_pTypeId;
        private: size_t m_ObjectGCHandle;
        // Use DkmBreakpointHitCountCondition::Create to create this object
        private: DkmBreakpointHitCountCondition();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmBreakpointHitCountCondition();
        // This object cannot be copied
        private: DkmBreakpointHitCountCondition& operator=(const DkmBreakpointHitCountCondition&);
        private: DkmBreakpointHitCountCondition(const DkmBreakpointHitCountCondition&);

        private: const Breakpoints::DkmBreakpointHitCountConditionOperator_t m_Operator;
        private: const UINT32 m_Operand;
        private: void* m__pExtendedData;

        // Operator to use between the current hit count and the condition operand to decide
        // if the hit count condition has been satisfied.
        public: DECLSPEC_NOTHROW Breakpoints::DkmBreakpointHitCountConditionOperator_t STDMETHODCALLTYPE Operator(
            );

        // Value to apply against the current hit when evaluating this condition.
        public: DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE Operand(
            );

        /// <summary>
        /// Create a new DkmBreakpointHitCountCondition object instance.
        /// </summary>
        /// <param name="Operator">
        /// [In] Operator to use between the current hit count and the condition operand to
        /// decide if the hit count condition has been satisfied.
        /// </param>
        /// <param name="Operand">
        /// [In] Value to apply against the current hit when evaluating this condition.
        /// </param>
        /// <param name="ppCreatedObject">
        /// [Out] Result of this method call.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ Breakpoints::DkmBreakpointHitCountConditionOperator_t Operator,
            _In_ UINT32 Operand,
            _Deref_out_ Breakpoints::DkmBreakpointHitCountCondition** ppCreatedObject
            );
    }; // end of DkmBreakpointHitCountCondition

    // Operator to use between the current hit count and the condition operand to decide if
    // the hit count condition has been satisfied.
    DEFINE_SCOPED_ENUM(DkmBreakpointHitCountConditionOperator)
    {
        // Break when 'CurrentHitCount == Operand'.
        Equal = 0,
        // Break when 'CurrentHitCount >= Operand'.
        EqualOrGreater = 1,
        // Break when 'CurrentHitCount % Operand == 0'.
        Modulo = 2
    };

    // Describes the severity of a message sent from a breakpoint manager back to the source
    // component. This list is sorted in order of priority, as the UI will only display the
    // most important warning. All warnings are ignored if the breakpoint is bound.
    DEFINE_SCOPED_ENUM(DkmBreakpointMessageLevel)
    {
        // This is the message level for the least significant breakpoint warnings. This
        // level is used for catch-all messages such as the 'The specified module has not
        // been loaded' message. This is equivalent to BPET_SEV_LOW in AD7.
        WarningLevel1 = 0,
        // This is the message level reserved for 3rd party components that wish to provide
        // their own catch-all errors. Warning levels go from 1 to 16 and in order of
        // increasing severity (1 = Lowest, 15 = Highest).
        WarningLevel2 = 1,
        // Level 3 warning. Warning levels go from 1 to 16 and in order of increasing
        // severity (1 = Lowest, 15 = Highest).
        WarningLevel3 = 2,
        // Level 4 warning. Warning levels go from 1 to 16 and in order of increasing
        // severity (1 = Lowest, 15 = Highest).
        WarningLevel4 = 3,
        // Level 5 warning. Warning levels go from 1 to 16 and in order of increasing
        // severity (1 = Lowest, 15 = Highest).
        WarningLevel5 = 4,
        // Level 6 warning. Warning levels go from 1 to 16 and in order of increasing
        // severity (1 = Lowest, 15 = Highest).
        WarningLevel6 = 5,
        // Level 7 warning. This is equivalent to BPET_SEV_GENERAL in AD7. Warning levels go
        // from 1 to 16 and in order of increasing severity (1 = Lowest, 15 = Highest).
        WarningLevel7 = 6,
        // Level 8 warning. Warning levels go from 1 to 16 and in order of increasing
        // severity (1 = Lowest, 15 = Highest).
        WarningLevel8 = 7,
        // Level 9 warning. Warning levels go from 1 to 16 and in order of increasing
        // severity (1 = Lowest, 15 = Highest).
        WarningLevel9 = 8,
        // Level 10 warning. Warning levels go from 1 to 16 and in order of increasing
        // severity (1 = Lowest, 15 = Highest).
        WarningLevel10 = 9,
        // Level 11 warning. Warning levels go from 1 to 16 and in order of increasing
        // severity (1 = Lowest, 15 = Highest).
        WarningLevel11 = 10,
        // Level 12 warning. Warning levels go from 1 to 16 and in order of increasing
        // severity (1 = Lowest, 15 = Highest).
        WarningLevel12 = 11,
        // Level 13 warning. Warning levels go from 1 to 16 and in order of increasing
        // severity (1 = Lowest, 15 = Highest).
        WarningLevel13 = 12,
        // Level 14 warning. Warning levels go from 1 to 16 and in order of increasing
        // severity (1 = Lowest, 15 = Highest).
        WarningLevel14 = 13,
        // Highest warning level. This is equivalent to BPET_SEV_HIGH in AD7. Warning levels
        // go from 1 to 16 and in order of increasing severity (1 = Lowest, 15 = Highest).
        WarningLevel15 = 14,
        // Lowest level breakpoint error.
        LowError = 15,
        // Typical level for errors binding breakpoints.
        StandardError = 16,
        // Highest level breakpoint error.
        HighestError = 17
    };

    // Describes the reason for a breakpoint to be unbound.
    DEFINE_SCOPED_ENUM(DkmBreakpointUnboundReason)
    {
        // Breakpoint is being unbound because the target code element has been unloaded.
        CodeUnload = 0,
        // Breakpoint is being unbound because it is being rebound to a different location.
        // (For example, this can happen after an ENC when the breakpoint moves, or if this
        // breakpoint was originally bound with a less than perfect file name match.)
        // Generally, the IDE will discard any persisted information about this breakpoint.
        Rebind = 1
    };

    // Result of an asynchronous DkmRuntimeBreakpoint.ClearConditions call.
    struct DkmClearRuntimeBreakpointConditionsAsyncResult
    {
        // HRESULT code returned from the caller. This will be
        // DkmExceptionCode.COR_E_OPERATIONCANCELED (0x8013153B) if the operation was
        // canceled before processing was complete.
        HRESULT ErrorCode;
    };

    // Result of an asynchronous DkmRuntimeBreakpoint.ClearHitCountCondition call.
    struct DkmClearRuntimeBreakpointHitCountConditionAsyncResult
    {
        // HRESULT code returned from the caller. This will be
        // DkmExceptionCode.COR_E_OPERATIONCANCELED (0x8013153B) if the operation was
        // canceled before processing was complete.
        HRESULT ErrorCode;

        // Number of times that the breakpoint has been hit as of the time that the condition
        // was removed.
        UINT32 CurrentHitCount;
    };

    // Mask of reasons why the data breakpoint should fire. For example, if 'Write' is set,
    // then the breakpoint will fire when the memory location is written.
    DEFINE_SCOPED_ENUM(DkmDataAccessStopMask)
    {
        // Stop when the CPU writes to the specified address.
        Write = 0x1,
        // Stop when the CPU reads or writes to the specified address.
        ReadWrite = 0x2,
        // Stop when the CPU tries to execute an instruction at the specified address.
        Execute = 0x4
    };
    DEFINE_SCOPED_ENUM_FLAG_OPERATORS(DkmDataAccessStopMask_t);

    // Result of an asynchronous DkmBoundBreakpoint.Disable call.
    struct DkmDisableBoundBreakpointAsyncResult
    {
        // HRESULT code returned from the caller. This will be
        // DkmExceptionCode.COR_E_OPERATIONCANCELED (0x8013153B) if the operation was
        // canceled before processing was complete.
        HRESULT ErrorCode;
    };

    // Result of an asynchronous DkmPendingBreakpoint.Disable call.
    struct DkmDisablePendingBreakpointAsyncResult
    {
        // HRESULT code returned from the caller. This will be
        // DkmExceptionCode.COR_E_OPERATIONCANCELED (0x8013153B) if the operation was
        // canceled before processing was complete.
        HRESULT ErrorCode;
    };

    // Result of an asynchronous DkmRuntimeBreakpoint.Disable call.
    struct DkmDisableRuntimeBreakpointAsyncResult
    {
        // HRESULT code returned from the caller. This will be
        // DkmExceptionCode.COR_E_OPERATIONCANCELED (0x8013153B) if the operation was
        // canceled before processing was complete.
        HRESULT ErrorCode;
    };

    // Result of an asynchronous DkmBoundBreakpoint.Enable call.
    struct DkmEnableBoundBreakpointAsyncResult
    {
        // HRESULT code returned from the caller. This will be
        // DkmExceptionCode.COR_E_OPERATIONCANCELED (0x8013153B) if the operation was
        // canceled before processing was complete.
        HRESULT ErrorCode;
    };

    // Result of an asynchronous DkmPendingBreakpoint.Enable call.
    struct DkmEnablePendingBreakpointAsyncResult
    {
        // HRESULT code returned from the caller. This will be
        // DkmExceptionCode.COR_E_OPERATIONCANCELED (0x8013153B) if the operation was
        // canceled before processing was complete.
        HRESULT ErrorCode;
    };

    // Result of an asynchronous DkmRuntimeBreakpoint.Enable call.
    struct DkmEnableRuntimeBreakpointAsyncResult
    {
        // HRESULT code returned from the caller. This will be
        // DkmExceptionCode.COR_E_OPERATIONCANCELED (0x8013153B) if the operation was
        // canceled before processing was complete. E_BP_MODULE_UNLOADED indicates that the
        // module instance specified by the breakpoint is no longer loaded.
        // E_TEXT_SPAN_NOT_LOADED indicates that TextSpan is not currently loaded in the
        // specified script document.
        HRESULT ErrorCode;
    };

    // Result of an asynchronous DkmPendingBreakpoint.Enroll call.
    struct DkmEnrollPendingBreakpointAsyncResult
    {
        // HRESULT code returned from the caller. This will be
        // DkmExceptionCode.COR_E_OPERATIONCANCELED (0x8013153B) if the operation was
        // canceled before processing was complete.
        HRESULT ErrorCode;
    };

    #ifndef EXCLUDE_MONITOR_ONLY_APIS
    // Result of an asynchronous DkmRuntimeBreakpoint.EvaluateConditionAndSelectThread call.
    struct DkmEvaluateConditionAndSelectThreadAsyncResult
    {
        // HRESULT code returned from the caller. This will be
        // DkmExceptionCode.COR_E_OPERATIONCANCELED (0x8013153B) if the operation was
        // canceled before processing was complete.
        HRESULT ErrorCode;

        // [Optional] The thread whose condition is true. The value is null in the case that
        // no thread is found to have a true condition.
        OPTIONAL DkmThread* pConditionMetThread;
    };
    #endif // #ifndef EXCLUDE_MONITOR_ONLY_APIS

    #ifndef EXCLUDE_MONITOR_ONLY_APIS
    // Represents a condition which is evaluated on the target computer. These objects are
    // used for languages where the expression evaluator is implemented on the target.
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("d838eb1d-9ec7-751c-1896-5057bf597376") DkmEvaluationBreakpointCondition : public DkmDataContainer
    {
        // Use DkmEvaluationBreakpointCondition::Create to create this object
        private: DkmEvaluationBreakpointCondition();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmEvaluationBreakpointCondition();
        // This object cannot be copied
        private: DkmEvaluationBreakpointCondition& operator=(const DkmEvaluationBreakpointCondition&);
        private: DkmEvaluationBreakpointCondition(const DkmEvaluationBreakpointCondition&);

        private: Breakpoints::DkmRuntimeBreakpoint* const m_pRuntimeBreakpoint;
        private: Breakpoints::DkmBreakpointCondition* const m_pSource;
        private: Evaluation::DkmLanguage* const m_pLanguage;
        private: const GUID m_UniqueId;
        private: void* m__pExtendedData;

        // Runtime breakpoint that this condition is used on.
        public: _Ret_ DECLSPEC_NOTHROW Breakpoints::DkmRuntimeBreakpoint* STDMETHODCALLTYPE RuntimeBreakpoint(
            );

        // The breakpoint condition which is evaluated.
        public: _Ret_ DECLSPEC_NOTHROW Breakpoints::DkmBreakpointCondition* STDMETHODCALLTYPE Source(
            );

        // Language used to parse the condition.
        public: _Ret_ DECLSPEC_NOTHROW Evaluation::DkmLanguage* STDMETHODCALLTYPE Language(
            );

        // Guid which uniquely identifies this condition object.
        public: DECLSPEC_NOTHROW const GUID& STDMETHODCALLTYPE UniqueId(
            );

        // The DkmRuntimeInstance class represents an execution environment which is loaded
        // into a DkmProcess and which contains code to be debugged.
        public: _Ret_ DECLSPEC_NOTHROW DkmRuntimeInstance* STDMETHODCALLTYPE RuntimeInstance(
            );

        /// <summary>
        /// Closes a DkmEvaluationBreakpointCondition object instance. This will release any
        /// resources associated with this object across all components. This includes
        /// resources across computer or managed/native marshalling boundaries.
        ///
        /// DkmEvaluationBreakpointCondition objects are automatically closed when their
        /// associated DkmRuntimeBreakpoint object is closed.
        ///
        /// This method may only be called by the component which created the object.
        ///
        /// Location constraint: API must be called from a Monitor component (component level
        /// &lt; 100,000).
        /// </summary>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Close(
            );

        /// <summary>
        /// Create a new DkmEvaluationBreakpointCondition object instance. The caller is
        /// responsible for closing the created object after they are done.
        ///
        /// Location constraint: API must be called from a Monitor component (component level
        /// &lt; 100,000).
        /// </summary>
        /// <param name="pRuntimeBreakpoint">
        /// [In] Runtime breakpoint that this condition is used on.
        /// </param>
        /// <param name="pSource">
        /// [In] The breakpoint condition which is evaluated.
        /// </param>
        /// <param name="pLanguage">
        /// [In] Language used to parse the condition.
        /// </param>
        /// <param name="DataItem">
        /// [In] Data object to add to the new DkmEvaluationBreakpointCondition instance.
        /// DkmDataItem::Null() in the case that the caller doesn't need to add a data item.
        /// </param>
        /// <param name="ppCreatedObject">
        /// [Out] Result of this method call.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ Breakpoints::DkmRuntimeBreakpoint* pRuntimeBreakpoint,
            _In_ Breakpoints::DkmBreakpointCondition* pSource,
            _In_ Evaluation::DkmLanguage* pLanguage,
            _In_ const DkmDataItem& DataItem,
            _Deref_out_ Breakpoints::DkmEvaluationBreakpointCondition** ppCreatedObject
            );

        /// <summary>
        /// Parses an input breakpoint condition so that it can later be evaluated. If the
        /// breakpoint condition uses DkmBreakpointConditionOperator.BreakWhenTrue, the
        /// expression evaluator should require that the specified condition evaluates to a
        /// Boolean value. The created query must return only a single result. For
        /// BreakWhenTrue conditions, this must be either a 4-byte or 1-byte value, and any
        /// non-zero value is considered true.
        ///
        /// Location constraint: API must be called from a Monitor component (component level
        /// &lt; 100,000).
        /// </summary>
        /// <param name="ppErrorText">
        /// [Out,Optional] If the condition could not be parsed, this indicates the reason
        /// why. This value should be null if the compile succeeded.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Parse(
            _Deref_out_opt_ DkmString** ppErrorText
            );

        /// <summary>
        /// Evaluates a condition to decide if the debugger should stop.
        ///
        /// Location constraint: API must be called from a Monitor component (component level
        /// &lt; 100,000).
        /// </summary>
        /// <param name="pStackFrame">
        /// [In] The stack frame to use when evaluating the condition.
        /// </param>
        /// <param name="pStop">
        /// [Out] True if the breakpoint condition indicated that the IDE should stop.
        /// </param>
        /// <param name="ppErrorText">
        /// [Out,Optional] If the condition could not be evaluated, this indicates the reason
        /// why. This value should be null if the compile succeeded.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Evaluate(
            _In_ CallStack::DkmStackWalkFrame* pStackFrame,
            _Out_ bool* pStop,
            _Deref_out_opt_ DkmString** ppErrorText
            );
    }; // end of DkmEvaluationBreakpointCondition
    #endif // #ifndef EXCLUDE_MONITOR_ONLY_APIS

    // Result of an asynchronous DkmBoundBreakpoint.GetHitCountValue call.
    struct DkmGetBoundBreakpointHitCountValueAsyncResult
    {
        // HRESULT code returned from the caller. This will be
        // DkmExceptionCode.COR_E_OPERATIONCANCELED (0x8013153B) if the operation was
        // canceled before processing was complete.
        HRESULT ErrorCode;

        // Number of times that the breakpoint has been hit.
        UINT32 CurrentHitCount;
    };

    // Result of an asynchronous DkmRuntimeBreakpoint.GetHitCountConditionStatus call.
    struct DkmGetRuntimeBreakpointHitCountConditionAsyncResult
    {
        // HRESULT code returned from the caller. This will be
        // DkmExceptionCode.COR_E_OPERATIONCANCELED (0x8013153B) if the operation was
        // canceled before processing was complete.
        HRESULT ErrorCode;

        // Number of times that the breakpoint has been hit.
        UINT32 CurrentHitCount;
    };

    // High level breakpoint object which is tied to a user-level construct (ex: source file,
    // function name) which may map to zero or more code-level constructs
    // (DkmBoundBreakpoint) and which may be tracked over time.
    //
    // Derived classes: DkmPendingAddressBreakpoint, DkmPendingAddressNameBreakpoint,
    // DkmPendingDataBreakpoint, DkmPendingFileLineBreakpoint, DkmPendingFunctionBreakpoint
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("c9e1ffa4-f943-14bc-5566-00a802dfc66f") DkmPendingBreakpoint : public DkmDataContainer
    {
        // Use DkmPendingBreakpoint::Create to create this object
        private: DkmPendingBreakpoint();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmPendingBreakpoint();
        // This object cannot be copied
        private: DkmPendingBreakpoint& operator=(const DkmPendingBreakpoint&);
        private: DkmPendingBreakpoint(const DkmPendingBreakpoint&);

        // DkmPendingBreakpoint is an abstract base class. This enum indicates which derived
        // class this object is an instance of.
        public: FORWARD_DECLARE_SCOPED_ENUM(Tag);
        DEFINE_SCOPED_ENUM(Tag)
        {
        // Object is an instance of 'DkmPendingFileLineBreakpoint'.
        FileLineBreakpoint = 0,
        // Object is an instance of 'DkmPendingFunctionBreakpoint'.
        FunctionBreakpoint = 1,
        // Object is an instance of 'DkmPendingAddressBreakpoint'.
        AddressBreakpoint = 2,
        // Object is an instance of 'DkmPendingAddressNameBreakpoint'.
        AddressNameBreakpoint = 3,
        // Object is an instance of 'DkmPendingDataBreakpoint'.
        DataBreakpoint = 4
        };

        private: const Tag_t m_TagValue;
        private: DkmProcess* const m_pProcess;
        private: const GUID m_UniqueId;
        private: const GUID m_SourceId;
        private: const Evaluation::DkmCompilerId m_CompilerId;
        private: OPTIONAL DkmThread* const m_pThread;
        private: const bool m_IsBarrier;
        private: void* m__pExtendedData;
        private: void* m_pBoundBreakpointCollection0;

        // DkmPendingBreakpoint is an abstract base class. This enum indicates which derived
        // class this object is an instance of.
        public: DECLSPEC_NOTHROW Tag_t STDMETHODCALLTYPE TagValue(
            );

        // DkmProcess represents a target process which is being debugged. The debugger
        // debugs processes, so this is the basic unit of debugging. A DkmProcess can
        // represent a system process or a virtual process such as minidumps.
        public: _Ret_ DECLSPEC_NOTHROW DkmProcess* STDMETHODCALLTYPE Process(
            );

        // Guid which uniquely identifies this pending breakpoint object.
        public: DECLSPEC_NOTHROW const GUID& STDMETHODCALLTYPE UniqueId(
            );

        // Identifies the source of an object. SourceIds are used to enable filtering in
        // scenarios when multiple components may be creating instances of a class. For
        // example, source ids can be used to determine if a breakpoint comes from the AD7 AL
        // (ex: user breakpoint, or other breakpoint visible at the SDM level) instead of a
        // breakpoint which may be created by another component (for example an internal
        // breakpoint used for stepping).
        public: DECLSPEC_NOTHROW const GUID& STDMETHODCALLTYPE SourceId(
            );

        // Identifies the source language (ex: C#) and compiler vendor (ex: Microsoft) that
        // the breakpoint should bind against. 'LanguageId' may be left as Guid.Empty to
        // indicate that the breakpoint should bind against all languages. 'VendorId' is
        // nearly always left as Guid.Empty, which indicates that only the language is known
        // (not the compiler).
        public: DECLSPEC_NOTHROW const Evaluation::DkmCompilerId& STDMETHODCALLTYPE CompilerId(
            );

        // [Optional] Thread on which this breakpoint should fire. If null, the breakpoint
        // will fire on all threads.
        public: _Ret_opt_ DECLSPEC_NOTHROW DkmThread* STDMETHODCALLTYPE Thread(
            );

        // Indicates if this breakpoint is a barrier that should be set on the hardware, this
        // works for GPU debugging.
        public: DECLSPEC_NOTHROW bool STDMETHODCALLTYPE IsBarrier(
            );

        /// <summary>
        /// Closes a DkmPendingBreakpoint object instance. This will release any resources
        /// associated with this object across all components. This includes resources across
        /// computer or managed/native marshalling boundaries.
        ///
        /// DkmPendingBreakpoint objects are automatically closed when their associated
        /// DkmProcess object is closed.
        ///
        /// This method may only be called by the component which created the object.
        /// </summary>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Close(
            );

        /// <summary>
        /// GetBoundBreakpoints enumerates the DkmBoundBreakpoint elements of this
        /// DkmPendingBreakpoint object.
        /// </summary>
        /// <param name="pBoundBreakpoints">
        /// [Out] Array containing the enumerated elements.
        ///
        /// The memory for the DkmArray members is allocated by the method implementation
        /// using DkmAllocBytes/DkmAllocArray. It is freed by the caller using the
        /// CAutoDkmArray template or with DkmFreeMemory and manual element release.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetBoundBreakpoints(
            _Out_ DkmArray<Breakpoints::DkmBoundBreakpoint*>* pBoundBreakpoints
            );

        #ifndef EXCLUDE_IDE_ONLY_APIS
        /// <summary>
        /// Sets the state of the pending breakpoint so that instances of the breakpoint that
        /// bind in the future will get hit. If the pending breakpoint is not yet enrolled,
        /// then this method will also enroll the breakpoint. Enrolling a pending breakpoint
        /// consists of attempting to resolve the breakpoint against any modules which are
        /// currently loaded and adding the breakpoint to the list of breakpoints which the
        /// breakpoint manager will bind on any module load. If the pending breakpoint is
        /// already enrolled, existing bound breakpoints will not automatically get enabled.
        /// Bound breakpoints must get enabled separately.
        ///
        /// This method will append a new work item to the specified work list, and return
        /// once the work item has been appended. The actual processing of the work item is
        /// asynchronous. The caller will be notified that the request is complete through
        /// the completion routine.
        ///
        /// Location constraint: API must be called from an IDE component (component level
        /// &gt; 100,000).
        /// </summary>
        /// <param name="pWorkList">
        /// WorkList to append the new work item to.
        /// </param>
        /// <param name="pCompletionRoutine">
        /// Routine to fire when the request is complete. If the request is successfully
        /// appended to the work list, this will always fire (including when the operation is
        /// canceled). This will never fire if appending the work item fails.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Enable(
            _In_ DkmWorkList* pWorkList,
            _In_ IDkmCompletionRoutine<Breakpoints::DkmEnablePendingBreakpointAsyncResult>* pCompletionRoutine
            );
        #endif // #ifndef EXCLUDE_IDE_ONLY_APIS

        #ifndef EXCLUDE_IDE_ONLY_APIS
        /// <summary>
        /// Disable the pending breakpoint object so that it will no longer fire. If the
        /// pending breakpoint is already bound, any bound breakpoints will be implicitly
        /// disabled.
        ///
        /// This method will append a new work item to the specified work list, and return
        /// once the work item has been appended. The actual processing of the work item is
        /// asynchronous. The caller will be notified that the request is complete through
        /// the completion routine.
        ///
        /// Location constraint: API must be called from an IDE component (component level
        /// &gt; 100,000).
        /// </summary>
        /// <param name="pWorkList">
        /// WorkList to append the new work item to.
        /// </param>
        /// <param name="pCompletionRoutine">
        /// Routine to fire when the request is complete. If the request is successfully
        /// appended to the work list, this will always fire (including when the operation is
        /// canceled). This will never fire if appending the work item fails.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Disable(
            _In_ DkmWorkList* pWorkList,
            _In_ IDkmCompletionRoutine<Breakpoints::DkmDisablePendingBreakpointAsyncResult>* pCompletionRoutine
            );
        #endif // #ifndef EXCLUDE_IDE_ONLY_APIS

        #ifndef EXCLUDE_IDE_ONLY_APIS
        /// <summary>
        /// This method will enroll the pending breakpoint without enabling it. The result is
        /// a breakpoint which the breakpoint manager will attempt to resolve, but which will
        /// not fire. Enrolling a pending breakpoint consists of attempting to resolve the
        /// breakpoint against any modules which are currently loaded and adding the
        /// breakpoint to the list of breakpoints which the breakpoint manager will bind on
        /// any module load.
        ///
        /// This method will append a new work item to the specified work list, and return
        /// once the work item has been appended. The actual processing of the work item is
        /// asynchronous. The caller will be notified that the request is complete through
        /// the completion routine.
        ///
        /// Location constraint: API must be called from an IDE component (component level
        /// &gt; 100,000).
        /// </summary>
        /// <param name="pWorkList">
        /// WorkList to append the new work item to.
        /// </param>
        /// <param name="pCompletionRoutine">
        /// Routine to fire when the request is complete. If the request is successfully
        /// appended to the work list, this will always fire (including when the operation is
        /// canceled). This will never fire if appending the work item fails.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Enroll(
            _In_ DkmWorkList* pWorkList,
            _In_ IDkmCompletionRoutine<Breakpoints::DkmEnrollPendingBreakpointAsyncResult>* pCompletionRoutine
            );
        #endif // #ifndef EXCLUDE_IDE_ONLY_APIS

        #ifndef EXCLUDE_IDE_ONLY_APIS
        /// <summary>
        /// Initialize, update or clear the language-level condition on all bound breakpoints
        /// of this condition breakpoint.  If the same breakpoint has both a language-level
        /// condition, and a hit count condition, the language-level condition is applied
        /// first.
        ///
        /// This method will append a new work item to the specified work list, and return
        /// once the work item has been appended. The actual processing of the work item is
        /// asynchronous. The caller will be notified that the request is complete through
        /// the completion routine.
        ///
        /// Location constraint: API must be called from an IDE component (component level
        /// &gt; 100,000).
        /// </summary>
        /// <param name="pWorkList">
        /// WorkList to append the new work item to.
        /// </param>
        /// <param name="pCondition">
        /// [In,Optional] Condition to apply to this breakpoint. This value may be 'null' if
        /// the caller wishes to remove the condition.
        /// </param>
        /// <param name="pCompletionRoutine">
        /// Routine to fire when the request is complete. If the request is successfully
        /// appended to the work list, this will always fire (including when the operation is
        /// canceled). This will never fire if appending the work item fails.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE SetCondition(
            _In_ DkmWorkList* pWorkList,
            _In_opt_ Breakpoints::DkmBreakpointCondition* pCondition,
            _In_ IDkmCompletionRoutine<Breakpoints::DkmSetPendingBreakpointConditionAsyncResult>* pCompletionRoutine
            );
        #endif // #ifndef EXCLUDE_IDE_ONLY_APIS

        #ifndef EXCLUDE_IDE_ONLY_APIS
        /// <summary>
        /// Initialize, update or clear the hit count condition on all bound breakpoints of
        /// this pending breakpoint. If the same breakpoint has both a language-level
        /// condition, and a hit count condition, the language-level condition is applied
        /// first.
        ///
        /// Note that the hit count condition acts independently on each bound breakpoint,
        /// rather than being aggregated together on the pending breakpoint. For example, if
        /// the hit count is configured to stop at hit #2, and the breakpoint to two separate
        /// locations, each of which hit the breakpoint once, the UI will still not have gone
        /// into break mode because neither individual bound breakpoint has hit twice.
        ///
        /// This method will append a new work item to the specified work list, and return
        /// once the work item has been appended. The actual processing of the work item is
        /// asynchronous. The caller will be notified that the request is complete through
        /// the completion routine.
        ///
        /// Location constraint: API must be called from an IDE component (component level
        /// &gt; 100,000).
        /// </summary>
        /// <param name="pWorkList">
        /// WorkList to append the new work item to.
        /// </param>
        /// <param name="pCondition">
        /// [In,Optional] Condition to apply to this breakpoint. This value may be 'null' if
        /// the caller wishes to remove the condition.
        /// </param>
        /// <param name="pCompletionRoutine">
        /// Routine to fire when the request is complete. If the request is successfully
        /// appended to the work list, this will always fire (including when the operation is
        /// canceled). This will never fire if appending the work item fails.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE SetHitCountCondition(
            _In_ DkmWorkList* pWorkList,
            _In_opt_ Breakpoints::DkmBreakpointHitCountCondition* pCondition,
            _In_ IDkmCompletionRoutine<Breakpoints::DkmSetPendingBreakpointHitCountConditionAsyncResult>* pCompletionRoutine
            );
        #endif // #ifndef EXCLUDE_IDE_ONLY_APIS

        /// <summary>
        /// Notification from the breakpoint manager when a breakpoint has been bound. In the
        /// case of user-set breakpoints, this notification will be sent to the AD7 AL, and
        /// the AD7 AL will fire a IDebugBreakpointBoundEvent2 to the Visual Studio Debugger
        /// UI.
        /// </summary>
        /// <param name="BoundBreakpoints">
        /// [In] Represents a breakpoint which has been bound (resolved) to a particular code
        /// instruction address or a particular data element. For example, in C++ templates
        /// one could create a DkmPendingBreakpoint for a source line. The breakpoint manager
        /// would resolve it to zero (ex: module not loaded), one (ex: template is only used
        /// on 'int') or many (ex: template is used with many template arguments) location.
        /// Each location would have a DkmBoundBreakpoint object.
        ///
        /// The memory for the DkmArray members is allocated by the caller, and can be from
        /// any source (stack memory, static buffer, heap, etc). The implementation should
        /// not modify the members.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE OnBreakpointBound(
            _In_ const DkmArray<Breakpoints::DkmBoundBreakpoint*>& BoundBreakpoints
            );

        /// <summary>
        /// Notification from the breakpoint manager which indicates that the given
        /// breakpoint is being unbound.
        /// </summary>
        /// <param name="BoundBreakpoints">
        /// [In] Represents a breakpoint which has been bound (resolved) to a particular code
        /// instruction address or a particular data element. For example, in C++ templates
        /// one could create a DkmPendingBreakpoint for a source line. The breakpoint manager
        /// would resolve it to zero (ex: module not loaded), one (ex: template is only used
        /// on 'int') or many (ex: template is used with many template arguments) location.
        /// Each location would have a DkmBoundBreakpoint object.
        ///
        /// The memory for the DkmArray members is allocated by the caller, and can be from
        /// any source (stack memory, static buffer, heap, etc). The implementation should
        /// not modify the members.
        /// </param>
        /// <param name="Reason">
        /// [In] Describes the reason for a breakpoint to be unbound.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE OnBreakpointUnbound(
            _In_ const DkmArray<Breakpoints::DkmBoundBreakpoint*>& BoundBreakpoints,
            _In_ Breakpoints::DkmBreakpointUnboundReason_t Reason
            );

        /// <summary>
        /// Notification from the breakpoint manager concerning the status of binding the
        /// breakpoint.
        /// </summary>
        /// <param name="Level">
        /// [In] Describes the severity of a message sent from a breakpoint manager back to
        /// the source component. This list is sorted in order of priority, as the UI will
        /// only display the most important warning. All warnings are ignored if the
        /// breakpoint is bound.
        /// </param>
        /// <param name="pMessage">
        /// [In] Message string to display to the user.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE OnBreakpointMessage(
            _In_ Breakpoints::DkmBreakpointMessageLevel_t Level,
            _In_ DkmString* pMessage
            );
    }; // end of DkmPendingBreakpoint

    // Result of an asynchronous DkmRuntimeBreakpoint.RequestBreakpointEventOnModifiedThread
    // call.
    struct DkmRequestBreakpointEventOnModifiedThreadAsyncResult
    {
        // HRESULT code returned from the caller. This will be
        // DkmExceptionCode.COR_E_OPERATIONCANCELED (0x8013153B) if the operation was
        // canceled before processing was complete.
        HRESULT ErrorCode;
    };

    // Low-level breakpoint object which is supported by debug monitors.
    //
    // Derived classes: DkmRuntimeHardwareDataBreakpoint, DkmRuntimeInstructionBreakpoint
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("c4815219-c5fd-3e96-9b86-fd6a36eef464") DkmRuntimeBreakpoint : public DkmDataContainer
    {
        // Use DkmRuntimeBreakpoint::Create to create this object
        private: DkmRuntimeBreakpoint();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmRuntimeBreakpoint();
        // This object cannot be copied
        private: DkmRuntimeBreakpoint& operator=(const DkmRuntimeBreakpoint&);
        private: DkmRuntimeBreakpoint(const DkmRuntimeBreakpoint&);

        // DkmRuntimeBreakpoint is an abstract base class. This enum indicates which derived
        // class this object is an instance of.
        public: FORWARD_DECLARE_SCOPED_ENUM(Tag);
        DEFINE_SCOPED_ENUM(Tag)
        {
        // Object is an instance of 'DkmRuntimeInstructionBreakpoint'.
        InstructionBreakpoint = 0,
        // Object is an instance of 'DkmRuntimeHardwareDataBreakpoint'.
        NativeDataBreakpoint = 1
        };

        private: const Tag_t m_TagValue;
        private: DkmRuntimeInstance* const m_pRuntimeInstance;
        private: const GUID m_UniqueId;
        private: const GUID m_SourceId;
        private: OPTIONAL DkmThread* const m_pThread;
        private: void* m__pExtendedData;
        private: void* m_pEvaluationConditionCollection0;

        // DkmRuntimeBreakpoint is an abstract base class. This enum indicates which derived
        // class this object is an instance of.
        public: DECLSPEC_NOTHROW Tag_t STDMETHODCALLTYPE TagValue(
            );

        // The DkmRuntimeInstance class represents an execution environment which is loaded
        // into a DkmProcess and which contains code to be debugged.
        public: _Ret_ DECLSPEC_NOTHROW DkmRuntimeInstance* STDMETHODCALLTYPE RuntimeInstance(
            );

        // Guid which uniquely identifies this pending breakpoint object.
        public: DECLSPEC_NOTHROW const GUID& STDMETHODCALLTYPE UniqueId(
            );

        // Identifies the source of an object. SourceIds are used to enable filtering in
        // scenarios when multiple components may be creating instances of a class. For
        // example, source ids can be used to determine if a breakpoint comes from the AD7 AL
        // (ex: user breakpoint, or other breakpoint visible at the SDM level) instead of a
        // breakpoint which may be created by another component (for example an internal
        // breakpoint used for stepping).
        public: DECLSPEC_NOTHROW const GUID& STDMETHODCALLTYPE SourceId(
            );

        // [Optional] Thread on which this breakpoint should fire. If null, the breakpoint
        // will fire on all threads.
        public: _Ret_opt_ DECLSPEC_NOTHROW DkmThread* STDMETHODCALLTYPE Thread(
            );

        // DkmProcess represents a target process which is being debugged. The debugger
        // debugs processes, so this is the basic unit of debugging. A DkmProcess can
        // represent a system process or a virtual process such as minidumps.
        public: _Ret_ DECLSPEC_NOTHROW DkmProcess* STDMETHODCALLTYPE Process(
            );

        /// <summary>
        /// Closes the breakpoint object instance. This will release any resources associated
        /// with this object across all components. If the breakpoint is currently enabled,
        /// it will be implicitly disabled.
        ///
        /// DkmRuntimeBreakpoint objects are automatically closed when their associated
        /// DkmRuntimeInstance object is closed.
        ///
        /// This method may only be called by the component which created the object.
        /// </summary>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Close(
            );

        /// <summary>
        /// This method is similar to SetCompiledCondition, but is used in cases where the
        /// instruction address is not known up front, such as data breakpoints. In these
        /// cases, when the breakpoint is first hit at a particular address, a call will be
        /// made to the breakpoint client to obtain a new compiled condition for this address
        /// (IDkmBreakpointConditionProcessorClient.GetCompiledCondition).  This is used for
        /// languages which are evaluated in the IDE process (ex: C++).
        /// </summary>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE SetCompiledConditionPending(
            );

        /// <summary>
        /// This method is similar to SetCompiledCondition, but is used in cases where the
        /// instruction address is not known up front, such as data breakpoints. In these
        /// cases, when the breakpoint is first hit at a particular address, a call will be
        /// made to the breakpoint client to obtain a new compiled condition for this address
        /// (IDkmBreakpointConditionProcessorClient.GetCompiledCondition).  This is used for
        /// languages which are evaluated in the IDE process (ex: C++).
        ///
        /// This method will append a new work item to the specified work list, and return
        /// once the work item has been appended. The actual processing of the work item is
        /// asynchronous. The caller will be notified that the request is complete through
        /// the completion routine.
        /// </summary>
        /// <param name="pWorkList">
        /// WorkList to append the new work item to.
        /// </param>
        /// <param name="pCompletionRoutine">
        /// Routine to fire when the request is complete. If the request is successfully
        /// appended to the work list, this will always fire (including when the operation is
        /// canceled). This will never fire if appending the work item fails.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE SetCompiledConditionPending(
            _In_ DkmWorkList* pWorkList,
            _In_ IDkmCompletionRoutine<Breakpoints::DkmSetCompiledConditionPendingAsyncResult>* pCompletionRoutine
            );

        /// <summary>
        /// Sets a breakpoint condition which is evaluated on the target computer. This is
        /// used for .NET languages.
        /// </summary>
        /// <param name="pCondition">
        /// [In] Conditions under which a breakpoint should fire.
        /// </param>
        /// <param name="ppErrorText">
        /// [Out,Optional] If the condition could not be parsed, this indicates the reason
        /// why. This value should be null if the compile succeeded.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE SetEvaluationCondition(
            _In_ Breakpoints::DkmBreakpointCondition* pCondition,
            _Deref_out_opt_ DkmString** ppErrorText
            );

        /// <summary>
        /// Sets a breakpoint condition which is evaluated on the target computer. This is
        /// used for .NET languages.
        ///
        /// This method will append a new work item to the specified work list, and return
        /// once the work item has been appended. The actual processing of the work item is
        /// asynchronous. The caller will be notified that the request is complete through
        /// the completion routine.
        /// </summary>
        /// <param name="pWorkList">
        /// WorkList to append the new work item to.
        /// </param>
        /// <param name="pCondition">
        /// [In] Conditions under which a breakpoint should fire.
        /// </param>
        /// <param name="pCompletionRoutine">
        /// Routine to fire when the request is complete. If the request is successfully
        /// appended to the work list, this will always fire (including when the operation is
        /// canceled). This will never fire if appending the work item fails.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE SetEvaluationCondition(
            _In_ DkmWorkList* pWorkList,
            _In_ Breakpoints::DkmBreakpointCondition* pCondition,
            _In_ IDkmCompletionRoutine<Breakpoints::DkmSetEvaluationConditionAsyncResult>* pCompletionRoutine
            );

        /// <summary>
        /// Clear any compiled/evaluation condition associated with the specified
        /// DkmRuntimeBreakpoint. This method is implicitly called when the
        /// DkmRuntimeBreakpoint is closed.
        /// </summary>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ClearConditions(
            );

        /// <summary>
        /// Clear any compiled/evaluation condition associated with the specified
        /// DkmRuntimeBreakpoint. This method is implicitly called when the
        /// DkmRuntimeBreakpoint is closed.
        ///
        /// This method will append a new work item to the specified work list, and return
        /// once the work item has been appended. The actual processing of the work item is
        /// asynchronous. The caller will be notified that the request is complete through
        /// the completion routine.
        /// </summary>
        /// <param name="pWorkList">
        /// WorkList to append the new work item to.
        /// </param>
        /// <param name="pCompletionRoutine">
        /// Routine to fire when the request is complete. If the request is successfully
        /// appended to the work list, this will always fire (including when the operation is
        /// canceled). This will never fire if appending the work item fails.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ClearConditions(
            _In_ DkmWorkList* pWorkList,
            _In_ IDkmCompletionRoutine<Breakpoints::DkmClearRuntimeBreakpointConditionsAsyncResult>* pCompletionRoutine
            );

        /// <summary>
        /// Initialize or update the hit count condition/value on a breakpoint. If the same
        /// breakpoint has both a language-level condition, and a hit count condition, the
        /// language-level condition is applied first. The condition is implicitly removed if
        /// the DkmRuntimeBreakpoint is closed.
        /// </summary>
        /// <param name="pCondition">
        /// [In] Condition to apply to this breakpoint.
        /// </param>
        /// <param name="HitCountValue">
        /// [In] The initial value of the breakpoint's hit count. A value of -1/MAXDWORD
        /// indicates that the current hit count value should be preserved.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE SetHitCountCondition(
            _In_ Breakpoints::DkmBreakpointHitCountCondition* pCondition,
            _In_ UINT32 HitCountValue
            );

        /// <summary>
        /// Initialize or update the hit count condition/value on a breakpoint. If the same
        /// breakpoint has both a language-level condition, and a hit count condition, the
        /// language-level condition is applied first. The condition is implicitly removed if
        /// the DkmRuntimeBreakpoint is closed.
        ///
        /// This method will append a new work item to the specified work list, and return
        /// once the work item has been appended. The actual processing of the work item is
        /// asynchronous. The caller will be notified that the request is complete through
        /// the completion routine.
        /// </summary>
        /// <param name="pWorkList">
        /// WorkList to append the new work item to.
        /// </param>
        /// <param name="pCondition">
        /// [In] Condition to apply to this breakpoint.
        /// </param>
        /// <param name="HitCountValue">
        /// [In] The initial value of the breakpoint's hit count. A value of -1/MAXDWORD
        /// indicates that the current hit count value should be preserved.
        /// </param>
        /// <param name="pCompletionRoutine">
        /// Routine to fire when the request is complete. If the request is successfully
        /// appended to the work list, this will always fire (including when the operation is
        /// canceled). This will never fire if appending the work item fails.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE SetHitCountCondition(
            _In_ DkmWorkList* pWorkList,
            _In_ Breakpoints::DkmBreakpointHitCountCondition* pCondition,
            _In_ UINT32 HitCountValue,
            _In_ IDkmCompletionRoutine<Breakpoints::DkmSetRuntimeBreakpointHitCountConditionAsyncResult>* pCompletionRoutine
            );

        /// <summary>
        /// Clears the hit count condition on a breakpoint.
        /// </summary>
        /// <param name="pCondition">
        /// [In] Condition to apply to this breakpoint.
        /// </param>
        /// <param name="pCurrentHitCount">
        /// [Out] Number of times that the breakpoint has been hit as of the time that the
        /// condition was removed.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ClearHitCountCondition(
            _In_ Breakpoints::DkmBreakpointHitCountCondition* pCondition,
            _Out_ UINT32* pCurrentHitCount
            );

        /// <summary>
        /// Clears the hit count condition on a breakpoint.
        ///
        /// This method will append a new work item to the specified work list, and return
        /// once the work item has been appended. The actual processing of the work item is
        /// asynchronous. The caller will be notified that the request is complete through
        /// the completion routine.
        /// </summary>
        /// <param name="pWorkList">
        /// WorkList to append the new work item to.
        /// </param>
        /// <param name="pCondition">
        /// [In] Condition to apply to this breakpoint.
        /// </param>
        /// <param name="pCompletionRoutine">
        /// Routine to fire when the request is complete. If the request is successfully
        /// appended to the work list, this will always fire (including when the operation is
        /// canceled). This will never fire if appending the work item fails.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ClearHitCountCondition(
            _In_ DkmWorkList* pWorkList,
            _In_ Breakpoints::DkmBreakpointHitCountCondition* pCondition,
            _In_ IDkmCompletionRoutine<Breakpoints::DkmClearRuntimeBreakpointHitCountConditionAsyncResult>* pCompletionRoutine
            );

        /// <summary>
        /// Obtains the current hit count value for a DkmRuntimeBreakpoint which has a hit
        /// count condition. This function will fail if the DkmRuntimeBreakpoint does not
        /// currently have a hit count condition.
        /// </summary>
        /// <param name="pCurrentHitCount">
        /// [Out] Number of times that the breakpoint has been hit.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetHitCountConditionStatus(
            _Out_ UINT32* pCurrentHitCount
            );

        /// <summary>
        /// Obtains the current hit count value for a DkmRuntimeBreakpoint which has a hit
        /// count condition. This function will fail if the DkmRuntimeBreakpoint does not
        /// currently have a hit count condition.
        ///
        /// This method will append a new work item to the specified work list, and return
        /// once the work item has been appended. The actual processing of the work item is
        /// asynchronous. The caller will be notified that the request is complete through
        /// the completion routine.
        /// </summary>
        /// <param name="pWorkList">
        /// WorkList to append the new work item to.
        /// </param>
        /// <param name="pCompletionRoutine">
        /// Routine to fire when the request is complete. If the request is successfully
        /// appended to the work list, this will always fire (including when the operation is
        /// canceled). This will never fire if appending the work item fails.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetHitCountConditionStatus(
            _In_ DkmWorkList* pWorkList,
            _In_ IDkmCompletionRoutine<Breakpoints::DkmGetRuntimeBreakpointHitCountConditionAsyncResult>* pCompletionRoutine
            );

        #ifndef EXCLUDE_MONITOR_ONLY_APIS
        /// <summary>
        /// Call back invoked from the breakpoint condition processor to the breakpoint
        /// manager (or other component which calls SetCompiledConditionPending) when the
        /// breakpoint condition needs to be re-compiled for a new instruction address.
        ///
        /// Location constraint: API must be called from a Monitor component (component level
        /// &lt; 100,000).
        /// </summary>
        /// <param name="pInstructionAddress">
        /// [In] The instruction address to compile the condition against.
        /// </param>
        /// <param name="pConditionOperator">
        /// [Out] Operator to use when evaluating the condition.
        /// </param>
        /// <param name="ppCompiledCondition">
        /// [Out,Optional] The compiled condition to be used for the specified instruction
        /// address. This value is null in the case that the condition failed to compile. In
        /// this case, the condition processor should stop on the breakpoint.
        /// </param>
        /// <returns>
        /// S_OK is returned if *ppCompiledCondition is non-NULL, S_FALSE is returned when
        /// *ppCompiledCondition is NULL, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetCompiledCondition(
            _In_ DkmInstructionAddress* pInstructionAddress,
            _Out_ Breakpoints::DkmBreakpointConditionOperator_t* pConditionOperator,
            _Deref_out_opt_ Evaluation::DkmCompiledInspectionQuery** ppCompiledCondition
            );
        #endif // #ifndef EXCLUDE_MONITOR_ONLY_APIS

        #ifndef EXCLUDE_MONITOR_ONLY_APIS
        /// <summary>
        /// Call back invoked from the breakpoint condition processor to the breakpoint
        /// manager when a breakpoint condition encounters a runtime error.
        ///
        /// Location constraint: API must be called from a Monitor component (component level
        /// &lt; 100,000).
        /// </summary>
        /// <param name="pErrorMessage">
        /// [In] The message to display to the user.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE OnBreakpointConditionFailed(
            _In_ DkmString* pErrorMessage
            );
        #endif // #ifndef EXCLUDE_MONITOR_ONLY_APIS

        /// <summary>
        /// The breakpoint condition processor decides not to break on the given thread but
        /// another thread of the same warp, so the breakpoint condition processor instructs
        /// the base debug monitor to re-send the breakpoint event on the other thread.
        /// </summary>
        /// <param name="pModifiedBreakThread">
        /// [In] The base debug monitor should re-send breakpoint event on this thread.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE RequestBreakpointEventOnModifiedThread(
            _In_ DkmThread* pModifiedBreakThread
            );

        /// <summary>
        /// The breakpoint condition processor decides not to break on the given thread but
        /// another thread of the same warp, so the breakpoint condition processor instructs
        /// the base debug monitor to re-send the breakpoint event on the other thread.
        ///
        /// This method will append a new work item to the specified work list, and return
        /// once the work item has been appended. The actual processing of the work item is
        /// asynchronous. The caller will be notified that the request is complete through
        /// the completion routine.
        /// </summary>
        /// <param name="pWorkList">
        /// WorkList to append the new work item to.
        /// </param>
        /// <param name="pModifiedBreakThread">
        /// [In] The base debug monitor should re-send breakpoint event on this thread.
        /// </param>
        /// <param name="pCompletionRoutine">
        /// Routine to fire when the request is complete. If the request is successfully
        /// appended to the work list, this will always fire (including when the operation is
        /// canceled). This will never fire if appending the work item fails.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE RequestBreakpointEventOnModifiedThread(
            _In_ DkmWorkList* pWorkList,
            _In_ DkmThread* pModifiedBreakThread,
            _In_ IDkmCompletionRoutine<Breakpoints::DkmRequestBreakpointEventOnModifiedThreadAsyncResult>* pCompletionRoutine
            );

        /// <summary>
        /// Enables a breakpoint. Breakpoints start off initially disabled, so this method
        /// must be called before the breakpoint can be set. Enabling a breakpoint is
        /// typically implemented in the debug monitor by modifying the state of the target
        /// process. For example inserting an 'int3' instruction into the code stream. If the
        /// breakpoint is already enabled, this operation has no effect.
        ///
        /// Once a breakpoint has been enabled, the debug monitor will raise a
        /// RuntimeBreakpoint event for this DkmRuntimeBreakpoint object whenever the trigger
        /// condition (ex: target instruction is executed) is met. Multiple
        /// DkmRuntimeBreakpoints may be set on the same instruction. In this case, the debug
        /// monitor will raise a different RuntimeBreakpoint event for each breakpoint
        /// object. Similarly, if a step complete and a breakpoint both complete on the same
        /// instruction, the debug monitor will raise both events.
        ///
        /// This method may only be called by the component which created the object.
        /// </summary>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// E_BP_MODULE_UNLOADED indicates that the module instance specified by the
        /// breakpoint is no longer loaded. E_TEXT_SPAN_NOT_LOADED indicates that TextSpan is
        /// not currently loaded in the specified script document.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Enable(
            );

        /// <summary>
        /// Enables a breakpoint. Breakpoints start off initially disabled, so this method
        /// must be called before the breakpoint can be set. Enabling a breakpoint is
        /// typically implemented in the debug monitor by modifying the state of the target
        /// process. For example inserting an 'int3' instruction into the code stream. If the
        /// breakpoint is already enabled, this operation has no effect.
        ///
        /// Once a breakpoint has been enabled, the debug monitor will raise a
        /// RuntimeBreakpoint event for this DkmRuntimeBreakpoint object whenever the trigger
        /// condition (ex: target instruction is executed) is met. Multiple
        /// DkmRuntimeBreakpoints may be set on the same instruction. In this case, the debug
        /// monitor will raise a different RuntimeBreakpoint event for each breakpoint
        /// object. Similarly, if a step complete and a breakpoint both complete on the same
        /// instruction, the debug monitor will raise both events.
        ///
        /// This method will append a new work item to the specified work list, and return
        /// once the work item has been appended. The actual processing of the work item is
        /// asynchronous. The caller will be notified that the request is complete through
        /// the completion routine.
        ///
        /// This method may only be called by the component which created the object.
        /// </summary>
        /// <param name="pWorkList">
        /// WorkList to append the new work item to.
        /// </param>
        /// <param name="pCompletionRoutine">
        /// Routine to fire when the request is complete. If the request is successfully
        /// appended to the work list, this will always fire (including when the operation is
        /// canceled). This will never fire if appending the work item fails.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Enable(
            _In_ DkmWorkList* pWorkList,
            _In_ IDkmCompletionRoutine<Breakpoints::DkmEnableRuntimeBreakpointAsyncResult>* pCompletionRoutine
            );

        /// <summary>
        /// Determines if the given DkmRuntimeBreakpoint could be enabled. This is used from
        /// within the breakpoints dialog to validate breakpoints before the dialog is
        /// closed.
        /// </summary>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// E_BP_MODULE_UNLOADED indicates that the module instance specified by the
        /// breakpoint is no longer loaded. E_TEXT_SPAN_NOT_LOADED indicates that TextSpan is
        /// not currently loaded in the specified script document.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Test(
            );

        /// <summary>
        /// Determines if the given DkmRuntimeBreakpoint could be enabled. This is used from
        /// within the breakpoints dialog to validate breakpoints before the dialog is
        /// closed.
        ///
        /// This method will append a new work item to the specified work list, and return
        /// once the work item has been appended. The actual processing of the work item is
        /// asynchronous. The caller will be notified that the request is complete through
        /// the completion routine.
        /// </summary>
        /// <param name="pWorkList">
        /// WorkList to append the new work item to.
        /// </param>
        /// <param name="pCompletionRoutine">
        /// Routine to fire when the request is complete. If the request is successfully
        /// appended to the work list, this will always fire (including when the operation is
        /// canceled). This will never fire if appending the work item fails.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Test(
            _In_ DkmWorkList* pWorkList,
            _In_ IDkmCompletionRoutine<Breakpoints::DkmTestRuntimeBreakpointAsyncResult>* pCompletionRoutine
            );

        /// <summary>
        /// Disables a breakpoint. Disabling a breakpoint is typically implemented by
        /// modifying the state of the target process so the breakpoint will no longer fire.
        /// For example, removing a previously inserted 'int3' from the instruction stream.
        /// If the breakpoint is already disabled, this operation has no effect. In addition
        /// to this method, a breakpoint is implicitly disabled when it is closed.
        ///
        /// If multiple breakpoints are set on the same instruction, disabling one breakpoint
        /// does not affect the other breakpoints set on this instruction.
        ///
        /// This method may only be called by the component which created the object.
        /// </summary>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Disable(
            );

        /// <summary>
        /// Disables a breakpoint. Disabling a breakpoint is typically implemented by
        /// modifying the state of the target process so the breakpoint will no longer fire.
        /// For example, removing a previously inserted 'int3' from the instruction stream.
        /// If the breakpoint is already disabled, this operation has no effect. In addition
        /// to this method, a breakpoint is implicitly disabled when it is closed.
        ///
        /// If multiple breakpoints are set on the same instruction, disabling one breakpoint
        /// does not affect the other breakpoints set on this instruction.
        ///
        /// This method will append a new work item to the specified work list, and return
        /// once the work item has been appended. The actual processing of the work item is
        /// asynchronous. The caller will be notified that the request is complete through
        /// the completion routine.
        ///
        /// This method may only be called by the component which created the object.
        /// </summary>
        /// <param name="pWorkList">
        /// WorkList to append the new work item to.
        /// </param>
        /// <param name="pCompletionRoutine">
        /// Routine to fire when the request is complete. If the request is successfully
        /// appended to the work list, this will always fire (including when the operation is
        /// canceled). This will never fire if appending the work item fails.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Disable(
            _In_ DkmWorkList* pWorkList,
            _In_ IDkmCompletionRoutine<Breakpoints::DkmDisableRuntimeBreakpointAsyncResult>* pCompletionRoutine
            );

        /// <summary>
        /// Raise a RuntimeBreakpoint event. Components which implement the event sync
        /// interface will receive the event notification. This method will enqueue the event
        /// and control will immediately return to the caller.
        /// </summary>
        /// <param name="pThread">
        /// [In] DkmThread represents a thread running in the target process.
        /// </param>
        /// <param name="HasException">
        /// [In] Contains true if the source runtime instance can determine that an exception
        /// is in flight on the thread which hit the breakpoint. Currently, only managed
        /// runtime instances ever set this. This is used to quickly determine if exception
        /// specific logic should apply without making another network round-trip.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE OnHit(
            _In_ DkmThread* pThread,
            _In_ bool HasException
            );

        #ifndef EXCLUDE_MONITOR_ONLY_APIS
        /// <summary>
        /// The base debug monitor asks the breakpoint condition processor to evaluate on all
        /// stopped threads, and selects the thread whose condition is true.
        ///
        /// Location constraint: API must be called from a Monitor component (component level
        /// &lt; 100,000).
        ///
        /// This API was introduced in Visual Studio 11 Update 1
        /// (DkmApiVersion.VS11FeaturePack1).
        /// </summary>
        /// <param name="pFirstStoppedThread">
        /// [In] The first stopped thread.
        /// </param>
        /// <param name="ppConditionMetThread">
        /// [Out,Optional] The thread whose condition is true. The value is null in the case
        /// that no thread is found to have a true condition.
        /// </param>
        /// <returns>
        /// S_OK is returned if *ppConditionMetThread is non-NULL, S_FALSE is returned when
        /// *ppConditionMetThread is NULL, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE EvaluateConditionAndSelectThread(
            _In_ DkmThread* pFirstStoppedThread,
            _Deref_out_opt_ DkmThread** ppConditionMetThread
            );
        #endif // #ifndef EXCLUDE_MONITOR_ONLY_APIS

        #ifndef EXCLUDE_MONITOR_ONLY_APIS
        /// <summary>
        /// The base debug monitor asks the breakpoint condition processor to evaluate on all
        /// stopped threads, and selects the thread whose condition is true.
        ///
        /// This method will append a new work item to the specified work list, and return
        /// once the work item has been appended. The actual processing of the work item is
        /// asynchronous. The caller will be notified that the request is complete through
        /// the completion routine.
        ///
        /// Location constraint: API must be called from a Monitor component (component level
        /// &lt; 100,000).
        ///
        /// This API was introduced in Visual Studio 11 Update 1
        /// (DkmApiVersion.VS11FeaturePack1).
        /// </summary>
        /// <param name="pWorkList">
        /// WorkList to append the new work item to.
        /// </param>
        /// <param name="pFirstStoppedThread">
        /// [In] The first stopped thread.
        /// </param>
        /// <param name="pCompletionRoutine">
        /// Routine to fire when the request is complete. If the request is successfully
        /// appended to the work list, this will always fire (including when the operation is
        /// canceled). This will never fire if appending the work item fails.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE EvaluateConditionAndSelectThread(
            _In_ DkmWorkList* pWorkList,
            _In_ DkmThread* pFirstStoppedThread,
            _In_ IDkmCompletionRoutine<Breakpoints::DkmEvaluateConditionAndSelectThreadAsyncResult>* pCompletionRoutine
            );
        #endif // #ifndef EXCLUDE_MONITOR_ONLY_APIS

        #ifndef EXCLUDE_MONITOR_ONLY_APIS
        /// <summary>
        /// Call back invoked from the breakpoint condition processor to the breakpoint
        /// manager when a breakpoint condition encounters a runtime error.
        ///
        /// Location constraint: API must be called from a Monitor component (component level
        /// &lt; 100,000).
        ///
        /// This API was introduced in Visual Studio 14 RTM (DkmApiVersion.VS14RTM).
        /// </summary>
        /// <param name="ErrorCode">
        /// [In] Failure code explaining why the IL-based breakpoint query failed to execute.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE OnBreakpointConditionFailed(
            _In_ Evaluation::IL::DkmILFailureReason_t ErrorCode
            );
        #endif // #ifndef EXCLUDE_MONITOR_ONLY_APIS
    }; // end of DkmRuntimeBreakpoint

    // Result of an asynchronous DkmRuntimeInstructionBreakpoint.SetCompiledCondition call.
    struct DkmSetCompiledConditionAsyncResult
    {
        // HRESULT code returned from the caller. This will be
        // DkmExceptionCode.COR_E_OPERATIONCANCELED (0x8013153B) if the operation was
        // canceled before processing was complete.
        HRESULT ErrorCode;
    };

    // Result of an asynchronous DkmRuntimeBreakpoint.SetCompiledConditionPending call.
    struct DkmSetCompiledConditionPendingAsyncResult
    {
        // HRESULT code returned from the caller. This will be
        // DkmExceptionCode.COR_E_OPERATIONCANCELED (0x8013153B) if the operation was
        // canceled before processing was complete.
        HRESULT ErrorCode;
    };

    // Result of an asynchronous DkmRuntimeBreakpoint.SetEvaluationCondition call.
    struct DkmSetEvaluationConditionAsyncResult
    {
        // HRESULT code returned from the caller. This will be
        // DkmExceptionCode.COR_E_OPERATIONCANCELED (0x8013153B) if the operation was
        // canceled before processing was complete.
        HRESULT ErrorCode;

        // [Optional] If the condition could not be parsed, this indicates the reason why.
        // This value should be null if the compile succeeded.
        OPTIONAL DkmString* pErrorText;
    };

    // Result of an asynchronous DkmPendingBreakpoint.SetCondition call.
    struct DkmSetPendingBreakpointConditionAsyncResult
    {
        // HRESULT code returned from the caller. This will be
        // DkmExceptionCode.COR_E_OPERATIONCANCELED (0x8013153B) if the operation was
        // canceled before processing was complete.
        HRESULT ErrorCode;
    };

    // Result of an asynchronous DkmPendingBreakpoint.SetHitCountCondition call.
    struct DkmSetPendingBreakpointHitCountConditionAsyncResult
    {
        // HRESULT code returned from the caller. This will be
        // DkmExceptionCode.COR_E_OPERATIONCANCELED (0x8013153B) if the operation was
        // canceled before processing was complete.
        HRESULT ErrorCode;
    };

    // Result of an asynchronous DkmRuntimeBreakpoint.SetHitCountCondition call.
    struct DkmSetRuntimeBreakpointHitCountConditionAsyncResult
    {
        // HRESULT code returned from the caller. This will be
        // DkmExceptionCode.COR_E_OPERATIONCANCELED (0x8013153B) if the operation was
        // canceled before processing was complete.
        HRESULT ErrorCode;
    };

    // Result of an asynchronous DkmRuntimeBreakpoint.Test call.
    struct DkmTestRuntimeBreakpointAsyncResult
    {
        // HRESULT code returned from the caller. This will be
        // DkmExceptionCode.COR_E_OPERATIONCANCELED (0x8013153B) if the operation was
        // canceled before processing was complete. E_BP_MODULE_UNLOADED indicates that the
        // module instance specified by the breakpoint is no longer loaded.
        // E_TEXT_SPAN_NOT_LOADED indicates that TextSpan is not currently loaded in the
        // specified script document.
        HRESULT ErrorCode;
    };

    // Result of an asynchronous
    // DkmRuntimeInstructionBreakpoint.TryClearConditionOnTargetDevice call.
    struct DkmTryClearConditionOnTargetDeviceAsyncResult
    {
        // HRESULT code returned from the caller. This will be
        // DkmExceptionCode.COR_E_OPERATIONCANCELED (0x8013153B) if the operation was
        // canceled before processing was complete.
        HRESULT ErrorCode;
    };

    // Result of an asynchronous
    // DkmRuntimeInstructionBreakpoint.TryPushConditionToTargetDevice call.
    struct DkmTryPushConditionToTargetDeviceAsyncResult
    {
        // HRESULT code returned from the caller. This will be
        // DkmExceptionCode.COR_E_OPERATIONCANCELED (0x8013153B) if the operation was
        // canceled before processing was complete.
        HRESULT ErrorCode;
    };

    // Pending breakpoint which is requested to bind against a particular instruction
    // address. Within the IDE, these breakpoints are set from the call stack window,
    // disassembly window, or by entering a hex address into the function breakpoint dialog.
    // Because the DkmInstructionAddress is given as input, these breakpoints can support
    // Runtimes which cannot persist their addresses to a string (ex: an interpreter).
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("5e4de51b-8d82-5d38-8041-3a42c18d3f47") DkmPendingAddressBreakpoint : public Breakpoints::DkmPendingBreakpoint
    {
        // Use DkmPendingAddressBreakpoint::Create to create this object
        private: DkmPendingAddressBreakpoint();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmPendingAddressBreakpoint();
        // This object cannot be copied
        private: DkmPendingAddressBreakpoint& operator=(const DkmPendingAddressBreakpoint&);
        private: DkmPendingAddressBreakpoint(const DkmPendingAddressBreakpoint&);

        private: DkmInstructionAddress* const m_pInstructionAddress;
        private: void* m__pExtendedData;

        // Abstract representation of an executable code location (ex: EIP value). If the
        // instruction address is unresolved (DkmUnknownInstructionAddress) and contains a
        // CPU instruction, the breakpoint manager will attempt to bind the instruction if a
        // module within that range loads.
        public: _Ret_ DECLSPEC_NOTHROW DkmInstructionAddress* STDMETHODCALLTYPE InstructionAddress(
            );

        // Attempt to cast a 'DkmPendingBreakpoint' to a 'DkmPendingAddressBreakpoint'. Return
        // NULL if the path object is not a 'DkmPendingAddressBreakpoint'.
        // pAddressBreakpoint : [In,Optional] Object to attempt to cast
        // Return Value : [Optional] Result of the cast.
        public: static DECLSPEC_NOTHROW DkmPendingAddressBreakpoint* TryCast(
            DkmPendingBreakpoint* pPendingBreakpoint
            )
        {
            if (pPendingBreakpoint == NULL || pPendingBreakpoint->TagValue() != Tag::AddressBreakpoint)
                return NULL;

            return static_cast<DkmPendingAddressBreakpoint*>(pPendingBreakpoint);
        }

        /// <summary>
        /// Creates a new pending breakpoint object. After creation, the returned object will
        /// still be disabled and will not be tracked by the breakpoint manager. To complete
        /// initialization, the caller should set additional properties on the breakpoint and
        /// 'Enable' or 'Enroll' it. The caller is responsible for closing the created object
        /// after they are done.
        /// </summary>
        /// <param name="SourceId">
        /// [In] Identifies the source of an object. SourceIds are used to enable filtering
        /// in scenarios when multiple components may be creating instances of a class. For
        /// example, source ids can be used to determine if a breakpoint comes from the AD7
        /// AL (ex: user breakpoint, or other breakpoint visible at the SDM level) instead of
        /// a breakpoint which may be created by another component (for example an internal
        /// breakpoint used for stepping).
        /// </param>
        /// <param name="CompilerId">
        /// [In] Identifies the source language (ex: C#) and compiler vendor (ex: Microsoft)
        /// that the breakpoint should bind against. 'LanguageId' may be left as Guid.Empty
        /// to indicate that the breakpoint should bind against all languages. 'VendorId' is
        /// nearly always left as Guid.Empty, which indicates that only the language is known
        /// (not the compiler).
        /// </param>
        /// <param name="pThread">
        /// [In,Optional] Thread on which this breakpoint should fire. If null, the
        /// breakpoint will fire on all threads.
        /// </param>
        /// <param name="IsBarrier">
        /// [In] Indicates if this breakpoint is a barrier that should be set on the
        /// hardware, this works for GPU debugging.
        /// </param>
        /// <param name="pInstructionAddress">
        /// [In] Abstract representation of an executable code location (ex: EIP value). If
        /// the instruction address is unresolved (DkmUnknownInstructionAddress) and contains
        /// a CPU instruction, the breakpoint manager will attempt to bind the instruction if
        /// a module within that range loads.
        /// </param>
        /// <param name="DataItem">
        /// [In] Data object to add to the new DkmPendingAddressBreakpoint instance.
        /// DkmDataItem::Null() in the case that the caller doesn't need to add a data item.
        /// </param>
        /// <param name="ppCreatedObject">
        /// [Out] Result of this method call.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ const GUID& SourceId,
            _In_ const Evaluation::DkmCompilerId& CompilerId,
            _In_opt_ DkmThread* pThread,
            _In_ bool IsBarrier,
            _In_ DkmInstructionAddress* pInstructionAddress,
            _In_ const DkmDataItem& DataItem,
            _Deref_out_ Breakpoints::DkmPendingAddressBreakpoint** ppCreatedObject
            );
    }; // end of DkmPendingAddressBreakpoint

    // Pending breakpoint which is requested to bind against the code element at a specific
    // instruction address string. Within the IDE, these breakpoints are created when the
    // user sets a breakpoint in the call stack or disassembly window, and then the debugger
    // is asked to rebind the breakpoint in another debug session or in another process
    // within the same debug session.
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("243712b0-a935-6c92-7fc4-6ffb461126ac") DkmPendingAddressNameBreakpoint : public Breakpoints::DkmPendingBreakpoint
    {
        // Use DkmPendingAddressNameBreakpoint::Create to create this object
        private: DkmPendingAddressNameBreakpoint();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmPendingAddressNameBreakpoint();
        // This object cannot be copied
        private: DkmPendingAddressNameBreakpoint& operator=(const DkmPendingAddressNameBreakpoint&);
        private: DkmPendingAddressNameBreakpoint(const DkmPendingAddressNameBreakpoint&);

        private: DkmString* const m_pModuleName;
        private: DkmString* const m_pAddressName;
        private: OPTIONAL DkmString* const m_pFunctionName;
        private: void* m__pExtendedData;

        // Name of the module to search for the breakpoint.
        public: _Ret_ DECLSPEC_NOTHROW DkmString* STDMETHODCALLTYPE ModuleName(
            );

        // String representation of the address to bind to.
        public: _Ret_ DECLSPEC_NOTHROW DkmString* STDMETHODCALLTYPE AddressName(
            );

        // [Optional] Name of the function which contains the address.
        public: _Ret_opt_ DECLSPEC_NOTHROW DkmString* STDMETHODCALLTYPE FunctionName(
            );

        // Attempt to cast a 'DkmPendingBreakpoint' to a 'DkmPendingAddressNameBreakpoint'. Return
        // NULL if the path object is not a 'DkmPendingAddressNameBreakpoint'.
        // pAddressNameBreakpoint : [In,Optional] Object to attempt to cast
        // Return Value : [Optional] Result of the cast.
        public: static DECLSPEC_NOTHROW DkmPendingAddressNameBreakpoint* TryCast(
            DkmPendingBreakpoint* pPendingBreakpoint
            )
        {
            if (pPendingBreakpoint == NULL || pPendingBreakpoint->TagValue() != Tag::AddressNameBreakpoint)
                return NULL;

            return static_cast<DkmPendingAddressNameBreakpoint*>(pPendingBreakpoint);
        }

        /// <summary>
        /// Creates a new pending breakpoint object. After creation, the returned object will
        /// still be disabled and will not be tracked by the breakpoint manager. To complete
        /// initialization, the caller should set additional properties on the breakpoint and
        /// 'Enable' or 'Enroll' it. The caller is responsible for closing the created object
        /// after they are done.
        /// </summary>
        /// <param name="pProcess">
        /// [In] DkmProcess represents a target process which is being debugged. The debugger
        /// debugs processes, so this is the basic unit of debugging. A DkmProcess can
        /// represent a system process or a virtual process such as minidumps.
        /// </param>
        /// <param name="SourceId">
        /// [In] Identifies the source of an object. SourceIds are used to enable filtering
        /// in scenarios when multiple components may be creating instances of a class. For
        /// example, source ids can be used to determine if a breakpoint comes from the AD7
        /// AL (ex: user breakpoint, or other breakpoint visible at the SDM level) instead of
        /// a breakpoint which may be created by another component (for example an internal
        /// breakpoint used for stepping).
        /// </param>
        /// <param name="CompilerId">
        /// [In] Identifies the source language (ex: C#) and compiler vendor (ex: Microsoft)
        /// that the breakpoint should bind against. 'LanguageId' may be left as Guid.Empty
        /// to indicate that the breakpoint should bind against all languages. 'VendorId' is
        /// nearly always left as Guid.Empty, which indicates that only the language is known
        /// (not the compiler).
        /// </param>
        /// <param name="pThread">
        /// [In,Optional] Thread on which this breakpoint should fire. If null, the
        /// breakpoint will fire on all threads.
        /// </param>
        /// <param name="IsBarrier">
        /// [In] Indicates if this breakpoint is a barrier that should be set on the
        /// hardware, this works for GPU debugging.
        /// </param>
        /// <param name="pModuleName">
        /// [In] Name of the module to search for the breakpoint.
        /// </param>
        /// <param name="pAddressName">
        /// [In] String representation of the address to bind to.
        /// </param>
        /// <param name="pFunctionName">
        /// [In,Optional] Name of the function which contains the address.
        /// </param>
        /// <param name="DataItem">
        /// [In] Data object to add to the new DkmPendingAddressNameBreakpoint instance.
        /// DkmDataItem::Null() in the case that the caller doesn't need to add a data item.
        /// </param>
        /// <param name="ppCreatedObject">
        /// [Out] Result of this method call.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ DkmProcess* pProcess,
            _In_ const GUID& SourceId,
            _In_ const Evaluation::DkmCompilerId& CompilerId,
            _In_opt_ DkmThread* pThread,
            _In_ bool IsBarrier,
            _In_ DkmString* pModuleName,
            _In_ DkmString* pAddressName,
            _In_opt_ DkmString* pFunctionName,
            _In_ const DkmDataItem& DataItem,
            _Deref_out_ Breakpoints::DkmPendingAddressNameBreakpoint** ppCreatedObject
            );
    }; // end of DkmPendingAddressNameBreakpoint

    // Pending breakpoint which is tied to a data expression instead of a code expression.
    // Data breakpoints fire when the specified element is written to.
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("afd7a281-dbf3-946b-9464-8ca12287616b") DkmPendingDataBreakpoint : public Breakpoints::DkmPendingBreakpoint
    {
        // Use DkmPendingDataBreakpoint::Create to create this object
        private: DkmPendingDataBreakpoint();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmPendingDataBreakpoint();
        // This object cannot be copied
        private: DkmPendingDataBreakpoint& operator=(const DkmPendingDataBreakpoint&);
        private: DkmPendingDataBreakpoint(const DkmPendingDataBreakpoint&);

        private: DkmString* const m_pDataElementLocation;
        private: const UINT32 m_Size;
        private: void* m__pExtendedData;

        // Indicates the location of the data value to watch.
        public: _Ret_ DECLSPEC_NOTHROW DkmString* STDMETHODCALLTYPE DataElementLocation(
            );

        // Specifies the size of the location, in bytes, to monitor for access. Valid sizes
        // may depend on the target processor (x86, x64, etc) and type of code being
        // debugging. For example, native code utilizes the CPU's breakpoint registers, and
        // x86-based processor supports sizes of 1, 2, and 4.
        public: DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE Size(
            );

        // Attempt to cast a 'DkmPendingBreakpoint' to a 'DkmPendingDataBreakpoint'. Return
        // NULL if the path object is not a 'DkmPendingDataBreakpoint'.
        // pDataBreakpoint : [In,Optional] Object to attempt to cast
        // Return Value : [Optional] Result of the cast.
        public: static DECLSPEC_NOTHROW DkmPendingDataBreakpoint* TryCast(
            DkmPendingBreakpoint* pPendingBreakpoint
            )
        {
            if (pPendingBreakpoint == NULL || pPendingBreakpoint->TagValue() != Tag::DataBreakpoint)
                return NULL;

            return static_cast<DkmPendingDataBreakpoint*>(pPendingBreakpoint);
        }

        /// <summary>
        /// Creates a new pending breakpoint object. After creation, the returned object will
        /// still be disabled and will not be tracked by the breakpoint manager. To complete
        /// initialization, the caller should set additional properties on the breakpoint and
        /// 'Enable' or 'Enroll' it. The caller is responsible for closing the created object
        /// after they are done.
        /// </summary>
        /// <param name="pProcess">
        /// [In] DkmProcess represents a target process which is being debugged. The debugger
        /// debugs processes, so this is the basic unit of debugging. A DkmProcess can
        /// represent a system process or a virtual process such as minidumps.
        /// </param>
        /// <param name="SourceId">
        /// [In] Identifies the source of an object. SourceIds are used to enable filtering
        /// in scenarios when multiple components may be creating instances of a class. For
        /// example, source ids can be used to determine if a breakpoint comes from the AD7
        /// AL (ex: user breakpoint, or other breakpoint visible at the SDM level) instead of
        /// a breakpoint which may be created by another component (for example an internal
        /// breakpoint used for stepping).
        /// </param>
        /// <param name="CompilerId">
        /// [In] Identifies the source language (ex: C#) and compiler vendor (ex: Microsoft)
        /// that the breakpoint should bind against. 'LanguageId' may be left as Guid.Empty
        /// to indicate that the breakpoint should bind against all languages. 'VendorId' is
        /// nearly always left as Guid.Empty, which indicates that only the language is known
        /// (not the compiler).
        /// </param>
        /// <param name="pThread">
        /// [In,Optional] Thread on which this breakpoint should fire. If null, the
        /// breakpoint will fire on all threads.
        /// </param>
        /// <param name="IsBarrier">
        /// [In] Indicates if this breakpoint is a barrier that should be set on the
        /// hardware, this works for GPU debugging.
        /// </param>
        /// <param name="pDataElementLocation">
        /// [In] Indicates the location of the data value to watch.
        /// </param>
        /// <param name="Size">
        /// [In] Specifies the size of the location, in bytes, to monitor for access. Valid
        /// sizes may depend on the target processor (x86, x64, etc) and type of code being
        /// debugging. For example, native code utilizes the CPU's breakpoint registers, and
        /// x86-based processor supports sizes of 1, 2, and 4.
        /// </param>
        /// <param name="DataItem">
        /// [In] Data object to add to the new DkmPendingDataBreakpoint instance.
        /// DkmDataItem::Null() in the case that the caller doesn't need to add a data item.
        /// </param>
        /// <param name="ppCreatedObject">
        /// [Out] Result of this method call.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ DkmProcess* pProcess,
            _In_ const GUID& SourceId,
            _In_ const Evaluation::DkmCompilerId& CompilerId,
            _In_opt_ DkmThread* pThread,
            _In_ bool IsBarrier,
            _In_ DkmString* pDataElementLocation,
            _In_ UINT32 Size,
            _In_ const DkmDataItem& DataItem,
            _Deref_out_ Breakpoints::DkmPendingDataBreakpoint** ppCreatedObject
            );
    }; // end of DkmPendingDataBreakpoint

    // Pending breakpoint which is requested to bind against code elements that point back to
    // a text span within a source file.
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("ea7b0aee-1cc5-a887-4dff-930fc23a6278") DkmPendingFileLineBreakpoint : public Breakpoints::DkmPendingBreakpoint
    {
        // Use DkmPendingFileLineBreakpoint::Create to create this object
        private: DkmPendingFileLineBreakpoint();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmPendingFileLineBreakpoint();
        // This object cannot be copied
        private: DkmPendingFileLineBreakpoint& operator=(const DkmPendingFileLineBreakpoint&);
        private: DkmPendingFileLineBreakpoint(const DkmPendingFileLineBreakpoint&);

        private: void* m__pExtendedData;

        // Attempt to cast a 'DkmPendingBreakpoint' to a 'DkmPendingFileLineBreakpoint'. Return
        // NULL if the path object is not a 'DkmPendingFileLineBreakpoint'.
        // pFileLineBreakpoint : [In,Optional] Object to attempt to cast
        // Return Value : [Optional] Result of the cast.
        public: static DECLSPEC_NOTHROW DkmPendingFileLineBreakpoint* TryCast(
            DkmPendingBreakpoint* pPendingBreakpoint
            )
        {
            if (pPendingBreakpoint == NULL || pPendingBreakpoint->TagValue() != Tag::FileLineBreakpoint)
                return NULL;

            return static_cast<DkmPendingFileLineBreakpoint*>(pPendingBreakpoint);
        }

        /// <summary>
        /// Creates a new pending breakpoint object. After creation, the returned object will
        /// still be disabled and will not be tracked by the breakpoint manager. To complete
        /// initialization, the caller should set additional properties on the breakpoint and
        /// 'Enable' or 'Enroll' it. The caller is responsible for closing the created object
        /// after they are done.
        /// </summary>
        /// <param name="pProcess">
        /// [In] DkmProcess represents a target process which is being debugged. The debugger
        /// debugs processes, so this is the basic unit of debugging. A DkmProcess can
        /// represent a system process or a virtual process such as minidumps.
        /// </param>
        /// <param name="SourceId">
        /// [In] Identifies the source of an object. SourceIds are used to enable filtering
        /// in scenarios when multiple components may be creating instances of a class. For
        /// example, source ids can be used to determine if a breakpoint comes from the AD7
        /// AL (ex: user breakpoint, or other breakpoint visible at the SDM level) instead of
        /// a breakpoint which may be created by another component (for example an internal
        /// breakpoint used for stepping).
        /// </param>
        /// <param name="CompilerId">
        /// [In] Identifies the source language (ex: C#) and compiler vendor (ex: Microsoft)
        /// that the breakpoint should bind against. 'LanguageId' may be left as Guid.Empty
        /// to indicate that the breakpoint should bind against all languages. 'VendorId' is
        /// nearly always left as Guid.Empty, which indicates that only the language is known
        /// (not the compiler).
        /// </param>
        /// <param name="pThread">
        /// [In,Optional] Thread on which this breakpoint should fire. If null, the
        /// breakpoint will fire on all threads.
        /// </param>
        /// <param name="IsBarrier">
        /// [In] Indicates if this breakpoint is a barrier that should be set on the
        /// hardware, this works for GPU debugging.
        /// </param>
        /// <param name="DataItem">
        /// [In] Data object to add to the new DkmPendingFileLineBreakpoint instance.
        /// DkmDataItem::Null() in the case that the caller doesn't need to add a data item.
        /// </param>
        /// <param name="ppCreatedObject">
        /// [Out] Result of this method call.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ DkmProcess* pProcess,
            _In_ const GUID& SourceId,
            _In_ const Evaluation::DkmCompilerId& CompilerId,
            _In_opt_ DkmThread* pThread,
            _In_ bool IsBarrier,
            _In_ const DkmDataItem& DataItem,
            _Deref_out_ Breakpoints::DkmPendingFileLineBreakpoint** ppCreatedObject
            );

        /// <summary>
        /// Returns the current location of a file/line breakpoint. In edit and continue
        /// scenarios, the location of the text marker may change within a debug session.
        /// </summary>
        /// <param name="ppCurrentPosition">
        /// [Out] Source code position which corresponds to a code element. The could
        /// represent a location which has been extracted from a symbol (PDB) file, or it
        /// could be the location of a breakpoint in the IDE.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetCurrentSourcePosition(
            _Deref_out_ Symbols::DkmSourcePosition** ppCurrentPosition
            );

        /// <summary>
        /// Returns the current text at the location of a file/line breakpoint.
        /// </summary>
        /// <param name="ppCurrentText">
        /// [Out,Optional] The current source text.
        /// </param>
        /// <returns>
        /// S_OK is returned if *ppCurrentText is non-NULL, S_FALSE is returned when
        /// *ppCurrentText is NULL, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetCurrentSourceText(
            _Deref_out_opt_ DkmString** ppCurrentText
            );
    }; // end of DkmPendingFileLineBreakpoint

    // Pending breakpoint which is requested to bind against code elements that have a
    // specific function name.
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("b463b9e3-5b9f-e0e4-f0e9-4f38c63ef443") DkmPendingFunctionBreakpoint : public Breakpoints::DkmPendingBreakpoint
    {
        // Use DkmPendingFunctionBreakpoint::Create to create this object
        private: DkmPendingFunctionBreakpoint();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmPendingFunctionBreakpoint();
        // This object cannot be copied
        private: DkmPendingFunctionBreakpoint& operator=(const DkmPendingFunctionBreakpoint&);
        private: DkmPendingFunctionBreakpoint(const DkmPendingFunctionBreakpoint&);

        private: OPTIONAL DkmString* const m_pModuleName;
        private: DkmString* const m_pFunctionName;
        private: const UINT32 m_LineOffset;
        private: void* m__pExtendedData;

        // [Optional] Name of the module to search for the breakpoint. If null, all modules
        // will be searched.
        public: _Ret_opt_ DECLSPEC_NOTHROW DkmString* STDMETHODCALLTYPE ModuleName(
            );

        // Name of the function to bind to.
        public: _Ret_ DECLSPEC_NOTHROW DkmString* STDMETHODCALLTYPE FunctionName(
            );

        // The line of the function to bind to.
        public: DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE LineOffset(
            );

        // Attempt to cast a 'DkmPendingBreakpoint' to a 'DkmPendingFunctionBreakpoint'. Return
        // NULL if the path object is not a 'DkmPendingFunctionBreakpoint'.
        // pFunctionBreakpoint : [In,Optional] Object to attempt to cast
        // Return Value : [Optional] Result of the cast.
        public: static DECLSPEC_NOTHROW DkmPendingFunctionBreakpoint* TryCast(
            DkmPendingBreakpoint* pPendingBreakpoint
            )
        {
            if (pPendingBreakpoint == NULL || pPendingBreakpoint->TagValue() != Tag::FunctionBreakpoint)
                return NULL;

            return static_cast<DkmPendingFunctionBreakpoint*>(pPendingBreakpoint);
        }

        /// <summary>
        /// Creates a new pending breakpoint object. After creation, the returned object will
        /// still be disabled and will not be tracked by the breakpoint manager. To complete
        /// initialization, the caller should set additional properties on the breakpoint and
        /// 'Enable' or 'Enroll' it. The caller is responsible for closing the created object
        /// after they are done.
        /// </summary>
        /// <param name="pProcess">
        /// [In] DkmProcess represents a target process which is being debugged. The debugger
        /// debugs processes, so this is the basic unit of debugging. A DkmProcess can
        /// represent a system process or a virtual process such as minidumps.
        /// </param>
        /// <param name="SourceId">
        /// [In] Identifies the source of an object. SourceIds are used to enable filtering
        /// in scenarios when multiple components may be creating instances of a class. For
        /// example, source ids can be used to determine if a breakpoint comes from the AD7
        /// AL (ex: user breakpoint, or other breakpoint visible at the SDM level) instead of
        /// a breakpoint which may be created by another component (for example an internal
        /// breakpoint used for stepping).
        /// </param>
        /// <param name="CompilerId">
        /// [In] Identifies the source language (ex: C#) and compiler vendor (ex: Microsoft)
        /// that the breakpoint should bind against. 'LanguageId' may be left as Guid.Empty
        /// to indicate that the breakpoint should bind against all languages. 'VendorId' is
        /// nearly always left as Guid.Empty, which indicates that only the language is known
        /// (not the compiler).
        /// </param>
        /// <param name="pThread">
        /// [In,Optional] Thread on which this breakpoint should fire. If null, the
        /// breakpoint will fire on all threads.
        /// </param>
        /// <param name="IsBarrier">
        /// [In] Indicates if this breakpoint is a barrier that should be set on the
        /// hardware, this works for GPU debugging.
        /// </param>
        /// <param name="pModuleName">
        /// [In,Optional] Name of the module to search for the breakpoint. If null, all
        /// modules will be searched.
        /// </param>
        /// <param name="pFunctionName">
        /// [In] Name of the function to bind to.
        /// </param>
        /// <param name="LineOffset">
        /// [In] The line of the function to bind to.
        /// </param>
        /// <param name="DataItem">
        /// [In] Data object to add to the new DkmPendingFunctionBreakpoint instance.
        /// DkmDataItem::Null() in the case that the caller doesn't need to add a data item.
        /// </param>
        /// <param name="ppCreatedObject">
        /// [Out] Result of this method call.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ DkmProcess* pProcess,
            _In_ const GUID& SourceId,
            _In_ const Evaluation::DkmCompilerId& CompilerId,
            _In_opt_ DkmThread* pThread,
            _In_ bool IsBarrier,
            _In_opt_ DkmString* pModuleName,
            _In_ DkmString* pFunctionName,
            _In_ UINT32 LineOffset,
            _In_ const DkmDataItem& DataItem,
            _Deref_out_ Breakpoints::DkmPendingFunctionBreakpoint** ppCreatedObject
            );
    }; // end of DkmPendingFunctionBreakpoint

    // Low-level data breakpoint which is set using the hardware breakpoint registers of the
    // CPU.
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("3346103d-7c30-4ee9-c3dd-e8e7e9f66a5e") DkmRuntimeHardwareDataBreakpoint : public Breakpoints::DkmRuntimeBreakpoint
    {
        // Use DkmRuntimeHardwareDataBreakpoint::Create to create this object
        private: DkmRuntimeHardwareDataBreakpoint();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmRuntimeHardwareDataBreakpoint();
        // This object cannot be copied
        private: DkmRuntimeHardwareDataBreakpoint& operator=(const DkmRuntimeHardwareDataBreakpoint&);
        private: DkmRuntimeHardwareDataBreakpoint(const DkmRuntimeHardwareDataBreakpoint&);

        private: const UINT64 m_Address;
        private: const Breakpoints::DkmDataAccessStopMask_t m_Access;
        private: const UINT32 m_Size;
        private: void* m__pExtendedData;

        // Address to stop on. This address must be suitably aligned to match the Size
        // parameter (example: if Size is 4, Address must be a multiple of 4).
        public: DECLSPEC_NOTHROW UINT64 STDMETHODCALLTYPE Address(
            );

        // Mask of reasons why the data breakpoint should fire. For example, if 'Write' is
        // set, then the breakpoint will fire when the memory location is written.
        public: DECLSPEC_NOTHROW Breakpoints::DkmDataAccessStopMask_t STDMETHODCALLTYPE Access(
            );

        // Specifies the size of the location, in bytes, to monitor for access. On an
        // x86-based processor, this parameter can be 1, 2, or 4. However, if Access is
        // DkmDataAccessStopMask.Execute, Size must be 1. On an x64-based processor, this
        // parameter can be 1, 2, 4, or 8. However, if Access equals Access is
        // DkmDataAccessStopMask.Execute, Size must be 1. On an Itanium-based processor, this
        // parameter can be any power of 2, from 1 to 0x80000000.
        public: DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE Size(
            );

        // Attempt to cast a 'DkmRuntimeBreakpoint' to a 'DkmRuntimeHardwareDataBreakpoint'. Return
        // NULL if the path object is not a 'DkmRuntimeHardwareDataBreakpoint'.
        // pNativeDataBreakpoint : [In,Optional] Object to attempt to cast
        // Return Value : [Optional] Result of the cast.
        public: static DECLSPEC_NOTHROW DkmRuntimeHardwareDataBreakpoint* TryCast(
            DkmRuntimeBreakpoint* pRuntimeBreakpoint
            )
        {
            if (pRuntimeBreakpoint == NULL || pRuntimeBreakpoint->TagValue() != Tag::NativeDataBreakpoint)
                return NULL;

            return static_cast<DkmRuntimeHardwareDataBreakpoint*>(pRuntimeBreakpoint);
        }

        /// <summary>
        /// Creates a new DkmRuntimeHardwareDataBreakpoint object. After creation, the
        /// breakpoint is in the disabled state, and must be explicitly enabled. The caller
        /// is responsible for closing the created object after they are done.
        /// </summary>
        /// <param name="pRuntimeInstance">
        /// [In] The DkmRuntimeInstance class represents an execution environment which is
        /// loaded into a DkmProcess and which contains code to be debugged.
        /// </param>
        /// <param name="SourceId">
        /// [In] Identifies the source of an object. SourceIds are used to enable filtering
        /// in scenarios when multiple components may be creating instances of a class. For
        /// example, source ids can be used to determine if a breakpoint comes from the AD7
        /// AL (ex: user breakpoint, or other breakpoint visible at the SDM level) instead of
        /// a breakpoint which may be created by another component (for example an internal
        /// breakpoint used for stepping).
        /// </param>
        /// <param name="pThread">
        /// [In,Optional] Thread on which this breakpoint should fire. If null, the
        /// breakpoint will fire on all threads.
        /// </param>
        /// <param name="Address">
        /// [In] Address to stop on. This address must be suitably aligned to match the Size
        /// parameter (example: if Size is 4, Address must be a multiple of 4).
        /// </param>
        /// <param name="Access">
        /// [In] Mask of reasons why the data breakpoint should fire. For example, if 'Write'
        /// is set, then the breakpoint will fire when the memory location is written.
        /// </param>
        /// <param name="Size">
        /// [In] Specifies the size of the location, in bytes, to monitor for access. On an
        /// x86-based processor, this parameter can be 1, 2, or 4. However, if Access is
        /// DkmDataAccessStopMask.Execute, Size must be 1. On an x64-based processor, this
        /// parameter can be 1, 2, 4, or 8. However, if Access equals Access is
        /// DkmDataAccessStopMask.Execute, Size must be 1. On an Itanium-based processor,
        /// this parameter can be any power of 2, from 1 to 0x80000000.
        /// </param>
        /// <param name="DataItem">
        /// [In] Data object to add to the new DkmRuntimeHardwareDataBreakpoint instance.
        /// DkmDataItem::Null() in the case that the caller doesn't need to add a data item.
        /// </param>
        /// <param name="ppCreatedObject">
        /// [Out] Result of this method call.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ DkmRuntimeInstance* pRuntimeInstance,
            _In_ const GUID& SourceId,
            _In_opt_ DkmThread* pThread,
            _In_ UINT64 Address,
            _In_ Breakpoints::DkmDataAccessStopMask_t Access,
            _In_ UINT32 Size,
            _In_ const DkmDataItem& DataItem,
            _Deref_out_ Breakpoints::DkmRuntimeHardwareDataBreakpoint** ppCreatedObject
            );
    }; // end of DkmRuntimeHardwareDataBreakpoint

    // Low-level breakpoint which is set on an instruction address.
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("4c0b1e65-9d9c-2a4b-9ea0-8b9ead27ca39") DkmRuntimeInstructionBreakpoint : public Breakpoints::DkmRuntimeBreakpoint
    {
        // Use DkmRuntimeInstructionBreakpoint::Create to create this object
        private: DkmRuntimeInstructionBreakpoint();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmRuntimeInstructionBreakpoint();
        // This object cannot be copied
        private: DkmRuntimeInstructionBreakpoint& operator=(const DkmRuntimeInstructionBreakpoint&);
        private: DkmRuntimeInstructionBreakpoint(const DkmRuntimeInstructionBreakpoint&);

        private: DkmInstructionAddress* const m_pInstructionAddress;
        private: const bool m_IsBarrier;
        private: void* m__pExtendedData;

        // Abstract representation of an executable code location (ex: EIP value). If
        // resolved, an Instruction Address will be within a particular module instance. An
        // Instruction Address is always within a particular Runtime Instance.
        public: _Ret_ DECLSPEC_NOTHROW DkmInstructionAddress* STDMETHODCALLTYPE InstructionAddress(
            );

        // Indicates if this instruction breakpoint works as a barrier, used in GPU debugging
        // scenarios.
        public: DECLSPEC_NOTHROW bool STDMETHODCALLTYPE IsBarrier(
            );

        // Attempt to cast a 'DkmRuntimeBreakpoint' to a 'DkmRuntimeInstructionBreakpoint'. Return
        // NULL if the path object is not a 'DkmRuntimeInstructionBreakpoint'.
        // pInstructionBreakpoint : [In,Optional] Object to attempt to cast
        // Return Value : [Optional] Result of the cast.
        public: static DECLSPEC_NOTHROW DkmRuntimeInstructionBreakpoint* TryCast(
            DkmRuntimeBreakpoint* pRuntimeBreakpoint
            )
        {
            if (pRuntimeBreakpoint == NULL || pRuntimeBreakpoint->TagValue() != Tag::InstructionBreakpoint)
                return NULL;

            return static_cast<DkmRuntimeInstructionBreakpoint*>(pRuntimeBreakpoint);
        }

        /// <summary>
        /// Creates a new DkmRuntimeInstructionBreakpoint object. After creation, the
        /// breakpoint is in the disabled state, and must be explicitly enabled. The caller
        /// is responsible for closing the created object after they are done.
        /// </summary>
        /// <param name="SourceId">
        /// [In] Identifies the source of an object. SourceIds are used to enable filtering
        /// in scenarios when multiple components may be creating instances of a class. For
        /// example, source ids can be used to determine if a breakpoint comes from the AD7
        /// AL (ex: user breakpoint, or other breakpoint visible at the SDM level) instead of
        /// a breakpoint which may be created by another component (for example an internal
        /// breakpoint used for stepping).
        /// </param>
        /// <param name="pThread">
        /// [In,Optional] Thread on which this breakpoint should fire. If null, the
        /// breakpoint will fire on all threads.
        /// </param>
        /// <param name="pInstructionAddress">
        /// [In] Abstract representation of an executable code location (ex: EIP value). If
        /// resolved, an Instruction Address will be within a particular module instance. An
        /// Instruction Address is always within a particular Runtime Instance.
        /// </param>
        /// <param name="IsBarrier">
        /// [In] Indicates if this instruction breakpoint works as a barrier, used in GPU
        /// debugging scenarios.
        /// </param>
        /// <param name="DataItem">
        /// [In] Data object to add to the new DkmRuntimeInstructionBreakpoint instance.
        /// DkmDataItem::Null() in the case that the caller doesn't need to add a data item.
        /// </param>
        /// <param name="ppCreatedObject">
        /// [Out] Result of this method call.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ const GUID& SourceId,
            _In_opt_ DkmThread* pThread,
            _In_ DkmInstructionAddress* pInstructionAddress,
            _In_ bool IsBarrier,
            _In_ const DkmDataItem& DataItem,
            _Deref_out_ Breakpoints::DkmRuntimeInstructionBreakpoint** ppCreatedObject
            );

        /// <summary>
        /// This sets an associated compiled condition on the specified runtime instruction
        /// breakpoint. The breakpoint condition processor will then test the condition
        /// whenever it is hit. This is used for languages which are evaluated in the IDE
        /// process (ex: C++).
        /// </summary>
        /// <param name="pCompiledCondition">
        /// [In] Compiled query used to evaluate the condition.
        /// </param>
        /// <param name="ConditionOperator">
        /// [In] Operator to use when evaluating the condition.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE SetCompiledCondition(
            _In_ Evaluation::DkmCompiledInspectionQuery* pCompiledCondition,
            _In_ Breakpoints::DkmBreakpointConditionOperator_t ConditionOperator
            );

        /// <summary>
        /// This sets an associated compiled condition on the specified runtime instruction
        /// breakpoint. The breakpoint condition processor will then test the condition
        /// whenever it is hit. This is used for languages which are evaluated in the IDE
        /// process (ex: C++).
        ///
        /// This method will append a new work item to the specified work list, and return
        /// once the work item has been appended. The actual processing of the work item is
        /// asynchronous. The caller will be notified that the request is complete through
        /// the completion routine.
        /// </summary>
        /// <param name="pWorkList">
        /// WorkList to append the new work item to.
        /// </param>
        /// <param name="pCompiledCondition">
        /// [In] Compiled query used to evaluate the condition.
        /// </param>
        /// <param name="ConditionOperator">
        /// [In] Operator to use when evaluating the condition.
        /// </param>
        /// <param name="pCompletionRoutine">
        /// Routine to fire when the request is complete. If the request is successfully
        /// appended to the work list, this will always fire (including when the operation is
        /// canceled). This will never fire if appending the work item fails.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE SetCompiledCondition(
            _In_ DkmWorkList* pWorkList,
            _In_ Evaluation::DkmCompiledInspectionQuery* pCompiledCondition,
            _In_ Breakpoints::DkmBreakpointConditionOperator_t ConditionOperator,
            _In_ IDkmCompletionRoutine<Breakpoints::DkmSetCompiledConditionAsyncResult>* pCompletionRoutine
            );

        /// <summary>
        /// This tries to push the associated condition on the specified runtime instruction
        /// breakpoint to the target. This is useful for GPU debugging since testing the
        /// condition on the target (GPU hardware or VSD3D ref) is much more efficient than
        /// doing it in the debugger. Once this method succeeds, breakpoint event will only
        /// be received by the debugger when the condition tests to be true on the debuggee;
        /// if it fails, the debugger can still test the condition.
        /// </summary>
        /// <param name="pCompiledCondition">
        /// [In] Compiled query used to evaluate the condition.
        /// </param>
        /// <param name="ConditionOperator">
        /// [In] Operator to use when evaluating the condition.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE TryPushConditionToTargetDevice(
            _In_ Evaluation::DkmCompiledInspectionQuery* pCompiledCondition,
            _In_ Breakpoints::DkmBreakpointConditionOperator_t ConditionOperator
            );

        /// <summary>
        /// This tries to push the associated condition on the specified runtime instruction
        /// breakpoint to the target. This is useful for GPU debugging since testing the
        /// condition on the target (GPU hardware or VSD3D ref) is much more efficient than
        /// doing it in the debugger. Once this method succeeds, breakpoint event will only
        /// be received by the debugger when the condition tests to be true on the debuggee;
        /// if it fails, the debugger can still test the condition.
        ///
        /// This method will append a new work item to the specified work list, and return
        /// once the work item has been appended. The actual processing of the work item is
        /// asynchronous. The caller will be notified that the request is complete through
        /// the completion routine.
        /// </summary>
        /// <param name="pWorkList">
        /// WorkList to append the new work item to.
        /// </param>
        /// <param name="pCompiledCondition">
        /// [In] Compiled query used to evaluate the condition.
        /// </param>
        /// <param name="ConditionOperator">
        /// [In] Operator to use when evaluating the condition.
        /// </param>
        /// <param name="pCompletionRoutine">
        /// Routine to fire when the request is complete. If the request is successfully
        /// appended to the work list, this will always fire (including when the operation is
        /// canceled). This will never fire if appending the work item fails.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE TryPushConditionToTargetDevice(
            _In_ DkmWorkList* pWorkList,
            _In_ Evaluation::DkmCompiledInspectionQuery* pCompiledCondition,
            _In_ Breakpoints::DkmBreakpointConditionOperator_t ConditionOperator,
            _In_ IDkmCompletionRoutine<Breakpoints::DkmTryPushConditionToTargetDeviceAsyncResult>* pCompletionRoutine
            );

        /// <summary>
        /// Clear any condition associated with the specified
        /// DkmRuntimeInstructionBreakpoint.
        /// </summary>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE TryClearConditionOnTargetDevice(
            );

        /// <summary>
        /// Clear any condition associated with the specified
        /// DkmRuntimeInstructionBreakpoint.
        ///
        /// This method will append a new work item to the specified work list, and return
        /// once the work item has been appended. The actual processing of the work item is
        /// asynchronous. The caller will be notified that the request is complete through
        /// the completion routine.
        /// </summary>
        /// <param name="pWorkList">
        /// WorkList to append the new work item to.
        /// </param>
        /// <param name="pCompletionRoutine">
        /// Routine to fire when the request is complete. If the request is successfully
        /// appended to the work list, this will always fire (including when the operation is
        /// canceled). This will never fire if appending the work item fails.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE TryClearConditionOnTargetDevice(
            _In_ DkmWorkList* pWorkList,
            _In_ IDkmCompletionRoutine<Breakpoints::DkmTryClearConditionOnTargetDeviceAsyncResult>* pCompletionRoutine
            );
    }; // end of DkmRuntimeInstructionBreakpoint

}; // end namespace Breakpoints

// Contains the types used to implement setting in the debugger.
namespace Stepping {
    // Flags which describe how to proceed with a Step-Into action.
    DEFINE_SCOPED_ENUM(DkmLanguageStepIntoFlags)
    {
        // The function stepping should not deviate from default.
        None = 0x0,
        // The function should not be stepped into.
        NoStepInto = 0x1
    };
    DEFINE_SCOPED_ENUM_FLAG_OPERATORS(DkmLanguageStepIntoFlags_t);

    // DkmNativeSteppingCallSite specifies a call instruction and it's target..
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("49b7610c-d229-e123-9f3a-b00df2ef4c24") DkmNativeSteppingCallSite : public IUnknown
    {
        private: ___ReferenceCount_t m_ReferenceCount;
        private: DkmDispatcherObjectFlags_t m_ObjectFlags;
        private: const GUID* m_pTypeId;
        private: size_t m_ObjectGCHandle;
        // Use DkmNativeSteppingCallSite::Create to create this object
        private: DkmNativeSteppingCallSite();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmNativeSteppingCallSite();
        // This object cannot be copied
        private: DkmNativeSteppingCallSite& operator=(const DkmNativeSteppingCallSite&);
        private: DkmNativeSteppingCallSite(const DkmNativeSteppingCallSite&);

        private: Native::DkmNativeInstructionAddress* const m_pCallSite;
        private: OPTIONAL Native::DkmNativeInstructionAddress* const m_pCallTarget;
        private: OPTIONAL Native::DkmNativeInstructionAddress* const m_pCallTargetAddress;
        private: void* m__pExtendedData;

        // The address of the call instruction.
        public: _Ret_ DECLSPEC_NOTHROW Native::DkmNativeInstructionAddress* STDMETHODCALLTYPE CallSite(
            );

        // [Optional] The address of the instruction that would be called by the call
        // instruction.
        public: _Ret_opt_ DECLSPEC_NOTHROW Native::DkmNativeInstructionAddress* STDMETHODCALLTYPE CallTarget(
            );

        // [Optional] For indirect calls only, the address being dereferenced by the call
        // instruction.
        public: _Ret_opt_ DECLSPEC_NOTHROW Native::DkmNativeInstructionAddress* STDMETHODCALLTYPE CallTargetAddress(
            );

        /// <summary>
        /// Create a new DkmNativeSteppingCallSite object instance.
        /// </summary>
        /// <param name="pCallSite">
        /// [In] The address of the call instruction.
        /// </param>
        /// <param name="pCallTarget">
        /// [In,Optional] The address of the instruction that would be called by the call
        /// instruction.
        /// </param>
        /// <param name="pCallTargetAddress">
        /// [In,Optional] For indirect calls only, the address being dereferenced by the call
        /// instruction.
        /// </param>
        /// <param name="ppCreatedObject">
        /// [Out] Result of this method call.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ Native::DkmNativeInstructionAddress* pCallSite,
            _In_opt_ Native::DkmNativeInstructionAddress* pCallTarget,
            _In_opt_ Native::DkmNativeInstructionAddress* pCallTargetAddress,
            _Deref_out_ Stepping::DkmNativeSteppingCallSite** ppCreatedObject
            );
    }; // end of DkmNativeSteppingCallSite

    // DkmSingleStepRequest represents a request to single step a thread.
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("15ec2b6b-561d-93d3-f7b4-50fba4cb8bb5") DkmSingleStepRequest : public IUnknown
    {
        private: ___ReferenceCount_t m_ReferenceCount;
        private: DkmDispatcherObjectFlags_t m_ObjectFlags;
        private: const GUID* m_pTypeId;
        private: size_t m_ObjectGCHandle;
        // Use DkmSingleStepRequest::Create to create this object
        private: DkmSingleStepRequest();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmSingleStepRequest();
        // This object cannot be copied
        private: DkmSingleStepRequest& operator=(const DkmSingleStepRequest&);
        private: DkmSingleStepRequest(const DkmSingleStepRequest&);

        private: const GUID m_SourceId;
        private: DkmThread* const m_pThread;
        private: void* m__pExtendedData;

        // Identifies the source of an object. SourceIds are used to enable filtering in
        // scenarios when multiple components may be creating instances of a class. For
        // example, source ids can be used to determine if a breakpoint comes from the AD7 AL
        // (ex: user breakpoint, or other breakpoint visible at the SDM level) instead of a
        // breakpoint which may be created by another component (for example an internal
        // breakpoint used for stepping).
        public: DECLSPEC_NOTHROW const GUID& STDMETHODCALLTYPE SourceId(
            );

        // DkmThread represents a thread running in the target process.
        public: _Ret_ DECLSPEC_NOTHROW DkmThread* STDMETHODCALLTYPE Thread(
            );

        /// <summary>
        /// Create a new DkmSingleStepRequest object instance.
        /// </summary>
        /// <param name="SourceId">
        /// [In] Identifies the source of an object. SourceIds are used to enable filtering
        /// in scenarios when multiple components may be creating instances of a class. For
        /// example, source ids can be used to determine if a breakpoint comes from the AD7
        /// AL (ex: user breakpoint, or other breakpoint visible at the SDM level) instead of
        /// a breakpoint which may be created by another component (for example an internal
        /// breakpoint used for stepping).
        /// </param>
        /// <param name="pThread">
        /// [In] DkmThread represents a thread running in the target process.
        /// </param>
        /// <param name="ppCreatedObject">
        /// [Out] Result of this method call.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ const GUID& SourceId,
            _In_ DkmThread* pThread,
            _Deref_out_ Stepping::DkmSingleStepRequest** ppCreatedObject
            );

        /// <summary>
        /// Raise a GPUSingleStepComplete event. Components which implement the event sync
        /// interface will receive the event notification. This method will enqueue the event
        /// and control will immediately return to the caller.
        /// </summary>
        /// <param name="pThread">
        /// [In] DkmThread represents a thread running in the target process.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE OnGPUSingleStepComplete(
            _In_ DkmThread* pThread
            );

        /// <summary>
        /// Enable temporary breakpoint in stepping on a thread. This is similar to single
        /// step except one or more instructions are advanced. When breakpoint is hit, step
        /// complete event is sent.
        /// </summary>
        /// <param name="TempBreakInstructions">
        /// [In] The instruction offset of temporary breakpoints to set.
        ///
        /// The memory for the DkmArray members is allocated by the caller, and can be from
        /// any source (stack memory, static buffer, heap, etc). The implementation should
        /// not modify the members.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE EnableTempBreak(
            _In_ const DkmArray<UINT64>& TempBreakInstructions
            );

        /// <summary>
        /// Clear temporary breakpoint in stepping on a thread.
        /// </summary>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ClearTempBreak(
            );

        /// <summary>
        /// Enable single step on a thread. When then single step completes, the
        /// SingleStepComplete event should be sent. The single step should reset after
        /// completion.  Implementers should send one single step complete event per instance
        /// of DkmSingleStepRequest they receive. Callers must make a new request to
        /// single-step after this DkmSingleStepRequest is complete.
        /// </summary>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE EnableSingleStep(
            );

        /// <summary>
        /// Disable single step on a thread.
        /// </summary>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ClearSingleStep(
            );

        /// <summary>
        /// Raise a SingleStepComplete event. Components which implement the event sync
        /// interface will receive the event notification. This method will enqueue the event
        /// and control will immediately return to the caller.
        /// </summary>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE OnSingleStepComplete(
            );
    }; // end of DkmSingleStepRequest

    // DkmStepArbitrationReason the reason step arbitration is occurring.
    DEFINE_SCOPED_ENUM(DkmStepArbitrationReason)
    {
        // The stepping manager is looking for a runtime to start a new step.
        NewStep = 0,
        // The instruction pointer has landed in a location not in a known DkmModuleInstance.
        UnknownModule = 1,
        // The instruction pointer has landed in a location in a known DkmModuleInstance with
        // no symbols.
        NoSymbols = 2,
        // The instruction pointer has landed in a location within a DkmModuleInstance marked
        // as a transition module.
        TransitionModule = 3,
        // The current runtime instance has just finished stepping through a known exit from
        // its runtime. The instruction pointer should be on the first instruction of the
        // next runtime's entry point.
        ExitRuntime = 4,
        // Another runtime instance has detected that the instruction pointer has hit an
        // entry point into its runtime. This is only used after a call to
        // StepControlRequested that return true.
        EnterRuntime = 5,
        // The instruction pointer has landed at a location in a known module but with no
        // source info.
        NoSource = 6,
        // An exception unwind was in flight and a handler was found. If a runtime's
        // exception model can be used by other runtimes, stepping arbitration should be
        // performed. For instance, CLR exceptions use native SEH exceptions. So, during a
        // managed step, if an exception is thrown and a handler is found, native will
        // receive its handler found notification. However, native should not take control of
        // that step. Managed should listen for stepping arbitration with
        // ExceptionHandlerFound as its reason and finish stepping to the managed catch
        // block.
        ExceptionHandlerFound = 7,
        // Used by the stepping manager to override a line or statement step with an
        // instruction level step. This is only passed to the native runtime instance if no
        // controlling runtime instance was found during initial stepping arbitration.
        InstructionLevelOverride = 8,
        // A runtime instance asked for stepping arbitration for an unknown reason.
        Unknown = 9,
        // A runtime instance that understands the async pattern has taken control of the
        // step. The step will complete asynchronously on another thread. Steppers should
        // clear all step state to allow for that.
        AsyncStep = 10
    };

    // DkmStepKind describes how to step the thread when the Step Method is called.
    DEFINE_SCOPED_ENUM(DkmStepKind)
    {
        // Step the thread into calls.
        Into = 0,
        // Step the thread over calls.
        Over = 1,
        // Step the thread out of the current frame.
        Out = 2,
        // Step into specific request.
        StepIntoSpecific = 3
    };

    // DkmStepUnit describes the granularity of the step when the Step method is called.
    DEFINE_SCOPED_ENUM(DkmStepUnit)
    {
        // Step the thread to the next statement.
        Statement = 0,
        // Step the thread to the next line.
        Line = 1,
        // Step the thread to the next instruction.
        Instruction = 2
    };

    // DkmStepper represents a request to step a thread. It facilitates shared object
    // lifetime between the various runtime debug monitors that participate in stepping.
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("2aae9764-33a3-8fc7-22ff-e27c9de91bda") DkmStepper : public DkmDataContainer
    {
        // Use DkmStepper::Create to create this object
        private: DkmStepper();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmStepper();
        // This object cannot be copied
        private: DkmStepper& operator=(const DkmStepper&);
        private: DkmStepper(const DkmStepper&);

        // Contains additional fields of DkmStepper which were added after the class was
        // initally introduced.
        private: struct ___ExtendedData
        {
            ___ExtendedData();

            // In managed debugging, it indicates if the stepper wanted to capture return
            // value during stepping. Default it is false.
            const bool ShouldCaptureReturnValue;

            // [Optional] In managed debugging, it contains all code paths in current step
            // range. Otherwise it is NULL.
            OPTIONAL DkmReadOnlyCollection<Stepping::DkmSteppingCodePath*>* const pCurrentCodePaths;

            // [Optional] In managed debugging, it contains current method name. Otherwise it
            // is NULL.
            OPTIONAL DkmString* const pCurrentMethodName;
        };

        private: const GUID m_UniqueId;
        private: DkmThread* const m_pThread;
        private: OPTIONAL DkmInstructionAddress* const m_pStartingAddress;
        private: const UINT64 m_FrameBase;
        private: const Stepping::DkmStepKind_t m_StepKind;
        private: const Stepping::DkmStepUnit_t m_StepUnit;
        private: const GUID m_SourceId;
        private: OPTIONAL Stepping::DkmSteppingCodePath* const m_pCodePath;
        private: OPTIONAL Stepping::DkmStepper* const m_pCrossThreadParent;
        private: ___ExtendedData* const m__pExtendedData;

        // Guid which uniquely identifies this DkmStepper.
        public: DECLSPEC_NOTHROW const GUID& STDMETHODCALLTYPE UniqueId(
            );

        // DkmThread represents a thread running in the target process.
        public: _Ret_ DECLSPEC_NOTHROW DkmThread* STDMETHODCALLTYPE Thread(
            );

        // [Optional] The instruction address of the process at the time this step started.
        // This will be NULL if the step originated on a thread with no frames (Script &
        // Managed Only).
        public: _Ret_opt_ DECLSPEC_NOTHROW DkmInstructionAddress* STDMETHODCALLTYPE StartingAddress(
            );

        // The frame base of the first frame at the beginning of the step. This value will be
        // MAXUINT64 if the StartingAddress was not specified.
        public: DECLSPEC_NOTHROW UINT64 STDMETHODCALLTYPE FrameBase(
            );

        // DkmStepKind describes how to step the thread when the Step Method is called.
        public: DECLSPEC_NOTHROW Stepping::DkmStepKind_t STDMETHODCALLTYPE StepKind(
            );

        // DkmStepUnit describes the granularity of the step when the Step method is called.
        public: DECLSPEC_NOTHROW Stepping::DkmStepUnit_t STDMETHODCALLTYPE StepUnit(
            );

        // Identifies the source of an object. SourceIds are used to enable filtering in
        // scenarios when multiple components may be creating instances of a class. For
        // example, source ids can be used to determine if a breakpoint comes from the AD7 AL
        // (ex: user breakpoint, or other breakpoint visible at the SDM level) instead of a
        // breakpoint which may be created by another component (for example an internal
        // breakpoint used for stepping).
        public: DECLSPEC_NOTHROW const GUID& STDMETHODCALLTYPE SourceId(
            );

        // [Optional] If StepKind is StepIntoSpecific, specifies which call we are stepping
        // into. Otherwise it is NULL.
        public: _Ret_opt_ DECLSPEC_NOTHROW Stepping::DkmSteppingCodePath* STDMETHODCALLTYPE CodePath(
            );

        // [Optional] If a new stepper is created using OnCrossThreadStepArbitration, the
        // stepping manager will set this field to make is easy to get back to the original
        // stepper if the cross thread step fails or needs to fallback.
        public: _Ret_opt_ DECLSPEC_NOTHROW Stepping::DkmStepper* STDMETHODCALLTYPE CrossThreadParent(
            );

        // In managed debugging, it indicates if the stepper wanted to capture return value
        // during stepping. Default it is false.
        //
        // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
        public: DECLSPEC_NOTHROW bool STDMETHODCALLTYPE ShouldCaptureReturnValue(
            );

        // [Optional] In managed debugging, it contains all code paths in current step range.
        // Otherwise it is NULL.
        //
        // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
        public: _Ret_opt_ DECLSPEC_NOTHROW DkmReadOnlyCollection<Stepping::DkmSteppingCodePath*>* STDMETHODCALLTYPE CurrentCodePaths(
            );

        // [Optional] In managed debugging, it contains current method name. Otherwise it is
        // NULL.
        //
        // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
        public: _Ret_opt_ DECLSPEC_NOTHROW DkmString* STDMETHODCALLTYPE CurrentMethodName(
            );

        /// <summary>
        /// Closes the stepper object. This should be closed by components when the stepper
        /// is done, such as when a step complete event is suppressed, or if the stepper
        /// fails to initialize. Steppers will be implicitly closed if their thread exits, or
        /// the debugger is stopped. They will be closed by the stepping manager if a
        /// different user-level execution request is issued.
        ///
        /// DkmStepper objects are automatically closed when their associated DkmThread
        /// object is closed.
        /// </summary>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Close(
            );

        /// <summary>
        /// DkmStepper objects are created by components that wish to issue a step.
        /// User-level steppers are created by the AD7-AL. To initialize a stepper object,
        /// Enable must be called. Stepper objects will live until the step completes, or is
        /// aborted.
        /// </summary>
        /// <param name="pThread">
        /// [In] DkmThread represents a thread running in the target process.
        /// </param>
        /// <param name="pStartingAddress">
        /// [In,Optional] The instruction address of the process at the time this step
        /// started. This will be NULL if the step originated on a thread with no frames
        /// (Script &amp; Managed Only).
        /// </param>
        /// <param name="FrameBase">
        /// [In] The frame base of the first frame at the beginning of the step. This value
        /// will be MAXUINT64 if the StartingAddress was not specified.
        /// </param>
        /// <param name="StepKind">
        /// [In] DkmStepKind describes how to step the thread when the Step Method is called.
        /// </param>
        /// <param name="StepUnit">
        /// [In] DkmStepUnit describes the granularity of the step when the Step method is
        /// called.
        /// </param>
        /// <param name="SourceId">
        /// [In] Identifies the source of an object. SourceIds are used to enable filtering
        /// in scenarios when multiple components may be creating instances of a class. For
        /// example, source ids can be used to determine if a breakpoint comes from the AD7
        /// AL (ex: user breakpoint, or other breakpoint visible at the SDM level) instead of
        /// a breakpoint which may be created by another component (for example an internal
        /// breakpoint used for stepping).
        /// </param>
        /// <param name="pCodePath">
        /// [In,Optional] If StepKind is StepIntoSpecific, specifies which call we are
        /// stepping into. Otherwise it is NULL.
        /// </param>
        /// <param name="pCrossThreadParent">
        /// [In,Optional] If a new stepper is created using OnCrossThreadStepArbitration, the
        /// stepping manager will set this field to make is easy to get back to the original
        /// stepper if the cross thread step fails or needs to fallback.
        /// </param>
        /// <param name="DataItem">
        /// [In] Data object to add to the new DkmStepper instance. DkmDataItem::Null() in
        /// the case that the caller doesn't need to add a data item.
        /// </param>
        /// <param name="ppCreatedObject">
        /// [Out] Result of this method call.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ DkmThread* pThread,
            _In_opt_ DkmInstructionAddress* pStartingAddress,
            _In_ UINT64 FrameBase,
            _In_ Stepping::DkmStepKind_t StepKind,
            _In_ Stepping::DkmStepUnit_t StepUnit,
            _In_ const GUID& SourceId,
            _In_opt_ Stepping::DkmSteppingCodePath* pCodePath,
            _In_opt_ Stepping::DkmStepper* pCrossThreadParent,
            _In_ const DkmDataItem& DataItem,
            _Deref_out_ Stepping::DkmStepper** ppCreatedObject
            );

        /// <summary>
        /// DkmStepper objects are created by components that wish to issue a step.
        /// User-level steppers are created by the AD7-AL. To initialize a stepper object,
        /// Enable must be called. Stepper objects will live until the step completes, or is
        /// aborted.
        ///
        /// This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
        /// </summary>
        /// <param name="pThread">
        /// [In] DkmThread represents a thread running in the target process.
        /// </param>
        /// <param name="pStartingAddress">
        /// [In,Optional] The instruction address of the process at the time this step
        /// started. This will be NULL if the step originated on a thread with no frames
        /// (Script &amp; Managed Only).
        /// </param>
        /// <param name="FrameBase">
        /// [In] The frame base of the first frame at the beginning of the step. This value
        /// will be MAXUINT64 if the StartingAddress was not specified.
        /// </param>
        /// <param name="StepKind">
        /// [In] DkmStepKind describes how to step the thread when the Step Method is called.
        /// </param>
        /// <param name="StepUnit">
        /// [In] DkmStepUnit describes the granularity of the step when the Step method is
        /// called.
        /// </param>
        /// <param name="SourceId">
        /// [In] Identifies the source of an object. SourceIds are used to enable filtering
        /// in scenarios when multiple components may be creating instances of a class. For
        /// example, source ids can be used to determine if a breakpoint comes from the AD7
        /// AL (ex: user breakpoint, or other breakpoint visible at the SDM level) instead of
        /// a breakpoint which may be created by another component (for example an internal
        /// breakpoint used for stepping).
        /// </param>
        /// <param name="pCodePath">
        /// [In,Optional] If StepKind is StepIntoSpecific, specifies which call we are
        /// stepping into. Otherwise it is NULL.
        /// </param>
        /// <param name="pCrossThreadParent">
        /// [In,Optional] If a new stepper is created using OnCrossThreadStepArbitration, the
        /// stepping manager will set this field to make is easy to get back to the original
        /// stepper if the cross thread step fails or needs to fallback.
        /// </param>
        /// <param name="ShouldCaptureReturnValue">
        /// [In] In managed debugging, it indicates if the stepper wanted to capture return
        /// value during stepping. Default it is false.
        /// </param>
        /// <param name="pCurrentCodePaths">
        /// [In,Optional] In managed debugging, it contains all code paths in current step
        /// range. Otherwise it is NULL.
        /// </param>
        /// <param name="pCurrentMethodName">
        /// [In,Optional] In managed debugging, it contains current method name. Otherwise it
        /// is NULL.
        /// </param>
        /// <param name="DataItem">
        /// [In] Data object to add to the new DkmStepper instance. DkmDataItem::Null() in
        /// the case that the caller doesn't need to add a data item.
        /// </param>
        /// <param name="ppCreatedObject">
        /// [Out] Result of this method call.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ DkmThread* pThread,
            _In_opt_ DkmInstructionAddress* pStartingAddress,
            _In_ UINT64 FrameBase,
            _In_ Stepping::DkmStepKind_t StepKind,
            _In_ Stepping::DkmStepUnit_t StepUnit,
            _In_ const GUID& SourceId,
            _In_opt_ Stepping::DkmSteppingCodePath* pCodePath,
            _In_opt_ Stepping::DkmStepper* pCrossThreadParent,
            _In_ bool ShouldCaptureReturnValue,
            _In_opt_ DkmReadOnlyCollection<Stepping::DkmSteppingCodePath*>* pCurrentCodePaths,
            _In_opt_ DkmString* pCurrentMethodName,
            _In_ const DkmDataItem& DataItem,
            _Deref_out_ Stepping::DkmStepper** ppCreatedObject
            );

        #ifndef EXCLUDE_MONITOR_ONLY_APIS
        /// <summary>
        /// Called by the stopping event manager before a step operation actually begins The
        /// stopping event manager will notify all runtime instances so they can setup any
        /// necessary state before the the stopping event manager starts blocking function
        /// evaluations.
        ///
        /// Location constraint: API must be called from a Monitor component (component level
        /// &lt; 100,000).
        /// </summary>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE BeforeEnable(
            );
        #endif // #ifndef EXCLUDE_MONITOR_ONLY_APIS

        #ifndef EXCLUDE_MONITOR_ONLY_APIS
        /// <summary>
        /// Used to initialize a stepper object so that the step will be performed when
        /// execution is next resumed. This method is implemented by the stepping manager by
        /// finding an appropriate runtime debug monitor, and asking this runtime debug
        /// monitor to setup a step. This method should only be called once for a given
        /// stepper object.
        ///
        /// Location constraint: API must be called from a Monitor component (component level
        /// &lt; 100,000).
        /// </summary>
        /// <param name="RemoveOtherSteppers">
        /// [In] Set to true if other steppers are to be removed. This is normally only set
        /// in response to user initiated step requests.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Enable(
            _In_ bool RemoveOtherSteppers
            );
        #endif // #ifndef EXCLUDE_MONITOR_ONLY_APIS

        #ifndef EXCLUDE_MONITOR_ONLY_APIS
        /// <summary>
        /// Allows a stepper to be cancelled after creation by the controlling runtime
        /// instance. The calling runtime instance must match the current controlling runtime
        /// instance. This is generally used in cross thread stepping scenarios where the
        /// original stepper may be reactivated. The stepping manager will close the stepper
        /// and not send step complete.
        ///
        /// Location constraint: API must be called from a Monitor component (component level
        /// &lt; 100,000).
        /// </summary>
        /// <param name="pCallingRuntimeInstance">
        /// [In] The calling runtime instance that wishes to take control of the step.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE CancelStepper(
            _In_ DkmRuntimeInstance* pCallingRuntimeInstance
            );
        #endif // #ifndef EXCLUDE_MONITOR_ONLY_APIS

        #ifndef EXCLUDE_MONITOR_ONLY_APIS
        /// <summary>
        /// Returns the runtime instance currently in-control of this DkmStepper.
        ///
        /// Location constraint: API must be called from a Monitor component (component level
        /// &lt; 100,000).
        /// </summary>
        /// <param name="ppRuntimeInstance">
        /// [Out] The runtime instance currently in control of this stepper.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetControllingRuntimeInstance(
            _Deref_out_ DkmRuntimeInstance** ppRuntimeInstance
            );
        #endif // #ifndef EXCLUDE_MONITOR_ONLY_APIS

        #ifndef EXCLUDE_MONITOR_ONLY_APIS
        /// <summary>
        /// StepControlRequested is called when a non-controlling runtime instance detects
        /// that the thread has hit a transition into its runtime. The stepping manager will
        /// forward the call to the current controlling runtime instance. If the current
        /// controlling runtime instance can stop stepping, it should set Granted to true.
        /// Actual control is not given until the requesting runtime calls
        /// DkmStepper.TakeStepControl. This two part process allows callers to request
        /// control of multiple steppers at the same time.
        ///
        /// Location constraint: API must be called from a Monitor component (component level
        /// &lt; 100,000).
        /// </summary>
        /// <param name="Reason">
        /// [In] DkmStepArbitrationReason the reason step arbitration is occurring.
        /// </param>
        /// <param name="pCallingRuntimeInstance">
        /// [In] The calling runtime instance that wishes to take control of the step.
        /// </param>
        /// <param name="pGranted">
        /// [Out] The the controlling runtime can stop the step and give control to the
        /// caller, then it should set this to true.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE StepControlRequested(
            _In_ Stepping::DkmStepArbitrationReason_t Reason,
            _In_ DkmRuntimeInstance* pCallingRuntimeInstance,
            _Out_ bool* pGranted
            );
        #endif // #ifndef EXCLUDE_MONITOR_ONLY_APIS

        #ifndef EXCLUDE_MONITOR_ONLY_APIS
        /// <summary>
        /// TakeStepControl is called when a non-controlling runtime instance detects that
        /// the thread has hit a transition into its runtime. The stepping manager will
        /// forward the call to the current controlling runtime instance. The runtime
        /// instance requesting control should first call StepControlRequested on all
        /// steppers it wants control of. If they all set Granted to true, the runtime
        /// instance should then call this method on each stepper it is taking control of.
        ///
        /// Location constraint: API must be called from a Monitor component (component level
        /// &lt; 100,000).
        /// </summary>
        /// <param name="LeaveGuardsInPlace">
        /// [In] Set to true by the caller if it would like the current controlling runtime
        /// instance to leave guards in place to stop the step if necessary. For instance,
        /// this can be used to leave guard breakpoints after a call instruction so another
        /// runtime can step back out if the target of the call doesn't have source. However,
        /// any stepping state that affects the immediate step, such as trap flags, should be
        /// removed by the controlling runtime instance.
        /// </param>
        /// <param name="Reason">
        /// [In] DkmStepArbitrationReason the reason step arbitration is occurring.
        /// </param>
        /// <param name="pCallingRuntimeInstance">
        /// [In] The calling runtime instance that wishes to take control of the step.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE TakeStepControl(
            _In_ bool LeaveGuardsInPlace,
            _In_ Stepping::DkmStepArbitrationReason_t Reason,
            _In_ DkmRuntimeInstance* pCallingRuntimeInstance
            );
        #endif // #ifndef EXCLUDE_MONITOR_ONLY_APIS

        #ifndef EXCLUDE_MONITOR_ONLY_APIS
        /// <summary>
        /// Called by a runtime monitor when a step has left the confines of what the runtime
        /// monitor understands or a potential transition into another runtime has been
        /// encountered during a step. The stepping manager will initiate stepping
        /// arbitration to give each runtime monitor a chance to inspect the process and
        /// determine which runtime should complete the step. The runtimes are called in
        /// priority order. After this process is complete, the stepping manager will call
        /// AfterSteppingArbitration on the monitor that requested arbitration so it can
        /// respond to the new controlling monitor if one was found, or finish the step if
        /// one was not found.
        ///
        /// Location constraint: API must be called from a Monitor component (component level
        /// &lt; 100,000).
        /// </summary>
        /// <param name="Reason">
        /// [In] DkmStepArbitrationReason the reason step arbitration is occurring.
        /// </param>
        /// <param name="pCurrentControllingRuntimeInstance">
        /// [In] The runtime instance requesting arbitration.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE OnStepArbitration(
            _In_ Stepping::DkmStepArbitrationReason_t Reason,
            _In_ DkmRuntimeInstance* pCurrentControllingRuntimeInstance
            );
        #endif // #ifndef EXCLUDE_MONITOR_ONLY_APIS

        #ifndef EXCLUDE_MONITOR_ONLY_APIS
        /// <summary>
        /// Called by a runtime monitor when a step is continuing on a different thread. The
        /// stepping manager will create a new DkmStepper to be used on the new thread and
        /// initiate stepping arbitration to determine which runtime should complete the step
        /// just as OnStepArbitration does. The new stepper uses the same step kind and step
        /// unit as the original stepper. A new starting instruction address must be given
        /// and is set as the stepper's starting address. The original stepper remains alive
        /// and when the new stepper completes the stepping manager will suppress the event
        /// and notify the original stepper of the completion.
        ///
        /// Location constraint: API must be called from a Monitor component (component level
        /// &lt; 100,000).
        /// </summary>
        /// <param name="Reason">
        /// [In] DkmStepArbitrationReason the reason step arbitration is occurring.
        /// </param>
        /// <param name="pCurrentControllingRuntimeInstance">
        /// [In] The runtime instance requesting arbitration.
        /// </param>
        /// <param name="pNewThread">
        /// [In] The thread on which to create the new stepper.
        /// </param>
        /// <param name="pNewStartingInstructionAddress">
        /// [In] Starting address of the new stepper.
        /// </param>
        /// <param name="ppNewStepper">
        /// [Out,Optional] The new stepper.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE OnCrossThreadStepArbitration(
            _In_ Stepping::DkmStepArbitrationReason_t Reason,
            _In_ DkmRuntimeInstance* pCurrentControllingRuntimeInstance,
            _In_ DkmThread* pNewThread,
            _In_ DkmInstructionAddress* pNewStartingInstructionAddress,
            _Deref_out_opt_ Stepping::DkmStepper** ppNewStepper
            );
        #endif // #ifndef EXCLUDE_MONITOR_ONLY_APIS

        /// <summary>
        /// Raise a ReturnValues event. Components which implement the event sync interface
        /// will receive the event notification. Control will return once all components have
        /// been notified.
        /// </summary>
        /// <param name="pReturnValues">
        /// [In,Optional] DkmRawReturnValues recorded.
        /// </param>
        /// <param name="LastValueInCurrentContext">
        /// [In] If true, it is valid to use the current thread context to evaluate the last
        /// return value.  This is true only in the case immediately after processing the
        /// return instruction, and so should only be set if raising this event immediately
        /// before, and on the same thread, as the StepComplete event.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE OnReturnValues(
            _In_opt_ DkmReadOnlyCollection<Evaluation::DkmRawReturnValue*>* pReturnValues,
            _In_ bool LastValueInCurrentContext
            );

        /// <summary>
        /// Raise a StepComplete event. Components which implement the event sync interface
        /// will receive the event notification. This method will enqueue the event and
        /// control will immediately return to the caller.
        /// </summary>
        /// <param name="pThread">
        /// [In] The thread the step actually finished on. Normally, this is the same as the
        /// thread in DkmStepper, but in some scenarios, it could be different.
        /// </param>
        /// <param name="HasException">
        /// [In] Contains true if the source runtime instance can determine that an exception
        /// is in flight on the stepping thread. Currently, only managed runtime instances
        /// ever set this. This is used to quickly determine if exception specific logic
        /// should apply without making another network round-trip.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE OnStepComplete(
            _In_ DkmThread* pThread,
            _In_ bool HasException
            );

        #ifndef EXCLUDE_MONITOR_ONLY_APIS
        /// <summary>
        /// Runtime monitors call this to set or clear a flag on the DkmStepper that can be
        /// used by cooperating runtimes to change the behavior of stepping if an exception
        /// is current in flight. Called by runtime monitors when an exception is encountered
        /// while stepping.
        ///
        /// Location constraint: API must be called from a Monitor component (component level
        /// &lt; 100,000).
        ///
        /// This API was introduced in Visual Studio 11 Update 1
        /// (DkmApiVersion.VS11FeaturePack1).
        /// </summary>
        /// <param name="Enable">
        /// [In] If true, the exception in flight flag is set. If false, it is cleared.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE SetExceptionInFlight(
            _In_ bool Enable
            );
        #endif // #ifndef EXCLUDE_MONITOR_ONLY_APIS

        #ifndef EXCLUDE_MONITOR_ONLY_APIS
        /// <summary>
        /// Gets the flag on the DkmStepper that states if a runtime monitor believes an
        /// exception is currently in flight during this step. This can be used by runtime
        /// monitors to change the behavior of stepping.
        ///
        /// Location constraint: API must be called from a Monitor component (component level
        /// &lt; 100,000).
        ///
        /// This API was introduced in Visual Studio 11 Update 1
        /// (DkmApiVersion.VS11FeaturePack1).
        /// </summary>
        /// <param name="pEnabled">
        /// [Out] If true, the exception in flight flag is set. If false, it is cleared.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE IsExceptionInFlight(
            _Out_ bool* pEnabled
            );
        #endif // #ifndef EXCLUDE_MONITOR_ONLY_APIS
    }; // end of DkmStepper

    // DkmSteppingCodePath represents a location that user can step to from current location.
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("14c9f40d-f492-532e-ea75-f0d1ab0e9fff") DkmSteppingCodePath : public IUnknown
    {
        private: ___ReferenceCount_t m_ReferenceCount;
        private: DkmDispatcherObjectFlags_t m_ObjectFlags;
        private: const GUID* m_pTypeId;
        private: size_t m_ObjectGCHandle;
        // Use DkmSteppingCodePath::Create to create this object
        private: DkmSteppingCodePath();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmSteppingCodePath();
        // This object cannot be copied
        private: DkmSteppingCodePath& operator=(const DkmSteppingCodePath&);
        private: DkmSteppingCodePath(const DkmSteppingCodePath&);

        private: DkmString* const m_pName;
        private: const UINT32 m_CodePathOffset;
        private: const UINT32 m_EndOffset;
        private: OPTIONAL DkmReadOnlyCollection<BYTE>* const m_pAdditionalData;
        private: void* m__pExtendedData;

        // The string that represents a possible code path user can select.
        public: _Ret_ DECLSPEC_NOTHROW DkmString* STDMETHODCALLTYPE Name(
            );

        // For managed this represents the IL offset to call instruction. For native it is
        // the RVA of the call instruction.
        public: DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE CodePathOffset(
            );

        // Represents end offset for current step unit.
        public: DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE EndOffset(
            );

        // [Optional] Additional data about the code path. Meaning is implementation
        // specific.
        public: _Ret_opt_ DECLSPEC_NOTHROW DkmReadOnlyCollection<BYTE>* STDMETHODCALLTYPE AdditionalData(
            );

        /// <summary>
        /// Create a new DkmSteppingCodePath object instance.
        /// </summary>
        /// <param name="pName">
        /// [In] The string that represents a possible code path user can select.
        /// </param>
        /// <param name="CodePathOffset">
        /// [In] For managed this represents the IL offset to call instruction. For native it
        /// is the RVA of the call instruction.
        /// </param>
        /// <param name="EndOffset">
        /// [In] Represents end offset for current step unit.
        /// </param>
        /// <param name="pAdditionalData">
        /// [In,Optional] Additional data about the code path. Meaning is implementation
        /// specific.
        /// </param>
        /// <param name="ppCreatedObject">
        /// [Out] Result of this method call.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ DkmString* pName,
            _In_ UINT32 CodePathOffset,
            _In_ UINT32 EndOffset,
            _In_opt_ DkmReadOnlyCollection<BYTE>* pAdditionalData,
            _Deref_out_ Stepping::DkmSteppingCodePath** ppCreatedObject
            );
    }; // end of DkmSteppingCodePath

    // Object used for filtering for step into specific.
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("b4f7a81a-62b9-de29-106d-5f055114810a") DkmSteppingCodePathSource : public IUnknown
    {
        private: ___ReferenceCount_t m_ReferenceCount;
        private: DkmDispatcherObjectFlags_t m_ObjectFlags;
        private: const GUID* m_pTypeId;
        private: size_t m_ObjectGCHandle;
        // Use DkmSteppingCodePathSource::Create to create this object
        private: DkmSteppingCodePathSource();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmSteppingCodePathSource();
        // This object cannot be copied
        private: DkmSteppingCodePathSource& operator=(const DkmSteppingCodePathSource&);
        private: DkmSteppingCodePathSource(const DkmSteppingCodePathSource&);

        private: Symbols::DkmInstructionSymbol* const m_pInstructionSymbol;
        private: DkmInstructionAddress* const m_pInstructionAddress;
        private: Evaluation::DkmLanguage* const m_pLanguage;
        private: void* m__pExtendedData;

        // The instruction symbol at the location to begin looking for step into specific
        // code paths.
        public: _Ret_ DECLSPEC_NOTHROW Symbols::DkmInstructionSymbol* STDMETHODCALLTYPE InstructionSymbol(
            );

        // The instruction address at the location to begin looking for step into specific
        // code paths.
        public: _Ret_ DECLSPEC_NOTHROW DkmInstructionAddress* STDMETHODCALLTYPE InstructionAddress(
            );

        // The language of the location to begin looking for step into specific code paths.
        public: _Ret_ DECLSPEC_NOTHROW Evaluation::DkmLanguage* STDMETHODCALLTYPE Language(
            );

        /// <summary>
        /// Create a new DkmSteppingCodePathSource object instance.
        /// </summary>
        /// <param name="pInstructionSymbol">
        /// [In] The instruction symbol at the location to begin looking for step into
        /// specific code paths.
        /// </param>
        /// <param name="pInstructionAddress">
        /// [In] The instruction address at the location to begin looking for step into
        /// specific code paths.
        /// </param>
        /// <param name="pLanguage">
        /// [In] The language of the location to begin looking for step into specific code
        /// paths.
        /// </param>
        /// <param name="ppCreatedObject">
        /// [Out] Result of this method call.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ Symbols::DkmInstructionSymbol* pInstructionSymbol,
            _In_ DkmInstructionAddress* pInstructionAddress,
            _In_ Evaluation::DkmLanguage* pLanguage,
            _Deref_out_ Stepping::DkmSteppingCodePathSource** ppCreatedObject
            );

        #ifndef EXCLUDE_IDE_ONLY_APIS
        /// <summary>
        /// GetCodePaths is called to get step into specific targets.
        ///
        /// Location constraint: API must be called from an IDE component (component level
        /// &gt; 100,000).
        /// </summary>
        /// <param name="pStackFrame">
        /// [In] Specifies the current frame.
        /// </param>
        /// <param name="StepUnit">
        /// [In] Specifies if code paths are for current statement or line.
        /// </param>
        /// <param name="pCodePaths">
        /// [Out] DkmSteppingCodePath[] represents a location that user can step to from
        /// current location.
        ///
        /// The memory for the DkmArray members is allocated by the method implementation
        /// using DkmAllocBytes/DkmAllocArray. It is freed by the caller using the
        /// CAutoDkmArray template or with DkmFreeMemory and manual element release.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetCodePaths(
            _In_ CallStack::DkmStackWalkFrame* pStackFrame,
            _In_ Stepping::DkmStepUnit_t StepUnit,
            _Out_ DkmArray<Stepping::DkmSteppingCodePath*>* pCodePaths
            );
        #endif // #ifndef EXCLUDE_IDE_ONLY_APIS
    }; // end of DkmSteppingCodePathSource

}; // end namespace Stepping

// Contains types for start debugging and launching processes.
namespace Start {
    // DkmLaunchedProcessInfo is returned from APIs that launch a process.
    struct DECLSPEC_UUID("df3c6c1f-676b-92dc-286b-b364a24342ae") DkmLaunchedProcessInfo
    {
        // Id of the launched process. Minidump implementations can set this to 0.
        UINT32 ProcessId;

        // 64-bit date time value indicating when the process was started. The start time
        // along with the id and the machine where the process was started can uniquely
        // identify a process. This can be set to 0 if this is unknown/invalid (ex:
        // minidumps).
        UINT64 StartTime;

        // Id of the first thread in the launched process. Minidump implementations can set
        // this to 0.
        UINT32 ThreadId;

        // Release all reference-counted fields within the DkmLaunchedProcessInfo structure.
        static DECLSPEC_NOTHROW void STDMETHODCALLTYPE Release(
            _In_ DkmLaunchedProcessInfo* pItem
            )
        {
            // structure requires no cleanup
        }
    };

    // Result of an asynchronous DkmTransportConnection.ActivateAppPackage call.
    struct DkmActivateAppPackageAsyncResult
    {
        // HRESULT code returned from the caller. This will be
        // DkmExceptionCode.COR_E_OPERATIONCANCELED (0x8013153B) if the operation was
        // canceled before processing was complete.
        HRESULT ErrorCode;
    };

    // Settings supplied during a start debugging operation from a project system or other
    // caller of LaunchDebugTargets (or various other start debugging APIs).
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("bbc4d5cc-e936-fc2a-64b7-ba716dda9020") DkmDebugLaunchSettings : public IUnknown
    {
        private: ___ReferenceCount_t m_ReferenceCount;
        private: DkmDispatcherObjectFlags_t m_ObjectFlags;
        private: const GUID* m_pTypeId;
        private: size_t m_ObjectGCHandle;
        // Use DkmDebugLaunchSettings::Create to create this object
        private: DkmDebugLaunchSettings();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmDebugLaunchSettings();
        // This object cannot be copied
        private: DkmDebugLaunchSettings& operator=(const DkmDebugLaunchSettings&);
        private: DkmDebugLaunchSettings(const DkmDebugLaunchSettings&);

        private: DkmString* const m_pOptionsString;
        private: OPTIONAL DkmReadOnlyCollection<GUID>* const m_pEngineFilter;
        private: void* m__pExtendedData;

        // Additional information provided by a project system when calling
        // LaunchDebugTargets through VsDebugTarget[2/3/etc].bstrOptions).
        public: _Ret_ DECLSPEC_NOTHROW DkmString* STDMETHODCALLTYPE OptionsString(
            );

        // [Optional] Guids for the set of debug engines being used to debug this process.
        // This will be null if the process was launched outside the debugger.
        public: _Ret_opt_ DECLSPEC_NOTHROW DkmReadOnlyCollection<GUID>* STDMETHODCALLTYPE EngineFilter(
            );

        /// <summary>
        /// Create a new DkmDebugLaunchSettings object instance.
        /// </summary>
        /// <param name="pOptionsString">
        /// [In] Additional information provided by a project system when calling
        /// LaunchDebugTargets through VsDebugTarget[2/3/etc].bstrOptions).
        /// </param>
        /// <param name="pEngineFilter">
        /// [In,Optional] Guids for the set of debug engines being used to debug this
        /// process. This will be null if the process was launched outside the debugger.
        /// </param>
        /// <param name="ppCreatedObject">
        /// [Out] Result of this method call.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ DkmString* pOptionsString,
            _In_opt_ DkmReadOnlyCollection<GUID>* pEngineFilter,
            _Deref_out_ Start::DkmDebugLaunchSettings** ppCreatedObject
            );

        #ifndef EXCLUDE_MONITOR_ONLY_APIS
        /// <summary>
        /// Obtains any environment variables which the extension would like to add.
        ///
        /// Location constraint: API must be called from a Monitor component (component level
        /// &lt; 100,000).
        /// </summary>
        /// <param name="Scenario">
        /// [In] Enumeration of the scenarios where IDkmProcessLaunchEnvironmentFilter
        /// implementations are invoked.
        /// </param>
        /// <param name="ppAdditionalEnvironmentBlock">
        /// [Out,Optional] One or more environment variables which should be passed to the
        /// target process. Multiple variables are separated with an embedded null ('\0').
        /// For example: "MyVariable1=1\0MyVariable2=12".
        ///
        /// Null or empty string are returned if the caller doesn't want to customize the
        /// environment block for this launch.
        /// </param>
        /// <returns>
        /// S_OK is returned if *ppAdditionalEnvironmentBlock is non-NULL, S_FALSE is
        /// returned when *ppAdditionalEnvironmentBlock is NULL, and failure codes are used
        /// for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetGPUAdditionalEnvironmentVariables(
            _In_ Start::DkmProcessLaunchEnvironmentFilterScenario_t Scenario,
            _Deref_out_opt_ DkmString** ppAdditionalEnvironmentBlock
            );
        #endif // #ifndef EXCLUDE_MONITOR_ONLY_APIS

        /// <summary>
        /// Engine is capable of debugging native code. This will be 'false' when debugging
        /// .NET CLR v2 code, or .NET code on the device. Note that even when true, native
        /// debugging may not be currently enabled (see
        /// DkmProcessSettings.IsNativeDebuggingEnabled).
        ///
        /// This API was introduced in Visual Studio 12 Update 2 (DkmApiVersion.VS12Update2).
        /// </summary>
        /// <param name="pEngineSettings">
        /// [In] EngineSettings to check native code support.
        /// </param>
        /// <param name="pNativeCodeSupported">
        /// [Out] Boolean value indicates if native code is supported.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE IsNativeCodeSupported(
            _In_ DkmEngineSettings* pEngineSettings,
            _Out_ bool* pNativeCodeSupported
            );
    }; // end of DkmDebugLaunchSettings

    // Object used to send a request to the IDE to request that Visual Studio should debug an
    // additional process. This may be used, for example, to debug a child process.
    //
    // This API was introduced in Visual Studio 14 RTM (DkmApiVersion.VS14RTM).
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("847301d5-269c-7461-c18d-90df9175fe08") DkmDebugProcessRequest : public IUnknown
    {
        private: ___ReferenceCount_t m_ReferenceCount;
        private: DkmDispatcherObjectFlags_t m_ObjectFlags;
        private: const GUID* m_pTypeId;
        private: size_t m_ObjectGCHandle;
        // Use DkmDebugProcessRequest::Create to create this object
        private: DkmDebugProcessRequest();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmDebugProcessRequest();
        // This object cannot be copied
        private: DkmDebugProcessRequest& operator=(const DkmDebugProcessRequest&);
        private: DkmDebugProcessRequest(const DkmDebugProcessRequest&);

        private: const UINT32 m_ProcessId;
        private: const UINT64 m_StartTime;
        private: DkmProcess* const m_pLogicalParentProcess;
        private: DkmString* const m_pPath;
        private: OPTIONAL DkmReadOnlyCollection<GUID>* const m_pEngineFilter;
        private: const Start::DkmDebugProcessRequestFlags_t m_Flags;
        private: void* m__pExtendedData;

        // Process which the debugger should attach to. In general, this should be a new
        // process which is still at the initial suspension point. However, in some cases
        // such as when a base dm is already attached to the process, and sends the request
        // merely to get the rest of the debugger ready to debug the process, this
        // restriction may not apply.
        //
        // This API was introduced in Visual Studio 14 RTM (DkmApiVersion.VS14RTM).
        public: DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE ProcessId(
            );

        // 64-bit date time value indicating when the process was started. The start time
        // along with the id and the machine where the process was started can uniquely
        // identify a process.
        //
        // This API was introduced in Visual Studio 14 RTM (DkmApiVersion.VS14RTM).
        public: DECLSPEC_NOTHROW UINT64 STDMETHODCALLTYPE StartTime(
            );

        // The process which is logically the parent of the new process which is going to be
        // debugged. For something like child process debugging, this should generally be the
        // actual parent process. In other cases, it could simply be the process which is
        // performing, an action which motivates the request to debug.
        //
        // This API was introduced in Visual Studio 14 RTM (DkmApiVersion.VS14RTM).
        public: _Ret_ DECLSPEC_NOTHROW DkmProcess* STDMETHODCALLTYPE LogicalParentProcess(
            );

        // Full path to the starting executable of the process.
        //
        // This API was introduced in Visual Studio 14 RTM (DkmApiVersion.VS14RTM).
        public: _Ret_ DECLSPEC_NOTHROW DkmString* STDMETHODCALLTYPE Path(
            );

        // [Optional] Guids for the set of debug engines to be used to debug this process. If
        // null, debugger will determine the correct engine filter based on any child process
        // debugging settings. Currently, this will simply use the engine from the parent
        // process, but this is subject to change in the future. To force the same engine to
        // be used, the caller should pass
        // LogicalParentProcess.DebugLaunchSettings.EngineFilter rather than null.
        //
        // This API was introduced in Visual Studio 14 RTM (DkmApiVersion.VS14RTM).
        public: _Ret_opt_ DECLSPEC_NOTHROW DkmReadOnlyCollection<GUID>* STDMETHODCALLTYPE EngineFilter(
            );

        // Flags passed in the DkmDebugProcessRequest object.
        //
        // This API was introduced in Visual Studio 14 RTM (DkmApiVersion.VS14RTM).
        public: DECLSPEC_NOTHROW Start::DkmDebugProcessRequestFlags_t STDMETHODCALLTYPE Flags(
            );

        /// <summary>
        /// Create a new DkmDebugProcessRequest object instance.
        ///
        /// This API was introduced in Visual Studio 14 RTM (DkmApiVersion.VS14RTM).
        /// </summary>
        /// <param name="ProcessId">
        /// [In] Process which the debugger should attach to. In general, this should be a
        /// new process which is still at the initial suspension point. However, in some
        /// cases such as when a base dm is already attached to the process, and sends the
        /// request merely to get the rest of the debugger ready to debug the process, this
        /// restriction may not apply.
        /// </param>
        /// <param name="StartTime">
        /// [In] 64-bit date time value indicating when the process was started. The start
        /// time along with the id and the machine where the process was started can uniquely
        /// identify a process.
        /// </param>
        /// <param name="pLogicalParentProcess">
        /// [In] The process which is logically the parent of the new process which is going
        /// to be debugged. For something like child process debugging, this should generally
        /// be the actual parent process. In other cases, it could simply be the process
        /// which is performing, an action which motivates the request to debug.
        /// </param>
        /// <param name="pPath">
        /// [In] Full path to the starting executable of the process.
        /// </param>
        /// <param name="pEngineFilter">
        /// [In,Optional] Guids for the set of debug engines to be used to debug this
        /// process. If null, debugger will determine the correct engine filter based on any
        /// child process debugging settings. Currently, this will simply use the engine from
        /// the parent process, but this is subject to change in the future. To force the
        /// same engine to be used, the caller should pass
        /// LogicalParentProcess.DebugLaunchSettings.EngineFilter rather than null.
        /// </param>
        /// <param name="Flags">
        /// [In] Flags passed in the DkmDebugProcessRequest object.
        /// </param>
        /// <param name="ppCreatedObject">
        /// [Out] Result of this method call.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ UINT32 ProcessId,
            _In_ UINT64 StartTime,
            _In_ DkmProcess* pLogicalParentProcess,
            _In_ DkmString* pPath,
            _In_opt_ DkmReadOnlyCollection<GUID>* pEngineFilter,
            _In_ Start::DkmDebugProcessRequestFlags_t Flags,
            _Deref_out_ Start::DkmDebugProcessRequest** ppCreatedObject
            );

        /// <summary>
        /// Sends the debug request to the IDE. The completion routine will be notified when
        /// the attach completes.
        ///
        /// This method will append a new work item to the specified work list, and return
        /// once the work item has been appended. The actual processing of the work item is
        /// asynchronous. The caller will be notified that the request is complete through
        /// the completion routine.
        ///
        /// This API was introduced in Visual Studio 14 RTM (DkmApiVersion.VS14RTM).
        /// </summary>
        /// <param name="pWorkList">
        /// WorkList to append the new work item to.
        /// </param>
        /// <param name="pCompletionRoutine">
        /// Routine to fire when the request is complete. If the request is successfully
        /// appended to the work list, this will always fire (including when the operation is
        /// canceled). This will never fire if appending the work item fails.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Send(
            _In_ DkmWorkList* pWorkList,
            _In_ IDkmCompletionRoutine<Start::DkmDebugProcessRequestAsyncResult>* pCompletionRoutine
            );
    }; // end of DkmDebugProcessRequest

    // Result of an asynchronous DkmDebugProcessRequest.Send call.
    struct DkmDebugProcessRequestAsyncResult
    {
        // HRESULT code returned from the caller. This will be
        // DkmExceptionCode.COR_E_OPERATIONCANCELED (0x8013153B) if the operation was
        // canceled before processing was complete. E_DEBUG_PROCESS_REQUEST_FAILED indicates
        // that the request to debug to the process failed.
        HRESULT ErrorCode;
    };

    // Flags passed in the DkmDebugProcessRequest object.
    //
    // This API was introduced in Visual Studio 14 RTM (DkmApiVersion.VS14RTM).
    DEFINE_SCOPED_ENUM(DkmDebugProcessRequestFlags)
    {
        // No flags are set.
        None = 0x0,
        // Detach from the process on stop debugging instead of terminating it.
        DetachOnStop = 0x1
    };
    DEFINE_SCOPED_ENUM_FLAG_OPERATORS(DkmDebugProcessRequestFlags_t);

    #ifndef EXCLUDE_MONITOR_ONLY_APIS
    // Object created by runtime debug monitors in order to defer the sending of the
    // LoadComplete event. This is important in attach scenario as load complete is used to
    // indicate that process attach has finished and that all breakpoints in running code
    // have been bound.
    //
    // This API was introduced in Visual Studio 12 Update 2 (DkmApiVersion.VS12Update2).
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("5e4f3517-4169-c1bf-6f13-0b84105f8c58") DkmLoadCompleteEventDeferral : public IUnknown
    {
        private: ___ReferenceCount_t m_ReferenceCount;
        private: DkmDispatcherObjectFlags_t m_ObjectFlags;
        private: const GUID* m_pTypeId;
        private: size_t m_ObjectGCHandle;
        // Use DkmLoadCompleteEventDeferral::Create to create this object
        private: DkmLoadCompleteEventDeferral();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmLoadCompleteEventDeferral();
        // This object cannot be copied
        private: DkmLoadCompleteEventDeferral& operator=(const DkmLoadCompleteEventDeferral&);
        private: DkmLoadCompleteEventDeferral(const DkmLoadCompleteEventDeferral&);

        private: DkmProcess* const m_pProcess;
        private: const GUID m_Id;
        private: void* m__pExtendedData;

        // DkmProcess represents a target process which is being debugged. The debugger
        // debugs processes, so this is the basic unit of debugging. A DkmProcess can
        // represent a system process or a virtual process such as minidumps.
        //
        // This API was introduced in Visual Studio 12 Update 2 (DkmApiVersion.VS12Update2).
        public: _Ret_ DECLSPEC_NOTHROW DkmProcess* STDMETHODCALLTYPE Process(
            );

        // Id to uniquely identify the deferral within a specific process.
        //
        // This API was introduced in Visual Studio 12 Update 2 (DkmApiVersion.VS12Update2).
        public: DECLSPEC_NOTHROW const GUID& STDMETHODCALLTYPE Id(
            );

        /// <summary>
        /// Create a new DkmLoadCompleteEventDeferral object instance. The deferral is not
        /// initially active, call 'Add' in order to all the deferral to the list of active
        /// deferrals.
        ///
        /// Location constraint: API must be called from a Monitor component (component level
        /// &lt; 100,000).
        ///
        /// This API was introduced in Visual Studio 12 Update 2 (DkmApiVersion.VS12Update2).
        /// </summary>
        /// <param name="pProcess">
        /// [In] DkmProcess represents a target process which is being debugged. The debugger
        /// debugs processes, so this is the basic unit of debugging. A DkmProcess can
        /// represent a system process or a virtual process such as minidumps.
        /// </param>
        /// <param name="Id">
        /// [In] Id to uniquely identify the deferral within a specific process.
        /// </param>
        /// <param name="ppCreatedObject">
        /// [Out] Result of this method call.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ DkmProcess* pProcess,
            _In_ const GUID& Id,
            _Deref_out_ Start::DkmLoadCompleteEventDeferral** ppCreatedObject
            );

        /// <summary>
        /// Adds a request to defer load complete. This method should be called before the
        /// base debug monitor issues the load complete event (calls
        /// DkmProcess.OnLoadComplete).
        ///
        /// Location constraint: API must be called from a Monitor component (component level
        /// &lt; 100,000).
        ///
        /// This API was introduced in Visual Studio 12 Update 2 (DkmApiVersion.VS12Update2).
        /// </summary>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// E_LOAD_COMPLETE_ALREADY_SENT indicates that DkmLoadCompleteEventDeferral.Add was
        /// called after the load complete event has been sent.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Add(
            );

        /// <summary>
        /// Removes the load complete defer request. This method must be called on the event
        /// thread is response to a stopping/pausing event. If the base debug monitor has
        /// already called DkmProcess.OnLoadComplete prior to the final call to Remove, the
        /// final call to Remove will then fire the load complete event.
        ///
        /// Location constraint: API must be called from a Monitor component (component level
        /// &lt; 100,000).
        ///
        /// This API was introduced in Visual Studio 12 Update 2 (DkmApiVersion.VS12Update2).
        /// </summary>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// E_WRONG_THREAD indicates that Remove was not called on an event thread.
        /// E_LOAD_COMPLETE_DEFERRAL_NOT_FOUND indicates that Remove was called on a deferral
        /// object was was not in the list of active deferrals.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Remove(
            );
    }; // end of DkmLoadCompleteEventDeferral
    #endif // #ifndef EXCLUDE_MONITOR_ONLY_APIS

    // DkmProcessAttachRequest is used to describe the process that debugger should attach
    // to.
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("7c0ada54-d17e-0067-cb5e-5a8169507663") DkmProcessAttachRequest : public IUnknown
    {
        private: ___ReferenceCount_t m_ReferenceCount;
        private: DkmDispatcherObjectFlags_t m_ObjectFlags;
        private: const GUID* m_pTypeId;
        private: size_t m_ObjectGCHandle;
        // Use DkmProcessAttachRequest::Create to create this object
        private: DkmProcessAttachRequest();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmProcessAttachRequest();
        // This object cannot be copied
        private: DkmProcessAttachRequest& operator=(const DkmProcessAttachRequest&);
        private: DkmProcessAttachRequest(const DkmProcessAttachRequest&);

        // Contains additional fields of DkmProcessAttachRequest which were added after the
        // class was initally introduced.
        private: struct ___ExtendedData
        {
            ___ExtendedData();

            // 64-bit date time value indicating when the process was started. The start time
            // along with the id and the machine where the process was started can uniquely
            // identify a process. This can be set to 0 if this is unknown/invalid (ex:
            // minidumps).
            const UINT64 StartTime;
        };

        private: DefaultPort::DkmTransportConnection* const m_pConnection;
        private: DkmString* const m_pPath;
        private: const UINT32 m_ProcessId;
        private: const GUID m_UniqueProcessId;
        private: const Start::DkmStartMethod_t m_StartMethod;
        private: const GUID m_HostingProcessLanguage;
        private: DkmEngineSettings* const m_pEngineSettings;
        private: Start::DkmDebugLaunchSettings* const m_pDebugLaunchSettings;
        private: ___ExtendedData* const m__pExtendedData;

        // This represents a connection between the monitor and the IDE. It can either be a
        // local connection if the monitor is running in the same process as the IDE, or it
        // can be a remote connection. In the monitor process, there is only one connection.
        public: _Ret_ DECLSPEC_NOTHROW DefaultPort::DkmTransportConnection* STDMETHODCALLTYPE Connection(
            );

        // Full path to the starting executable of the process.
        public: _Ret_ DECLSPEC_NOTHROW DkmString* STDMETHODCALLTYPE Path(
            );

        // Id of the process which the debugger should attach to.
        public: DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE ProcessId(
            );

        // Value to assign to the 'DkmProcess.UniqueId' field. This Guid is generated by the
        // port, and is used to uniquely identifies the process object.
        public: DECLSPEC_NOTHROW const GUID& STDMETHODCALLTYPE UniqueProcessId(
            );

        // DkmStartMethod describes how the debug engine started debugging this process.
        public: DECLSPEC_NOTHROW Start::DkmStartMethod_t STDMETHODCALLTYPE StartMethod(
            );

        // [Optional] Unique id for a programming language. These values must also be
        // registered under $(RegRoot)\AD7Metric\ExpressionEvaluator and returned from symbol
        // providers (through GetCompilerId) and language services (through
        // IVsLanguageDebugInfo.GetLanguageID).
        public: DECLSPEC_NOTHROW const GUID& STDMETHODCALLTYPE HostingProcessLanguage(
            );

        // Contains the session-wide debug settings. There is one instance of this object per
        // engine Guid (ex: one instance for COMPlusOnlyEng2, one instance for
        // COMPlusNativeEng).
        public: _Ret_ DECLSPEC_NOTHROW DkmEngineSettings* STDMETHODCALLTYPE EngineSettings(
            );

        // Settings supplied during a start debugging operation from a project system or
        // other caller of LaunchDebugTargets (or various other start debugging APIs).
        public: _Ret_ DECLSPEC_NOTHROW Start::DkmDebugLaunchSettings* STDMETHODCALLTYPE DebugLaunchSettings(
            );

        // 64-bit date time value indicating when the process was started. The start time
        // along with the id and the machine where the process was started can uniquely
        // identify a process. This can be set to 0 if this is unknown/invalid (ex:
        // minidumps).
        //
        // This API was introduced in Visual Studio 14 RTM (DkmApiVersion.VS14RTM).
        public: DECLSPEC_NOTHROW UINT64 STDMETHODCALLTYPE StartTime(
            );

        /// <summary>
        /// Create a new DkmProcessAttachRequest object instance.
        /// </summary>
        /// <param name="pConnection">
        /// [In] This represents a connection between the monitor and the IDE. It can either
        /// be a local connection if the monitor is running in the same process as the IDE,
        /// or it can be a remote connection. In the monitor process, there is only one
        /// connection.
        /// </param>
        /// <param name="pPath">
        /// [In] Full path to the starting executable of the process.
        /// </param>
        /// <param name="ProcessId">
        /// [In] Id of the process which the debugger should attach to.
        /// </param>
        /// <param name="UniqueProcessId">
        /// [In] Value to assign to the 'DkmProcess.UniqueId' field. This Guid is generated
        /// by the port, and is used to uniquely identifies the process object.
        /// </param>
        /// <param name="StartMethod">
        /// [In] DkmStartMethod describes how the debug engine started debugging this
        /// process.
        /// </param>
        /// <param name="HostingProcessLanguage">
        /// [In,Optional] Unique id for a programming language. These values must also be
        /// registered under $(RegRoot)\AD7Metric\ExpressionEvaluator and returned from
        /// symbol providers (through GetCompilerId) and language services (through
        /// IVsLanguageDebugInfo.GetLanguageID).
        /// </param>
        /// <param name="pEngineSettings">
        /// [In] Contains the session-wide debug settings. There is one instance of this
        /// object per engine Guid (ex: one instance for COMPlusOnlyEng2, one instance for
        /// COMPlusNativeEng).
        /// </param>
        /// <param name="pDebugLaunchSettings">
        /// [In] Settings supplied during a start debugging operation from a project system
        /// or other caller of LaunchDebugTargets (or various other start debugging APIs).
        /// </param>
        /// <param name="ppCreatedObject">
        /// [Out] Result of this method call.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ DefaultPort::DkmTransportConnection* pConnection,
            _In_ DkmString* pPath,
            _In_ UINT32 ProcessId,
            _In_ const GUID& UniqueProcessId,
            _In_ Start::DkmStartMethod_t StartMethod,
            _In_ const GUID& HostingProcessLanguage,
            _In_ DkmEngineSettings* pEngineSettings,
            _In_ Start::DkmDebugLaunchSettings* pDebugLaunchSettings,
            _Deref_out_ Start::DkmProcessAttachRequest** ppCreatedObject
            );

        /// <summary>
        /// Create a new DkmProcessAttachRequest object instance.
        ///
        /// This API was introduced in Visual Studio 14 RTM (DkmApiVersion.VS14RTM).
        /// </summary>
        /// <param name="pConnection">
        /// [In] This represents a connection between the monitor and the IDE. It can either
        /// be a local connection if the monitor is running in the same process as the IDE,
        /// or it can be a remote connection. In the monitor process, there is only one
        /// connection.
        /// </param>
        /// <param name="pPath">
        /// [In] Full path to the starting executable of the process.
        /// </param>
        /// <param name="ProcessId">
        /// [In] Id of the process which the debugger should attach to.
        /// </param>
        /// <param name="UniqueProcessId">
        /// [In] Value to assign to the 'DkmProcess.UniqueId' field. This Guid is generated
        /// by the port, and is used to uniquely identifies the process object.
        /// </param>
        /// <param name="StartMethod">
        /// [In] DkmStartMethod describes how the debug engine started debugging this
        /// process.
        /// </param>
        /// <param name="HostingProcessLanguage">
        /// [In,Optional] Unique id for a programming language. These values must also be
        /// registered under $(RegRoot)\AD7Metric\ExpressionEvaluator and returned from
        /// symbol providers (through GetCompilerId) and language services (through
        /// IVsLanguageDebugInfo.GetLanguageID).
        /// </param>
        /// <param name="pEngineSettings">
        /// [In] Contains the session-wide debug settings. There is one instance of this
        /// object per engine Guid (ex: one instance for COMPlusOnlyEng2, one instance for
        /// COMPlusNativeEng).
        /// </param>
        /// <param name="pDebugLaunchSettings">
        /// [In] Settings supplied during a start debugging operation from a project system
        /// or other caller of LaunchDebugTargets (or various other start debugging APIs).
        /// </param>
        /// <param name="StartTime">
        /// [In] 64-bit date time value indicating when the process was started. The start
        /// time along with the id and the machine where the process was started can uniquely
        /// identify a process. This can be set to 0 if this is unknown/invalid (ex:
        /// minidumps).
        /// </param>
        /// <param name="ppCreatedObject">
        /// [Out] Result of this method call.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ DefaultPort::DkmTransportConnection* pConnection,
            _In_ DkmString* pPath,
            _In_ UINT32 ProcessId,
            _In_ const GUID& UniqueProcessId,
            _In_ Start::DkmStartMethod_t StartMethod,
            _In_ const GUID& HostingProcessLanguage,
            _In_ DkmEngineSettings* pEngineSettings,
            _In_ Start::DkmDebugLaunchSettings* pDebugLaunchSettings,
            _In_ UINT64 StartTime,
            _Deref_out_ Start::DkmProcessAttachRequest** ppCreatedObject
            );

        /// <summary>
        /// Causes the debug monitor to attach to the process. Before this method returns,
        /// the debug monitor must start an event thread (or reuse an existing event thread)
        /// and create the DkmProcess object on the event thread. Creating the DkmProcess
        /// object will send a process create event.
        ///
        /// Note that this method may only be called in response to the Visual Studio
        /// debugger package requesting an attach. Components that wish to attach to another
        /// process should send a custom event to a visual studio package. From a package, an
        /// attach can be requested through the IVsDebugger.LaunchDebugTargets API.
        /// </summary>
        /// <param name="ppProcess">
        /// [Out] DkmProcess represents a target process which is being debugged. The
        /// debugger debugs processes, so this is the basic unit of debugging. A DkmProcess
        /// can represent a system process or a virtual process such as minidumps.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// E_ATTACH_USER_CANCELED indicates that the attach to process operation was
        /// canceled. Returning this error will suppress most error messages. So it can be
        /// used in combination with DkmUserMessage.Post or DkmCustomMessage.SendToVsService
        /// as a way of providing custom failure messages to the user.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE AttachToProcess(
            _Deref_out_ DkmProcess** ppProcess
            );
    }; // end of DkmProcessAttachRequest

    #ifndef EXCLUDE_MONITOR_ONLY_APIS
    // DkmProcessLaunchEnvironmentFilterInputData is used to provide input to a
    // IDkmProcessLaunchEnvironmentFilter140 implementation. It describes the process which
    // is about to be started.
    //
    // This API was introduced in Visual Studio 14 RTM (DkmApiVersion.VS14RTM).
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("e646e5ef-5ba2-e021-4f3d-70f85015bff6") DkmProcessLaunchEnvironmentFilterInputData : public IUnknown
    {
        private: ___ReferenceCount_t m_ReferenceCount;
        private: DkmDispatcherObjectFlags_t m_ObjectFlags;
        private: const GUID* m_pTypeId;
        private: size_t m_ObjectGCHandle;
        // Use DkmProcessLaunchEnvironmentFilterInputData::Create to create this object
        private: DkmProcessLaunchEnvironmentFilterInputData();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmProcessLaunchEnvironmentFilterInputData();
        // This object cannot be copied
        private: DkmProcessLaunchEnvironmentFilterInputData& operator=(const DkmProcessLaunchEnvironmentFilterInputData&);
        private: DkmProcessLaunchEnvironmentFilterInputData(const DkmProcessLaunchEnvironmentFilterInputData&);

        private: DefaultPort::DkmTransportConnection* const m_pConnection;
        private: Start::DkmDebugLaunchSettings* const m_pDebugLaunchSettings;
        private: OPTIONAL DkmString* const m_pExecutablePath;
        private: OPTIONAL DefaultPort::DkmAppPackageId* const m_pAppPackageId;
        private: const Start::DkmProcessLaunchFlags_t m_LaunchFlags;
        private: void* m__pExtendedData;

        // This represents a connection between the monitor and the IDE. It can either be a
        // local connection if the monitor is running in the same process as the IDE, or it
        // can be a remote connection. In the monitor process, there is only one connection.
        //
        // This API was introduced in Visual Studio 14 RTM (DkmApiVersion.VS14RTM).
        public: _Ret_ DECLSPEC_NOTHROW DefaultPort::DkmTransportConnection* STDMETHODCALLTYPE Connection(
            );

        // Settings supplied during a start debugging operation from a project system or
        // other caller of LaunchDebugTargets (or various other start debugging APIs).
        //
        // This API was introduced in Visual Studio 14 RTM (DkmApiVersion.VS14RTM).
        public: _Ret_ DECLSPEC_NOTHROW Start::DkmDebugLaunchSettings* STDMETHODCALLTYPE DebugLaunchSettings(
            );

        // [Optional] Path to the executable file to launch. For a desktop app launch
        // (AppPackageId is null) this will be the full path to the executable which will be
        // launched. For Windows Store or a project system using the
        // IVsDebugLaunchNotifyListener110 API, this value is a hint from the project system.
        // It could be null, it could be just the file name of the executable rather than a
        // full path, or it could represent only one of the executables that could be
        // launched in the package.
        //
        // This API was introduced in Visual Studio 14 RTM (DkmApiVersion.VS14RTM).
        public: _Ret_opt_ DECLSPEC_NOTHROW DkmString* STDMETHODCALLTYPE ExecutablePath(
            );

        // [Optional] The Windows Store (or possibly other container in the future) app
        // package of the app which is about to be started.
        //
        // This API was introduced in Visual Studio 14 RTM (DkmApiVersion.VS14RTM).
        public: _Ret_opt_ DECLSPEC_NOTHROW DefaultPort::DkmAppPackageId* STDMETHODCALLTYPE AppPackageId(
            );

        // Flags associated with a request to launch a process.
        //
        // This API was introduced in Visual Studio 14 RTM (DkmApiVersion.VS14RTM).
        public: DECLSPEC_NOTHROW Start::DkmProcessLaunchFlags_t STDMETHODCALLTYPE LaunchFlags(
            );

        /// <summary>
        /// Create a new DkmProcessLaunchEnvironmentFilterInputData object instance.
        ///
        /// Location constraint: API must be called from a Monitor component (component level
        /// &lt; 100,000).
        ///
        /// This API was introduced in Visual Studio 14 RTM (DkmApiVersion.VS14RTM).
        /// </summary>
        /// <param name="pConnection">
        /// [In] This represents a connection between the monitor and the IDE. It can either
        /// be a local connection if the monitor is running in the same process as the IDE,
        /// or it can be a remote connection. In the monitor process, there is only one
        /// connection.
        /// </param>
        /// <param name="pDebugLaunchSettings">
        /// [In] Settings supplied during a start debugging operation from a project system
        /// or other caller of LaunchDebugTargets (or various other start debugging APIs).
        /// </param>
        /// <param name="pExecutablePath">
        /// [In,Optional] Path to the executable file to launch. For a desktop app launch
        /// (AppPackageId is null) this will be the full path to the executable which will be
        /// launched. For Windows Store or a project system using the
        /// IVsDebugLaunchNotifyListener110 API, this value is a hint from the project
        /// system. It could be null, it could be just the file name of the executable rather
        /// than a full path, or it could represent only one of the executables that could be
        /// launched in the package.
        /// </param>
        /// <param name="pAppPackageId">
        /// [In,Optional] The Windows Store (or possibly other container in the future) app
        /// package of the app which is about to be started.
        /// </param>
        /// <param name="LaunchFlags">
        /// [In] Flags associated with a request to launch a process.
        /// </param>
        /// <param name="ppCreatedObject">
        /// [Out] Result of this method call.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ DefaultPort::DkmTransportConnection* pConnection,
            _In_ Start::DkmDebugLaunchSettings* pDebugLaunchSettings,
            _In_opt_ DkmString* pExecutablePath,
            _In_opt_ DefaultPort::DkmAppPackageId* pAppPackageId,
            _In_ Start::DkmProcessLaunchFlags_t LaunchFlags,
            _Deref_out_ Start::DkmProcessLaunchEnvironmentFilterInputData** ppCreatedObject
            );
    }; // end of DkmProcessLaunchEnvironmentFilterInputData
    #endif // #ifndef EXCLUDE_MONITOR_ONLY_APIS

    // Holds the list of implementations of the IDkmProcessLaunchEnvironmentFilter interface
    // which may be called by a component. This object is used to call these environment
    // filters.
    class DkmProcessLaunchEnvironmentFilterList : public IUnknown
    {
        private: ___ReferenceCount_t m_ReferenceCount;
        private: const DWORD m_count;

        // Use DkmProcessLaunchEnvironmentFilterList::Create to create this object
        private: DkmProcessLaunchEnvironmentFilterList();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmProcessLaunchEnvironmentFilterList();
        // This object cannot be copied
        private: DkmProcessLaunchEnvironmentFilterList& operator=(const DkmProcessLaunchEnvironmentFilterList&);
        private: DkmProcessLaunchEnvironmentFilterList(const DkmProcessLaunchEnvironmentFilterList&);

        // Returns the number of implemantions of the IDkmProcessLaunchEnvironmentFilter interface which
        // may be called through this object.
        public: inline DECLSPEC_NOTHROW DWORD STDMETHODCALLTYPE Count(
            )
        {
            return m_count;
        }

        #ifndef EXCLUDE_MONITOR_ONLY_APIS
        /// <summary>
        /// Obtains any environment variables which the extension would like to add.
        ///
        /// Location constraint: API must be called from a Monitor component (component level
        /// &lt; 100,000).
        /// </summary>
        /// <param name="ImplementationIndex">
        /// [In] Zero-based index into the collection of {0} implementations that the caller
        /// wishes to be invoked. This should be less than the 'Count' property.
        /// </param>
        /// <param name="pDebugLaunchSettings">
        /// [In] Settings supplied during a start debugging operation from a project system
        /// or other caller of LaunchDebugTargets (or various other start debugging APIs).
        /// </param>
        /// <param name="Scenario">
        /// [In] Enumeration of the scenarios where IDkmProcessLaunchEnvironmentFilter
        /// implementations are invoked.
        /// </param>
        /// <param name="ppAdditionalEnvironmentBlock">
        /// [Out,Optional] One or more environment variables which should be passed to the
        /// target process. Multiple variables are separated with an embedded null ('\0').
        /// For example: "MyVariable1=1\0MyVariable2=12".
        ///
        /// Null or empty string are returned if the caller doesn't want to customize the
        /// environment block for this launch.
        /// </param>
        /// <returns>
        /// S_OK is returned if *ppAdditionalEnvironmentBlock is non-NULL, S_FALSE is
        /// returned when *ppAdditionalEnvironmentBlock is NULL, and failure codes are used
        /// for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetAdditionalEnvironmentVariables(
            _In_ UINT32 ImplementationIndex,
            _In_ Start::DkmDebugLaunchSettings* pDebugLaunchSettings,
            _In_ Start::DkmProcessLaunchEnvironmentFilterScenario_t Scenario,
            _Deref_out_opt_ DkmString** ppAdditionalEnvironmentBlock
            );
        #endif // #ifndef EXCLUDE_MONITOR_ONLY_APIS

        #ifndef EXCLUDE_MONITOR_ONLY_APIS
        /// <summary>
        /// Create a new DkmProcessLaunchEnvironmentFilterList object instance.
        ///
        /// Location constraint: API must be called from a Monitor component (component level
        /// &lt; 100,000).
        /// </summary>
        /// <param name="ppCreatedObject">
        /// [Out] Result of this method call.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _Deref_out_ Start::DkmProcessLaunchEnvironmentFilterList** ppCreatedObject
            );
        #endif // #ifndef EXCLUDE_MONITOR_ONLY_APIS
    };

    // Holds the list of implementations of the IDkmProcessLaunchEnvironmentFilter interface
    // which may be called by a component. This object is used to call these environment
    // filters.
    //
    // This API was introduced in Visual Studio 14 RTM (DkmApiVersion.VS14RTM).
    class DkmProcessLaunchEnvironmentFilterList140 : public IUnknown
    {
        private: ___ReferenceCount_t m_ReferenceCount;
        private: const DWORD m_count;

        // Use DkmProcessLaunchEnvironmentFilterList140::Create to create this object
        private: DkmProcessLaunchEnvironmentFilterList140();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmProcessLaunchEnvironmentFilterList140();
        // This object cannot be copied
        private: DkmProcessLaunchEnvironmentFilterList140& operator=(const DkmProcessLaunchEnvironmentFilterList140&);
        private: DkmProcessLaunchEnvironmentFilterList140(const DkmProcessLaunchEnvironmentFilterList140&);

        // Returns the number of implemantions of the IDkmProcessLaunchEnvironmentFilter140 interface which
        // may be called through this object.
        public: inline DECLSPEC_NOTHROW DWORD STDMETHODCALLTYPE Count(
            )
        {
            return m_count;
        }

        #ifndef EXCLUDE_MONITOR_ONLY_APIS
        /// <summary>
        /// Obtains any environment variables which the extension would like to add.
        ///
        /// Location constraint: API must be called from a Monitor component (component level
        /// &lt; 100,000).
        ///
        /// This API was introduced in Visual Studio 14 RTM (DkmApiVersion.VS14RTM).
        /// </summary>
        /// <param name="ImplementationIndex">
        /// [In] Zero-based index into the collection of {0} implementations that the caller
        /// wishes to be invoked. This should be less than the 'Count' property.
        /// </param>
        /// <param name="pInputData">
        /// [In] DkmProcessLaunchEnvironmentFilterInputData is used to provide input to a
        /// IDkmProcessLaunchEnvironmentFilter140 implementation. It describes the process
        /// which is about to be started.
        /// </param>
        /// <param name="ppAdditionalEnvironmentBlock">
        /// [Out,Optional] One or more environment variables which should be passed to the
        /// target process. Multiple variables are separated with an embedded null ('\0').
        /// For example: "MyVariable1=1\0MyVariable2=12".
        ///
        /// Null or empty string are returned if the caller doesn't want to customize the
        /// environment block for this launch.
        /// </param>
        /// <returns>
        /// S_OK is returned if *ppAdditionalEnvironmentBlock is non-NULL, S_FALSE is
        /// returned when *ppAdditionalEnvironmentBlock is NULL, and failure codes are used
        /// for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetAdditionalEnvironmentVariables(
            _In_ UINT32 ImplementationIndex,
            _In_ Start::DkmProcessLaunchEnvironmentFilterInputData* pInputData,
            _Deref_out_opt_ DkmString** ppAdditionalEnvironmentBlock
            );
        #endif // #ifndef EXCLUDE_MONITOR_ONLY_APIS

        #ifndef EXCLUDE_MONITOR_ONLY_APIS
        /// <summary>
        /// Create a new DkmProcessLaunchEnvironmentFilterList140 object instance.
        ///
        /// Location constraint: API must be called from a Monitor component (component level
        /// &lt; 100,000).
        ///
        /// This API was introduced in Visual Studio 14 RTM (DkmApiVersion.VS14RTM).
        /// </summary>
        /// <param name="ppCreatedObject">
        /// [Out] Result of this method call.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _Deref_out_ Start::DkmProcessLaunchEnvironmentFilterList140** ppCreatedObject
            );
        #endif // #ifndef EXCLUDE_MONITOR_ONLY_APIS
    };

    // Enumeration of the scenarios where IDkmProcessLaunchEnvironmentFilter implementations
    // are invoked.
    DEFINE_SCOPED_ENUM(DkmProcessLaunchEnvironmentFilterScenario)
    {
        // Application is about to be launched with CreateProcess.
        ClassicLaunch = 0,
        // Windows Store app package or Windows Phone app package is about to be started.
        AppPackageLaunch = 1
    };

    // Flags associated with a request to launch a process.
    //
    // This API was introduced in Visual Studio 14 RTM (DkmApiVersion.VS14RTM).
    DEFINE_SCOPED_ENUM(DkmProcessLaunchFlags)
    {
        // No flags are set.
        None = 0x0,
        // Indicates that one or more vsdebugeng.dll-based debug engines are being used to
        // debug this process. This will be clear if the process is being started outside of
        // the debugger, or if another engine, such as the legacy managed debug engine, is
        // being used to debug the process.
        VsdebugengEngineUsed = 0x1
    };
    DEFINE_SCOPED_ENUM_FLAG_OPERATORS(DkmProcessLaunchFlags_t);

    // Flag traits of a DkmProcessLaunchRequest.
    DEFINE_SCOPED_ENUM(DkmProcessLaunchModeFlags)
    {
        // No launch flags are set.
        None = 0x0,
        // Launch the process without debugging (Ctrl+F5).
        NoDebug = 0x1,
        // Launch the process with Edit and Continue enabled.
        EnableENC = 0x2,
        // Merge DkmProcessLaunchRequest.Environment with the environment block of the
        // monitor. If this flag is missing and DkmProcessLaunchRequest.Environment is
        // specified then the processed will be launched with only environment variables from
        // the input block.
        MergeEnvironment = 0x4
    };
    DEFINE_SCOPED_ENUM_FLAG_OPERATORS(DkmProcessLaunchModeFlags_t);

    // DkmProcessLaunchRequest is used to describe the process that debugger should launch.
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("7107fc56-3477-2708-fc00-174f33c04b08") DkmProcessLaunchRequest : public DkmDataContainer
    {
        // Use DkmProcessLaunchRequest::Create to create this object
        private: DkmProcessLaunchRequest();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmProcessLaunchRequest();
        // This object cannot be copied
        private: DkmProcessLaunchRequest& operator=(const DkmProcessLaunchRequest&);
        private: DkmProcessLaunchRequest(const DkmProcessLaunchRequest&);

        // Contains additional fields of DkmProcessLaunchRequest which were added after the
        // class was initally introduced.
        private: struct ___ExtendedData
        {
            ___ExtendedData();

            // Flags associated with a request to launch a process.
            const Start::DkmProcessLaunchFlags_t LaunchFlags;
        };

        private: DkmString* const m_pFileName;
        private: OPTIONAL DkmString* const m_pArguments;
        private: DkmString* const m_pWorkingDirectory;
        private: OPTIONAL DkmString* const m_pEnvironment;
        private: OPTIONAL Start::DkmProcessStartupInfo* const m_pStartupInfo;
        private: const Start::DkmProcessLaunchModeFlags_t m_ModeFlags;
        private: const UINT32 m_Win32Flags;
        private: DefaultPort::DkmTransportConnection* const m_pConnection;
        private: const GUID m_UniqueId;
        private: OPTIONAL DkmEngineSettings* const m_pEngineSettings;
        private: Start::DkmDebugLaunchSettings* const m_pDebugLaunchSettings;
        private: ___ExtendedData* const m__pExtendedData;

        // Path to the executable file to launch.
        public: _Ret_ DECLSPEC_NOTHROW DkmString* STDMETHODCALLTYPE FileName(
            );

        // [Optional] Arguments to pass to the executable file on the command line.
        public: _Ret_opt_ DECLSPEC_NOTHROW DkmString* STDMETHODCALLTYPE Arguments(
            );

        // The full path to the current directory for the process. The string can also
        // specify a UNC path.
        public: _Ret_ DECLSPEC_NOTHROW DkmString* STDMETHODCALLTYPE WorkingDirectory(
            );

        // [Optional] A pointer to the environment block for the new process. If this
        // parameter is NULL, the new process uses the environment of the calling process.
        //
        // An environment block consists of a null-terminated block of null-terminated
        // strings. Each string is in the following form: 'name=value\0'. Because the equal
        // sign is used as a separator, it must not be used in the name of an environment
        // variable.
        public: _Ret_opt_ DECLSPEC_NOTHROW DkmString* STDMETHODCALLTYPE Environment(
            );

        // [Optional] Additional information used to launch a new process. This information
        // is contained within the 'STARTUPINFO' structure in Win32.
        public: _Ret_opt_ DECLSPEC_NOTHROW Start::DkmProcessStartupInfo* STDMETHODCALLTYPE StartupInfo(
            );

        // Flag traits of a DkmProcessLaunchRequest.
        public: DECLSPEC_NOTHROW Start::DkmProcessLaunchModeFlags_t STDMETHODCALLTYPE ModeFlags(
            );

        // Win32 process creation flags used when launching the process. For example,
        // CREATE_NO_WINDOW (0x08000000) could be passed to disable the creation of the
        // console window. The following flags should never be passed, and the behavior is
        // undefined if they are present: DEBUG_PROCESS, DEBUG_ONLY_THIS_PROCESS,
        // CREATE_SUSPENDED, EXTENDED_STARTUPINFO_PRESENT, CREATE_SEPARATE_WOW_VDM,
        // CREATE_SHARED_WOW_VDM, and CREATE_UNICODE_ENVIRONMENT.
        public: DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE Win32Flags(
            );

        // This represents a connection between the monitor and the IDE. It can either be a
        // local connection if the monitor is running in the same process as the IDE, or it
        // can be a remote connection. In the monitor process, there is only one connection.
        public: _Ret_ DECLSPEC_NOTHROW DefaultPort::DkmTransportConnection* STDMETHODCALLTYPE Connection(
            );

        // UniqueId uniquely identifies the launch request.
        public: DECLSPEC_NOTHROW const GUID& STDMETHODCALLTYPE UniqueId(
            );

        // [Optional] Settings to use when launching this executable under the debugger. This
        // may be omitted if the process is not being launched under the debugger (ex:
        // Ctrl-F5).
        public: _Ret_opt_ DECLSPEC_NOTHROW DkmEngineSettings* STDMETHODCALLTYPE EngineSettings(
            );

        // Settings supplied during a start debugging operation from a project system or
        // other caller of LaunchDebugTargets (or various other start debugging APIs).
        public: _Ret_ DECLSPEC_NOTHROW Start::DkmDebugLaunchSettings* STDMETHODCALLTYPE DebugLaunchSettings(
            );

        // Flags associated with a request to launch a process.
        //
        // This API was introduced in Visual Studio 14 RTM (DkmApiVersion.VS14RTM).
        public: DECLSPEC_NOTHROW Start::DkmProcessLaunchFlags_t STDMETHODCALLTYPE LaunchFlags(
            );

        /// <summary>
        /// Closes a DkmProcessLaunchRequest object instance. This will release any resources
        /// associated with this object across all components. This includes resources across
        /// computer or managed/native marshalling boundaries.
        ///
        /// DkmProcessLaunchRequest objects are automatically closed when their associated
        /// DkmTransportConnection object is closed.
        ///
        /// This method may only be called by the component which created the object.
        /// </summary>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Close(
            );

        /// <summary>
        /// Create a new DkmProcessLaunchRequest object instance. The caller is responsible
        /// for closing the created object after they are done.
        /// </summary>
        /// <param name="pFileName">
        /// [In] Path to the executable file to launch.
        /// </param>
        /// <param name="pArguments">
        /// [In,Optional] Arguments to pass to the executable file on the command line.
        /// </param>
        /// <param name="pWorkingDirectory">
        /// [In] The full path to the current directory for the process. The string can also
        /// specify a UNC path.
        /// </param>
        /// <param name="pEnvironment">
        /// [In,Optional] A pointer to the environment block for the new process. If this
        /// parameter is NULL, the new process uses the environment of the calling process.
        ///
        /// An environment block consists of a null-terminated block of null-terminated
        /// strings. Each string is in the following form: 'name=value\0'. Because the equal
        /// sign is used as a separator, it must not be used in the name of an environment
        /// variable.
        /// </param>
        /// <param name="pStartupInfo">
        /// [In,Optional] Additional information used to launch a new process. This
        /// information is contained within the 'STARTUPINFO' structure in Win32.
        /// </param>
        /// <param name="ModeFlags">
        /// [In] Flag traits of a DkmProcessLaunchRequest.
        /// </param>
        /// <param name="Win32Flags">
        /// [In] Win32 process creation flags used when launching the process. For example,
        /// CREATE_NO_WINDOW (0x08000000) could be passed to disable the creation of the
        /// console window. The following flags should never be passed, and the behavior is
        /// undefined if they are present: DEBUG_PROCESS, DEBUG_ONLY_THIS_PROCESS,
        /// CREATE_SUSPENDED, EXTENDED_STARTUPINFO_PRESENT, CREATE_SEPARATE_WOW_VDM,
        /// CREATE_SHARED_WOW_VDM, and CREATE_UNICODE_ENVIRONMENT.
        /// </param>
        /// <param name="pConnection">
        /// [In] This represents a connection between the monitor and the IDE. It can either
        /// be a local connection if the monitor is running in the same process as the IDE,
        /// or it can be a remote connection. In the monitor process, there is only one
        /// connection.
        /// </param>
        /// <param name="pEngineSettings">
        /// [In,Optional] Settings to use when launching this executable under the debugger.
        /// This may be omitted if the process is not being launched under the debugger (ex:
        /// Ctrl-F5).
        /// </param>
        /// <param name="pDebugLaunchSettings">
        /// [In] Settings supplied during a start debugging operation from a project system
        /// or other caller of LaunchDebugTargets (or various other start debugging APIs).
        /// </param>
        /// <param name="DataItem">
        /// [In] Data object to add to the new DkmProcessLaunchRequest instance.
        /// DkmDataItem::Null() in the case that the caller doesn't need to add a data item.
        /// </param>
        /// <param name="ppCreatedObject">
        /// [Out] Result of this method call.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ DkmString* pFileName,
            _In_opt_ DkmString* pArguments,
            _In_ DkmString* pWorkingDirectory,
            _In_opt_ DkmString* pEnvironment,
            _In_opt_ Start::DkmProcessStartupInfo* pStartupInfo,
            _In_ Start::DkmProcessLaunchModeFlags_t ModeFlags,
            _In_ UINT32 Win32Flags,
            _In_ DefaultPort::DkmTransportConnection* pConnection,
            _In_opt_ DkmEngineSettings* pEngineSettings,
            _In_ Start::DkmDebugLaunchSettings* pDebugLaunchSettings,
            _In_ const DkmDataItem& DataItem,
            _Deref_out_ Start::DkmProcessLaunchRequest** ppCreatedObject
            );

        /// <summary>
        /// Create a new DkmProcessLaunchRequest object instance. The caller is responsible
        /// for closing the created object after they are done.
        ///
        /// This API was introduced in Visual Studio 14 RTM (DkmApiVersion.VS14RTM).
        /// </summary>
        /// <param name="pFileName">
        /// [In] Path to the executable file to launch.
        /// </param>
        /// <param name="pArguments">
        /// [In,Optional] Arguments to pass to the executable file on the command line.
        /// </param>
        /// <param name="pWorkingDirectory">
        /// [In] The full path to the current directory for the process. The string can also
        /// specify a UNC path.
        /// </param>
        /// <param name="pEnvironment">
        /// [In,Optional] A pointer to the environment block for the new process. If this
        /// parameter is NULL, the new process uses the environment of the calling process.
        ///
        /// An environment block consists of a null-terminated block of null-terminated
        /// strings. Each string is in the following form: 'name=value\0'. Because the equal
        /// sign is used as a separator, it must not be used in the name of an environment
        /// variable.
        /// </param>
        /// <param name="pStartupInfo">
        /// [In,Optional] Additional information used to launch a new process. This
        /// information is contained within the 'STARTUPINFO' structure in Win32.
        /// </param>
        /// <param name="ModeFlags">
        /// [In] Flag traits of a DkmProcessLaunchRequest.
        /// </param>
        /// <param name="Win32Flags">
        /// [In] Win32 process creation flags used when launching the process. For example,
        /// CREATE_NO_WINDOW (0x08000000) could be passed to disable the creation of the
        /// console window. The following flags should never be passed, and the behavior is
        /// undefined if they are present: DEBUG_PROCESS, DEBUG_ONLY_THIS_PROCESS,
        /// CREATE_SUSPENDED, EXTENDED_STARTUPINFO_PRESENT, CREATE_SEPARATE_WOW_VDM,
        /// CREATE_SHARED_WOW_VDM, and CREATE_UNICODE_ENVIRONMENT.
        /// </param>
        /// <param name="pConnection">
        /// [In] This represents a connection between the monitor and the IDE. It can either
        /// be a local connection if the monitor is running in the same process as the IDE,
        /// or it can be a remote connection. In the monitor process, there is only one
        /// connection.
        /// </param>
        /// <param name="pEngineSettings">
        /// [In,Optional] Settings to use when launching this executable under the debugger.
        /// This may be omitted if the process is not being launched under the debugger (ex:
        /// Ctrl-F5).
        /// </param>
        /// <param name="pDebugLaunchSettings">
        /// [In] Settings supplied during a start debugging operation from a project system
        /// or other caller of LaunchDebugTargets (or various other start debugging APIs).
        /// </param>
        /// <param name="LaunchFlags">
        /// [In] Flags associated with a request to launch a process.
        /// </param>
        /// <param name="DataItem">
        /// [In] Data object to add to the new DkmProcessLaunchRequest instance.
        /// DkmDataItem::Null() in the case that the caller doesn't need to add a data item.
        /// </param>
        /// <param name="ppCreatedObject">
        /// [Out] Result of this method call.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ DkmString* pFileName,
            _In_opt_ DkmString* pArguments,
            _In_ DkmString* pWorkingDirectory,
            _In_opt_ DkmString* pEnvironment,
            _In_opt_ Start::DkmProcessStartupInfo* pStartupInfo,
            _In_ Start::DkmProcessLaunchModeFlags_t ModeFlags,
            _In_ UINT32 Win32Flags,
            _In_ DefaultPort::DkmTransportConnection* pConnection,
            _In_opt_ DkmEngineSettings* pEngineSettings,
            _In_ Start::DkmDebugLaunchSettings* pDebugLaunchSettings,
            _In_ Start::DkmProcessLaunchFlags_t LaunchFlags,
            _In_ const DkmDataItem& DataItem,
            _Deref_out_ Start::DkmProcessLaunchRequest** ppCreatedObject
            );

        /// <summary>
        /// This API is remote-able version of the Win32 CreateProcess API. The
        /// implementation will merge the environment block, process command line redirection
        /// and launch the process. Unless the NoDebug flag is used, CreateProcess will use
        /// the DEBUG_PROCESS flag when creating the Win32 process.
        /// </summary>
        /// <param name="AdditionalWin32Flags">
        /// [In] Win32 process creation flags in addition to those found in the
        /// DkmProcessLaunchRequest.Win32Flags. This is often used to pass DEBUG_PROCESS
        /// (0x1), DEBUG_ONLY_THIS_PROCESS (0x2), or CREATE_SUSPENDED (0x4).
        /// </param>
        /// <param name="pLaunchedProcess">
        /// [Out] DkmLaunchedProcessInfo is returned from APIs that launch a process.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE LaunchProcess(
            _In_ UINT32 AdditionalWin32Flags,
            _Out_ Start::DkmLaunchedProcessInfo* pLaunchedProcess
            );

        /// <summary>
        /// This API is used to resume a process which was launched from CreateProcess with
        /// the LaunchSuspended flag set to true.
        /// </summary>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ResumeProcess(
            );

        /// <summary>
        /// Causes the debug monitor to create a new process under the debugger. The process
        /// should be left suspended until ResumeDebuggedProcess is called. The debug monitor
        /// must wait for ResumeDebuggedProcess before creating the DkmProcess object since
        /// it needs the UniqueProcessId value from the AD7 Layer.
        ///
        /// Note that this method may only be called in response to the Visual Studio
        /// debugger package requesting a launch. Components that wish to launch another
        /// process under the debugger should send a custom event to a visual studio package.
        /// From a package, a launch can be requested through the
        /// IVsDebugger.LaunchDebugTargets API.
        /// </summary>
        /// <param name="pLaunchedProcess">
        /// [Out] DkmLaunchedProcessInfo is returned from APIs that launch a process.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE LaunchDebuggedProcess(
            _Out_ Start::DkmLaunchedProcessInfo* pLaunchedProcess
            );

        /// <summary>
        /// Causes the debug monitor to resume a launched process and create the DkmProcess
        /// object. The DkmProcess object will be created on the event thread and creating
        /// the object will send a process create event.
        ///
        /// Note that this method may only be called in response to the Visual Studio
        /// debugger package requesting a launch. Components that wish to launch another
        /// process under the debugger should send a custom event to a visual studio package.
        /// From a package, a launch can be requested through the
        /// IVsDebugger.LaunchDebugTargets API.
        /// </summary>
        /// <param name="UniqueProcessId">
        /// [In] Value to assign to the 'DkmProcess.UniqueId' field. This Guid is generated
        /// by the port, and is used to uniquely identifies the process object.
        /// </param>
        /// <param name="ppProcess">
        /// [Out] DkmProcess represents a target process which is being debugged. The
        /// debugger debugs processes, so this is the basic unit of debugging. A DkmProcess
        /// can represent a system process or a virtual process such as minidumps.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ResumeDebuggedProcess(
            _In_ const GUID& UniqueProcessId,
            _Deref_out_ DkmProcess** ppProcess
            );
    }; // end of DkmProcessLaunchRequest

    // Additional information used to launch a new process. This information is contained
    // within the 'STARTUPINFO' structure in Win32.
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("9e5881db-f4be-b1eb-2ba5-ed18f73a7979") DkmProcessStartupInfo : public IUnknown
    {
        private: ___ReferenceCount_t m_ReferenceCount;
        private: DkmDispatcherObjectFlags_t m_ObjectFlags;
        private: const GUID* m_pTypeId;
        private: size_t m_ObjectGCHandle;
        // Use DkmProcessStartupInfo::Create to create this object
        private: DkmProcessStartupInfo();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmProcessStartupInfo();
        // This object cannot be copied
        private: DkmProcessStartupInfo& operator=(const DkmProcessStartupInfo&);
        private: DkmProcessStartupInfo(const DkmProcessStartupInfo&);

        private: OPTIONAL DkmString* const m_pDesktop;
        private: OPTIONAL DkmString* const m_pTitle;
        private: const UINT32 m_X;
        private: const UINT32 m_Y;
        private: const UINT32 m_XSize;
        private: const UINT32 m_YSize;
        private: const UINT32 m_XCountChars;
        private: const UINT32 m_YCountChars;
        private: const UINT32 m_FillAttribute;
        private: const UINT32 m_Flags;
        private: const UINT16 m_ShowWindow;
        private: const UINT64 m_StdInputHandle;
        private: const UINT64 m_StdOutputHandle;
        private: const UINT64 m_StdErrorHandle;
        private: void* m__pExtendedData;

        // [Optional] The name of the desktop, or the name of both the desktop and window
        // station for this process. A backslash in the string indicates that the string
        // includes both the desktop and window station names. For more information, see
        // Thread Connection to a Desktop.
        public: _Ret_opt_ DECLSPEC_NOTHROW DkmString* STDMETHODCALLTYPE Desktop(
            );

        // [Optional] For console processes, this is the title displayed in the title bar if
        // a new console window is created. If NULL, the name of the executable file is used
        // as the window title instead. This parameter must be NULL for GUI or console
        // processes that do not create a new console window.
        public: _Ret_opt_ DECLSPEC_NOTHROW DkmString* STDMETHODCALLTYPE Title(
            );

        // If 'Flags' specifies STARTF_USEPOSITION, this member is the x offset of the upper
        // left corner of a window if a new window is created, in pixels. Otherwise, this
        // member is ignored.
        public: DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE X(
            );

        // If 'Flags' specifies STARTF_USEPOSITION, this member is the y offset of the upper
        // left corner of a window if a new window is created, in pixels. Otherwise, this
        // member is ignored.
        public: DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE Y(
            );

        // If 'Flags' specifies STARTF_USESIZE, this member is the width of the window if a
        // new window is created, in pixels. Otherwise, this member is ignored.
        public: DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE XSize(
            );

        // If 'Flags' specifies STARTF_USESIZE, this member is the height of the window if a
        // new window is created, in pixels. Otherwise, this member is ignored.
        public: DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE YSize(
            );

        // If 'Flags' specifies STARTF_USECOUNTCHARS, if a new console window is created in a
        // console process, this member specifies the screen buffer width, in character
        // columns. Otherwise, this member is ignored.
        public: DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE XCountChars(
            );

        // If 'Flags' specifies STARTF_USECOUNTCHARS, if a new console window is created in a
        // console process, this member specifies the screen buffer height, in character
        // rows. Otherwise, this member is ignored.
        public: DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE YCountChars(
            );

        // If 'Flags' specifies STARTF_USEFILLATTRIBUTE, this member is the initial text and
        // background colors if a new console window is created in a console application.
        // Otherwise, this member is ignored.
        public: DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE FillAttribute(
            );

        // 'STARTF_*' flags for this request. More information can be found in Win32
        // documentation under 'STARTUPINFO.dwFlags'.
        public: DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE Flags(
            );

        // If 'Flags' specifies STARTF_USESHOWWINDOW, this member can be any of the values
        // that can be specified in the nCmdShow parameter for the ShowWindow function,
        // except for SW_SHOWDEFAULT. Otherwise, this member is ignored.
        public: DECLSPEC_NOTHROW UINT16 STDMETHODCALLTYPE ShowWindow(
            );

        // If 'Flags' specifies STARTF_USESTDHANDLES, this member is the standard input
        // handle for the process. Otherwise, this value should be zero.
        public: DECLSPEC_NOTHROW UINT64 STDMETHODCALLTYPE StdInputHandle(
            );

        // If 'Flags' specifies STARTF_USESTDHANDLES, this member is the standard output
        // handle for the process. Otherwise, this value should be zero.
        public: DECLSPEC_NOTHROW UINT64 STDMETHODCALLTYPE StdOutputHandle(
            );

        // If 'Flags' specifies STARTF_USESTDHANDLES, this member is the standard error
        // handle for the process. Otherwise, this value should be zero.
        public: DECLSPEC_NOTHROW UINT64 STDMETHODCALLTYPE StdErrorHandle(
            );

        /// <summary>
        /// Create a new DkmProcessStartupInfo object instance.
        /// </summary>
        /// <param name="pDesktop">
        /// [In,Optional] The name of the desktop, or the name of both the desktop and window
        /// station for this process. A backslash in the string indicates that the string
        /// includes both the desktop and window station names. For more information, see
        /// Thread Connection to a Desktop.
        /// </param>
        /// <param name="pTitle">
        /// [In,Optional] For console processes, this is the title displayed in the title bar
        /// if a new console window is created. If NULL, the name of the executable file is
        /// used as the window title instead. This parameter must be NULL for GUI or console
        /// processes that do not create a new console window.
        /// </param>
        /// <param name="X">
        /// [In] If 'Flags' specifies STARTF_USEPOSITION, this member is the x offset of the
        /// upper left corner of a window if a new window is created, in pixels. Otherwise,
        /// this member is ignored.
        /// </param>
        /// <param name="Y">
        /// [In] If 'Flags' specifies STARTF_USEPOSITION, this member is the y offset of the
        /// upper left corner of a window if a new window is created, in pixels. Otherwise,
        /// this member is ignored.
        /// </param>
        /// <param name="XSize">
        /// [In] If 'Flags' specifies STARTF_USESIZE, this member is the width of the window
        /// if a new window is created, in pixels. Otherwise, this member is ignored.
        /// </param>
        /// <param name="YSize">
        /// [In] If 'Flags' specifies STARTF_USESIZE, this member is the height of the window
        /// if a new window is created, in pixels. Otherwise, this member is ignored.
        /// </param>
        /// <param name="XCountChars">
        /// [In] If 'Flags' specifies STARTF_USECOUNTCHARS, if a new console window is
        /// created in a console process, this member specifies the screen buffer width, in
        /// character columns. Otherwise, this member is ignored.
        /// </param>
        /// <param name="YCountChars">
        /// [In] If 'Flags' specifies STARTF_USECOUNTCHARS, if a new console window is
        /// created in a console process, this member specifies the screen buffer height, in
        /// character rows. Otherwise, this member is ignored.
        /// </param>
        /// <param name="FillAttribute">
        /// [In] If 'Flags' specifies STARTF_USEFILLATTRIBUTE, this member is the initial
        /// text and background colors if a new console window is created in a console
        /// application. Otherwise, this member is ignored.
        /// </param>
        /// <param name="Flags">
        /// [In] 'STARTF_*' flags for this request. More information can be found in Win32
        /// documentation under 'STARTUPINFO.dwFlags'.
        /// </param>
        /// <param name="ShowWindow">
        /// [In] If 'Flags' specifies STARTF_USESHOWWINDOW, this member can be any of the
        /// values that can be specified in the nCmdShow parameter for the ShowWindow
        /// function, except for SW_SHOWDEFAULT. Otherwise, this member is ignored.
        /// </param>
        /// <param name="StdInputHandle">
        /// [In] If 'Flags' specifies STARTF_USESTDHANDLES, this member is the standard input
        /// handle for the process. Otherwise, this value should be zero.
        /// </param>
        /// <param name="StdOutputHandle">
        /// [In] If 'Flags' specifies STARTF_USESTDHANDLES, this member is the standard
        /// output handle for the process. Otherwise, this value should be zero.
        /// </param>
        /// <param name="StdErrorHandle">
        /// [In] If 'Flags' specifies STARTF_USESTDHANDLES, this member is the standard error
        /// handle for the process. Otherwise, this value should be zero.
        /// </param>
        /// <param name="ppCreatedObject">
        /// [Out] Result of this method call.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_opt_ DkmString* pDesktop,
            _In_opt_ DkmString* pTitle,
            _In_ UINT32 X,
            _In_ UINT32 Y,
            _In_ UINT32 XSize,
            _In_ UINT32 YSize,
            _In_ UINT32 XCountChars,
            _In_ UINT32 YCountChars,
            _In_ UINT32 FillAttribute,
            _In_ UINT32 Flags,
            _In_ UINT16 ShowWindow,
            _In_ UINT64 StdInputHandle,
            _In_ UINT64 StdOutputHandle,
            _In_ UINT64 StdErrorHandle,
            _Deref_out_ Start::DkmProcessStartupInfo** ppCreatedObject
            );
    }; // end of DkmProcessStartupInfo

    // DkmStartMethod describes how the debug engine started debugging this process.
    DEFINE_SCOPED_ENUM(DkmStartMethod)
    {
        // Process was launched under the debugger.
        Launch = 0,
        // Process was launched outside the debugger and the debugger attached.
        Attach = 1,
        // Process was launched suspended by the project system or SDM. Then the engine was
        // asked to attach to the process while the process was still at the initial
        // suspension point. This is used for Low-rights IE (LoRIE).
        AttachForSuspendedLaunch = 2,
        // Hosting process was launched by the project system and then the project system
        // asked the debugger to attach to the process.
        AttachForHostingLaunch = 3
    };

}; // end namespace Start

// Contains types used to perform the basic, generally pre-debugging, tasks on the target
// computer such as listing processes, deploying files, etc.
namespace DefaultPort {
    // Result of an asynchronous DkmTransportConnection.ActivateBackgroundTask call.
    struct DkmActivateBackgroundTaskAsyncResult
    {
        // HRESULT code returned from the caller. This will be
        // DkmExceptionCode.COR_E_OPERATIONCANCELED (0x8013153B) if the operation was
        // canceled before processing was complete.
        HRESULT ErrorCode;
    };

    // Identifies a Windows Store app package or Windows Phone app package.
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("40f5e02e-bbc4-3b2a-5595-51d3208fb72f") DkmAppPackageId : public IUnknown
    {
        private: ___ReferenceCount_t m_ReferenceCount;
        private: DkmDispatcherObjectFlags_t m_ObjectFlags;
        private: const GUID* m_pTypeId;
        private: size_t m_ObjectGCHandle;
        // Use DkmAppPackageId::Create to create this object
        private: DkmAppPackageId();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmAppPackageId();
        // This object cannot be copied
        private: DkmAppPackageId& operator=(const DkmAppPackageId&);
        private: DkmAppPackageId(const DkmAppPackageId&);

        private: const DefaultPort::DkmPackagedAppPlatform_t m_AppPlatform;
        private: DkmString* const m_pFullName;
        private: void* m__pExtendedData;

        // Indicates if the specified application package is a Windows Phone or Windows Store
        // app.
        public: DECLSPEC_NOTHROW DefaultPort::DkmPackagedAppPlatform_t STDMETHODCALLTYPE AppPlatform(
            );

        // The full name of the application. For DkmApplicationPlatform.WindowsAppx, this is
        // the package full name.
        public: _Ret_ DECLSPEC_NOTHROW DkmString* STDMETHODCALLTYPE FullName(
            );

        /// <summary>
        /// Create a new DkmAppPackageId object instance.
        /// </summary>
        /// <param name="AppPlatform">
        /// [In] Indicates if the specified application package is a Windows Phone or Windows
        /// Store app.
        /// </param>
        /// <param name="pFullName">
        /// [In] The full name of the application. For DkmApplicationPlatform.WindowsAppx,
        /// this is the package full name.
        /// </param>
        /// <param name="ppCreatedObject">
        /// [Out] Result of this method call.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ DefaultPort::DkmPackagedAppPlatform_t AppPlatform,
            _In_ DkmString* pFullName,
            _Deref_out_ DefaultPort::DkmAppPackageId** ppCreatedObject
            );
    }; // end of DkmAppPackageId

    // Object representing an arbitrary executable which is executed on the target computer.
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("301484b2-442b-a6f7-f258-48db3d9d121a") DkmDeploymentCommand : public DkmDataContainer
    {
        // Use DkmDeploymentCommand::Create to create this object
        private: DkmDeploymentCommand();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmDeploymentCommand();
        // This object cannot be copied
        private: DkmDeploymentCommand& operator=(const DkmDeploymentCommand&);
        private: DkmDeploymentCommand(const DkmDeploymentCommand&);

        private: const GUID m_UniqueId;
        private: DefaultPort::DkmTransportConnection* const m_pConnection;
        private: const GUID m_SourceId;
        private: DkmString* const m_pRemoteExecutable;
        private: OPTIONAL DkmString* const m_pArguments;
        private: OPTIONAL DkmString* const m_pCurrentDirectory;
        private: const DefaultPort::DkmDeploymentCommandFlags_t m_Flags;
        private: void* m__pExtendedData;

        // Guid which uniquely identifies this object.
        public: DECLSPEC_NOTHROW const GUID& STDMETHODCALLTYPE UniqueId(
            );

        // Transport connection to the target where the command should execute.
        public: _Ret_ DECLSPEC_NOTHROW DefaultPort::DkmTransportConnection* STDMETHODCALLTYPE Connection(
            );

        // Identifies the source of an object. SourceIds are used to enable filtering in
        // scenarios when multiple components may be creating instances of a class. For
        // example, source ids can be used to determine if a breakpoint comes from the AD7 AL
        // (ex: user breakpoint, or other breakpoint visible at the SDM level) instead of a
        // breakpoint which may be created by another component (for example an internal
        // breakpoint used for stepping).
        public: DECLSPEC_NOTHROW const GUID& STDMETHODCALLTYPE SourceId(
            );

        // Path to the remote executable. Environment variables will be expanded (ex:
        // %TMP%\mycommand.exe). If this is not a full path, the remote debugger will look
        // next to itself, and then search the PATH environment variable.
        public: _Ret_ DECLSPEC_NOTHROW DkmString* STDMETHODCALLTYPE RemoteExecutable(
            );

        // [Optional] Arguments to pass to the remote command. This value may be null to pass
        // no arguments.
        public: _Ret_opt_ DECLSPEC_NOTHROW DkmString* STDMETHODCALLTYPE Arguments(
            );

        // [Optional] Initial current directory for the target process. This value may be
        // null to use the directory of the remote debugger.
        public: _Ret_opt_ DECLSPEC_NOTHROW DkmString* STDMETHODCALLTYPE CurrentDirectory(
            );

        // Flags effecting the processing of deployment commands.
        public: DECLSPEC_NOTHROW DefaultPort::DkmDeploymentCommandFlags_t STDMETHODCALLTYPE Flags(
            );

        /// <summary>
        /// Closes the deployment command object. This should be called by the creator of the
        /// DkmDeploymentCommand object after execution has completed
        /// (IDkmDeploymentCommandCallback.OnProcessExit is called).
        ///
        /// DkmDeploymentCommand objects are automatically closed when their associated
        /// DkmTransportConnection object is closed.
        ///
        /// This method may only be called by the component which created the object.
        /// </summary>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Close(
            );

        /// <summary>
        /// Creates a new DkmDeploymentCommand object. The command will not begin executing
        /// until Start is called. The caller is responsible for closing the created object
        /// after they are done.
        /// </summary>
        /// <param name="pConnection">
        /// [In] Transport connection to the target where the command should execute.
        /// </param>
        /// <param name="SourceId">
        /// [In] Identifies the source of an object. SourceIds are used to enable filtering
        /// in scenarios when multiple components may be creating instances of a class. For
        /// example, source ids can be used to determine if a breakpoint comes from the AD7
        /// AL (ex: user breakpoint, or other breakpoint visible at the SDM level) instead of
        /// a breakpoint which may be created by another component (for example an internal
        /// breakpoint used for stepping).
        /// </param>
        /// <param name="pRemoteExecutable">
        /// [In] Path to the remote executable. Environment variables will be expanded (ex:
        /// %TMP%\mycommand.exe). If this is not a full path, the remote debugger will look
        /// next to itself, and then search the PATH environment variable.
        /// </param>
        /// <param name="pArguments">
        /// [In,Optional] Arguments to pass to the remote command. This value may be null to
        /// pass no arguments.
        /// </param>
        /// <param name="pCurrentDirectory">
        /// [In,Optional] Initial current directory for the target process. This value may be
        /// null to use the directory of the remote debugger.
        /// </param>
        /// <param name="Flags">
        /// [In] Flags effecting the processing of deployment commands.
        /// </param>
        /// <param name="DataItem">
        /// [In] Data object to add to the new DkmDeploymentCommand instance.
        /// DkmDataItem::Null() in the case that the caller doesn't need to add a data item.
        /// </param>
        /// <param name="ppCreatedObject">
        /// [Out] Result of this method call.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ DefaultPort::DkmTransportConnection* pConnection,
            _In_ const GUID& SourceId,
            _In_ DkmString* pRemoteExecutable,
            _In_opt_ DkmString* pArguments,
            _In_opt_ DkmString* pCurrentDirectory,
            _In_ DefaultPort::DkmDeploymentCommandFlags_t Flags,
            _In_ const DkmDataItem& DataItem,
            _Deref_out_ DefaultPort::DkmDeploymentCommand** ppCreatedObject
            );

        #ifndef EXCLUDE_MONITOR_ONLY_APIS
        /// <summary>
        /// Indication that the launched command has completed. After this is received, no
        /// further notifications will be sent.
        ///
        /// Location constraint: API must be called from a Monitor component (component level
        /// &lt; 100,000).
        /// </summary>
        /// <param name="ExitCode">
        /// [In] 32-bit value which the processed returned on exit. This is the same value
        /// that would be reported from the kernel32!GetExitCodeProcess.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE OnProcessExit(
            _In_ UINT32 ExitCode
            );
        #endif // #ifndef EXCLUDE_MONITOR_ONLY_APIS

        #ifndef EXCLUDE_MONITOR_ONLY_APIS
        /// <summary>
        /// Indication that the target wrote to stdout. This is also used for StdErr if the
        /// DkmDeploymentCommandFlags.CombineStdErr flag is used.
        ///
        /// Location constraint: API must be called from a Monitor component (component level
        /// &lt; 100,000).
        /// </summary>
        /// <param name="pText">
        /// [In] Text written to stdout.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE OnStdOut(
            _In_ DkmString* pText
            );
        #endif // #ifndef EXCLUDE_MONITOR_ONLY_APIS

        #ifndef EXCLUDE_MONITOR_ONLY_APIS
        /// <summary>
        /// Indication that the target wrote to stderr. This will not be used if the
        /// DkmDeploymentCommandFlags.CombineStdErr flag is used. Note that the output from
        /// stderr and stdout is not synchronized, so if a program writes to stdout before
        /// stderr, a listener may still get the stderr output first (or vice versa).
        ///
        /// Location constraint: API must be called from a Monitor component (component level
        /// &lt; 100,000).
        /// </summary>
        /// <param name="pText">
        /// [In] Text written to stderr.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE OnStdErr(
            _In_ DkmString* pText
            );
        #endif // #ifndef EXCLUDE_MONITOR_ONLY_APIS

        /// <summary>
        /// Begin execution of the deployment command. This method will return once the
        /// deployed command has begun execution. Callers of this method would typically
        /// implement IDkmDeploymentCommandCallback with a SourceId filter to receive
        /// information about the command.
        /// </summary>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Start(
            );

        /// <summary>
        /// Abort execution of the command by terminating the launched process. If
        /// successful, this will cause IDkmDeploymentCommandCallback.OnProcessExit to be
        /// called.
        /// </summary>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Abort(
            );
    }; // end of DkmDeploymentCommand

    // Flags effecting the processing of deployment commands.
    DEFINE_SCOPED_ENUM(DkmDeploymentCommandFlags)
    {
        // No flags are set.
        Default = 0x0,
        // Launched program writes to StdOut/StdErr with the target computer's console code
        // page rather than Unicode (UTF-16).
        ConsoleCodePage = 0x1,
        // Combine StdErr with StdOut. When this flag is set,
        // IDkmDeploymentCommandCallback.OnStdErr will not be called. This is helpful to
        // synchronize StdErr/StdOut content.
        CombineStdErr = 0x2,
        // Show the UI for the executed command instead of running hidden.
        ShowUI = 0x4
    };
    DEFINE_SCOPED_ENUM_FLAG_OPERATORS(DkmDeploymentCommandFlags_t);

    // The device information for current system, available for Windows 10 or later. This
    // includes the physical form factor of the device, and the OS family and version number
    // of the operating system.
    //
    // This API was introduced in Visual Studio 14 RTM (DkmApiVersion.VS14RTM).
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("64bdfd1a-cb8a-31dc-a97d-b3e15116885a") DkmDeviceInfo : public IUnknown
    {
        private: ___ReferenceCount_t m_ReferenceCount;
        private: DkmDispatcherObjectFlags_t m_ObjectFlags;
        private: const GUID* m_pTypeId;
        private: size_t m_ObjectGCHandle;
        // Use DkmDeviceInfo::Create to create this object
        private: DkmDeviceInfo();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmDeviceInfo();
        // This object cannot be copied
        private: DkmDeviceInfo& operator=(const DkmDeviceInfo&);
        private: DkmDeviceInfo(const DkmDeviceInfo&);

        private: DkmString* const m_pDeviceFamily;
        private: DkmString* const m_pDeviceFamilyVersion;
        private: DkmString* const m_pDeviceForm;
        private: void* m__pExtendedData;

        // The family of the device, say Windows.Universal, Windows.Server, Windows.Xbox,
        // Windows.IoT, or many others.
        //
        // This API was introduced in Visual Studio 14 RTM (DkmApiVersion.VS14RTM).
        public: _Ret_ DECLSPEC_NOTHROW DkmString* STDMETHODCALLTYPE DeviceFamily(
            );

        // The version number of the Operating System running on the device.
        //
        // This API was introduced in Visual Studio 14 RTM (DkmApiVersion.VS14RTM).
        public: _Ret_ DECLSPEC_NOTHROW DkmString* STDMETHODCALLTYPE DeviceFamilyVersion(
            );

        // The physical form of the device, say Phone, Tablet, Desktop, Notebook, or many
        // others.
        //
        // This API was introduced in Visual Studio 14 RTM (DkmApiVersion.VS14RTM).
        public: _Ret_ DECLSPEC_NOTHROW DkmString* STDMETHODCALLTYPE DeviceForm(
            );

        /// <summary>
        /// Create a new DkmDeviceInfo object instance.
        ///
        /// This API was introduced in Visual Studio 14 RTM (DkmApiVersion.VS14RTM).
        /// </summary>
        /// <param name="pDeviceFamily">
        /// [In] The family of the device, say Windows.Universal, Windows.Server,
        /// Windows.Xbox, Windows.IoT, or many others.
        /// </param>
        /// <param name="pDeviceFamilyVersion">
        /// [In] The version number of the Operating System running on the device.
        /// </param>
        /// <param name="pDeviceForm">
        /// [In] The physical form of the device, say Phone, Tablet, Desktop, Notebook, or
        /// many others.
        /// </param>
        /// <param name="ppCreatedObject">
        /// [Out] Result of this method call.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ DkmString* pDeviceFamily,
            _In_ DkmString* pDeviceFamilyVersion,
            _In_ DkmString* pDeviceForm,
            _Deref_out_ DefaultPort::DkmDeviceInfo** ppCreatedObject
            );
    }; // end of DkmDeviceInfo

    #ifndef EXCLUDE_IDE_ONLY_APIS
    // Result of an asynchronous DkmTransportConnection.DownloadFile call.
    struct DkmDownloadFileAsyncResult
    {
        // HRESULT code returned from the caller. This will be
        // DkmExceptionCode.COR_E_OPERATIONCANCELED (0x8013153B) if the operation was
        // canceled before processing was complete.
        HRESULT ErrorCode;
    };
    #endif // #ifndef EXCLUDE_IDE_ONLY_APIS

    // Result of an asynchronous DkmTransportConnection.EnumerateBackgroundTasks call.
    struct DkmEnumerateBackgroundTasksAsyncResult
    {
        // HRESULT code returned from the caller. This will be
        // DkmExceptionCode.COR_E_OPERATIONCANCELED (0x8013153B) if the operation was
        // canceled before processing was complete.
        HRESULT ErrorCode;

        // Background task ids (GUIDs).
        DkmArray<GUID> TaskIds;

        // Background task names.
        DkmArray<DkmString*> TaskNames;
    };

    // Contains basic information about a file which is returned from
    // DefaultPort.DkmTransportConnection.GetFileListing.
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("c255d11c-e40f-9be0-11ac-0f5da8427782") DkmFileInfo : public IUnknown
    {
        private: ___ReferenceCount_t m_ReferenceCount;
        private: DkmDispatcherObjectFlags_t m_ObjectFlags;
        private: const GUID* m_pTypeId;
        private: size_t m_ObjectGCHandle;
        // Use DkmFileInfo::Create to create this object
        private: DkmFileInfo();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmFileInfo();
        // This object cannot be copied
        private: DkmFileInfo& operator=(const DkmFileInfo&);
        private: DkmFileInfo(const DkmFileInfo&);

        private: DkmString* const m_pFileName;
        private: DkmString* const m_pFilePath;
        private: const UINT32 m_Attributes;
        private: const UINT64 m_CreationTime;
        private: const UINT64 m_LastAccessTime;
        private: const UINT64 m_LastWriteTime;
        private: const UINT64 m_FileSize;
        private: void* m__pExtendedData;

        // Name of the file or sub directory. This name does not contain the directory (ex:
        // example.txt instead of c:\folder\example.txt).
        public: _Ret_ DECLSPEC_NOTHROW DkmString* STDMETHODCALLTYPE FileName(
            );

        // Full path to the file or sub directory (ex: c:\folder\example.txt).
        public: _Ret_ DECLSPEC_NOTHROW DkmString* STDMETHODCALLTYPE FilePath(
            );

        // Win32 File attribute values (ex: FILE_ATTRIBUTE_DIRECTORY (0x10)).
        public: DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE Attributes(
            );

        // Time the the file was created in FILETIME units (number of 100-nanosecond
        // intervals since January 1, 1601 (UTC)).
        public: DECLSPEC_NOTHROW UINT64 STDMETHODCALLTYPE CreationTime(
            );

        // Time the file was accessed in FILETIME units (number of 100-nanosecond intervals
        // since January 1, 1601 (UTC)).
        public: DECLSPEC_NOTHROW UINT64 STDMETHODCALLTYPE LastAccessTime(
            );

        // Time the file was written to in FILETIME units (number of 100-nanosecond intervals
        // since January 1, 1601 (UTC)).
        public: DECLSPEC_NOTHROW UINT64 STDMETHODCALLTYPE LastWriteTime(
            );

        // Size of the file in bytes.
        public: DECLSPEC_NOTHROW UINT64 STDMETHODCALLTYPE FileSize(
            );

        /// <summary>
        /// Create a new DkmFileInfo object instance.
        /// </summary>
        /// <param name="pFileName">
        /// [In] Name of the file or sub directory. This name does not contain the directory
        /// (ex: example.txt instead of c:\folder\example.txt).
        /// </param>
        /// <param name="pFilePath">
        /// [In] Full path to the file or sub directory (ex: c:\folder\example.txt).
        /// </param>
        /// <param name="Attributes">
        /// [In] Win32 File attribute values (ex: FILE_ATTRIBUTE_DIRECTORY (0x10)).
        /// </param>
        /// <param name="CreationTime">
        /// [In] Time the the file was created in FILETIME units (number of 100-nanosecond
        /// intervals since January 1, 1601 (UTC)).
        /// </param>
        /// <param name="LastAccessTime">
        /// [In] Time the file was accessed in FILETIME units (number of 100-nanosecond
        /// intervals since January 1, 1601 (UTC)).
        /// </param>
        /// <param name="LastWriteTime">
        /// [In] Time the file was written to in FILETIME units (number of 100-nanosecond
        /// intervals since January 1, 1601 (UTC)).
        /// </param>
        /// <param name="FileSize">
        /// [In] Size of the file in bytes.
        /// </param>
        /// <param name="ppCreatedObject">
        /// [Out] Result of this method call.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ DkmString* pFileName,
            _In_ DkmString* pFilePath,
            _In_ UINT32 Attributes,
            _In_ UINT64 CreationTime,
            _In_ UINT64 LastAccessTime,
            _In_ UINT64 LastWriteTime,
            _In_ UINT64 FileSize,
            _Deref_out_ DefaultPort::DkmFileInfo** ppCreatedObject
            );
    }; // end of DkmFileInfo

    // Represents a file stream which can be used to transfer a large file over the remote
    // debugger connection.
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("cfeabf40-7ab2-7d44-c16d-ef23d4579e8c") DkmFileTransferStream : public DkmDataContainer
    {
        // Use DkmFileTransferStream::Create to create this object
        private: DkmFileTransferStream();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmFileTransferStream();
        // This object cannot be copied
        private: DkmFileTransferStream& operator=(const DkmFileTransferStream&);
        private: DkmFileTransferStream(const DkmFileTransferStream&);

        private: const GUID m_UniqueId;
        private: DefaultPort::DkmTransportConnection* const m_pConnection;
        private: DkmString* const m_pRemoteFilePath;
        private: void* m__pExtendedData;

        // Guid which uniquely identifies this object.
        public: DECLSPEC_NOTHROW const GUID& STDMETHODCALLTYPE UniqueId(
            );

        // Transport connection over which the file will be transferred.
        public: _Ret_ DECLSPEC_NOTHROW DefaultPort::DkmTransportConnection* STDMETHODCALLTYPE Connection(
            );

        // Path to the file being transferred. Environment variables will be expanded (ex:
        // %TMP%\deploy.txt). The path must be a full path to the file.
        public: _Ret_ DECLSPEC_NOTHROW DkmString* STDMETHODCALLTYPE RemoteFilePath(
            );

        /// <summary>
        /// Closes the file transfer object. This will close the underlying file handle if it
        /// is not already closed because all the bytes have been transferred. This method
        /// must be called by the component which created the file file transfer object.
        ///
        /// DkmFileTransferStream objects are automatically closed when their associated
        /// DkmTransportConnection object is closed.
        ///
        /// This method may only be called by the component which created the object.
        /// </summary>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Close(
            );

        /// <summary>
        /// Creates a new file transfer stream object which is used to represent a file which
        /// is being streamed over the network. Note that the file is not immediately opened
        /// when the object is created. The caller should close the file transfer object when
        /// done. The caller is responsible for closing the created object after they are
        /// done.
        /// </summary>
        /// <param name="pConnection">
        /// [In] Transport connection over which the file will be transferred.
        /// </param>
        /// <param name="pRemoteFilePath">
        /// [In] Path to the file being transferred. Environment variables will be expanded
        /// (ex: %TMP%\deploy.txt). The path must be a full path to the file.
        /// </param>
        /// <param name="DataItem">
        /// [In] Data object to add to the new DkmFileTransferStream instance.
        /// DkmDataItem::Null() in the case that the caller doesn't need to add a data item.
        /// </param>
        /// <param name="ppCreatedObject">
        /// [Out] Result of this method call.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ DefaultPort::DkmTransportConnection* pConnection,
            _In_ DkmString* pRemoteFilePath,
            _In_ const DkmDataItem& DataItem,
            _Deref_out_ DefaultPort::DkmFileTransferStream** ppCreatedObject
            );

        /// <summary>
        /// Begins a remote file write operation. The remote file will be opened and the
        /// bytes from Content will be written to it. If additional bytes beyond what is in
        /// Content should be transferred, then WriteNext should be called to transfer those.
        /// If the directory of this file does not exist, the debugger will attempt to create
        /// it.
        /// </summary>
        /// <param name="Content">
        /// [In] The initial set of bytes to write to the file.
        ///
        /// The memory for the DkmArray members is allocated by the caller, and can be from
        /// any source (stack memory, static buffer, heap, etc). The implementation should
        /// not modify the members.
        /// </param>
        /// <param name="TotalFileSize">
        /// [In] Indicates the number of bytes which will be written to the file. The file
        /// system handle will automatically be closed once this number of bytes has been
        /// received. Attempts to write past this number of bytes will fail. If the
        /// DkmFileTransferStream is closed before this number of bytes is transferred, the
        /// file will be deleted.
        /// </param>
        /// <param name="LastWriteTime">
        /// [In] The date/time to set for when this file was last modified. The format of
        /// this is the same as a Win32 FILETIME structure, which is a 64-bit value
        /// representing the number of 100-nanosecond intervals since January 1, 1601. The
        /// value 0xffffffffffffffff may be used to specify that the current time should be
        /// used.
        /// </param>
        /// <param name="OverwriteExisting">
        /// [In] true if the debugger should attempt to overwrite any existing file. This
        /// will fail if the existing file is read-only.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE WriteFirst(
            _In_ const DkmArray<BYTE>& Content,
            _In_ UINT64 TotalFileSize,
            _In_ UINT64 LastWriteTime,
            _In_ bool OverwriteExisting
            );

        /// <summary>
        /// Writes the next set of bytes to the remote file. This API will fail if WriteFirst
        /// has not already been called on the DkmFileTransferStream.
        /// </summary>
        /// <param name="Content">
        /// [In] The next set of bytes to write to the file.
        ///
        /// The memory for the DkmArray members is allocated by the caller, and can be from
        /// any source (stack memory, static buffer, heap, etc). The implementation should
        /// not modify the members.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE WriteNext(
            _In_ const DkmArray<BYTE>& Content
            );

        /// <summary>
        /// Begins a remote file read operation. The remote file will be opened and bytes up
        /// to the size of the content buffer will be transferred. If the file is too large
        /// to fit into the content buffer, than ReadNext can be called to read the remaining
        /// bytes.
        /// </summary>
        /// <param name="pContentBuffer">
        /// [In,Out] Buffer which receives the starting bytes of the file.
        /// </param>
        /// <param name="BufferSize">
        /// [In] Indicates the size of the content buffer.
        /// </param>
        /// <param name="pBytesRead">
        /// [Out,Optional] Indicates the number of bytes read into the content buffer. This
        /// will be the minimum of the file size and the buffer size.
        /// </param>
        /// <param name="pLastWriteTime">
        /// [Out] The date/time to set for when this file was last modified. The format of
        /// this is the same as a Win32 FILETIME structure, which is a 64-bit value
        /// representing the number of 100-nanosecond intervals since January 1, 1601.
        /// </param>
        /// <param name="pTotalFileSize">
        /// [Out] Indicates the size of the file on disk.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ReadFirst(
            _Out_capcount_(BufferSize) void* pContentBuffer,
            _In_ UINT32 BufferSize,
            _Out_ UINT32* pBytesRead,
            _Out_ UINT64* pLastWriteTime,
            _Out_ UINT64* pTotalFileSize
            );

        /// <summary>
        /// Reads the next set of bytes from the remote file. This API will fail if ReadFirst
        /// has not already been called on the DkmFileTransferStream.
        /// </summary>
        /// <param name="pContentBuffer">
        /// [In,Out] Buffer which receives the next bytes of the file.
        /// </param>
        /// <param name="BufferSize">
        /// [In] Indicates the size of the content buffer.
        /// </param>
        /// <param name="pBytesRead">
        /// [Out,Optional] Indicates the number of bytes read into the content buffer. This
        /// value is the smaller of the number of bytes left in the file (TotalFileSize
        /// returned from ReadFirst minus bytes already returned), and the size of the input
        /// buffer. In pseudo-code: min(TotalFileSize-BytesAlreadyReturned, BufferSize).
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ReadNext(
            _Out_capcount_(BufferSize) void* pContentBuffer,
            _In_ UINT32 BufferSize,
            _Out_ UINT32* pBytesRead
            );
    }; // end of DkmFileTransferStream

    // Identifies an installed Windows Store App Package.
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("686d56ce-05cf-f74b-c723-7b0b4e2cd09d") DkmInstalledAppPackageInfo : public IUnknown
    {
        private: ___ReferenceCount_t m_ReferenceCount;
        private: DkmDispatcherObjectFlags_t m_ObjectFlags;
        private: const GUID* m_pTypeId;
        private: size_t m_ObjectGCHandle;
        // Use DkmInstalledAppPackageInfo::Create to create this object
        private: DkmInstalledAppPackageInfo();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmInstalledAppPackageInfo();
        // This object cannot be copied
        private: DkmInstalledAppPackageInfo& operator=(const DkmInstalledAppPackageInfo&);
        private: DkmInstalledAppPackageInfo(const DkmInstalledAppPackageInfo&);

        private: DefaultPort::DkmAppPackageId* const m_pAppPackageId;
        private: DkmString* const m_pDisplayName;
        private: DkmString* const m_pVersion;
        private: OPTIONAL DkmString* const m_pLogoPath;
        private: OPTIONAL DkmReadOnlyCollection<DefaultPort::DkmInstalledApplicationInfo*>* const m_pApplications;
        private: void* m__pExtendedData;

        // Identifies a Windows Store app package or Windows Phone app package.
        public: _Ret_ DECLSPEC_NOTHROW DefaultPort::DkmAppPackageId* STDMETHODCALLTYPE AppPackageId(
            );

        // The App Package display name.
        public: _Ret_ DECLSPEC_NOTHROW DkmString* STDMETHODCALLTYPE DisplayName(
            );

        // The App Package version.
        public: _Ret_ DECLSPEC_NOTHROW DkmString* STDMETHODCALLTYPE Version(
            );

        // [Optional] The App Package logo path. For remote this will be the path on the
        // remote system.
        public: _Ret_opt_ DECLSPEC_NOTHROW DkmString* STDMETHODCALLTYPE LogoPath(
            );

        // [Optional] Array of applications found in the App Package.
        public: _Ret_opt_ DECLSPEC_NOTHROW DkmReadOnlyCollection<DefaultPort::DkmInstalledApplicationInfo*>* STDMETHODCALLTYPE Applications(
            );

        /// <summary>
        /// Create a new DkmInstalledAppPackageInfo object instance.
        /// </summary>
        /// <param name="pAppPackageId">
        /// [In] Identifies a Windows Store app package or Windows Phone app package.
        /// </param>
        /// <param name="pDisplayName">
        /// [In] The App Package display name.
        /// </param>
        /// <param name="pVersion">
        /// [In] The App Package version.
        /// </param>
        /// <param name="pLogoPath">
        /// [In,Optional] The App Package logo path. For remote this will be the path on the
        /// remote system.
        /// </param>
        /// <param name="pApplications">
        /// [In,Optional] Array of applications found in the App Package.
        /// </param>
        /// <param name="ppCreatedObject">
        /// [Out] Result of this method call.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ DefaultPort::DkmAppPackageId* pAppPackageId,
            _In_ DkmString* pDisplayName,
            _In_ DkmString* pVersion,
            _In_opt_ DkmString* pLogoPath,
            _In_opt_ DkmReadOnlyCollection<DefaultPort::DkmInstalledApplicationInfo*>* pApplications,
            _Deref_out_ DefaultPort::DkmInstalledAppPackageInfo** ppCreatedObject
            );
    }; // end of DkmInstalledAppPackageInfo

    // Identifies an installed Windows Store App.
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("220918fc-b335-72c8-16d2-4bfeaceee181") DkmInstalledApplicationInfo : public IUnknown
    {
        private: ___ReferenceCount_t m_ReferenceCount;
        private: DkmDispatcherObjectFlags_t m_ObjectFlags;
        private: const GUID* m_pTypeId;
        private: size_t m_ObjectGCHandle;
        // Use DkmInstalledApplicationInfo::Create to create this object
        private: DkmInstalledApplicationInfo();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmInstalledApplicationInfo();
        // This object cannot be copied
        private: DkmInstalledApplicationInfo& operator=(const DkmInstalledApplicationInfo&);
        private: DkmInstalledApplicationInfo(const DkmInstalledApplicationInfo&);

        private: DkmString* const m_pAppUserModelId;
        private: DkmString* const m_pDisplayName;
        private: OPTIONAL DkmString* const m_pExecutable;
        private: OPTIONAL DkmString* const m_pSmallLogoPath;
        private: OPTIONAL DkmString* const m_pBackgroundColor;
        private: DkmString* const m_pDescription;
        private: const GUID m_DefaultDebugEngine;
        private: void* m__pExtendedData;

        // The app user model id.
        public: _Ret_ DECLSPEC_NOTHROW DkmString* STDMETHODCALLTYPE AppUserModelId(
            );

        // The application display name.
        public: _Ret_ DECLSPEC_NOTHROW DkmString* STDMETHODCALLTYPE DisplayName(
            );

        // [Optional] The executable name.
        public: _Ret_opt_ DECLSPEC_NOTHROW DkmString* STDMETHODCALLTYPE Executable(
            );

        // [Optional] The application small logo path. For remote this will be the path on
        // the remote system.
        public: _Ret_opt_ DECLSPEC_NOTHROW DkmString* STDMETHODCALLTYPE SmallLogoPath(
            );

        // [Optional] The application background color.
        public: _Ret_opt_ DECLSPEC_NOTHROW DkmString* STDMETHODCALLTYPE BackgroundColor(
            );

        // The application description name.
        public: _Ret_ DECLSPEC_NOTHROW DkmString* STDMETHODCALLTYPE Description(
            );

        // The default debug engine to use for debugging this app.  If unable to determine,
        // the default is native.
        public: DECLSPEC_NOTHROW const GUID& STDMETHODCALLTYPE DefaultDebugEngine(
            );

        /// <summary>
        /// Create a new DkmInstalledApplicationInfo object instance.
        /// </summary>
        /// <param name="pAppUserModelId">
        /// [In] The app user model id.
        /// </param>
        /// <param name="pDisplayName">
        /// [In] The application display name.
        /// </param>
        /// <param name="pExecutable">
        /// [In,Optional] The executable name.
        /// </param>
        /// <param name="pSmallLogoPath">
        /// [In,Optional] The application small logo path. For remote this will be the path
        /// on the remote system.
        /// </param>
        /// <param name="pBackgroundColor">
        /// [In,Optional] The application background color.
        /// </param>
        /// <param name="pDescription">
        /// [In] The application description name.
        /// </param>
        /// <param name="DefaultDebugEngine">
        /// [In] The default debug engine to use for debugging this app.  If unable to
        /// determine, the default is native.
        /// </param>
        /// <param name="ppCreatedObject">
        /// [Out] Result of this method call.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ DkmString* pAppUserModelId,
            _In_ DkmString* pDisplayName,
            _In_opt_ DkmString* pExecutable,
            _In_opt_ DkmString* pSmallLogoPath,
            _In_opt_ DkmString* pBackgroundColor,
            _In_ DkmString* pDescription,
            _In_ const GUID& DefaultDebugEngine,
            _Deref_out_ DefaultPort::DkmInstalledApplicationInfo** ppCreatedObject
            );
    }; // end of DkmInstalledApplicationInfo

    // Describes the application package's current execution state. For Windows Store apps,
    // the values match the values in PACKAGE_EXECUTION_STATE.
    DEFINE_SCOPED_ENUM(DkmPackageExecutionState)
    {
        // The application's state is unknown.
        Unknown = 0,
        // The application is running.
        Running = 1,
        // The application is being suspended.
        Suspending = 2,
        // The application is suspended.
        Suspended = 3,
        // The application is terminated.
        Terminated = 4
    };

    // Indicates if the specified application package is a Windows Phone or Windows Store
    // app.
    DEFINE_SCOPED_ENUM(DkmPackagedAppPlatform)
    {
        // Used for Windows Store app.
        WindowsAppx = 0,
        // Used for Windows Phone XAP applications.
        WindowsPhoneXAP = 1
    };

    // Flags indicating features which are available in the processor on which this
    // system/process/thread is running. These generally deal with register set availability.
    DEFINE_SCOPED_ENUM(DkmProcessorFeatures)
    {
        // Processor does not support any additional features.
        None = 0x0,
        // On X86, used to indicate that the CPU supports MMX registers.
        MMX = 0x1,
        // On X86, used to indicate that the CPU supports SSE registers.
        SSE = 0x2,
        // On X86, used to indicate that the CPU supports SSE2 registers.
        SSE2 = 0x4,
        // On X86, used to indicate that the CPU supports 3DNow! registers.
        AMD3DNow = 0x8,
        // On X86/X64, used to indicate that the CPU supports AVX registers.
        AVX = 0x10,
        // On ARM, used to indicate that the CPU supports the full set of floating-point
        // registers (Q0-Q15, D0-D31, and S0-S63, ).  On arm, when this flag is cleared, the
        // only supported floating-point registers include Q0-Q3, D0-D7, and S0-S15.
        VFP32 = 0x20
    };
    DEFINE_SCOPED_ENUM_FLAG_OPERATORS(DkmProcessorFeatures_t);

    // Contains information about a debuggable runtime which has been loaded into a process
    // on the computer (included processes which aren't being debugged). This will be used to
    // represent programs published through pdm.dll, which is used for active script programs
    // or other programs published through CLSID_ProgramPublisher
    // (IDebugProgramPublisher2.PublishProgram/PublishProgramNode). It can also be used for
    // other runtimes that might be loaded in the target process, such as CoreCLR.
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("eaeb3217-af01-dcda-7d08-2cabbddc2351") DkmPublishedProgramInfo : public IUnknown
    {
        private: ___ReferenceCount_t m_ReferenceCount;
        private: DkmDispatcherObjectFlags_t m_ObjectFlags;
        private: const GUID* m_pTypeId;
        private: size_t m_ObjectGCHandle;
        // Use DkmPublishedProgramInfo::Create to create this object
        private: DkmPublishedProgramInfo();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmPublishedProgramInfo();
        // This object cannot be copied
        private: DkmPublishedProgramInfo& operator=(const DkmPublishedProgramInfo&);
        private: DkmPublishedProgramInfo(const DkmPublishedProgramInfo&);

        private: OPTIONAL DkmString* const m_pFriendlyName;
        private: DkmReadOnlyCollection<GUID>* const m_pEngineIds;
        private: void* m__pExtendedData;

        // [Optional] A friendly name for the program. This may be displayed in the attach to
        // processes window. This is exposed to the AD7 API via
        // IDebugProgramNode2.GetHostName(GHN_FRIENDLY_NAME).
        public: _Ret_opt_ DECLSPEC_NOTHROW DkmString* STDMETHODCALLTYPE FriendlyName(
            );

        // The collection of engines which are capable of debugging this code. Generally,
        // this collection only has one entry. For script, this value is DkmEngineId.Script.
        public: _Ret_ DECLSPEC_NOTHROW DkmReadOnlyCollection<GUID>* STDMETHODCALLTYPE EngineIds(
            );

        /// <summary>
        /// Create a new DkmPublishedProgramInfo object instance.
        /// </summary>
        /// <param name="pFriendlyName">
        /// [In,Optional] A friendly name for the program. This may be displayed in the
        /// attach to processes window. This is exposed to the AD7 API via
        /// IDebugProgramNode2.GetHostName(GHN_FRIENDLY_NAME).
        /// </param>
        /// <param name="pEngineIds">
        /// [In] The collection of engines which are capable of debugging this code.
        /// Generally, this collection only has one entry. For script, this value is
        /// DkmEngineId.Script.
        /// </param>
        /// <param name="ppCreatedObject">
        /// [Out] Result of this method call.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_opt_ DkmString* pFriendlyName,
            _In_ DkmReadOnlyCollection<GUID>* pEngineIds,
            _Deref_out_ DefaultPort::DkmPublishedProgramInfo** ppCreatedObject
            );
    }; // end of DkmPublishedProgramInfo

    // Authentication mode to use when connecting over a standard remote connection.
    DEFINE_SCOPED_ENUM(DkmRemoteAuthenticationMode)
    {
        // Use built-in Windows authentication. Client and server will negotiate either
        // Kerberos or NTLM. This is the default value.
        WindowsNegotiate = 0,
        // Use built-in Windows Kerberos Authentication.
        Kerberos = 1,
        // Use built-in NTLM authentication. This option can be used when Kerberos is
        // malfunctioning.
        NTLM = 2,
        // Disable authentication. This value can only be used on trusted networks.
        None = 3,
        // Other form of authentication used by a custom transport.
        Custom = 4
    };

    // Flags containing Boolean properties of the running process.
    DEFINE_SCOPED_ENUM(DkmRunningProcessFlags)
    {
        // Default value for DkmRunningProcessFlags.
        None = 0x0,
        // Process is a 32-bit process running on a 64-bit computer. This is computed when
        // DkmRunningProcessInfoPropertyMask.BasicInfoFlags is set.
        Wow64 = 0x1,
        // There is a Win32 debugger attached to the process. This is computed when
        // DkmRunningProcessInfoPropertyMask.BasicInfoFlags is set.
        DebuggerAttached = 0x2,
        // Process is running under a different user account than the debug monitor.
        OtherUser = 0x4,
        // A security warning should be displayed before attaching to this process.
        SecurityWarningOnAttach = 0x8,
        // Process is running in AppContainer.
        AppContainer = 0x10,
        // Process should be hidden in the process listing unless the user wants all
        // processes to be shown. This is computed when
        // DkmRunningProcessInfoPropertyMask.FilterFlags is set.
        HideFromDefaultProcessList = 0x20,
        // The runtime used to execute native-compiled .NET Framework code is loaded in the
        // target process. This is computed when
        // DkmRunningProcessInfoPropertyMask.ClrVersions is specified.
        ClrNativeCompilationRuntimeLoaded = 0x40
    };
    DEFINE_SCOPED_ENUM_FLAG_OPERATORS(DkmRunningProcessFlags_t);

    // Snapshot of basic information about a running process. Unlike DkmProcess, this
    // information is for a process which is not necessarily being debugged. This can either
    // be returned as part of a task list, or information can be returned for a single
    // process.
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("b7b99a64-a129-3356-e276-1a7873905ceb") DkmRunningProcessInfo : public IUnknown
    {
        private: ___ReferenceCount_t m_ReferenceCount;
        private: DkmDispatcherObjectFlags_t m_ObjectFlags;
        private: const GUID* m_pTypeId;
        private: size_t m_ObjectGCHandle;
        // Use DkmRunningProcessInfo::Create to create this object
        private: DkmRunningProcessInfo();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmRunningProcessInfo();
        // This object cannot be copied
        private: DkmRunningProcessInfo& operator=(const DkmRunningProcessInfo&);
        private: DkmRunningProcessInfo(const DkmRunningProcessInfo&);

        private: const UINT32 m_Id;
        private: const UINT64 m_StartTime;
        private: const UINT32 m_SessionId;
        private: OPTIONAL DkmString* const m_pName;
        private: OPTIONAL DkmString* const m_pTitle;
        private: OPTIONAL DkmString* const m_pUserName;
        private: OPTIONAL DkmReadOnlyCollection<DkmString*>* const m_pClrVersions;
        private: OPTIONAL DkmString* const m_pCommandLine;
        private: OPTIONAL DkmString* const m_pCurrentDirectory;
        private: OPTIONAL DkmString* const m_pEnvironmentBlock;
        private: const UINT32 m_IntegrityLevel;
        private: OPTIONAL DkmReadOnlyCollection<DefaultPort::DkmPublishedProgramInfo*>* const m_pPublishedPrograms;
        private: const DefaultPort::DkmRunningProcessFlags_t m_Flags;
        private: const UINT16 m_ProcessorArchitecture;
        private: OPTIONAL DefaultPort::DkmAppPackageId* const m_pAppPackageId;
        private: void* m__pExtendedData;

        // Process Id (PID) assigned by the operating system.
        public: DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE Id(
            );

        // 64-bit date time value indicating when the process was started. The start time
        // along with the id and the machine where the process was started can uniquely
        // identify a process.
        public: DECLSPEC_NOTHROW UINT64 STDMETHODCALLTYPE StartTime(
            );

        // Terminal server session id for the process (-1 if not obtained).
        public: DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE SessionId(
            );

        // [Optional] Full path to the starting executable of the process. If the full path
        // cannot be obtained, this may only contain the base executable name.
        public: _Ret_opt_ DECLSPEC_NOTHROW DkmString* STDMETHODCALLTYPE Name(
            );

        // [Optional] Title of the process's main window (if any).
        public: _Ret_opt_ DECLSPEC_NOTHROW DkmString* STDMETHODCALLTYPE Title(
            );

        // [Optional] User name that the process is running under (ex: MyCompany\MyAlias).
        public: _Ret_opt_ DECLSPEC_NOTHROW DkmString* STDMETHODCALLTYPE UserName(
            );

        // [Optional] Version number for all the CLR instances loaded into the debugged
        // process.
        public: _Ret_opt_ DECLSPEC_NOTHROW DkmReadOnlyCollection<DkmString*>* STDMETHODCALLTYPE ClrVersions(
            );

        // [Optional] Command line used to start the process.
        public: _Ret_opt_ DECLSPEC_NOTHROW DkmString* STDMETHODCALLTYPE CommandLine(
            );

        // [Optional] Current directory of the process.
        public: _Ret_opt_ DECLSPEC_NOTHROW DkmString* STDMETHODCALLTYPE CurrentDirectory(
            );

        // [Optional] Environment block of the process.
        public: _Ret_opt_ DECLSPEC_NOTHROW DkmString* STDMETHODCALLTYPE EnvironmentBlock(
            );

        // SECURITY_MANDATORY_*_RID value used to indicate the integrity level of this
        // process. -1/MAXDWORD is used if the integrity level is unknown/invalid such as on
        // pre-Vista operating systems where integrity levels do not exist, or if the user
        // identity of process could not be obtained.
        public: DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE IntegrityLevel(
            );

        // [Optional] Provides information about which runtimes are active in the target
        // process. Currently this is used for script debugging and CoreCLR debugging, and it
        // is likely to be used for other runtimes in the future.
        public: _Ret_opt_ DECLSPEC_NOTHROW DkmReadOnlyCollection<DefaultPort::DkmPublishedProgramInfo*>* STDMETHODCALLTYPE PublishedPrograms(
            );

        // Flags containing Boolean properties of the running process.
        public: DECLSPEC_NOTHROW DefaultPort::DkmRunningProcessFlags_t STDMETHODCALLTYPE Flags(
            );

        // Example: PROCESSOR_ARCHITECTURE_INTEL (0), PROCESSOR_ARCHITECTURE_ARM (5), or
        // PROCESSOR_ARCHITECTURE_AMD64 (9).  This is computed when
        // DkmRunningProcessInfoPropertyMask.BasicInfoFlags is set.
        public: DECLSPEC_NOTHROW UINT16 STDMETHODCALLTYPE ProcessorArchitecture(
            );

        // [Optional] The id of the application package for this process. Null if the process
        // is not part of a Windows Store app, or Windows Phone application. This is computed
        // when DkmRunningProcessInfoPropertyMask.AppPackageId is set.
        public: _Ret_opt_ DECLSPEC_NOTHROW DefaultPort::DkmAppPackageId* STDMETHODCALLTYPE AppPackageId(
            );

        /// <summary>
        /// Create a new DkmRunningProcessInfo object instance.
        /// </summary>
        /// <param name="Id">
        /// [In] Process Id (PID) assigned by the operating system.
        /// </param>
        /// <param name="StartTime">
        /// [In] 64-bit date time value indicating when the process was started. The start
        /// time along with the id and the machine where the process was started can uniquely
        /// identify a process.
        /// </param>
        /// <param name="SessionId">
        /// [In] Terminal server session id for the process (-1 if not obtained).
        /// </param>
        /// <param name="pName">
        /// [In,Optional] Full path to the starting executable of the process. If the full
        /// path cannot be obtained, this may only contain the base executable name.
        /// </param>
        /// <param name="pTitle">
        /// [In,Optional] Title of the process's main window (if any).
        /// </param>
        /// <param name="pUserName">
        /// [In,Optional] User name that the process is running under (ex:
        /// MyCompany\MyAlias).
        /// </param>
        /// <param name="pClrVersions">
        /// [In,Optional] Version number for all the CLR instances loaded into the debugged
        /// process.
        /// </param>
        /// <param name="pCommandLine">
        /// [In,Optional] Command line used to start the process.
        /// </param>
        /// <param name="pCurrentDirectory">
        /// [In,Optional] Current directory of the process.
        /// </param>
        /// <param name="pEnvironmentBlock">
        /// [In,Optional] Environment block of the process.
        /// </param>
        /// <param name="IntegrityLevel">
        /// [In] SECURITY_MANDATORY_*_RID value used to indicate the integrity level of this
        /// process. -1/MAXDWORD is used if the integrity level is unknown/invalid such as on
        /// pre-Vista operating systems where integrity levels do not exist, or if the user
        /// identity of process could not be obtained.
        /// </param>
        /// <param name="pPublishedPrograms">
        /// [In,Optional] Provides information about which runtimes are active in the target
        /// process. Currently this is used for script debugging and CoreCLR debugging, and
        /// it is likely to be used for other runtimes in the future.
        /// </param>
        /// <param name="Flags">
        /// [In] Flags containing Boolean properties of the running process.
        /// </param>
        /// <param name="ProcessorArchitecture">
        /// [In] Example: PROCESSOR_ARCHITECTURE_INTEL (0), PROCESSOR_ARCHITECTURE_ARM (5),
        /// or PROCESSOR_ARCHITECTURE_AMD64 (9).  This is computed when
        /// DkmRunningProcessInfoPropertyMask.BasicInfoFlags is set.
        /// </param>
        /// <param name="pAppPackageId">
        /// [In,Optional] The id of the application package for this process. Null if the
        /// process is not part of a Windows Store app, or Windows Phone application. This is
        /// computed when DkmRunningProcessInfoPropertyMask.AppPackageId is set.
        /// </param>
        /// <param name="ppCreatedObject">
        /// [Out] Result of this method call.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ UINT32 Id,
            _In_ UINT64 StartTime,
            _In_ UINT32 SessionId,
            _In_opt_ DkmString* pName,
            _In_opt_ DkmString* pTitle,
            _In_opt_ DkmString* pUserName,
            _In_opt_ DkmReadOnlyCollection<DkmString*>* pClrVersions,
            _In_opt_ DkmString* pCommandLine,
            _In_opt_ DkmString* pCurrentDirectory,
            _In_opt_ DkmString* pEnvironmentBlock,
            _In_ UINT32 IntegrityLevel,
            _In_opt_ DkmReadOnlyCollection<DefaultPort::DkmPublishedProgramInfo*>* pPublishedPrograms,
            _In_ DefaultPort::DkmRunningProcessFlags_t Flags,
            _In_ UINT16 ProcessorArchitecture,
            _In_opt_ DefaultPort::DkmAppPackageId* pAppPackageId,
            _Deref_out_ DefaultPort::DkmRunningProcessInfo** ppCreatedObject
            );
    }; // end of DkmRunningProcessInfo

    // Flags indicating which properties of DkmRunningProcessInfo should be computed.
    DEFINE_SCOPED_ENUM(DkmRunningProcessInfoPropertyMask)
    {
        // No information should be computed.
        Empty = 0x0,
        // 'StartTime' field should be computed.
        StartTime = 0x1,
        // 'SessionId' field should be computed.
        SessionId = 0x2,
        // 'Name' field should be computed.
        Name = 0x4,
        // 'Title' field should be computed.
        Title = 0x8,
        // 'UserName' field should be computed.
        UserName = 0x10,
        // Compute the 'ClrVersions' field and
        // 'DkmRunningProcessFlags.ClrNativeCompilationRuntimeLoaded'.
        ClrVersions = 0x20,
        // 'CommandLine' field should be computed.
        CommandLine = 0x40,
        // 'CurrentDirectory' field should be computed.
        CurrentDirectory = 0x80,
        // 'EnvironmentBlock' field should be computed.
        EnvironmentBlock = 0x100,
        // 'IntegrityLevel' field should be computed.
        IntegrityLevel = 0x200,
        // 'DkmRunningProcessFlags.Wow64' and 'DkmRunningProcessFlags.DebuggerAttached'
        // should be computed.
        BasicInfoFlags = 0x400,
        // 'DkmRunningProcessFlags.OtherUser' and
        // 'DkmRunningProcessFlags.SecurityWarningOnAttach' should be computed.
        UserIdentityFlags = 0x800,
        // 'DkmRunningProcessFlags.HideFromDefaultProcessList' should be computed.
        FilterFlags = 0x1000,
        // PublishedPrograms field should be computed.
        PublishedPrograms = 0x2000,
        // 'AppPackageId' field should be computed.
        AppPackageId = 0x4000,
        // Indicates if Core CLR DkmPublishedProgramInfo should be computed.
        CoreClrPublishedProgram = 0x8000
    };
    DEFINE_SCOPED_ENUM_FLAG_OPERATORS(DkmRunningProcessInfoPropertyMask_t);

    // Result of an asynchronous DkmTransportConnection.ShutDownAppPackage call.
    struct DkmShutDownAppPackageAsyncResult
    {
        // HRESULT code returned from the caller. This will be
        // DkmExceptionCode.COR_E_OPERATIONCANCELED (0x8013153B) if the operation was
        // canceled before processing was complete.
        HRESULT ErrorCode;
    };

    // Result of an asynchronous DkmTransportConnection.SuspendAppPackage call.
    struct DkmSuspendAppPackageAsyncResult
    {
        // HRESULT code returned from the caller. This will be
        // DkmExceptionCode.COR_E_OPERATIONCANCELED (0x8013153B) if the operation was
        // canceled before processing was complete.
        HRESULT ErrorCode;
    };

    // Contains information about the computer system that a process or connection is using.
    // It can be obtained through the 'SystemInformation' property of a process, or from
    // DefaultPort.DkmTransportConnection.GetSystemInformation.
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("0b539dba-077a-7055-b78c-44e3b1d35bba") DkmSystemInformation : public IUnknown
    {
        private: ___ReferenceCount_t m_ReferenceCount;
        private: DkmDispatcherObjectFlags_t m_ObjectFlags;
        private: const GUID* m_pTypeId;
        private: size_t m_ObjectGCHandle;
        // Use DkmSystemInformation::Create to create this object
        private: DkmSystemInformation();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmSystemInformation();
        // This object cannot be copied
        private: DkmSystemInformation& operator=(const DkmSystemInformation&);
        private: DkmSystemInformation(const DkmSystemInformation&);

        // Contains additional fields of DkmSystemInformation which were added after the
        // class was initally introduced.
        private: struct ___ExtendedData
        {
            ___ExtendedData();

            // If dump debugging, specifies the MINIDUMP_TYPE flags of the mini dump being
            // debugged.  If live debugging, this value is always zero.
            const MINIDUMP_TYPE MinidumpFlags;

            // [Optional] The path of the system directory.  For both 32-bit and 64-bit
            // Windows, this value is typically C:\Windows\System32.
            OPTIONAL DkmString* const pSystemDirectory;

            // [Optional] The path of the WOW64 system directory.  This value is typically
            // C:\Windows\SysWOW64. On 32-bit Windows, this value will be NULL.
            OPTIONAL DkmString* const pSystemWow64Directory;

            // [Optional] The device information for current system, available for Windows 10
            // or later. This includes the physical form factor of the device, and the OS
            // family and version number of the operating system.
            OPTIONAL DefaultPort::DkmDeviceInfo* const pDeviceInfo;
        };

        private: const UINT16 m_ProcessorArchitecture;
        private: const UINT32 m_PageSize;
        private: const UINT32 m_OperatingSystemVersion;
        private: const UINT16 m_SuiteMask;
        private: const DefaultPort::DkmSystemInformationFlags_t m_Flags;
        private: const DefaultPort::DkmProcessorFeatures_t m_ProcessorFeatures;
        private: ___ExtendedData* const m__pExtendedData;

        // Example: PROCESSOR_ARCHITECTURE_INTEL (0), PROCESSOR_ARCHITECTURE_ARM (5), or
        // PROCESSOR_ARCHITECTURE_AMD64 (9).
        public: DECLSPEC_NOTHROW UINT16 STDMETHODCALLTYPE ProcessorArchitecture(
            );

        // Minimum size for a virtual memory page. This value may be zero in remote device
        // scenarios where the page size is unknown.
        public: DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE PageSize(
            );

        // 4-byte value containing the operating system version packed as {platform id, major
        // version, minor version, service pack major version}. The platform id from the
        // OSVERSIONINFO structure and is currently always defined to VER_PLATFORM_WIN32_NT
        // (2).
        public: DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE OperatingSystemVersion(
            );

        // VER_SUITE_* flags from the OSVERSIONINFOEX structure.
        public: DECLSPEC_NOTHROW UINT16 STDMETHODCALLTYPE SuiteMask(
            );

        // Flags which provide information about the system that a computer system that a
        // process/thread/connection is using.
        public: DECLSPEC_NOTHROW DefaultPort::DkmSystemInformationFlags_t STDMETHODCALLTYPE Flags(
            );

        // Flags indicating features which are available in the processor on which this
        // system/process/thread is running. These generally deal with register set
        // availability.
        public: DECLSPEC_NOTHROW DefaultPort::DkmProcessorFeatures_t STDMETHODCALLTYPE ProcessorFeatures(
            );

        // If dump debugging, specifies the MINIDUMP_TYPE flags of the mini dump being
        // debugged.  If live debugging, this value is always zero.
        //
        // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
        public: DECLSPEC_NOTHROW MINIDUMP_TYPE STDMETHODCALLTYPE MinidumpFlags(
            );

        // [Optional] The path of the system directory.  For both 32-bit and 64-bit Windows,
        // this value is typically C:\Windows\System32.
        //
        // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
        public: _Ret_opt_ DECLSPEC_NOTHROW DkmString* STDMETHODCALLTYPE SystemDirectory(
            );

        // [Optional] The path of the WOW64 system directory.  This value is typically
        // C:\Windows\SysWOW64. On 32-bit Windows, this value will be NULL.
        //
        // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
        public: _Ret_opt_ DECLSPEC_NOTHROW DkmString* STDMETHODCALLTYPE SystemWow64Directory(
            );

        // [Optional] The device information for current system, available for Windows 10 or
        // later. This includes the physical form factor of the device, and the OS family and
        // version number of the operating system.
        //
        // This API was introduced in Visual Studio 14 RTM (DkmApiVersion.VS14RTM).
        public: _Ret_opt_ DECLSPEC_NOTHROW DefaultPort::DkmDeviceInfo* STDMETHODCALLTYPE DeviceInfo(
            );

        /// <summary>
        /// Create a new DkmSystemInformation object instance.
        /// </summary>
        /// <param name="ProcessorArchitecture">
        /// [In] Example: PROCESSOR_ARCHITECTURE_INTEL (0), PROCESSOR_ARCHITECTURE_ARM (5),
        /// or PROCESSOR_ARCHITECTURE_AMD64 (9).
        /// </param>
        /// <param name="PageSize">
        /// [In] Minimum size for a virtual memory page. This value may be zero in remote
        /// device scenarios where the page size is unknown.
        /// </param>
        /// <param name="OperatingSystemVersion">
        /// [In] 4-byte value containing the operating system version packed as {platform id,
        /// major version, minor version, service pack major version}. The platform id from
        /// the OSVERSIONINFO structure and is currently always defined to
        /// VER_PLATFORM_WIN32_NT (2).
        /// </param>
        /// <param name="SuiteMask">
        /// [In] VER_SUITE_* flags from the OSVERSIONINFOEX structure.
        /// </param>
        /// <param name="Flags">
        /// [In] Flags which provide information about the system that a computer system that
        /// a process/thread/connection is using.
        /// </param>
        /// <param name="ProcessorFeatures">
        /// [In] Flags indicating features which are available in the processor on which this
        /// system/process/thread is running. These generally deal with register set
        /// availability.
        /// </param>
        /// <param name="ppCreatedObject">
        /// [Out] Result of this method call.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ UINT16 ProcessorArchitecture,
            _In_ UINT32 PageSize,
            _In_ UINT32 OperatingSystemVersion,
            _In_ UINT16 SuiteMask,
            _In_ DefaultPort::DkmSystemInformationFlags_t Flags,
            _In_ DefaultPort::DkmProcessorFeatures_t ProcessorFeatures,
            _Deref_out_ DefaultPort::DkmSystemInformation** ppCreatedObject
            );

        /// <summary>
        /// Create a new DkmSystemInformation object instance.
        ///
        /// This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
        /// </summary>
        /// <param name="ProcessorArchitecture">
        /// [In] Example: PROCESSOR_ARCHITECTURE_INTEL (0), PROCESSOR_ARCHITECTURE_ARM (5),
        /// or PROCESSOR_ARCHITECTURE_AMD64 (9).
        /// </param>
        /// <param name="PageSize">
        /// [In] Minimum size for a virtual memory page. This value may be zero in remote
        /// device scenarios where the page size is unknown.
        /// </param>
        /// <param name="OperatingSystemVersion">
        /// [In] 4-byte value containing the operating system version packed as {platform id,
        /// major version, minor version, service pack major version}. The platform id from
        /// the OSVERSIONINFO structure and is currently always defined to
        /// VER_PLATFORM_WIN32_NT (2).
        /// </param>
        /// <param name="SuiteMask">
        /// [In] VER_SUITE_* flags from the OSVERSIONINFOEX structure.
        /// </param>
        /// <param name="Flags">
        /// [In] Flags which provide information about the system that a computer system that
        /// a process/thread/connection is using.
        /// </param>
        /// <param name="ProcessorFeatures">
        /// [In] Flags indicating features which are available in the processor on which this
        /// system/process/thread is running. These generally deal with register set
        /// availability.
        /// </param>
        /// <param name="MinidumpFlags">
        /// [In] If dump debugging, specifies the MINIDUMP_TYPE flags of the mini dump being
        /// debugged.  If live debugging, this value is always zero.
        /// </param>
        /// <param name="pSystemDirectory">
        /// [In,Optional] The path of the system directory.  For both 32-bit and 64-bit
        /// Windows, this value is typically C:\Windows\System32.
        /// </param>
        /// <param name="pSystemWow64Directory">
        /// [In,Optional] The path of the WOW64 system directory.  This value is typically
        /// C:\Windows\SysWOW64. On 32-bit Windows, this value will be NULL.
        /// </param>
        /// <param name="ppCreatedObject">
        /// [Out] Result of this method call.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ UINT16 ProcessorArchitecture,
            _In_ UINT32 PageSize,
            _In_ UINT32 OperatingSystemVersion,
            _In_ UINT16 SuiteMask,
            _In_ DefaultPort::DkmSystemInformationFlags_t Flags,
            _In_ DefaultPort::DkmProcessorFeatures_t ProcessorFeatures,
            _In_ MINIDUMP_TYPE MinidumpFlags,
            _In_opt_ DkmString* pSystemDirectory,
            _In_opt_ DkmString* pSystemWow64Directory,
            _Deref_out_ DefaultPort::DkmSystemInformation** ppCreatedObject
            );

        /// <summary>
        /// Create a new DkmSystemInformation object instance.
        ///
        /// This API was introduced in Visual Studio 14 RTM (DkmApiVersion.VS14RTM).
        /// </summary>
        /// <param name="ProcessorArchitecture">
        /// [In] Example: PROCESSOR_ARCHITECTURE_INTEL (0), PROCESSOR_ARCHITECTURE_ARM (5),
        /// or PROCESSOR_ARCHITECTURE_AMD64 (9).
        /// </param>
        /// <param name="PageSize">
        /// [In] Minimum size for a virtual memory page. This value may be zero in remote
        /// device scenarios where the page size is unknown.
        /// </param>
        /// <param name="OperatingSystemVersion">
        /// [In] 4-byte value containing the operating system version packed as {platform id,
        /// major version, minor version, service pack major version}. The platform id from
        /// the OSVERSIONINFO structure and is currently always defined to
        /// VER_PLATFORM_WIN32_NT (2).
        /// </param>
        /// <param name="SuiteMask">
        /// [In] VER_SUITE_* flags from the OSVERSIONINFOEX structure.
        /// </param>
        /// <param name="Flags">
        /// [In] Flags which provide information about the system that a computer system that
        /// a process/thread/connection is using.
        /// </param>
        /// <param name="ProcessorFeatures">
        /// [In] Flags indicating features which are available in the processor on which this
        /// system/process/thread is running. These generally deal with register set
        /// availability.
        /// </param>
        /// <param name="MinidumpFlags">
        /// [In] If dump debugging, specifies the MINIDUMP_TYPE flags of the mini dump being
        /// debugged.  If live debugging, this value is always zero.
        /// </param>
        /// <param name="pSystemDirectory">
        /// [In,Optional] The path of the system directory.  For both 32-bit and 64-bit
        /// Windows, this value is typically C:\Windows\System32.
        /// </param>
        /// <param name="pSystemWow64Directory">
        /// [In,Optional] The path of the WOW64 system directory.  This value is typically
        /// C:\Windows\SysWOW64. On 32-bit Windows, this value will be NULL.
        /// </param>
        /// <param name="pDeviceInfo">
        /// [In,Optional] The device information for current system, available for Windows 10
        /// or later. This includes the physical form factor of the device, and the OS family
        /// and version number of the operating system.
        /// </param>
        /// <param name="ppCreatedObject">
        /// [Out] Result of this method call.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ UINT16 ProcessorArchitecture,
            _In_ UINT32 PageSize,
            _In_ UINT32 OperatingSystemVersion,
            _In_ UINT16 SuiteMask,
            _In_ DefaultPort::DkmSystemInformationFlags_t Flags,
            _In_ DefaultPort::DkmProcessorFeatures_t ProcessorFeatures,
            _In_ MINIDUMP_TYPE MinidumpFlags,
            _In_opt_ DkmString* pSystemDirectory,
            _In_opt_ DkmString* pSystemWow64Directory,
            _In_opt_ DefaultPort::DkmDeviceInfo* pDeviceInfo,
            _Deref_out_ DefaultPort::DkmSystemInformation** ppCreatedObject
            );
    }; // end of DkmSystemInformation

    // Flags which provide information about the system that a computer system that a
    // process/thread/connection is using.
    DEFINE_SCOPED_ENUM(DkmSystemInformationFlags)
    {
        // No flags are set.
        Default = 0x0,
        // The process/OS is 64-bit.
        Is64Bit = 0x1,
        // Indicates that the process/OS is from a .dmp file or other snapshot of a single
        // point in time.
        DumpFile = 0x2,
        // Indicates that if target process/OS allows debugger to arbitrarily access file
        // system.
        CanAccessFileSystem = 0x4,
        // Indicates that the target OS is a core system.  (Examples:  XBox, Phone, etc.).
        CoreSystem = 0x8,
        // Indicates that msvsmon has been launched inside a chamber. (Phone execution
        // model).
        LaunchedInChamber = 0x10
    };
    DEFINE_SCOPED_ENUM_FLAG_OPERATORS(DkmSystemInformationFlags_t);

    // This represents a connection between the monitor and the IDE. It can either be a local
    // connection if the monitor is running in the same process as the IDE, or it can be a
    // remote connection. In the monitor process, there is only one connection.
    //
    // Derived classes: DkmStandardRemoteTransportConnection
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("37f756b6-9ea0-4c02-3f0a-99fb3a0f7a77") DkmTransportConnection : public DkmDataContainer
    {
        // Use DkmTransportConnection::Create to create this object
        private: DkmTransportConnection();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmTransportConnection();
        // This object cannot be copied
        private: DkmTransportConnection& operator=(const DkmTransportConnection&);
        private: DkmTransportConnection(const DkmTransportConnection&);

        // Contains additional fields of DkmTransportConnection which were added after the
        // class was initally introduced.
        private: struct ___ExtendedData
        {
            ___ExtendedData();

            // The version of the protocol used between Visual Studio and the target
            // computer. This is the minimum of the protocol version that Visual Studio
            // understands, and the protocol version that the remote debugger understands.
            const DkmApiVersion_t ProtocolVersion;
        };

        private: const GUID m_UniqueId;
        private: OPTIONAL DkmString* const m_pQualifier;
        private: const GUID m_Kind;
        private: const DefaultPort::DkmTransportConnectionFlags_t m_Flags;
        private: ___ExtendedData* const m__pExtendedData;
        private: void* m_pCausalityConnectionCollection0;
        private: void* m_pDeploymentCommandCollection0;
        private: void* m_pDeploymentSessionCollection0;
        private: void* m_pFileTransferStreamCollection0;
        private: void* m_pLiveProcessCollection3;
        private: void* m_pProcessCollection0;
        private: void* m_pProcessLaunchNotifyListenerCollection0;
        private: void* m_pRequestCollection0;

        // Guid which uniquely identifies this connection. The local connection will use the
        // value 'DkmTransportKind.Local'. The value for other connections will be randomly
        // generated.
        public: DECLSPEC_NOTHROW const GUID& STDMETHODCALLTYPE UniqueId(
            );

        // [Optional] String indicating the connection destination. This will be null for the
        // local connection. For default remote debugging, this is computer name and port
        // number that we are trying to connect to.
        public: _Ret_opt_ DECLSPEC_NOTHROW DkmString* STDMETHODCALLTYPE Qualifier(
            );

        // Indicates the type of transport being used to debug.
        public: DECLSPEC_NOTHROW const GUID& STDMETHODCALLTYPE Kind(
            );

        // Flags indicating traits of the underlying connection.
        public: DECLSPEC_NOTHROW DefaultPort::DkmTransportConnectionFlags_t STDMETHODCALLTYPE Flags(
            );

        // The version of the protocol used between Visual Studio and the target computer.
        // This is the minimum of the protocol version that Visual Studio understands, and
        // the protocol version that the remote debugger understands.
        //
        // This API was introduced in Visual Studio 11 Update 1
        // (DkmApiVersion.VS11FeaturePack1).
        public: DECLSPEC_NOTHROW DkmApiVersion_t STDMETHODCALLTYPE ProtocolVersion(
            );

        /// <summary>
        /// Find a DkmTransportConnection object. If no object with the given input key is
        /// present, FindConnection will fail.
        /// </summary>
        /// <param name="UniqueId">
        /// [In] Search key used to find the element.
        /// </param>
        /// <param name="ppConnection">
        /// [Out] Result of the search.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// E_XAPI_OBJECT_NOT_FOUND indicates that the search key cannot be found.
        /// </returns>
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE FindConnection(
            _In_ const GUID& UniqueId,
            _Deref_out_ DefaultPort::DkmTransportConnection** ppConnection
            );

        /// <summary>
        /// GetConnections enumerates all the created DkmTransportConnection objects.
        /// </summary>
        /// <param name="pConnections">
        /// [Out] Array containing the enumerated elements.
        ///
        /// The memory for the DkmArray members is allocated by the method implementation
        /// using DkmAllocBytes/DkmAllocArray. It is freed by the caller using the
        /// CAutoDkmArray template or with DkmFreeMemory and manual element release.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetConnections(
            _Out_ DkmArray<DefaultPort::DkmTransportConnection*>* pConnections
            );

        /// <summary>
        /// Find a DkmProcess element within this DkmTransportConnection. If no element with
        /// the given input key is present, FindProcess will fail.
        /// </summary>
        /// <param name="UniqueId">
        /// [In] Search key used to find the element.
        /// </param>
        /// <param name="ppProcess">
        /// [Out] Result of the search.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// E_XAPI_OBJECT_NOT_FOUND indicates that the search key cannot be found.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE FindProcess(
            _In_ const GUID& UniqueId,
            _Deref_out_ DkmProcess** ppProcess
            );

        /// <summary>
        /// GetProcesses enumerates the DkmProcess elements of this DkmTransportConnection
        /// object.
        /// </summary>
        /// <param name="pProcesses">
        /// [Out] Array containing the enumerated elements.
        ///
        /// The memory for the DkmArray members is allocated by the method implementation
        /// using DkmAllocBytes/DkmAllocArray. It is freed by the caller using the
        /// CAutoDkmArray template or with DkmFreeMemory and manual element release.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetProcesses(
            _Out_ DkmArray<DkmProcess*>* pProcesses
            );

        /// <summary>
        /// Find a DkmProcess element within this DkmTransportConnection. If no element with
        /// the given input key is present, FindLiveProcess will fail. If an object is found,
        /// it will always contain the 'Live' Part.
        /// </summary>
        /// <param name="Id">
        /// [In] Search key used to find the element.
        /// </param>
        /// <param name="ppProcess">
        /// [Out] Result of the search.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// E_XAPI_OBJECT_NOT_FOUND indicates that the search key cannot be found.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE FindLiveProcess(
            _In_ UINT32 Id,
            _Deref_out_ DkmProcess** ppProcess
            );

        /// <summary>
        /// GetLiveProcesses enumerates the DkmProcess elements of this
        /// DkmTransportConnectionobject. All objects contain the 'Live' Part.
        /// </summary>
        /// <param name="pProcesses">
        /// [Out] Array containing the enumerated elements.
        ///
        /// The memory for the DkmArray members is allocated by the method implementation
        /// using DkmAllocBytes/DkmAllocArray. It is freed by the caller using the
        /// CAutoDkmArray template or with DkmFreeMemory and manual element release.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetLiveProcesses(
            _Out_ DkmArray<DkmProcess*>* pProcesses
            );

        /// <summary>
        /// GetRequests enumerates the DkmProcessLaunchRequest elements of this
        /// DkmTransportConnection object.
        /// </summary>
        /// <param name="pRequests">
        /// [Out] Array containing the enumerated elements.
        ///
        /// The memory for the DkmArray members is allocated by the method implementation
        /// using DkmAllocBytes/DkmAllocArray. It is freed by the caller using the
        /// CAutoDkmArray template or with DkmFreeMemory and manual element release.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetRequests(
            _Out_ DkmArray<Start::DkmProcessLaunchRequest*>* pRequests
            );

        /// <summary>
        /// Activates the specified packaged application. This will cause the application to
        /// start if it has not already started, and will bring it back as the active
        /// application if it is already running. When launching under the debugger,
        /// IDkmProcessLaunchNotifyListener.StartListener will be called before this API.
        ///
        /// This method will append a new work item to the specified work list, and return
        /// once the work item has been appended. The actual processing of the work item is
        /// asynchronous. The caller will be notified that the request is complete through
        /// the completion routine.
        /// </summary>
        /// <param name="pWorkList">
        /// WorkList to append the new work item to.
        /// </param>
        /// <param name="AppPlatform">
        /// [In] Indicates if the specified application package is a Windows Phone or Windows
        /// Store app.
        /// </param>
        /// <param name="pActivationName">
        /// [In] Identifier for the application to launch.
        /// </param>
        /// <param name="LaunchForDebugging">
        /// [In] If true, the app is being debugged.
        /// </param>
        /// <param name="pCompletionRoutine">
        /// Routine to fire when the request is complete. If the request is successfully
        /// appended to the work list, this will always fire (including when the operation is
        /// canceled). This will never fire if appending the work item fails.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ActivateAppPackage(
            _In_ DkmWorkList* pWorkList,
            _In_ DefaultPort::DkmPackagedAppPlatform_t AppPlatform,
            _In_ DkmString* pActivationName,
            _In_ bool LaunchForDebugging,
            _In_ IDkmCompletionRoutine<Start::DkmActivateAppPackageAsyncResult>* pCompletionRoutine
            );

        /// <summary>
        /// Performs a simulated process lifetime management-based suspend on the specified
        /// application. This is used by developers to test their app's suspend handler.
        ///
        /// This method will append a new work item to the specified work list, and return
        /// once the work item has been appended. The actual processing of the work item is
        /// asynchronous. The caller will be notified that the request is complete through
        /// the completion routine.
        /// </summary>
        /// <param name="pWorkList">
        /// WorkList to append the new work item to.
        /// </param>
        /// <param name="pAppPackageId">
        /// [In] Identifies a Windows Store app package or Windows Phone app package.
        /// </param>
        /// <param name="SessionId">
        /// [In] The id of the session where the application is running.
        /// </param>
        /// <param name="pCompletionRoutine">
        /// Routine to fire when the request is complete. If the request is successfully
        /// appended to the work list, this will always fire (including when the operation is
        /// canceled). This will never fire if appending the work item fails.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE SuspendAppPackage(
            _In_ DkmWorkList* pWorkList,
            _In_ DefaultPort::DkmAppPackageId* pAppPackageId,
            _In_ UINT32 SessionId,
            _In_ IDkmCompletionRoutine<DefaultPort::DkmSuspendAppPackageAsyncResult>* pCompletionRoutine
            );

        /// <summary>
        /// Performs a simulated process lifetime management-based resume on the specified
        /// application. This is used by developers to test their app's resume handler.
        /// </summary>
        /// <param name="pAppPackageId">
        /// [In] Identifies a Windows Store app package or Windows Phone app package.
        /// </param>
        /// <param name="SessionId">
        /// [In] The id of the session where the application is running.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ResumeAppPackage(
            _In_ DefaultPort::DkmAppPackageId* pAppPackageId,
            _In_ UINT32 SessionId
            );

        /// <summary>
        /// Suspend and then shut down the specified application using the process lifetime
        /// management services. Using this followed by a second app launch, developers can
        /// test their app's ability to restart from suspended state.
        ///
        /// This method will append a new work item to the specified work list, and return
        /// once the work item has been appended. The actual processing of the work item is
        /// asynchronous. The caller will be notified that the request is complete through
        /// the completion routine.
        /// </summary>
        /// <param name="pWorkList">
        /// WorkList to append the new work item to.
        /// </param>
        /// <param name="pAppPackageId">
        /// [In] Identifies a Windows Store app package or Windows Phone app package.
        /// </param>
        /// <param name="SessionId">
        /// [In] The id of the session where the application is running.
        /// </param>
        /// <param name="pCompletionRoutine">
        /// Routine to fire when the request is complete. If the request is successfully
        /// appended to the work list, this will always fire (including when the operation is
        /// canceled). This will never fire if appending the work item fails.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ShutDownAppPackage(
            _In_ DkmWorkList* pWorkList,
            _In_ DefaultPort::DkmAppPackageId* pAppPackageId,
            _In_ UINT32 SessionId,
            _In_ IDkmCompletionRoutine<DefaultPort::DkmShutDownAppPackageAsyncResult>* pCompletionRoutine
            );

        /// <summary>
        /// Obtain the full path to the isolated storage root directory for the specified
        /// application.
        ///
        /// This API is not yet implemented for Windows Store apps, but is reserved for
        /// future use.
        /// </summary>
        /// <param name="pAppPackageId">
        /// [In] Identifies a Windows Store app package or Windows Phone app package.
        /// </param>
        /// <param name="ppDirectoryFullPath">
        /// [Out,Optional] Full path to the directory on the target system. Null if the
        /// application has no isolated storage directory.
        /// </param>
        /// <returns>
        /// S_OK is returned if *ppDirectoryFullPath is non-NULL, S_FALSE is returned when
        /// *ppDirectoryFullPath is NULL, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetIsolatedStorageRootForApplication(
            _In_ DefaultPort::DkmAppPackageId* pAppPackageId,
            _Deref_out_opt_ DkmString** ppDirectoryFullPath
            );

        /// <summary>
        /// Get the execution state of the Windows Store app. The values in this field are
        /// specified in PACKAGE_EXECUTION_STATE.
        /// </summary>
        /// <param name="pAppPackageId">
        /// [In] Identifies a Windows Store app package or Windows Phone app package.
        /// </param>
        /// <param name="SessionId">
        /// [In] The id of the session where the application is running.
        /// </param>
        /// <param name="pAppPackageExecutionState">
        /// [Out] The execution state of the application.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetAppPackageExecutionState(
            _In_ DefaultPort::DkmAppPackageId* pAppPackageId,
            _In_ UINT32 SessionId,
            _Out_ DefaultPort::DkmPackageExecutionState_t* pAppPackageExecutionState
            );

        /// <summary>
        /// Enumerates the existing background tasks. This is used by developers to test
        /// their app's enum handler.
        ///
        /// This method will append a new work item to the specified work list, and return
        /// once the work item has been appended. The actual processing of the work item is
        /// asynchronous. The caller will be notified that the request is complete through
        /// the completion routine.
        /// </summary>
        /// <param name="pWorkList">
        /// WorkList to append the new work item to.
        /// </param>
        /// <param name="pAppPackageId">
        /// [In] Identifies a Windows Store app package or Windows Phone app package.
        /// </param>
        /// <param name="SessionId">
        /// [In] The id of the session where the application is running.
        /// </param>
        /// <param name="pCompletionRoutine">
        /// Routine to fire when the request is complete. If the request is successfully
        /// appended to the work list, this will always fire (including when the operation is
        /// canceled). This will never fire if appending the work item fails.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE EnumerateBackgroundTasks(
            _In_ DkmWorkList* pWorkList,
            _In_ DefaultPort::DkmAppPackageId* pAppPackageId,
            _In_ UINT32 SessionId,
            _In_ IDkmCompletionRoutine<DefaultPort::DkmEnumerateBackgroundTasksAsyncResult>* pCompletionRoutine
            );

        /// <summary>
        /// Activate an background task. This is used by developers to test their app's
        /// activate handler.
        ///
        /// This method will append a new work item to the specified work list, and return
        /// once the work item has been appended. The actual processing of the work item is
        /// asynchronous. The caller will be notified that the request is complete through
        /// the completion routine.
        /// </summary>
        /// <param name="pWorkList">
        /// WorkList to append the new work item to.
        /// </param>
        /// <param name="pAppPackageId">
        /// [In] Identifies a Windows Store app package or Windows Phone app package.
        /// </param>
        /// <param name="SessionId">
        /// [In] The id of the session where the application is running.
        /// </param>
        /// <param name="TaskId">
        /// [In] Activating task id (GUID).
        /// </param>
        /// <param name="pCompletionRoutine">
        /// Routine to fire when the request is complete. If the request is successfully
        /// appended to the work list, this will always fire (including when the operation is
        /// canceled). This will never fire if appending the work item fails.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ActivateBackgroundTask(
            _In_ DkmWorkList* pWorkList,
            _In_ DefaultPort::DkmAppPackageId* pAppPackageId,
            _In_ UINT32 SessionId,
            _In_ const GUID& TaskId,
            _In_ IDkmCompletionRoutine<DefaultPort::DkmActivateBackgroundTaskAsyncResult>* pCompletionRoutine
            );

        #ifndef EXCLUDE_IDE_ONLY_APIS
        /// <summary>
        /// Enumerates installed and launchable (App Packages with applications) App
        /// Packages.
        ///
        /// Location constraint: API must be called from an IDE component (component level
        /// &gt; 100,000).
        /// </summary>
        /// <param name="pPackages">
        /// [Out] Array of App Packages found.
        ///
        /// The memory for the DkmArray members is allocated by the method implementation
        /// using DkmAllocBytes/DkmAllocArray. It is freed by the caller using the
        /// CAutoDkmArray template or with DkmFreeMemory and manual element release.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE EnumPackages(
            _Out_ DkmArray<DefaultPort::DkmInstalledAppPackageInfo*>* pPackages
            );
        #endif // #ifndef EXCLUDE_IDE_ONLY_APIS

        #ifndef EXCLUDE_IDE_ONLY_APIS
        /// <summary>
        /// Deploy a file to the target computer. Note that this will copy the file content
        /// and last write time, but not attributes.
        ///
        /// Location constraint: API must be called from an IDE component (component level
        /// &gt; 100,000).
        /// </summary>
        /// <param name="pLocalFilePath">
        /// [In] Path to the local file which will be copied. The path must be a full path.
        /// </param>
        /// <param name="pRemoteFilePath">
        /// [In] Path to the remote file that will be written. Environment variables will be
        /// expanded (ex: %TMP%\deploy.txt). This must be a full path. If the directory of
        /// this file does not exist, the debugger will attempt to create it.
        /// </param>
        /// <param name="OverwriteExisting">
        /// [In] true if the debugger should attempt to overwrite any existing file. This
        /// will fail if the existing file is read-only.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE DeployFile(
            _In_ DkmString* pLocalFilePath,
            _In_ DkmString* pRemoteFilePath,
            _In_ bool OverwriteExisting
            );
        #endif // #ifndef EXCLUDE_IDE_ONLY_APIS

        #ifndef EXCLUDE_IDE_ONLY_APIS
        /// <summary>
        /// Download a file from the target computer. Note that this will copy the file
        /// content and last write time, but not attributes.
        ///
        /// Location constraint: API must be called from an IDE component (component level
        /// &gt; 100,000).
        /// </summary>
        /// <param name="pRemoteFilePath">
        /// [In] Path to the remote file that will be written. Environment variables will be
        /// expanded (ex: %TMP%\deploy.txt).
        /// </param>
        /// <param name="pLocalFilePath">
        /// [In] Local path where the download file will be placed. The path must be a full
        /// path, and the directory must already exist.
        /// </param>
        /// <param name="OverwriteExisting">
        /// [In] true if the debugger should attempt to overwrite any existing file. This
        /// will fail if the existing file is read-only.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE DownloadFile(
            _In_ DkmString* pRemoteFilePath,
            _In_ DkmString* pLocalFilePath,
            _In_ bool OverwriteExisting
            );
        #endif // #ifndef EXCLUDE_IDE_ONLY_APIS

        #ifndef EXCLUDE_IDE_ONLY_APIS
        /// <summary>
        /// Download a file from the target computer. Note that this will copy the file
        /// content and last write time, but not attributes.
        ///
        /// This method will append a new work item to the specified work list, and return
        /// once the work item has been appended. The actual processing of the work item is
        /// asynchronous. The caller will be notified that the request is complete through
        /// the completion routine.
        ///
        /// Location constraint: API must be called from an IDE component (component level
        /// &gt; 100,000).
        /// </summary>
        /// <param name="pWorkList">
        /// WorkList to append the new work item to.
        /// </param>
        /// <param name="pRemoteFilePath">
        /// [In] Path to the remote file that will be written. Environment variables will be
        /// expanded (ex: %TMP%\deploy.txt).
        /// </param>
        /// <param name="pLocalFilePath">
        /// [In] Local path where the download file will be placed. The path must be a full
        /// path, and the directory must already exist.
        /// </param>
        /// <param name="OverwriteExisting">
        /// [In] true if the debugger should attempt to overwrite any existing file. This
        /// will fail if the existing file is read-only.
        /// </param>
        /// <param name="pCompletionRoutine">
        /// Routine to fire when the request is complete. If the request is successfully
        /// appended to the work list, this will always fire (including when the operation is
        /// canceled). This will never fire if appending the work item fails.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE DownloadFile(
            _In_ DkmWorkList* pWorkList,
            _In_ DkmString* pRemoteFilePath,
            _In_ DkmString* pLocalFilePath,
            _In_ bool OverwriteExisting,
            _In_ IDkmCompletionRoutine<DefaultPort::DkmDownloadFileAsyncResult>* pCompletionRoutine
            );
        #endif // #ifndef EXCLUDE_IDE_ONLY_APIS

        /// <summary>
        /// Delete a file on the target computer.
        /// </summary>
        /// <param name="pRemoteFilePath">
        /// [In] Path to the remote file that will be deleted. Environment variables will be
        /// expanded (ex: %TMP%\deploy.txt).
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE DeleteFile(
            _In_ DkmString* pRemoteFilePath
            );

        /// <summary>
        /// Provides the physical DNS host name that the target computer uses.
        /// </summary>
        /// <param name="ppName">
        /// [Out] Computer name. For more information, see ComputerNamePhysicalDnsHostname in
        /// the Win32 documentation for GetComputerNameEx.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetDNSName(
            _Deref_out_ DkmString** ppName
            );

        /// <summary>
        /// Creates a directory on the target computer. Note that directories are implicitly
        /// created when deploying files. So this API does not need to be used in that
        /// scenario.
        /// </summary>
        /// <param name="pRemoteDirectoryPath">
        /// [In] Path to the remote directory that will be created. Environment variables
        /// will be expanded (ex: %TMP%\MyDirectory). The directory cannot be a relative
        /// path.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE CreateDirectory(
            _In_ DkmString* pRemoteDirectoryPath
            );

        /// <summary>
        /// Removes a directory on the target computer.
        /// </summary>
        /// <param name="pRemoteDirectoryPath">
        /// [In] Path to the remote directory that will be removed. Environment variables
        /// will be expanded (ex: %TMP%\MyDirectory). The directory cannot be a relative
        /// path.
        /// </param>
        /// <param name="Recursive">
        /// [In] True if all files and subdirectories under 'RootDirectoryPath' should be
        /// removed. If false, this operation will fail unless the directory is empty.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE RemoveDirectory(
            _In_ DkmString* pRemoteDirectoryPath,
            _In_ bool Recursive
            );

        /// <summary>
        /// Obtains a listing of files and subdirectories that exist on the target computer.
        /// </summary>
        /// <param name="pRootDirectoryPath">
        /// [In] Path to a remote directory under which the search will be preformed.
        /// Environment variables will be expanded (ex: %TMP%\MyDirectory). The directory
        /// cannot be a relative path.
        /// </param>
        /// <param name="pSearchWildcard">
        /// [In] Wildcard search string to use when matching files. For example, '*' to
        /// obtain all files and directories, or 'example.txt' to obtain information on just
        /// 'example.txt'.
        /// </param>
        /// <param name="Recursive">
        /// [In] True if all subdirectories under 'RootDirectoryPath' should be checked for
        /// files. This option excludes reparse points like mounted drives and symbolic
        /// links.
        /// </param>
        /// <param name="pResults">
        /// [Out] File information for all found files and subdirectories.
        ///
        /// The memory for the DkmArray members is allocated by the method implementation
        /// using DkmAllocBytes/DkmAllocArray. It is freed by the caller using the
        /// CAutoDkmArray template or with DkmFreeMemory and manual element release.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetFileListing(
            _In_ DkmString* pRootDirectoryPath,
            _In_ DkmString* pSearchWildcard,
            _In_ bool Recursive,
            _Out_ DkmArray<DefaultPort::DkmFileInfo*>* pResults
            );

        /// <summary>
        /// Provides a listing of all the processes running on the target computer (including
        /// processes not being debugged).
        /// </summary>
        /// <param name="IncludeFromAllUsers">
        /// [In] If true, processes from all users should be included.
        /// </param>
        /// <param name="RequestedPropertyMask">
        /// [In] Flags indicating which properties of DkmRunningProcessInfo should be
        /// computed.
        /// </param>
        /// <param name="pProcesses">
        /// [Out] Array of processes running on the target computer.
        ///
        /// The memory for the DkmArray members is allocated by the method implementation
        /// using DkmAllocBytes/DkmAllocArray. It is freed by the caller using the
        /// CAutoDkmArray template or with DkmFreeMemory and manual element release.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE EnumRunningProcesses(
            _In_ bool IncludeFromAllUsers,
            _In_ DefaultPort::DkmRunningProcessInfoPropertyMask_t RequestedPropertyMask,
            _Out_ DkmArray<DefaultPort::DkmRunningProcessInfo*>* pProcesses
            );

        /// <summary>
        /// Obtain information about a process running on the target computer.
        /// </summary>
        /// <param name="Id">
        /// [In] Process Id (PID) assigned by the operating system.
        /// </param>
        /// <param name="StartTime">
        /// [In] 64-bit date time value indicating when the process was started. The start
        /// time along with the id and the machine where the process was started can uniquely
        /// identify a process. '0' can be passed if the start time is unknown.
        /// </param>
        /// <param name="IsDebuggee">
        /// [In] When true, the request will fail if the debugger has insufficient privileges
        /// to complete the request. If false, the implementation should calculate what it
        /// can.
        /// </param>
        /// <param name="RequestedPropertyMask">
        /// [In] Flags indicating which properties of DkmRunningProcessInfo should be
        /// computed.
        /// </param>
        /// <param name="ppProcessInfo">
        /// [Out] Information about the requested process.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetRunningProcessInfo(
            _In_ UINT32 Id,
            _In_ UINT64 StartTime,
            _In_ bool IsDebuggee,
            _In_ DefaultPort::DkmRunningProcessInfoPropertyMask_t RequestedPropertyMask,
            _Deref_out_ DefaultPort::DkmRunningProcessInfo** ppProcessInfo
            );

        /// <summary>
        /// Terminates a process running on target computer which is not being debugged.
        /// </summary>
        /// <param name="Id">
        /// [In] Process Id (PID) assigned by the operating system.
        /// </param>
        /// <param name="StartTime">
        /// [In] 64-bit date time value indicating when the process was started. The start
        /// time along with the id and the machine where the process was started can uniquely
        /// identify a process. '0' can be passed if the start time is unknown.
        /// </param>
        /// <param name="ExitCode">
        /// [In] The exit code to be used by the process and threads terminated as a result
        /// of this call. Use the GetExitCodeProcess function to retrieve a process's exit
        /// value. Use the GetExitCodeThread function to retrieve a thread's exit value.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE TerminateRunningProcess(
            _In_ UINT32 Id,
            _In_ UINT64 StartTime,
            _In_ UINT32 ExitCode
            );

        /// <summary>
        /// Provides information about the computer where the debug monitor is running.
        /// </summary>
        /// <param name="NativeSystemInfo">
        /// [In] If true and if the debug monitor is running under WOW64, this function will
        /// return information about the native subsystem rather than WOW. If the debug
        /// monitor is not running under WOW, this function is ignored.
        /// </param>
        /// <param name="ppSystemInfo">
        /// [Out] Object describing the system where the debugger is running.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetSystemInformation(
            _In_ bool NativeSystemInfo,
            _Deref_out_ DefaultPort::DkmSystemInformation** ppSystemInfo
            );

        /// <summary>
        /// Provides the version string for the CLR that the debugger expects a given
        /// executable to load. The return value is based on the content of the executable's
        /// PE header (if the exe is managed), the executable's config file, CLR environment
        /// variables, and loader policy in the registry. The return value may be incorrect,
        /// especially in the case of a native executable.
        /// </summary>
        /// <param name="pExePath">
        /// [In] Path to the executable file.
        /// </param>
        /// <param name="ppClrVersionString">
        /// [Out] Version string of the CLR. Ex:'v4.0.30319'.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetClrVersionOfExecutable(
            _In_ DkmString* pExePath,
            _Deref_out_ DkmString** ppClrVersionString
            );

        /// <summary>
        /// Determines if the given executable file will execute within WOW64 (Windows On
        /// Windows), which is used to execute 32-bit processes on a 64-bit OS.
        /// </summary>
        /// <param name="pExePath">
        /// [In] Path to the executable file.
        /// </param>
        /// <param name="pResult">
        /// [Out] true if the specified executable file will execute under WOW.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE QueryIsWOW64Executable(
            _In_ DkmString* pExePath,
            _Out_ bool* pResult
            );

        /// <summary>
        /// Returns the version of the CLR which is loaded in the monitor process.
        /// </summary>
        /// <param name="ppClrVersionString">
        /// [Out] Version string of the CLR. Ex:'v4.0.30319'.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetDefaultClrVersion(
            _Deref_out_ DkmString** ppClrVersionString
            );

        #ifndef EXCLUDE_IDE_ONLY_APIS
        /// <summary>
        /// This function is used to force all object close notifications to be immediately
        /// exchanged with the monitor process. Like 'GC.Collect' in managed code, this
        /// function is normally unnecessary, as the system automatically flushes the queue.
        /// However, this method can be used if it is important that all updates are
        /// immediately exchanged.
        ///
        /// An object close notification is created (and queued) when a component calls
        /// 'Close' on a given object. Both the monitor process and the engine process
        /// maintain a queue of closed objects. This method may only be called from the
        /// engine process, but it is used to flush both queues.
        ///
        /// Location constraint: API must be called from an IDE component (component level
        /// &gt; 100,000).
        /// </summary>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE FlushClosedObjectQueue(
            );
        #endif // #ifndef EXCLUDE_IDE_ONLY_APIS

        /// <summary>
        /// Triggers application content prefetch.
        ///
        /// This API was introduced in Visual Studio 12 Update 2 (DkmApiVersion.VS12Update2).
        /// </summary>
        /// <param name="pPackageFullName">
        /// [In] Triggering application full name (package moniker).
        /// </param>
        /// <param name="Platform">
        /// [In] Application platform.
        /// </param>
        /// <param name="pResult">
        /// [Out] The result of trigger prefetch.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE TriggerPrefetch(
            _In_ DkmString* pPackageFullName,
            _In_ DefaultPort::DkmPackagedAppPlatform_t Platform,
            _Out_ HRESULT* pResult
            );

        /// <summary>
        /// Removes an immersive app icon from the taskbar by closing it.
        ///
        /// This API was introduced in Visual Studio 12 Update 3 (DkmApiVersion.VS12Update3).
        /// </summary>
        /// <param name="pAppPackageId">
        /// [In] The DkmAppPackageId of the app package to be closed.
        /// </param>
        /// <param name="SessionId">
        /// [In] The ID of the session that the app package is running in.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE RemoveAppPackageFromTaskbar(
            _In_ DefaultPort::DkmAppPackageId* pAppPackageId,
            _In_ UINT32 SessionId
            );

        /// <summary>
        /// Activates a packaged application on the specified monitor. This will cause the
        /// application to start if it has not already started, and will bring it back as the
        /// active application if it is already running.
        ///
        /// This method will append a new work item to the specified work list, and return
        /// once the work item has been appended. The actual processing of the work item is
        /// asynchronous. The caller will be notified that the request is complete through
        /// the completion routine.
        ///
        /// This API was introduced in Visual Studio 12 Update 3 (DkmApiVersion.VS12Update3).
        /// </summary>
        /// <param name="pWorkList">
        /// WorkList to append the new work item to.
        /// </param>
        /// <param name="AppPlatform">
        /// [In] Application platform id.
        /// </param>
        /// <param name="pActivationName">
        /// [In] Identifier for the application to launch.
        /// </param>
        /// <param name="LaunchForDebugging">
        /// [In] If true, the app is being debugged.
        /// </param>
        /// <param name="Monitor">
        /// [In] Target monitor index.
        /// </param>
        /// <param name="pCompletionRoutine">
        /// Routine to fire when the request is complete. If the request is successfully
        /// appended to the work list, this will always fire (including when the operation is
        /// canceled). This will never fire if appending the work item fails.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ActivateAppPackageOnTargetMonitor(
            _In_ DkmWorkList* pWorkList,
            _In_ DefaultPort::DkmPackagedAppPlatform_t AppPlatform,
            _In_ DkmString* pActivationName,
            _In_ bool LaunchForDebugging,
            _In_ UINT32 Monitor,
            _In_ IDkmCompletionRoutine<Start::DkmActivateAppPackageAsyncResult>* pCompletionRoutine
            );

        /// <summary>
        /// Activates the specified packaged application. This will cause the application to
        /// start if it has not already started, and will bring it back as the active
        /// application if it is already running. When launching under the debugger,
        /// IDkmProcessLaunchNotifyListener.StartListener will be called before this API.
        ///
        /// This method will append a new work item to the specified work list, and return
        /// once the work item has been appended. The actual processing of the work item is
        /// asynchronous. The caller will be notified that the request is complete through
        /// the completion routine.
        ///
        /// This API was introduced in Visual Studio 14 RTM (DkmApiVersion.VS14RTM).
        /// </summary>
        /// <param name="pWorkList">
        /// WorkList to append the new work item to.
        /// </param>
        /// <param name="pActivationName">
        /// [In] Identifier for the package to launch.
        /// </param>
        /// <param name="LaunchForDebugging">
        /// [In] If true, the app is being debugged.
        /// </param>
        /// <param name="pCompletionRoutine">
        /// Routine to fire when the request is complete. If the request is successfully
        /// appended to the work list, this will always fire (including when the operation is
        /// canceled). This will never fire if appending the work item fails.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ActivateAppPackageWithStartupTask(
            _In_ DkmWorkList* pWorkList,
            _In_ DkmString* pActivationName,
            _In_ bool LaunchForDebugging,
            _In_ IDkmCompletionRoutine<Start::DkmActivateAppPackageAsyncResult>* pCompletionRoutine
            );
    }; // end of DkmTransportConnection

    // Flags indicating traits of the underlying connection.
    DEFINE_SCOPED_ENUM(DkmTransportConnectionFlags)
    {
        // Connection is to the local computer. This is used for both the 'pseudo-remote'
        // connection and the local connection.
        LocalComputer = 0x1,
        // Requests that cross from the higher level debugger components (ex: AD7 AL, symbol
        // handler, etc) to the low-level debugger components (ex: debug monitor) require
        // marshalling.
        MarshallingRequired = 0x2,
        // This connection is considered the default way to connect to the destination
        // computer. This flag will be used for the local connection, and for connections
        // running on the default port of remote computers.
        DefaultConnectionToTarget = 0x4
    };
    DEFINE_SCOPED_ENUM_FLAG_OPERATORS(DkmTransportConnectionFlags_t);

    // Indicates the type of transport being used to debug.
    struct DkmTransportKind
    {
        // Local is used when the monitor and engine are in the same process. This is used to
        // debug local 32-bit processes.
        // Local is defined as {99a12aaf-a2fe-4a5f-90f8-39b805c6946b}.
        static const GUID Local;
        // PseudoRemote is used when the monitor and engine are in separate processes on the
        // same machine. This is used for debugging 64-bit processes.
        // PseudoRemote is defined as {2411b469-cf60-40af-aad5-8dbb3a2d5373}.
        static const GUID PseudoRemote;
        // StandardRemote is used for remote debugging over the standard remoting
        // infrastructure.
        // StandardRemote is defined as {e7a57bd9-a372-4ea8-9764-84b9bb3501b9}.
        static const GUID StandardRemote;
    };
    __declspec(selectany) const GUID DkmTransportKind::Local = { 0x99a12aaf, 0xa2fe, 0x4a5f, { 0x90, 0xf8, 0x39, 0xb8, 0x5, 0xc6, 0x94, 0x6b } };
    __declspec(selectany) const GUID DkmTransportKind::PseudoRemote = { 0x2411b469, 0xcf60, 0x40af, { 0xaa, 0xd5, 0x8d, 0xbb, 0x3a, 0x2d, 0x53, 0x73 } };
    __declspec(selectany) const GUID DkmTransportKind::StandardRemote = { 0xe7a57bd9, 0xa372, 0x4ea8, { 0x97, 0x64, 0x84, 0xb9, 0xbb, 0x35, 0x1, 0xb9 } };

    // This represents a remote connection between the monitor and the IDE over the standard
    // transport. This class derives from DkmTransportConnection, and defines options used to
    // connect to the target computer.
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("97a0464d-a80e-ab40-233b-e55b49e3dfd9") DkmStandardRemoteTransportConnection : public DefaultPort::DkmTransportConnection
    {
        // Use DkmStandardRemoteTransportConnection::Create to create this object
        private: DkmStandardRemoteTransportConnection();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmStandardRemoteTransportConnection();
        // This object cannot be copied
        private: DkmStandardRemoteTransportConnection& operator=(const DkmStandardRemoteTransportConnection&);
        private: DkmStandardRemoteTransportConnection(const DkmStandardRemoteTransportConnection&);

        private: const DefaultPort::DkmRemoteAuthenticationMode_t m_AuthenticationMode;
        private: OPTIONAL DkmString* const m_pProxyServer;
        private: void* m__pExtendedData;

        // Authentication mode to use when connecting over a standard remote connection.
        public: DECLSPEC_NOTHROW DefaultPort::DkmRemoteAuthenticationMode_t STDMETHODCALLTYPE AuthenticationMode(
            );

        // [Optional] Proxy server used when connecting to this computer. This is null if the
        // debugger is directly connected to the computer.
        public: _Ret_opt_ DECLSPEC_NOTHROW DkmString* STDMETHODCALLTYPE ProxyServer(
            );

        /// <summary>
        /// Silently aborts the transport connection in a similar way to what happens if the
        /// Visual Studio or the Remote Debugger is terminated. The underlying connection
        /// will be dropped, any in-flight operations will be aborted, and currently any
        /// debugged processes will be terminated.
        ///
        /// This API was introduced in Visual Studio 11 Update 2 (DkmApiVersion.VS11Update2).
        /// </summary>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Abort(
            );
    }; // end of DkmStandardRemoteTransportConnection

}; // end namespace DefaultPort

// Contains types specific to debugging code running under the Common Language Runtime
// (CLR).
namespace Clr {
    // Contains the offsets for an await expression.
    struct DECLSPEC_UUID("f22942ed-2e95-dba6-04f2-d42f3439af36") DkmClrAwaitExpressionInfo
    {
        // The offset at which the expression yields.
        UINT32 YieldOffset;

        // The offset at which the expression resumes.
        UINT32 ResumeOffset;

        // The method in which the expression resumes.
        UINT32 ResumeMethodToken;

        // Release all reference-counted fields within the DkmClrAwaitExpressionInfo structure.
        static DECLSPEC_NOTHROW void STDMETHODCALLTYPE Release(
            _In_ DkmClrAwaitExpressionInfo* pItem
            )
        {
            // structure requires no cleanup
        }
    };

    // DkmClrMethodId is a token/version pair which is used to uniquely identify the symbol
    // store's understanding of a particular CLR method within a module.
    struct DECLSPEC_UUID("023de36c-0bd8-a8ac-b6d4-b1870aae7471") DkmClrMethodId
    {
        // The method definition metadata token of the method that contains this symbol.
        UINT32 Token;

        // Version is a 1-based index. This will be '1' for methods that have not been edited
        // through Edit-and-continue. For edited methods, the version indicates the ENC apply
        // of this method. Thus if the user does 5 ENC applies and a particular method is
        // only edited in the 5th apply, then there are two method ids for this method, and
        // they have Version=1 and Version=5.
        //
        // The debugger needs to deal with old versions of the method because they will
        // continue to be on the call stack until control is unwound. The debugger can also
        // hit breakpoints or stop for exceptions within exception handling regions of old
        // methods. In other words, if the user sets a breakpoint within the catch block of a
        // non-leaf method, the debugger needs to set that breakpoint within the old version
        // of the method.
        //
        // In scenarios such as function breakpoint binding, the value '0' may used to
        // indicate the current version of the method.
        UINT32 Version;

        // Compare an instance of the DkmClrMethodId struct to another instance.
        // Return value is as follows:
        // Less than zero:     This instance is less than 'other'.
        // Zero:               This instance is equal to 'other'.
        // Greater than zero:  This instance is greater than 'other'.
        DECLSPEC_NOTHROW int STDMETHODCALLTYPE CompareTo(
            const DkmClrMethodId& other
            ) const;

        bool operator==(const DkmClrMethodId& rhs) const     { return CompareTo(rhs) == 0; }
        bool operator!=(const DkmClrMethodId& rhs) const     { return CompareTo(rhs) != 0; }
        bool operator> (const DkmClrMethodId& rhs) const     { return CompareTo(rhs) > 0;  }
        bool operator< (const DkmClrMethodId& rhs) const     { return CompareTo(rhs) < 0;  }
        bool operator>=(const DkmClrMethodId& rhs) const     { return CompareTo(rhs) >= 0; }
        bool operator<=(const DkmClrMethodId& rhs) const     { return CompareTo(rhs) <= 0; }

        // Release all reference-counted fields within the DkmClrMethodId structure.
        static DECLSPEC_NOTHROW void STDMETHODCALLTYPE Release(
            _In_ DkmClrMethodId* pItem
            )
        {
            // structure requires no cleanup
        }
    };

    // Describes a range of IL instructions within a method.
    struct DECLSPEC_UUID("0dc8d999-b496-cd95-0469-06d11d4d8b23") DkmILRange
    {
        // Beginning IL offset the range.
        UINT32 StartOffset;

        // Ending IL offset of the range.
        UINT32 EndOffset;

        // Release all reference-counted fields within the DkmILRange structure.
        static DECLSPEC_NOTHROW void STDMETHODCALLTYPE Release(
            _In_ DkmILRange* pItem
            )
        {
            // structure requires no cleanup
        }
    };

    // DkmClrMethodScopeData describes a scope within a method. These are defined using
    // ISymUnmanagedWriter::OpenScope/CloseScope.
    struct DECLSPEC_UUID("97ed6d00-e7ea-5bd4-a627-de120e2e98ed") DkmClrMethodScopeData
    {
        // The IL range of this scope.
        Clr::DkmILRange ILRange;

        // The index of the parent scope in the array of scopes for the method.
        INT32 ParentScope;

        // Local variables defined in the PDB.
        DkmReadOnlyCollection<Clr::DkmClrLocalVariable*>* pLocalVariables;

        // Local constants defined in the PDB.
        DkmReadOnlyCollection<Clr::DkmClrLocalConstant*>* pLocalConstants;

        // Namespaces that are being 'used' within this scope.
        DkmReadOnlyCollection<DkmString*>* pNamespaces;

        // Release all reference-counted fields within the DkmClrMethodScopeData structure.
        static DECLSPEC_NOTHROW void STDMETHODCALLTYPE Release(
            _In_ DkmClrMethodScopeData* pItem
            );
    };

    // Structure to define the IL instruction mapping for one or more native instructions.
    struct DECLSPEC_UUID("ff28f1ad-c2f5-1684-f358-eef67257c074") DkmClrNativeCodeMapEntry
    {
        // Starting address for this block of native code.
        UINT64 NativeAddress;

        // Number of bytes of native instruction memory described by this
        // DkmClrNativeCodeMapEntry.
        UINT32 NativeSize;

        // Offset of the native instruction.
        UINT32 NativeOffset;

        // Offset of the IL instruction. '-1' is used to indicate that the native
        // instructions cannot be mapped to an IL instruction. '-2' is used to indicate that
        // the native instructions are part of the prolog. '-3' is used to indicate that the
        // naive instructions are part of the epilog.
        UINT32 ILOffset;

        // Release all reference-counted fields within the DkmClrNativeCodeMapEntry structure.
        static DECLSPEC_NOTHROW void STDMETHODCALLTYPE Release(
            _In_ DkmClrNativeCodeMapEntry* pItem
            )
        {
            // structure requires no cleanup
        }
    };

    // Represents managed type id of an object. Corresponds to COR_TYPEID defined in
    // cordebug.h.
    //
    // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
    struct DECLSPEC_UUID("e60e3116-d0f8-efb9-ef36-a373271ad669") DkmManagedTypeId
    {
        // The first token.
        UINT64 Token1;

        // The second token.
        UINT64 Token2;

        // Compare an instance of the DkmManagedTypeId struct to another instance.
        // Return value is as follows:
        // Less than zero:     This instance is less than 'other'.
        // Zero:               This instance is equal to 'other'.
        // Greater than zero:  This instance is greater than 'other'.
        DECLSPEC_NOTHROW int STDMETHODCALLTYPE CompareTo(
            const DkmManagedTypeId& other
            ) const;

        bool operator==(const DkmManagedTypeId& rhs) const     { return CompareTo(rhs) == 0; }
        bool operator!=(const DkmManagedTypeId& rhs) const     { return CompareTo(rhs) != 0; }
        bool operator> (const DkmManagedTypeId& rhs) const     { return CompareTo(rhs) > 0;  }
        bool operator< (const DkmManagedTypeId& rhs) const     { return CompareTo(rhs) < 0;  }
        bool operator>=(const DkmManagedTypeId& rhs) const     { return CompareTo(rhs) >= 0; }
        bool operator<=(const DkmManagedTypeId& rhs) const     { return CompareTo(rhs) <= 0; }

        // Release all reference-counted fields within the DkmManagedTypeId structure.
        static DECLSPEC_NOTHROW void STDMETHODCALLTYPE Release(
            _In_ DkmManagedTypeId* pItem
            )
        {
            // structure requires no cleanup
        }
    };

    // Represents managed heap object info. Corresponds to COR_HEAPOBJECT defined in
    // cordebug.h.
    //
    // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
    struct DECLSPEC_UUID("606505d6-885d-610e-9c8f-20b721710dc8") DkmManagedHeapObjectInfo
    {
        // The address of the object in memory.
        UINT64 Address;

        // The total size of the object, in bytes.
        UINT64 Size;

        // A unique id that represents the type of the object.
        Clr::DkmManagedTypeId TypeId;

        // Release all reference-counted fields within the DkmManagedHeapObjectInfo structure.
        static DECLSPEC_NOTHROW void STDMETHODCALLTYPE Release(
            _In_ DkmManagedHeapObjectInfo* pItem
            )
        {
            // structure requires no cleanup
        }
    };

    // Represents info about a managed heap root.
    //
    // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
    struct DECLSPEC_UUID("7ccd05ef-9127-6160-f766-ac0d5c7bb7ec") DkmManagedHeapRootInfo
    {
        // Address of the object.
        UINT64 Address;

        // Root type of the object.
        CorGCReferenceType RootType;

        // Name of the root object (if available).
        DkmString* pRootName;

        // ExtraData field of the CorGCReference structure that changes depending on the root
        // type. For instance for dependent handles this is the link to the secondary object.
        // For RefCount handles this is the reference count.
        UINT64 ExtraData;

        // Release all reference-counted fields within the DkmManagedHeapRootInfo structure.
        static DECLSPEC_NOTHROW void STDMETHODCALLTYPE Release(
            _In_ DkmManagedHeapRootInfo* pItem
            );
    };

    // Represents info about a managed heap segment.
    //
    // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
    struct DECLSPEC_UUID("e97bab76-a083-6166-5d3a-d22bd6576782") DkmManagedHeapSegmentInfo
    {
        // Start address of the segment.
        UINT64 StartAddress;

        // End address of the segment.
        UINT64 EndAddress;

        // Generation of the segment.
        BYTE Generation;

        // Release all reference-counted fields within the DkmManagedHeapSegmentInfo structure.
        static DECLSPEC_NOTHROW void STDMETHODCALLTYPE Release(
            _In_ DkmManagedHeapSegmentInfo* pItem
            )
        {
            // structure requires no cleanup
        }
    };

    // Represents info about a type in managed heap.
    //
    // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
    struct DECLSPEC_UUID("5c2790a6-65bd-568c-796b-7509eebb6ef1") DkmManagedHeapTypeInfo
    {
        // Name of the type.
        DkmString* pName;

        // Total number of objects for the type.
        UINT32 TotalCount;

        // Total size of the object for the type.
        UINT64 TotalSize;

        // Release all reference-counted fields within the DkmManagedHeapTypeInfo structure.
        static DECLSPEC_NOTHROW void STDMETHODCALLTYPE Release(
            _In_ DkmManagedHeapTypeInfo* pItem
            );
    };

    // Represents info about a managed object reference.
    //
    // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
    struct DECLSPEC_UUID("11a79ceb-e6b7-e642-81d1-1e7be6a42a5b") DkmManagedObjectReferenceInfo
    {
        // Address of the source object.
        UINT64 From;

        // Address of the target object.
        UINT64 To;

        // Release all reference-counted fields within the DkmManagedObjectReferenceInfo structure.
        static DECLSPEC_NOTHROW void STDMETHODCALLTYPE Release(
            _In_ DkmManagedObjectReferenceInfo* pItem
            )
        {
            // structure requires no cleanup
        }
    };

    // Describes an alias that is understood by CLR expression evaluators. An alias is a
    // symbol that can be used to refer to a value known by the debugger. Examples of these
    // values are the current exception and values returned by the last method call.  The
    // Expression Compiler can use this method to determine which aliases are valid for use
    // in expressions and their types.
    //
    // This API was introduced in Visual Studio 14 RTM (DkmApiVersion.VS14RTM).
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("04a0b24c-08ff-14c2-f131-9ec01bc1dae1") DkmClrAlias : public IUnknown
    {
        private: ___ReferenceCount_t m_ReferenceCount;
        private: DkmDispatcherObjectFlags_t m_ObjectFlags;
        private: const GUID* m_pTypeId;
        private: size_t m_ObjectGCHandle;
        // Use DkmClrAlias::Create to create this object
        private: DkmClrAlias();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmClrAlias();
        // This object cannot be copied
        private: DkmClrAlias& operator=(const DkmClrAlias&);
        private: DkmClrAlias(const DkmClrAlias&);

        private: const Clr::DkmClrAliasKind_t m_Kind;
        private: DkmString* const m_pName;
        private: DkmString* const m_pFullName;
        private: DkmString* const m_pType;
        private: const GUID m_CustomTypeInfoPayloadTypeId;
        private: DkmReadOnlyCollection<BYTE>* const m_pCustomTypeInfoPayload;
        private: void* m__pExtendedData;

        // The kind of alias this is.
        //
        // This API was introduced in Visual Studio 14 RTM (DkmApiVersion.VS14RTM).
        public: DECLSPEC_NOTHROW Clr::DkmClrAliasKind_t STDMETHODCALLTYPE Kind(
            );

        // The name of this alias.  This is the value displayed in the "Name" column of the
        // variable inspection windows.
        //
        // This API was introduced in Visual Studio 14 RTM (DkmApiVersion.VS14RTM).
        public: _Ret_ DECLSPEC_NOTHROW DkmString* STDMETHODCALLTYPE Name(
            );

        // The full name of this alias.  This is the expression to evaluate if this alias is
        // added to the Watch window.
        //
        // This API was introduced in Visual Studio 14 RTM (DkmApiVersion.VS14RTM).
        public: _Ret_ DECLSPEC_NOTHROW DkmString* STDMETHODCALLTYPE FullName(
            );

        // The assembly qualified name of the runtime type of this alias.
        //
        // This API was introduced in Visual Studio 14 RTM (DkmApiVersion.VS14RTM).
        public: _Ret_ DECLSPEC_NOTHROW DkmString* STDMETHODCALLTYPE Type(
            );

        // If this is a variable with custom type information, this is the identifier that is
        // used to identify the compiler that generated the custom type information.
        //
        // This API was introduced in Visual Studio 14 RTM (DkmApiVersion.VS14RTM).
        public: DECLSPEC_NOTHROW const GUID& STDMETHODCALLTYPE CustomTypeInfoPayloadTypeId(
            );

        // The custom type information payload used by the compiler to embed custom type
        // information.  The compiler should verify that the id stored in
        // CustomTypeInfoPayloadTypeId matches the expected id before using this value.
        //
        // This API was introduced in Visual Studio 14 RTM (DkmApiVersion.VS14RTM).
        public: _Ret_ DECLSPEC_NOTHROW DkmReadOnlyCollection<BYTE>* STDMETHODCALLTYPE CustomTypeInfoPayload(
            );

        /// <summary>
        /// Create a new DkmClrAlias object instance.
        ///
        /// This API was introduced in Visual Studio 14 RTM (DkmApiVersion.VS14RTM).
        /// </summary>
        /// <param name="Kind">
        /// [In] The kind of alias this is.
        /// </param>
        /// <param name="pName">
        /// [In] The name of this alias.  This is the value displayed in the "Name" column of
        /// the variable inspection windows.
        /// </param>
        /// <param name="pFullName">
        /// [In] The full name of this alias.  This is the expression to evaluate if this
        /// alias is added to the Watch window.
        /// </param>
        /// <param name="pType">
        /// [In] The assembly qualified name of the runtime type of this alias.
        /// </param>
        /// <param name="CustomTypeInfoPayloadTypeId">
        /// [In] If this is a variable with custom type information, this is the identifier
        /// that is used to identify the compiler that generated the custom type information.
        /// </param>
        /// <param name="pCustomTypeInfoPayload">
        /// [In] The custom type information payload used by the compiler to embed custom
        /// type information.  The compiler should verify that the id stored in
        /// CustomTypeInfoPayloadTypeId matches the expected id before using this value.
        /// </param>
        /// <param name="ppCreatedObject">
        /// [Out] Result of this method call.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ Clr::DkmClrAliasKind_t Kind,
            _In_ DkmString* pName,
            _In_ DkmString* pFullName,
            _In_ DkmString* pType,
            _In_ const GUID& CustomTypeInfoPayloadTypeId,
            _In_ DkmReadOnlyCollection<BYTE>* pCustomTypeInfoPayload,
            _Deref_out_ Clr::DkmClrAlias** ppCreatedObject
            );
    }; // end of DkmClrAlias

    // Enum that defines the kinds of aliases returned by DkmClrRuntimeInstance.GetAliases.
    // The methods referred to below are defined in the virtual module
    // Microsoft.VisualStudio.Debugger.Clr.IntrinsicMethods.  The metadata for this module is
    // available by calling DkmClrRuntimeInstance.GetIntrinsicAssemblyMetaDataBytesPtr.
    //
    // This API was introduced in Visual Studio 14 RTM (DkmApiVersion.VS14RTM).
    DEFINE_SCOPED_ENUM(DkmClrAliasKind)
    {
        // The alias is the exception on the given thread. To get this value, the Expression
        // Compiler should emit a call to GetException.
        Exception = 0,
        // The alias is a stowed exception To get this value, the Expression Compiler should
        // emit a call to GetStowedException.
        StowedException = 1,
        // The alias is a return value To get this value, the Expression Compiler should emit
        // a call to GetReturnValue.
        ReturnValue = 2,
        // The alias is a variable defined by the user using the Expression Evaluator To get
        // this value, the Expression Compiler should emit a call to GetObjectByAlias. The
        // value can be set by getting its address via GetVariableAddress then storing the
        // new value at that address.
        Variable = 3,
        // The alias is a heap value being tracked due to a call to CreateObjectId To get
        // this value, the Expression Compiler should emit a call to GetObjectByAlias.
        ObjectId = 4
    };

    // DkmClrAppDomain represents a CLR app domain inside a process which is being debugged.
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("337360db-44af-e459-1323-f16ddacf8b79") DkmClrAppDomain : public DkmDataContainer
    {
        // Use DkmClrAppDomain::Create to create this object
        private: DkmClrAppDomain();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmClrAppDomain();
        // This object cannot be copied
        private: DkmClrAppDomain& operator=(const DkmClrAppDomain&);
        private: DkmClrAppDomain(const DkmClrAppDomain&);

        private: const GUID m_UniqueId;
        private: const UINT32 m_Id;
        private: Clr::DkmClrRuntimeInstance* const m_pRuntimeInstance;
        private: DkmString* m_pName;
        private: void* m__pExtendedData;
        private: void* m_pClrModuleInstanceCollection0;

        // Guid which uniquely identifies this app domain object.
        public: DECLSPEC_NOTHROW const GUID& STDMETHODCALLTYPE UniqueId(
            );

        // Id of the underlying CLR app domain. While running, this uniquely identifies the
        // app domain within a particular DkmRuntimeInstance.
        public: DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE Id(
            );

        // Represents a CLR instance running in a target process.
        public: _Ret_ DECLSPEC_NOTHROW Clr::DkmClrRuntimeInstance* STDMETHODCALLTYPE RuntimeInstance(
            );

        // DkmProcess represents a target process which is being debugged. The debugger
        // debugs processes, so this is the basic unit of debugging. A DkmProcess can
        // represent a system process or a virtual process such as minidumps.
        public: _Ret_ DECLSPEC_NOTHROW DkmProcess* STDMETHODCALLTYPE Process(
            );

        // AppDomain Name.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetName(
            _Deref_out_ DkmString** ppValue);

        /// <summary>
        /// Closes a DkmClrAppDomain object instance. This will release any resources
        /// associated with this object across all components. This includes resources across
        /// computer or managed/native marshalling boundaries.
        ///
        /// DkmClrAppDomain objects are automatically closed when their associated
        /// DkmClrRuntimeInstance object is closed.
        ///
        /// This method may only be called by the component which created the object.
        /// </summary>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Close(
            );

        /// <summary>
        /// This method is called by the managed debug monitor to create a DkmClrAppDomain
        /// object. It is called on the event thread in response to the target process
        /// creating an AppDomain. The caller is responsible for closing the created object
        /// after they are done.
        /// </summary>
        /// <param name="Id">
        /// [In] Id of the underlying CLR app domain. While running, this uniquely identifies
        /// the app domain within a particular DkmRuntimeInstance.
        /// </param>
        /// <param name="pRuntimeInstance">
        /// [In] Represents a CLR instance running in a target process.
        /// </param>
        /// <param name="pName">
        /// [In] AppDomain Name.
        /// </param>
        /// <param name="DataItem">
        /// [In] Data object to add to the new DkmClrAppDomain instance. DkmDataItem::Null()
        /// in the case that the caller doesn't need to add a data item.
        /// </param>
        /// <param name="ppCreatedObject">
        /// [Out] Result of this method call.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ UINT32 Id,
            _In_ Clr::DkmClrRuntimeInstance* pRuntimeInstance,
            _In_ DkmString* pName,
            _In_ const DkmDataItem& DataItem,
            _Deref_out_ Clr::DkmClrAppDomain** ppCreatedObject
            );

        /// <summary>
        /// Find a DkmClrModuleInstance element within this DkmClrAppDomain. If no element
        /// with the given input key is present, FindClrModuleInstance will fail.
        /// </summary>
        /// <param name="Mvid">
        /// [In] Search key used to find the element.
        /// </param>
        /// <param name="ppClrModuleInstance">
        /// [Out] Result of the search.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// E_XAPI_OBJECT_NOT_FOUND indicates that the search key cannot be found.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE FindClrModuleInstance(
            _In_ const GUID& Mvid,
            _Deref_out_ Clr::DkmClrModuleInstance** ppClrModuleInstance
            );

        /// <summary>
        /// GetClrModuleInstances enumerates the DkmClrModuleInstance elements of this
        /// DkmClrAppDomain object.
        /// </summary>
        /// <param name="pClrModuleInstances">
        /// [Out] Array containing the enumerated elements.
        ///
        /// The memory for the DkmArray members is allocated by the method implementation
        /// using DkmAllocBytes/DkmAllocArray. It is freed by the caller using the
        /// CAutoDkmArray template or with DkmFreeMemory and manual element release.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetClrModuleInstances(
            _Out_ DkmArray<Clr::DkmClrModuleInstance*>* pClrModuleInstances
            );

        #ifndef EXCLUDE_MONITOR_ONLY_APIS
        /// <summary>
        /// Provides direct access to the ICorDebugAppDomain object, which expression
        /// evaluators or other components can use to inspect the app domain.
        ///
        /// The returned interface may ONLY be used to inspect the target process, and should
        /// NEVER be used to control execution (no stepping, no breakpoints, no continue,
        /// etc). Doing so is unsupported and will result in undefined behavior.
        ///
        /// Location constraint: API must be called from a Monitor component (component level
        /// &lt; 100,000).
        /// </summary>
        /// <param name="ppCorAppDomain">
        /// [Out] ICorDebug interface representing an app domain inspection.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetCorObject(
            _Deref_out_ ICorDebugAppDomain** ppCorAppDomain
            );
        #endif // #ifndef EXCLUDE_MONITOR_ONLY_APIS

        #ifndef EXCLUDE_MONITOR_ONLY_APIS
        /// <summary>
        /// Get the managed runtime module instance.(mscorlib.dll).
        ///
        /// Location constraint: API must be called from a Monitor component (component level
        /// &lt; 100,000).
        ///
        /// This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
        /// </summary>
        /// <param name="ppRuntimeModule">
        /// [Out] The CLR runtime module instance found.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetManagedRuntimeModule(
            _Deref_out_ Clr::DkmClrModuleInstance** ppRuntimeModule
            );
        #endif // #ifndef EXCLUDE_MONITOR_ONLY_APIS

        /// <summary>
        /// Get a pointer to the raw metadata bytes of the manifest module of the requested
        /// assembly that has not been loaded in the debuggee process. NOTE:  This pointer
        /// value will become invalid if/when the actual module loads in the debuggee process
        /// or if the app domain is unloaded.
        ///
        /// This API was introduced in Visual Studio 14 RTM (DkmApiVersion.VS14RTM).
        /// </summary>
        /// <param name="pAssemblyName">
        /// [In] The fully qualified name of the assembly to load.
        /// </param>
        /// <param name="pSize">
        /// [Out] The size of the metadata buffer.
        /// </param>
        /// <param name="pMetaDataPtr">
        /// [Out] A pointer to the metadata buffer.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// CORDB_E_MISSING_METADATA indicates that the assembly was not found or could not
        /// be loaded.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetMetaDataBytesPtr(
            _In_ DkmString* pAssemblyName,
            _Out_ UINT32* pSize,
            _Out_ LPCVOID* pMetaDataPtr
            );

        #ifndef EXCLUDE_IDE_ONLY_APIS
        /// <summary>
        /// Used internally to support DkmClrAppDomain.GetMetaDataBytesPtr.  For performance
        /// reasons, use GetMetaDataBytesPtr instead of this method.
        ///
        /// Location constraint: API must be called from an IDE component (component level
        /// &gt; 100,000).
        ///
        /// This API was introduced in Visual Studio 14 RTM (DkmApiVersion.VS14RTM).
        /// </summary>
        /// <param name="pAssemblyName">
        /// [In] The fully qualified name of the assembly to load.
        /// </param>
        /// <param name="pMvid">
        /// [Out] The MVID of the module that was loaded.
        /// </param>
        /// <param name="pMetaData">
        /// [Out] The metadata blob.
        ///
        /// The memory for the DkmArray members is allocated by the method implementation
        /// using DkmAllocBytes/DkmAllocArray. It is freed by the caller using the
        /// CAutoDkmArray template or with DkmFreeMemory and manual element release.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// CORDB_E_MISSING_METADATA indicates that the assembly was not found or could not
        /// be loaded.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetMetaDataBytes(
            _In_ DkmString* pAssemblyName,
            _Out_ GUID* pMvid,
            _Out_ DkmArray<BYTE>* pMetaData
            );
        #endif // #ifndef EXCLUDE_IDE_ONLY_APIS

        #ifndef EXCLUDE_IDE_ONLY_APIS
        /// <summary>
        /// Resolve an assembly by name and return the MVID of its manifest module.
        ///
        /// Location constraint: API must be called from an IDE component (component level
        /// &gt; 100,000).
        ///
        /// This API was introduced in Visual Studio 14 RTM (DkmApiVersion.VS14RTM).
        /// </summary>
        /// <param name="pAssemblyName">
        /// [In] The fully qualified name of the assembly to resolve.
        /// </param>
        /// <param name="pMvid">
        /// [Out] The MVID of the resolved assembly's manifest module.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// COR_E_FILENOTFOUND/System.FileNotFoundException indicates that the assembly was
        /// not found or could not be loaded.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ResolveMvidByAssemblyName(
            _In_ DkmString* pAssemblyName,
            _Out_ GUID* pMvid
            );
        #endif // #ifndef EXCLUDE_IDE_ONLY_APIS
    }; // end of DkmClrAppDomain

    // In an async method. all the possible locations the debugger could have stopped.
    DEFINE_SCOPED_ENUM(DkmClrAsyncMethodLocation)
    {
        // Not an async method.
        None = 0x0,
        // First statement of an async method. We step out synchronously here.
        FirstStatement = 0x1,
        // In an async method but not at an await expression.
        NonAwaitStatement = 0x2,
        // In an await statement and before an yield point.
        BeforeYield = 0x4,
        // At an yield point.
        AtYield = 0x8,
        // Last statement of the method - step into or step over should turn into step out.
        LastStatement = 0x10
    };
    DEFINE_SCOPED_ENUM_FLAG_OPERATORS(DkmClrAsyncMethodLocation_t);

    // Provides information about an exception which was caught in the target process. This
    // information includes details of the exception that was caught.
    //
    // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("0550d914-26fe-bbe7-2d19-a432bbfea685") DkmClrCaughtExceptionInformation : public IUnknown
    {
        private: ___ReferenceCount_t m_ReferenceCount;
        private: DkmDispatcherObjectFlags_t m_ObjectFlags;
        private: const GUID* m_pTypeId;
        private: size_t m_ObjectGCHandle;
        // Use DkmClrCaughtExceptionInformation::Create to create this object
        private: DkmClrCaughtExceptionInformation();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmClrCaughtExceptionInformation();
        // This object cannot be copied
        private: DkmClrCaughtExceptionInformation& operator=(const DkmClrCaughtExceptionInformation&);
        private: DkmClrCaughtExceptionInformation(const DkmClrCaughtExceptionInformation&);

        private: DkmThread* const m_pThread;
        private: const UINT64 m_FrameStart;
        private: const UINT64 m_FrameEnd;
        private: DkmInstructionAddress* const m_pInstructionAddress;
        private: const UINT32 m_CatchHandlerILOffset;
        private: DkmString* const m_pName;
        private: void* m__pExtendedData;

        // DkmThread represents a thread running in the target process.
        //
        // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
        public: _Ret_ DECLSPEC_NOTHROW DkmThread* STDMETHODCALLTYPE Thread(
            );

        // Start Address the current frame.
        //
        // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
        public: DECLSPEC_NOTHROW UINT64 STDMETHODCALLTYPE FrameStart(
            );

        // End Address the current frame.
        //
        // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
        public: DECLSPEC_NOTHROW UINT64 STDMETHODCALLTYPE FrameEnd(
            );

        // The Instruction address for this caught exception.
        //
        // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
        public: _Ret_ DECLSPEC_NOTHROW DkmInstructionAddress* STDMETHODCALLTYPE InstructionAddress(
            );

        // The IL offset of the catch handler which is about to catch this exception.
        //
        // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
        public: DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE CatchHandlerILOffset(
            );

        // Name of the Exception.
        //
        // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
        public: _Ret_ DECLSPEC_NOTHROW DkmString* STDMETHODCALLTYPE Name(
            );

        // DkmProcess represents a target process which is being debugged. The debugger
        // debugs processes, so this is the basic unit of debugging. A DkmProcess can
        // represent a system process or a virtual process such as minidumps.
        //
        // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
        public: _Ret_ DECLSPEC_NOTHROW DkmProcess* STDMETHODCALLTYPE Process(
            );

        /// <summary>
        /// Create a new DkmClrCaughtExceptionInformation object instance.
        ///
        /// This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
        /// </summary>
        /// <param name="pThread">
        /// [In] DkmThread represents a thread running in the target process.
        /// </param>
        /// <param name="FrameStart">
        /// [In] Start Address the current frame.
        /// </param>
        /// <param name="FrameEnd">
        /// [In] End Address the current frame.
        /// </param>
        /// <param name="pInstructionAddress">
        /// [In] The Instruction address for this caught exception.
        /// </param>
        /// <param name="CatchHandlerILOffset">
        /// [In] The IL offset of the catch handler which is about to catch this exception.
        /// </param>
        /// <param name="pName">
        /// [In] Name of the Exception.
        /// </param>
        /// <param name="ppCreatedObject">
        /// [Out] Result of this method call.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ DkmThread* pThread,
            _In_ UINT64 FrameStart,
            _In_ UINT64 FrameEnd,
            _In_ DkmInstructionAddress* pInstructionAddress,
            _In_ UINT32 CatchHandlerILOffset,
            _In_ DkmString* pName,
            _Deref_out_ Clr::DkmClrCaughtExceptionInformation** ppCreatedObject
            );

        #ifndef EXCLUDE_MONITOR_ONLY_APIS
        /// <summary>
        /// Raise a ClrDebugMonitorExceptionCaught event. Components which implement the
        /// event sync interface will receive the event notification. Control will return
        /// once all components have been notified.
        ///
        /// Location constraint: API must be called from a Monitor component (component level
        /// &lt; 100,000).
        ///
        /// This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
        /// </summary>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE OnClrDebugMonitorExceptionCaught(
            );
        #endif // #ifndef EXCLUDE_MONITOR_ONLY_APIS
    }; // end of DkmClrCaughtExceptionInformation

    // Indicates which version of the CLR debugging services (mscordbi.dll or other
    // implementation of the ICorDebug API) should be used when debugging this process.
    DEFINE_SCOPED_ENUM(DkmClrDebuggingServicesId)
    {
        // Debug an application using .NET Framework version 4 or later out-of-process CLR
        // execution pipeline.
        OutOfProcessPipeline = 0,
        // Debug an application running under .NET Framework version 4 or later. Note that
        // this value can use either the in-process (helper-thread based) or out-of-process
        // implementation of ICorDebug.
        DesktopClrV4 = 1,
        // Debug an application running under .NET Framework version 2.0 or earlier.
        DesktopClrV2 = 2,
        // Debug an application running using Silverlight on a Windows operating system.
        SilverlightWindows = 3,
        // Debug an application running on using Silverlight on a Mac operating system.
        SilverlightMac = 4,
        // Debug an application running under the .NET  Framework on a Windows CE device.
        DevicesClr = 5,
        // Debug an application running under the CoreCLR on a Windows Phone device.
        CoreSystemClr = 6
    };

    // Contains information from the 'Flags' field of the IMAGE_COR20_HEADER of the loaded
    // module. This indicates which type of binary was loaded.
    DEFINE_SCOPED_ENUM(DkmClrHeaderStatus)
    {
        // The binary contains no CLR code. This value is used for binaries without a
        // IMAGE_COR20_HEADER.
        NativeBinary = 0,
        // The binary contains both managed and native code. This value is used for binaries
        // with a IMAGE_COR20_HEADER and without the COMIMAGE_FLAGS_ILONLY flag.
        MixedModeBinary = 1,
        // The binary contains only managed code. This value is used for binaries with a
        // IMAGE_COR20_HEADER and with the COMIMAGE_FLAGS_ILONLY flag.
        ManagedOnlyBinary = 2,
        // The binary contains only pre-JITed managed code. This value is used for binaries
        // with a IMAGE_COR20_HEADER and with the COMIMAGE_FLAGS_IL_LIBRARY flag.
        NGenBinary = 3
    };

    // Represents a local constant defined within a method scope. These are defined with
    // ISymUnmanagedWriter::DefineConstant or ISymUnmanagedWriter2::DefineConstant2.
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("be763bf4-5d54-ece8-8dcb-6f5ed4ae3506") DkmClrLocalConstant : public IUnknown
    {
        private: ___ReferenceCount_t m_ReferenceCount;
        private: DkmDispatcherObjectFlags_t m_ObjectFlags;
        private: const GUID* m_pTypeId;
        private: size_t m_ObjectGCHandle;
        // Use DkmClrLocalConstant::Create to create this object
        private: DkmClrLocalConstant();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmClrLocalConstant();
        // This object cannot be copied
        private: DkmClrLocalConstant& operator=(const DkmClrLocalConstant&);
        private: DkmClrLocalConstant(const DkmClrLocalConstant&);

        private: Symbols::DkmModule* const m_pModule;
        private: DkmString* const m_pName;
        private: OPTIONAL DkmVariant* const m_pValue;
        private: OPTIONAL DkmReadOnlyCollection<BYTE>* const m_pAdditionalData;
        private: void* m__pExtendedData;

        // Module where this local constant is defined.
        public: _Ret_ DECLSPEC_NOTHROW Symbols::DkmModule* STDMETHODCALLTYPE Module(
            );

        // Name of the constant.
        public: _Ret_ DECLSPEC_NOTHROW DkmString* STDMETHODCALLTYPE Name(
            );

        // [Optional] Value assigned to this constant. No value implies VT_EMPTY.
        public: _Ret_opt_ DECLSPEC_NOTHROW DkmVariant* STDMETHODCALLTYPE Value(
            );

        // [Optional] Additional data used by the symbol provider to identify the constant.
        // Meaning is implementation specific.
        public: _Ret_opt_ DECLSPEC_NOTHROW DkmReadOnlyCollection<BYTE>* STDMETHODCALLTYPE AdditionalData(
            );

        /// <summary>
        /// Create a new DkmClrLocalConstant object instance.
        /// </summary>
        /// <param name="pModule">
        /// [In] Module where this local constant is defined.
        /// </param>
        /// <param name="pName">
        /// [In] Name of the constant.
        /// </param>
        /// <param name="pValue">
        /// [In,Optional] Value assigned to this constant. No value implies VT_EMPTY.
        /// </param>
        /// <param name="pAdditionalData">
        /// [In,Optional] Additional data used by the symbol provider to identify the
        /// constant. Meaning is implementation specific.
        /// </param>
        /// <param name="ppCreatedObject">
        /// [Out] Result of this method call.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ Symbols::DkmModule* pModule,
            _In_ DkmString* pName,
            _In_opt_ DkmVariant* pValue,
            _In_opt_ DkmReadOnlyCollection<BYTE>* pAdditionalData,
            _Deref_out_ Clr::DkmClrLocalConstant** ppCreatedObject
            );

        /// <summary>
        /// Provides the COR_SIGNATURE for a local constant.
        ///
        /// Location constraint: This API will fail when called from an IDE component to
        /// query information for server-side compiled ASP.NET code, or dynamically compiled
        /// code.
        /// </summary>
        /// <param name="pSignature">
        /// [Out] The COR_SIGNATURE for the constant, which defines the type of this
        /// constant.
        ///
        /// The memory for the DkmArray members is allocated by the method implementation
        /// using DkmAllocBytes/DkmAllocArray. It is freed by the caller using the
        /// CAutoDkmArray template or with DkmFreeMemory and manual element release.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetSignature(
            _Out_ DkmArray<BYTE>* pSignature
            );
    }; // end of DkmClrLocalConstant

    // Represents a local variable defined within a method scope. These are defined with
    // ISymUnmanagedWriter::DefineLocalVariable or
    // ISymUnmanagedWriter2::DefineLocalVariable2.
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("8ea1e31c-295d-3d63-f790-8f0eca9158c5") DkmClrLocalVariable : public IUnknown
    {
        private: ___ReferenceCount_t m_ReferenceCount;
        private: DkmDispatcherObjectFlags_t m_ObjectFlags;
        private: const GUID* m_pTypeId;
        private: size_t m_ObjectGCHandle;
        // Use DkmClrLocalVariable::Create to create this object
        private: DkmClrLocalVariable();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmClrLocalVariable();
        // This object cannot be copied
        private: DkmClrLocalVariable& operator=(const DkmClrLocalVariable&);
        private: DkmClrLocalVariable(const DkmClrLocalVariable&);

        private: Symbols::DkmModule* const m_pModule;
        private: DkmString* const m_pName;
        private: const UINT32 m_Attributes;
        private: const UINT32 m_Slot;
        private: OPTIONAL DkmReadOnlyCollection<BYTE>* const m_pAdditionalData;
        private: void* m__pExtendedData;

        // Module where this local variable is defined.
        public: _Ret_ DECLSPEC_NOTHROW Symbols::DkmModule* STDMETHODCALLTYPE Module(
            );

        // Name of the local variable.
        public: _Ret_ DECLSPEC_NOTHROW DkmString* STDMETHODCALLTYPE Name(
            );

        // Variable attributes defined in CorSymVarFlag. Currently, the only defined bit is
        // VAR_IS_COMP_GEN (0x1).
        public: DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE Attributes(
            );

        // The local slot used by the IL in stloc/ldloc instructions.
        public: DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE Slot(
            );

        // [Optional] Additional data used by the symbol provider to identify the local
        // variable. Meaning is implementation specific.
        public: _Ret_opt_ DECLSPEC_NOTHROW DkmReadOnlyCollection<BYTE>* STDMETHODCALLTYPE AdditionalData(
            );

        /// <summary>
        /// Create a new DkmClrLocalVariable object instance.
        /// </summary>
        /// <param name="pModule">
        /// [In] Module where this local variable is defined.
        /// </param>
        /// <param name="pName">
        /// [In] Name of the local variable.
        /// </param>
        /// <param name="Attributes">
        /// [In] Variable attributes defined in CorSymVarFlag. Currently, the only defined
        /// bit is VAR_IS_COMP_GEN (0x1).
        /// </param>
        /// <param name="Slot">
        /// [In] The local slot used by the IL in stloc/ldloc instructions.
        /// </param>
        /// <param name="pAdditionalData">
        /// [In,Optional] Additional data used by the symbol provider to identify the local
        /// variable. Meaning is implementation specific.
        /// </param>
        /// <param name="ppCreatedObject">
        /// [Out] Result of this method call.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ Symbols::DkmModule* pModule,
            _In_ DkmString* pName,
            _In_ UINT32 Attributes,
            _In_ UINT32 Slot,
            _In_opt_ DkmReadOnlyCollection<BYTE>* pAdditionalData,
            _Deref_out_ Clr::DkmClrLocalVariable** ppCreatedObject
            );

        /// <summary>
        /// Provides the COR_SIGNATURE for a local Variable.
        ///
        /// Location constraint: This API will fail when called from an IDE component to
        /// query information for server-side compiled ASP.NET code, or dynamically compiled
        /// code.
        /// </summary>
        /// <param name="pSignature">
        /// [Out] The COR_SIGNATURE for the Variable, which defines the type of this
        /// Variable.
        ///
        /// The memory for the DkmArray members is allocated by the method implementation
        /// using DkmAllocBytes/DkmAllocArray. It is freed by the caller using the
        /// CAutoDkmArray template or with DkmFreeMemory and manual element release.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetSignature(
            _Out_ DkmArray<BYTE>* pSignature
            );
    }; // end of DkmClrLocalVariable

    // Flags which indicates traits of a DkmModuleInstance which has been loaded by the CLR.
    DEFINE_SCOPED_ENUM(DkmClrModuleFlags)
    {
        // No CLR module flags are set.
        None = 0x0,
        // Module is a dynamic module (types can be added to the module as it runs).
        Dynamic = 0x1,
        // Set if the module is the core module for the managed runtime (mscorlib.dll).
        RuntimeModule = 0x2,
        // Corresponds to the value returned by ICorDebugAssembly2::IsFullyTrusted. If the
        // CLR the process is running on does not implement ICorDebugAssembly2 or
        // ICorDebugAssembly2::IsFullyTrusted fails, this flag will not be set.
        FullyTrusted = 0x4
    };
    DEFINE_SCOPED_ENUM_FLAG_OPERATORS(DkmClrModuleFlags_t);

    #ifndef EXCLUDE_MONITOR_ONLY_APIS
    // Represents a managed type.
    //
    // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("837d21de-5f4c-e07c-0f1d-227f6422d67a") DkmClrType : public IUnknown
    {
        private: ___ReferenceCount_t m_ReferenceCount;
        private: DkmDispatcherObjectFlags_t m_ObjectFlags;
        private: const GUID* m_pTypeId;
        private: size_t m_ObjectGCHandle;
        // Use DkmClrType::Create to create this object
        private: DkmClrType();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmClrType();
        // This object cannot be copied
        private: DkmClrType& operator=(const DkmClrType&);
        private: DkmClrType(const DkmClrType&);

        // Contains additional fields of DkmClrType which were added after the class was
        // initally introduced.
        private: struct ___ExtendedData
        {
            ___ExtendedData();

            // [Optional] The type of the object encompassed or referenced by this type given
            // the type is an array, pointer or reference.  This value is null if there is no
            // element type.
            OPTIONAL Clr::DkmClrType* const pElementType;

            // The CorElementType of this type.
            const UINT32 CorElementType;

            // The rank of the array.  This value is 0 if the type is not an array.
            const UINT32 ArrayRank;

            // If this type is synthetic and does not exist in the debuggee, this is the MVID
            // of the module the type belongs to.
            const GUID SyntheticMvid;
        };

        private: Clr::DkmClrModuleInstance* const m_pModuleInstance;
        private: const UINT32 m_Token;
        private: OPTIONAL DkmReadOnlyCollection<Clr::DkmClrType*>* const m_pGenericArguments;
        private: ___ExtendedData* const m__pExtendedData;

        // The module the type resides in.  If the type resides in a synthetic assembly, this
        // value will be a real module in the same AppDomain.
        //
        // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
        public: _Ret_ DECLSPEC_NOTHROW Clr::DkmClrModuleInstance* STDMETHODCALLTYPE ModuleInstance(
            );

        // The type def token of the type.
        //
        // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
        public: DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE Token(
            );

        // [Optional] If the type is generic, specifies the generic arguments for the type.
        //
        // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
        public: _Ret_opt_ DECLSPEC_NOTHROW DkmReadOnlyCollection<Clr::DkmClrType*>* STDMETHODCALLTYPE GenericArguments(
            );

        // [Optional] The type of the object encompassed or referenced by this type given the
        // type is an array, pointer or reference.  This value is null if there is no element
        // type.
        //
        // This API was introduced in Visual Studio 14 RTM (DkmApiVersion.VS14RTM).
        public: _Ret_opt_ DECLSPEC_NOTHROW Clr::DkmClrType* STDMETHODCALLTYPE ElementType(
            );

        // The CorElementType of this type.
        //
        // This API was introduced in Visual Studio 14 RTM (DkmApiVersion.VS14RTM).
        public: DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE CorElementType(
            );

        // The rank of the array.  This value is 0 if the type is not an array.
        //
        // This API was introduced in Visual Studio 14 RTM (DkmApiVersion.VS14RTM).
        public: DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE ArrayRank(
            );

        // If this type is synthetic and does not exist in the debuggee, this is the MVID of
        // the module the type belongs to.
        //
        // This API was introduced in Visual Studio 14 RTM (DkmApiVersion.VS14RTM).
        public: DECLSPEC_NOTHROW const GUID& STDMETHODCALLTYPE SyntheticMvid(
            );

        // The app domain of the type.
        //
        // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
        public: _Ret_ DECLSPEC_NOTHROW Clr::DkmClrAppDomain* STDMETHODCALLTYPE AppDomain(
            );

        // The process of the type.
        //
        // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
        public: _Ret_ DECLSPEC_NOTHROW Clr::DkmClrRuntimeInstance* STDMETHODCALLTYPE RuntimeInstance(
            );

        /// <summary>
        /// Create a new DkmClrType object instance.
        ///
        /// Location constraint: API must be called from a Monitor component (component level
        /// &lt; 100,000).
        ///
        /// This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
        /// </summary>
        /// <param name="pModuleInstance">
        /// [In] The module the type resides in.  If the type resides in a synthetic
        /// assembly, this value will be a real module in the same AppDomain.
        /// </param>
        /// <param name="Token">
        /// [In] The type def token of the type.
        /// </param>
        /// <param name="pGenericArguments">
        /// [In,Optional] If the type is generic, specifies the generic arguments for the
        /// type.
        /// </param>
        /// <param name="ppCreatedObject">
        /// [Out] Result of this method call.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ Clr::DkmClrModuleInstance* pModuleInstance,
            _In_ UINT32 Token,
            _In_opt_ DkmReadOnlyCollection<Clr::DkmClrType*>* pGenericArguments,
            _Deref_out_ Clr::DkmClrType** ppCreatedObject
            );

        /// <summary>
        /// Create a new DkmClrType object instance.
        ///
        /// Location constraint: API must be called from a Monitor component (component level
        /// &lt; 100,000).
        ///
        /// This API was introduced in Visual Studio 14 RTM (DkmApiVersion.VS14RTM).
        /// </summary>
        /// <param name="pModuleInstance">
        /// [In] The module the type resides in.  If the type resides in a synthetic
        /// assembly, this value will be a real module in the same AppDomain.
        /// </param>
        /// <param name="Token">
        /// [In] The type def token of the type.
        /// </param>
        /// <param name="pGenericArguments">
        /// [In,Optional] If the type is generic, specifies the generic arguments for the
        /// type.
        /// </param>
        /// <param name="pElementType">
        /// [In,Optional] The type of the object encompassed or referenced by this type given
        /// the type is an array, pointer or reference.  This value is null if there is no
        /// element type.
        /// </param>
        /// <param name="CorElementType">
        /// [In] The CorElementType of this type.
        /// </param>
        /// <param name="ArrayRank">
        /// [In] The rank of the array.  This value is 0 if the type is not an array.
        /// </param>
        /// <param name="SyntheticMvid">
        /// [In] If this type is synthetic and does not exist in the debuggee, this is the
        /// MVID of the module the type belongs to.
        /// </param>
        /// <param name="ppCreatedObject">
        /// [Out] Result of this method call.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ Clr::DkmClrModuleInstance* pModuleInstance,
            _In_ UINT32 Token,
            _In_opt_ DkmReadOnlyCollection<Clr::DkmClrType*>* pGenericArguments,
            _In_opt_ Clr::DkmClrType* pElementType,
            _In_ UINT32 CorElementType,
            _In_ UINT32 ArrayRank,
            _In_ const GUID& SyntheticMvid,
            _Deref_out_ Clr::DkmClrType** ppCreatedObject
            );

        /// <summary>
        /// Resolves a method name belonging to a given class into a DkmClrMethodId.
        ///
        /// Location constraint: API must be called from a Monitor component (component level
        /// &lt; 100,000).
        ///
        /// This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
        /// </summary>
        /// <param name="pMethodName">
        /// [In] The name of the method.
        /// </param>
        /// <param name="pParameterTypes">
        /// [In,Optional] Optional array of parameter types.
        /// </param>
        /// <param name="pResult">
        /// [Out] A DkmClrMethodId describing the method.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ResolveMethodName(
            _In_ DkmString* pMethodName,
            _In_opt_ DkmReadOnlyCollection<Clr::DkmClrType*>* pParameterTypes,
            _Out_ Clr::DkmClrMethodId* pResult
            );

        /// <summary>
        /// Gets attributes on the type that affect the way variables are displayed in the
        /// debugger windows.
        ///
        /// Location constraint: API must be called from a Monitor component (component level
        /// &lt; 100,000).
        ///
        /// This API was introduced in Visual Studio 14 RTM (DkmApiVersion.VS14RTM).
        /// </summary>
        /// <param name="ppAttributes">
        /// [Out] A list of attributes that apply to this type or its members.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetEvalAttributes(
            _Deref_out_ DkmReadOnlyCollection<Evaluation::ClrCompilation::DkmClrEvalAttribute*>** ppAttributes
            );
    }; // end of DkmClrType
    #endif // #ifndef EXCLUDE_MONITOR_ONLY_APIS

    // Result of an asynchronous
    // DkmClrInstructionSymbol.GetAllAwaitExpressionInfoForStatement call.
    struct DkmGetAllAwaitExpressionInfoForStatementAsyncResult
    {
        // HRESULT code returned from the caller. This will be
        // DkmExceptionCode.COR_E_OPERATIONCANCELED (0x8013153B) if the operation was
        // canceled before processing was complete.
        HRESULT ErrorCode;

        // An array of the yield and resume points for the statement.
        DkmArray<Clr::DkmClrAwaitExpressionInfo> AsyncExpressionInfo;
    };

    // Result of an asynchronous DkmClrInstructionSymbol.GetAsyncKickoffMethod call.
    struct DkmGetAsyncKickoffMethodAsyncResult
    {
        // HRESULT code returned from the caller. This will be
        // DkmExceptionCode.COR_E_OPERATIONCANCELED (0x8013153B) if the operation was
        // canceled before processing was complete.
        HRESULT ErrorCode;

        // Kickoff method token.
        UINT32 KickoffMethodToken;
    };

    // Result of an asynchronous DkmClrInstructionSymbol.GetAsyncMethodLocation call.
    struct DkmGetAsyncMethodLocationAsyncResult
    {
        // HRESULT code returned from the caller. This will be
        // DkmExceptionCode.COR_E_OPERATIONCANCELED (0x8013153B) if the operation was
        // canceled before processing was complete.
        HRESULT ErrorCode;

        // The location of the given instruction.
        Clr::DkmClrAsyncMethodLocation_t AsyncLocation;
    };

    // Result of an asynchronous DkmClrInstructionSymbol.GetMethodLocalSymbols call.
    struct DkmGetMethodLocalSymbolsAsyncResult
    {
        // HRESULT code returned from the caller. This will be
        // DkmExceptionCode.COR_E_OPERATIONCANCELED (0x8013153B) if the operation was
        // canceled before processing was complete.
        HRESULT ErrorCode;

        // DkmClrMethodScopeData[] describes a scope within a method. These are defined using
        // ISymUnmanagedWriter::OpenScope/CloseScope.
        DkmArray<Clr::DkmClrMethodScopeData> Scopes;
    };

    // Result of an asynchronous DkmClrInstructionSymbol.GetMethodSymbolStoreAttribute call.
    struct DkmGetMethodSymbolStoreAttributeAsyncResult
    {
        // HRESULT code returned from the caller. This will be
        // DkmExceptionCode.COR_E_OPERATIONCANCELED (0x8013153B) if the operation was
        // canceled before processing was complete.
        HRESULT ErrorCode;

        // The value of the requested symbol store attribute. This will be an empty array if
        // the specified attribute name cannot be found.
        DkmArray<BYTE> Data;
    };

    // Result of an asynchronous DkmClrModuleInstance.GetMethodTokens call.
    struct DkmGetMethodTokensAsyncResult
    {
        // HRESULT code returned from the caller. This will be
        // DkmExceptionCode.COR_E_OPERATIONCANCELED (0x8013153B) if the operation was
        // canceled before processing was complete.
        HRESULT ErrorCode;

        // Array of tokens for the method.
        DkmArray<UINT32> Tokens;
    };

    // Result of an asynchronous DkmClrInstructionSymbol.GetNextAwaitExpressionInfo call.
    struct DkmGetNextAwaitExpressionInfoAsyncResult
    {
        // HRESULT code returned from the caller. This will be
        // DkmExceptionCode.COR_E_OPERATIONCANCELED (0x8013153B) if the operation was
        // canceled before processing was complete.
        HRESULT ErrorCode;

        // Next await expression info.
        Clr::DkmClrAwaitExpressionInfo AwaitExpressionInfo;
    };

    // Represents options for invoking the IL interpreter.
    //
    // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
    DEFINE_SCOPED_ENUM(DkmILInterpreterOptions)
    {
        // If true and we are interpreting a virtual function, indicates that the IL
        // interpreter should use virtual dispatch to figure out the most derived
        // implementation. If false, the specific method provided will be the one
        // interpreted.
        ResolveVirtual = 0x1
    };
    DEFINE_SCOPED_ENUM_FLAG_OPERATORS(DkmILInterpreterOptions_t);

    #ifndef EXCLUDE_MONITOR_ONLY_APIS
    // A value that can be passed into and returned from a managed method being interpreted.
    //
    // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
    //
    // Derived classes: DkmILInterpreterPrimitiveValue, DkmILInterpreterReferenceValue
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("4851b2d6-89f2-46f5-1a56-f257135c3b4b") DkmILInterpreterValue : public IUnknown
    {
        private: ___ReferenceCount_t m_ReferenceCount;
        private: DkmDispatcherObjectFlags_t m_ObjectFlags;
        private: const GUID* m_pTypeId;
        private: size_t m_ObjectGCHandle;
        // Use DkmILInterpreterValue::Create to create this object
        private: DkmILInterpreterValue();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmILInterpreterValue();
        // This object cannot be copied
        private: DkmILInterpreterValue& operator=(const DkmILInterpreterValue&);
        private: DkmILInterpreterValue(const DkmILInterpreterValue&);

        // DkmILInterpreterValue is an abstract base class. This enum indicates which derived
        // class this object is an instance of.
        public: FORWARD_DECLARE_SCOPED_ENUM(Tag);
        DEFINE_SCOPED_ENUM(Tag)
        {
        // Object is an instance of 'DkmILInterpreterPrimitiveValue'.
        PrimitiveValue = 0,
        // Object is an instance of 'DkmILInterpreterReferenceValue'.
        ReferenceValue = 1
        };

        private: const Tag_t m_TagValue;
        private: Clr::DkmClrRuntimeInstance* const m_pRuntimeInstance;
        private: void* m__pExtendedData;

        // DkmILInterpreterValue is an abstract base class. This enum indicates which derived
        // class this object is an instance of.
        public: DECLSPEC_NOTHROW Tag_t STDMETHODCALLTYPE TagValue(
            );

        // Represents a CLR instance running in a target process.
        //
        // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
        public: _Ret_ DECLSPEC_NOTHROW Clr::DkmClrRuntimeInstance* STDMETHODCALLTYPE RuntimeInstance(
            );
    }; // end of DkmILInterpreterValue
    #endif // #ifndef EXCLUDE_MONITOR_ONLY_APIS

    // DkmManagedHeapSampler represents a sampler for objects in the managed heap.
    //
    // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("14537042-a674-0f63-20ba-a9fab411d46a") DkmManagedHeapSampler : public DkmDataContainer
    {
        // Use DkmManagedHeapSampler::Create to create this object
        private: DkmManagedHeapSampler();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmManagedHeapSampler();
        // This object cannot be copied
        private: DkmManagedHeapSampler& operator=(const DkmManagedHeapSampler&);
        private: DkmManagedHeapSampler(const DkmManagedHeapSampler&);

        private: const GUID m_UniqueId;
        private: DkmRuntimeInstance* const m_pRuntimeInstance;
        private: void* m__pExtendedData;

        // Guid which uniquely identifies this DkmManagedHeapSampler.
        //
        // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
        public: DECLSPEC_NOTHROW const GUID& STDMETHODCALLTYPE UniqueId(
            );

        // The DkmRuntimeInstance class represents an execution environment which is loaded
        // into a DkmProcess and which contains code to be debugged.
        //
        // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
        public: _Ret_ DECLSPEC_NOTHROW DkmRuntimeInstance* STDMETHODCALLTYPE RuntimeInstance(
            );

        /// <summary>
        /// Closes a DkmManagedHeapSampler object instance. This will release any resources
        /// associated with this object across all components. This includes resources across
        /// computer or managed/native marshalling boundaries.
        ///
        /// DkmManagedHeapSampler objects are automatically closed when their associated
        /// DkmRuntimeInstance object is closed.
        ///
        /// This method may only be called by the component which created the object.
        ///
        /// This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
        /// </summary>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Close(
            );

        /// <summary>
        /// Create a new DkmManagedHeapSampler object instance. The caller is responsible for
        /// closing the created object after they are done.
        ///
        /// This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
        /// </summary>
        /// <param name="pRuntimeInstance">
        /// [In] The DkmRuntimeInstance class represents an execution environment which is
        /// loaded into a DkmProcess and which contains code to be debugged.
        /// </param>
        /// <param name="DataItem">
        /// [In] Data object to add to the new DkmManagedHeapSampler instance.
        /// DkmDataItem::Null() in the case that the caller doesn't need to add a data item.
        /// </param>
        /// <param name="ppCreatedObject">
        /// [Out] Result of this method call.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ DkmRuntimeInstance* pRuntimeInstance,
            _In_ const DkmDataItem& DataItem,
            _Deref_out_ Clr::DkmManagedHeapSampler** ppCreatedObject
            );

        /// <summary>
        /// Initializes heap sampler.
        ///
        /// This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
        /// </summary>
        /// <param name="TargetObjectCount">
        /// [In] The number of sampled objects to return.
        /// </param>
        /// <param name="LiveObjectStatsOnly">
        /// [In] Whether the sampler should calculate stats for only the live objects on the
        /// heap.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// E_MANAGED_HEAP_NOT_ENUMERABLE indicates that the managed heap is not a state that
        /// can be enumerated.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE InitializeHeapObjectWalk(
            _In_ UINT32 TargetObjectCount,
            _In_ bool LiveObjectStatsOnly
            );

        /// <summary>
        /// Walks the given number of objects on the heap.
        ///
        /// This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
        /// </summary>
        /// <param name="RequestCount">
        /// [In] Count of items requested.
        /// </param>
        /// <param name="pFetchedCount">
        /// [Out] Count of items fetched.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE NextObjects(
            _In_ UINT32 RequestCount,
            _Out_ UINT32* pFetchedCount
            );

        /// <summary>
        /// Walks the given number of references on the heap.
        ///
        /// This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
        /// </summary>
        /// <param name="RequestCount">
        /// [In] Count of items requested.
        /// </param>
        /// <param name="pFetchedCount">
        /// [Out] Count of items fetched.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE NextReferences(
            _In_ UINT32 RequestCount,
            _Out_ UINT32* pFetchedCount
            );

        /// <summary>
        /// Walks the given number of GC roots on the heap.
        ///
        /// This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
        /// </summary>
        /// <param name="RequestCount">
        /// [In] Count of items requested.
        /// </param>
        /// <param name="pFetchedCount">
        /// [Out] Count of items fetched.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE NextRoots(
            _In_ UINT32 RequestCount,
            _Out_ UINT32* pFetchedCount
            );

        /// <summary>
        /// Returns the next requested portion of serialized object graph data.
        ///
        /// This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
        /// </summary>
        /// <param name="RequestCount">
        /// [In] Count of items requested.
        /// </param>
        /// <param name="pItems">
        /// [Out] Sampled heap data.
        ///
        /// The memory for the DkmArray members is allocated by the method implementation
        /// using DkmAllocBytes/DkmAllocArray. It is freed by the caller using the
        /// CAutoDkmArray template or with DkmFreeMemory and manual element release.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetSampledHeapData(
            _In_ UINT32 RequestCount,
            _Out_ DkmArray<BYTE>* pItems
            );

        /// <summary>
        /// Returns the heap type stats.
        ///
        /// This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
        /// </summary>
        /// <param name="pItems">
        /// [Out] Sampled heap type stats.
        ///
        /// The memory for the DkmArray members is allocated by the method implementation
        /// using DkmAllocBytes/DkmAllocArray. It is freed by the caller using the
        /// CAutoDkmArray template or with DkmFreeMemory and manual element release.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetSampledHeapTypeStats(
            _Out_ DkmArray<Clr::DkmManagedHeapTypeInfo>* pItems
            );

        /// <summary>
        /// Returns roots from the sampled heap.
        ///
        /// This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
        /// </summary>
        /// <param name="pItems">
        /// [Out] Sampled heap roots.
        ///
        /// The memory for the DkmArray members is allocated by the method implementation
        /// using DkmAllocBytes/DkmAllocArray. It is freed by the caller using the
        /// CAutoDkmArray template or with DkmFreeMemory and manual element release.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetRoots(
            _Out_ DkmArray<Clr::DkmManagedHeapRootInfo>* pItems
            );
    }; // end of DkmManagedHeapSampler

    // DkmManagedHeapWalker represents an enumerator for managed heap.
    //
    // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("dca8e5e0-6bfc-1a87-5ae8-4c165856c3cb") DkmManagedHeapWalker : public DkmDataContainer
    {
        // Use DkmManagedHeapWalker::Create to create this object
        private: DkmManagedHeapWalker();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmManagedHeapWalker();
        // This object cannot be copied
        private: DkmManagedHeapWalker& operator=(const DkmManagedHeapWalker&);
        private: DkmManagedHeapWalker(const DkmManagedHeapWalker&);

        private: const GUID m_UniqueId;
        private: DkmRuntimeInstance* const m_pRuntimeInstance;
        private: void* m__pExtendedData;

        // Guid which uniquely identifies this DkmManagedHeapWalker.
        //
        // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
        public: DECLSPEC_NOTHROW const GUID& STDMETHODCALLTYPE UniqueId(
            );

        // The DkmRuntimeInstance class represents an execution environment which is loaded
        // into a DkmProcess and which contains code to be debugged.
        //
        // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
        public: _Ret_ DECLSPEC_NOTHROW DkmRuntimeInstance* STDMETHODCALLTYPE RuntimeInstance(
            );

        /// <summary>
        /// Closes a DkmManagedHeapWalker object instance. This will release any resources
        /// associated with this object across all components. This includes resources across
        /// computer or managed/native marshalling boundaries.
        ///
        /// DkmManagedHeapWalker objects are automatically closed when their associated
        /// DkmRuntimeInstance object is closed.
        ///
        /// This method may only be called by the component which created the object.
        ///
        /// This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
        /// </summary>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Close(
            );

        /// <summary>
        /// Create a new DkmManagedHeapWalker object instance. The caller is responsible for
        /// closing the created object after they are done.
        ///
        /// This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
        /// </summary>
        /// <param name="pRuntimeInstance">
        /// [In] The DkmRuntimeInstance class represents an execution environment which is
        /// loaded into a DkmProcess and which contains code to be debugged.
        /// </param>
        /// <param name="DataItem">
        /// [In] Data object to add to the new DkmManagedHeapWalker instance.
        /// DkmDataItem::Null() in the case that the caller doesn't need to add a data item.
        /// </param>
        /// <param name="ppCreatedObject">
        /// [Out] Result of this method call.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ DkmRuntimeInstance* pRuntimeInstance,
            _In_ const DkmDataItem& DataItem,
            _Deref_out_ Clr::DkmManagedHeapWalker** ppCreatedObject
            );

        /// <summary>
        /// Prepares enumerator for walking the objects in the heap, returns error if heap
        /// cannot be enumerated.
        ///
        /// This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
        /// </summary>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// E_MANAGED_HEAP_NOT_ENUMERABLE indicates that the managed heap is not a state that
        /// can be enumerated.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE InitializeHeapObjectWalk(
            );

        /// <summary>
        /// Prepares enumeration for reporting references between objects in the heap,
        /// returns error if heap cannot be enumerated.
        ///
        /// This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
        /// </summary>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// E_MANAGED_HEAP_NOT_ENUMERABLE indicates that the managed heap is not a state that
        /// can be enumerated.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE InitializeHeapReferenceWalk(
            );

        /// <summary>
        /// Prepares enumeration for reporting roots in the heap, returns error if heap
        /// cannot be enumerated.
        ///
        /// This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
        /// </summary>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// E_MANAGED_HEAP_NOT_ENUMERABLE indicates that the managed heap is not a state that
        /// can be enumerated.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE InitializeHeapRootsWalk(
            );

        /// <summary>
        /// Returns the next set of objects from the enumeration.
        ///
        /// This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
        /// </summary>
        /// <param name="RequestCount">
        /// [In] Count of items requested.
        /// </param>
        /// <param name="pItems">
        /// [Out] Array containing the managed heap object infos.
        ///
        /// The memory for the DkmArray members is allocated by the method implementation
        /// using DkmAllocBytes/DkmAllocArray. It is freed by the caller using the
        /// CAutoDkmArray template or with DkmFreeMemory and manual element release.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE NextObjects(
            _In_ UINT32 RequestCount,
            _Out_ DkmArray<Clr::DkmManagedHeapObjectInfo>* pItems
            );

        /// <summary>
        /// Returns the next set of elements from the enumeration.
        ///
        /// This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
        /// </summary>
        /// <param name="RequestCount">
        /// [In] Count of items requested.
        /// </param>
        /// <param name="pItems">
        /// [Out] Array containing the managed heap reference infos.
        ///
        /// The memory for the DkmArray members is allocated by the method implementation
        /// using DkmAllocBytes/DkmAllocArray. It is freed by the caller using the
        /// CAutoDkmArray template or with DkmFreeMemory and manual element release.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE NextReferences(
            _In_ UINT32 RequestCount,
            _Out_ DkmArray<Clr::DkmManagedObjectReferenceInfo>* pItems
            );

        /// <summary>
        /// Returns the next set of roots from the enumeration.
        ///
        /// This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
        /// </summary>
        /// <param name="RequestCount">
        /// [In] Count of items requested.
        /// </param>
        /// <param name="pItems">
        /// [Out] Array containing the managed heap root infos.
        ///
        /// The memory for the DkmArray members is allocated by the method implementation
        /// using DkmAllocBytes/DkmAllocArray. It is freed by the caller using the
        /// CAutoDkmArray template or with DkmFreeMemory and manual element release.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE NextRoots(
            _In_ UINT32 RequestCount,
            _Out_ DkmArray<Clr::DkmManagedHeapRootInfo>* pItems
            );

        /// <summary>
        /// Gets the type names for the given type ids.
        ///
        /// This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
        /// </summary>
        /// <param name="TypeIds">
        /// [In] The list of managed type ids.
        ///
        /// The memory for the DkmArray members is allocated by the caller, and can be from
        /// any source (stack memory, static buffer, heap, etc). The implementation should
        /// not modify the members.
        /// </param>
        /// <param name="pTypeNames">
        /// [Out] The list of type names.
        ///
        /// The memory for the DkmArray members is allocated by the method implementation
        /// using DkmAllocBytes/DkmAllocArray. It is freed by the caller using the
        /// CAutoDkmArray template or with DkmFreeMemory and manual element release.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetTypeNames(
            _In_ const DkmArray<Clr::DkmManagedTypeId>& TypeIds,
            _Out_ DkmArray<DkmString*>* pTypeNames
            );

        /// <summary>
        /// Gets the list of segments in the heap.
        ///
        /// This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
        /// </summary>
        /// <param name="pSegments">
        /// [Out] The list of heap segments.
        ///
        /// The memory for the DkmArray members is allocated by the method implementation
        /// using DkmAllocBytes/DkmAllocArray. It is freed by the caller using the
        /// CAutoDkmArray template or with DkmFreeMemory and manual element release.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetSegments(
            _Out_ DkmArray<Clr::DkmManagedHeapSegmentInfo>* pSegments
            );
    }; // end of DkmManagedHeapWalker

    // Contains information needed to construct a managed DkmStackWalkFrame.
    //
    // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("b4660c09-eaf1-87dd-bbdf-8210478281a6") DkmManagedReturnStackFrame : public IUnknown
    {
        private: ___ReferenceCount_t m_ReferenceCount;
        private: DkmDispatcherObjectFlags_t m_ObjectFlags;
        private: const GUID* m_pTypeId;
        private: size_t m_ObjectGCHandle;
        // Use DkmManagedReturnStackFrame::Create to create this object
        private: DkmManagedReturnStackFrame();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmManagedReturnStackFrame();
        // This object cannot be copied
        private: DkmManagedReturnStackFrame& operator=(const DkmManagedReturnStackFrame&);
        private: DkmManagedReturnStackFrame(const DkmManagedReturnStackFrame&);

        private: DkmThread* const m_pThread;
        private: const CallStack::DkmStackWalkFrameFlags_t m_Flags;
        private: const Clr::DkmClrMethodId m_Method;
        private: Clr::DkmClrModuleInstance* const m_pModuleInstance;
        private: const UINT32 m_AwaitIndex;
        private: CallStack::DkmAsyncStackWalkContext* const m_pAsyncStackWalkContext;
        private: CallStack::DkmStackWalkFrameData* const m_pData;
        private: void* m__pExtendedData;

        // The thread that this frame belongs to.
        //
        // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
        public: _Ret_ DECLSPEC_NOTHROW DkmThread* STDMETHODCALLTYPE Thread(
            );

        // Flags associated with this frame.
        //
        // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
        public: DECLSPEC_NOTHROW CallStack::DkmStackWalkFrameFlags_t STDMETHODCALLTYPE Flags(
            );

        // The managed method that this frame belongs to.
        //
        // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
        public: DECLSPEC_NOTHROW const Clr::DkmClrMethodId& STDMETHODCALLTYPE Method(
            );

        // The module that this method belongs to.
        //
        // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
        public: _Ret_ DECLSPEC_NOTHROW Clr::DkmClrModuleInstance* STDMETHODCALLTYPE ModuleInstance(
            );

        // The index of the await statement where code will transfer to when this frame later
        // executes.
        //
        // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
        public: DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE AwaitIndex(
            );

        // Context to use for continuing to walk the async return stack beyond this frame.
        //
        // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
        public: _Ret_ DECLSPEC_NOTHROW CallStack::DkmAsyncStackWalkContext* STDMETHODCALLTYPE AsyncStackWalkContext(
            );

        // Optional data object to associate with this frame.
        //
        // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
        public: _Ret_ DECLSPEC_NOTHROW CallStack::DkmStackWalkFrameData* STDMETHODCALLTYPE Data(
            );

        /// <summary>
        /// Create a new DkmManagedReturnStackFrame object instance.
        ///
        /// This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
        /// </summary>
        /// <param name="pThread">
        /// [In] The thread that this frame belongs to.
        /// </param>
        /// <param name="Flags">
        /// [In] Flags associated with this frame.
        /// </param>
        /// <param name="Method">
        /// [In] The managed method that this frame belongs to.
        /// </param>
        /// <param name="pModuleInstance">
        /// [In] The module that this method belongs to.
        /// </param>
        /// <param name="AwaitIndex">
        /// [In] The index of the await statement where code will transfer to when this frame
        /// later executes.
        /// </param>
        /// <param name="pAsyncStackWalkContext">
        /// [In] Context to use for continuing to walk the async return stack beyond this
        /// frame.
        /// </param>
        /// <param name="pData">
        /// [In] Optional data object to associate with this frame.
        /// </param>
        /// <param name="ppCreatedObject">
        /// [Out] Result of this method call.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ DkmThread* pThread,
            _In_ CallStack::DkmStackWalkFrameFlags_t Flags,
            _In_ const Clr::DkmClrMethodId& Method,
            _In_ Clr::DkmClrModuleInstance* pModuleInstance,
            _In_ UINT32 AwaitIndex,
            _In_ CallStack::DkmAsyncStackWalkContext* pAsyncStackWalkContext,
            _In_ CallStack::DkmStackWalkFrameData* pData,
            _Deref_out_ Clr::DkmManagedReturnStackFrame** ppCreatedObject
            );
    }; // end of DkmManagedReturnStackFrame

    // Provides a context for managed return value.
    //
    // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("5550ca27-ac65-0a34-f6fb-5a0688bb83aa") DkmManagedReturnValueContext : public IUnknown
    {
        private: ___ReferenceCount_t m_ReferenceCount;
        private: DkmDispatcherObjectFlags_t m_ObjectFlags;
        private: const GUID* m_pTypeId;
        private: size_t m_ObjectGCHandle;
        // Use DkmManagedReturnValueContext::Create to create this object
        private: DkmManagedReturnValueContext();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmManagedReturnValueContext();
        // This object cannot be copied
        private: DkmManagedReturnValueContext& operator=(const DkmManagedReturnValueContext&);
        private: DkmManagedReturnValueContext(const DkmManagedReturnValueContext&);

        private: DkmThread* const m_pThread;
        private: DkmRuntimeInstance* const m_pRuntime;
        private: Clr::DkmClrInstructionAddress* const m_pAddress;
        private: DkmString* const m_pName;
        private: OPTIONAL DkmString* const m_pFullName;
        private: void* m__pExtendedData;

        // The thread to retrieve the return value.
        //
        // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
        public: _Ret_ DECLSPEC_NOTHROW DkmThread* STDMETHODCALLTYPE Thread(
            );

        // The runtime of the Expression Evaluator that should evaluate this return value.
        //
        // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
        public: _Ret_ DECLSPEC_NOTHROW DkmRuntimeInstance* STDMETHODCALLTYPE Runtime(
            );

        // Return value hitting guard breakpoint address.
        //
        // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
        public: _Ret_ DECLSPEC_NOTHROW Clr::DkmClrInstructionAddress* STDMETHODCALLTYPE Address(
            );

        // Name of the finished method call.
        //
        // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
        public: _Ret_ DECLSPEC_NOTHROW DkmString* STDMETHODCALLTYPE Name(
            );

        // [Optional] Deprecated - no longer used. Full names for return value properties
        // should now be constructed based on the return value's id returned by
        // DkmRawReturnValueContainer::Id().
        //
        // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
        public: _Ret_opt_ DECLSPEC_NOTHROW DkmString* STDMETHODCALLTYPE FullName(
            );

        /// <summary>
        /// Create a new DkmManagedReturnValueContext object instance.
        ///
        /// This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
        /// </summary>
        /// <param name="pThread">
        /// [In] The thread to retrieve the return value.
        /// </param>
        /// <param name="pRuntime">
        /// [In] The runtime of the Expression Evaluator that should evaluate this return
        /// value.
        /// </param>
        /// <param name="pAddress">
        /// [In] Return value hitting guard breakpoint address.
        /// </param>
        /// <param name="pName">
        /// [In] Name of the finished method call.
        /// </param>
        /// <param name="pFullName">
        /// [In,Optional] Deprecated - no longer used. Full names for return value properties
        /// should now be constructed based on the return value's id returned by
        /// DkmRawReturnValueContainer::Id().
        /// </param>
        /// <param name="ppCreatedObject">
        /// [Out] Result of this method call.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ DkmThread* pThread,
            _In_ DkmRuntimeInstance* pRuntime,
            _In_ Clr::DkmClrInstructionAddress* pAddress,
            _In_ DkmString* pName,
            _In_opt_ DkmString* pFullName,
            _Deref_out_ Clr::DkmManagedReturnValueContext** ppCreatedObject
            );

        #ifndef EXCLUDE_MONITOR_ONLY_APIS
        /// <summary>
        /// Evaluates and formats a given DkmRawReturnValue using solely the provided data.
        ///
        /// Location constraint: API must be called from a Monitor component (component level
        /// &lt; 100,000).
        ///
        /// This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
        /// </summary>
        /// <param name="ppValueInfo">
        /// [Out] Return value from CLR.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetReturnValueInfo(
            _Deref_out_ Clr::DkmManagedReturnValueInfo** ppValueInfo
            );
        #endif // #ifndef EXCLUDE_MONITOR_ONLY_APIS
    }; // end of DkmManagedReturnValueContext

    // Provides information for managed return value.
    //
    // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
    //
    // Derived classes: DkmManagedReturnValueCopy, DkmManagedReturnValueReference
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("d72b0393-ff2a-9a20-531c-68d2bdbaaeb9") DkmManagedReturnValueInfo : public IUnknown
    {
        private: ___ReferenceCount_t m_ReferenceCount;
        private: DkmDispatcherObjectFlags_t m_ObjectFlags;
        private: const GUID* m_pTypeId;
        private: size_t m_ObjectGCHandle;
        // Use DkmManagedReturnValueInfo::Create to create this object
        private: DkmManagedReturnValueInfo();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmManagedReturnValueInfo();
        // This object cannot be copied
        private: DkmManagedReturnValueInfo& operator=(const DkmManagedReturnValueInfo&);
        private: DkmManagedReturnValueInfo(const DkmManagedReturnValueInfo&);

        // DkmManagedReturnValueInfo is an abstract base class. This enum indicates which
        // derived class this object is an instance of.
        public: FORWARD_DECLARE_SCOPED_ENUM(Tag);
        DEFINE_SCOPED_ENUM(Tag)
        {
        // Object is an instance of 'DkmManagedReturnValueReference'.
        ManagedReturnValueReference = 0,
        // Object is an instance of 'DkmManagedReturnValueCopy'.
        ManagedReturnValueCopy = 1
        };

        private: const Tag_t m_TagValue;
        private: ICorDebugType* const m_pCorType;
        private: void* m__pExtendedData;

        // DkmManagedReturnValueInfo is an abstract base class. This enum indicates which
        // derived class this object is an instance of.
        public: DECLSPEC_NOTHROW Tag_t STDMETHODCALLTYPE TagValue(
            );

        // ICorDebugType of the return value.
        //
        // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
        public: _Ret_ DECLSPEC_NOTHROW ICorDebugType* STDMETHODCALLTYPE CorType(
            );
    }; // end of DkmManagedReturnValueInfo

    // Describes whether or not metadata is available for a given module instance.
    //
    // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
    DEFINE_SCOPED_ENUM(DkmMetadataStatus)
    {
        // Not determined.
        NotDetermined = 0,
        // Metadata is present.
        Present = 1,
        // Metadata is not present.  This case can happen only in minidumps without heap when
        // we haven't loaded the binary.
        NotPresent = 2
    };

    // Indicates whether non user code is due to DebuggerHidden, DebuggerStepThrough, or
    // DebuggerNonUserCode attribute marked on method or class or marked hidden due 0xfeefee
    // sequence point.
    DEFINE_SCOPED_ENUM(DkmNonUserCodeFlags)
    {
        // Method or class is not marked with non user code related attributes.
        None = 0x0,
        // Method or class is marked with the DebuggerHidden attribute or marked hidden due
        // to 0xfeefee sequence point.
        HiddenAttribute = 0x1,
        // Method or class is marked with the DebuggerStepThrough attribute.
        StepThroughAttribute = 0x2,
        // Method or class is marked with the DebuggerNonUserCode attribute.
        NonUserCodeAttribute = 0x4
    };
    DEFINE_SCOPED_ENUM_FLAG_OPERATORS(DkmNonUserCodeFlags_t);

    // Provides information about a CLR exception which was raised in the target process.
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("42d9ccf0-bf7f-1064-377a-4aa80ac85812") DkmClrExceptionInformation : public Exceptions::DkmExceptionInformation
    {
        // Use DkmClrExceptionInformation::Create to create this object
        private: DkmClrExceptionInformation();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmClrExceptionInformation();
        // This object cannot be copied
        private: DkmClrExceptionInformation& operator=(const DkmClrExceptionInformation&);
        private: DkmClrExceptionInformation(const DkmClrExceptionInformation&);

        private: void* m__pExtendedData;

        // Type name of the exception. Example: 'System.NullReferenceException'.
        public: _Ret_ DECLSPEC_NOTHROW DkmString* STDMETHODCALLTYPE Name(
            );

        // [Optional] Address where the exception occurred. This will be null if the CLR
        // exception occurred inside the runtime when no managed code was on the stack.
        public: _Ret_opt_ DECLSPEC_NOTHROW Clr::DkmClrInstructionAddress* STDMETHODCALLTYPE InstructionAddress(
            );

        // Attempt to cast a 'DkmExceptionInformation' to a 'DkmClrExceptionInformation'. Return
        // NULL if the path object is not a 'DkmClrExceptionInformation'.
        // pClrException : [In,Optional] Object to attempt to cast
        // Return Value : [Optional] Result of the cast.
        public: static DECLSPEC_NOTHROW DkmClrExceptionInformation* TryCast(
            DkmExceptionInformation* pException
            )
        {
            if (pException == NULL || pException->TagValue() != Tag::ClrException)
                return NULL;

            return static_cast<DkmClrExceptionInformation*>(pException);
        }

        /// <summary>
        /// Create a new DkmClrExceptionInformation object instance.
        /// </summary>
        /// <param name="pRuntimeInstance">
        /// [In] The DkmRuntimeInstance class represents an execution environment which is
        /// loaded into a DkmProcess and which contains code to be debugged.
        /// </param>
        /// <param name="pThread">
        /// [In] DkmThread represents a thread running in the target process.
        /// </param>
        /// <param name="ProcessingStage">
        /// [In] The debugger receives notifications from the target process at various
        /// stages within exception processing (ex: exception thrown, exception unhandled).
        /// This enumeration indicates the stage(s) for a notification.
        /// </param>
        /// <param name="pName">
        /// [In] Type name of the exception. Example: 'System.NullReferenceException'.
        /// </param>
        /// <param name="pInstructionAddress">
        /// [In,Optional] Address where the exception occurred. This will be null if the CLR
        /// exception occurred inside the runtime when no managed code was on the stack.
        /// </param>
        /// <param name="ppCreatedObject">
        /// [Out] Result of this method call.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ DkmRuntimeInstance* pRuntimeInstance,
            _In_ DkmThread* pThread,
            _In_ Exceptions::DkmExceptionProcessingStage_t ProcessingStage,
            _In_ DkmString* pName,
            _In_opt_ Clr::DkmClrInstructionAddress* pInstructionAddress,
            _Deref_out_ Clr::DkmClrExceptionInformation** ppCreatedObject
            );
    }; // end of DkmClrExceptionInformation

    // DkmClrInstructionAddress is used for addresses in managed code.
    //
    // Derived classes: DkmClrNcInstructionAddress
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("ef7a9773-03a1-0aab-55bb-ee6b870e6246") DkmClrInstructionAddress : public DkmInstructionAddress
    {
        // Use DkmClrInstructionAddress::Create to create this object
        private: DkmClrInstructionAddress();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmClrInstructionAddress();
        // This object cannot be copied
        private: DkmClrInstructionAddress& operator=(const DkmClrInstructionAddress&);
        private: DkmClrInstructionAddress(const DkmClrInstructionAddress&);

        private: const Clr::DkmClrMethodId m_MethodId;
        private: const UINT32 m_NativeOffset;
        private: const UINT32 m_ILOffset;
        private: void* m__pExtendedData;

        // Represents a CLR instance running in a target process.
        public: _Ret_ DECLSPEC_NOTHROW Clr::DkmClrRuntimeInstance* STDMETHODCALLTYPE RuntimeInstance(
            );

        // The module containing the InstructionPointer.
        public: _Ret_ DECLSPEC_NOTHROW Clr::DkmClrModuleInstance* STDMETHODCALLTYPE ModuleInstance(
            );

        // The version/token pair for this method.
        public: DECLSPEC_NOTHROW const Clr::DkmClrMethodId& STDMETHODCALLTYPE MethodId(
            );

        // For the standard .NET Framework, NativeOffset is a byte offset relative to start
        // of the method where the CPU instruction can be found. For the purpose of this
        // value, the method should be treated as a contiguous block of bytes. If the method
        // has not been Just-in-time compiled or if this address is being used to refer
        // purely to the IL address, NativeOffset will be set to UInt32.MaxValue.
        //
        // For native-compiled .NET Framework modules,  this value is the RVA of the native
        // instruction in the module.
        public: DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE NativeOffset(
            );

        // ILOffset is the index of the IL instruction that this address represents. This
        // value may be set to UInt32.MaxValue for an instruction that is within the given
        // method, but not tied to a particular IL instruction. This is used for CLR native
        // instructions that don't map to an IL instruction. (ICorDebugILFrame::GetIP
        // indicates MAPPING_UNMAPPED_ADDRESS).
        public: DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE ILOffset(
            );

        // Attempt to cast a 'DkmInstructionAddress' to a 'DkmClrInstructionAddress'. Return
        // NULL if the path object is not a 'DkmClrInstructionAddress'.
        // pClrAddress : [In,Optional] Object to attempt to cast
        // Return Value : [Optional] Result of the cast.
        public: static DECLSPEC_NOTHROW DkmClrInstructionAddress* TryCast(
            DkmInstructionAddress* pInstructionAddress
            )
        {
            if (pInstructionAddress == NULL || pInstructionAddress->TagValue() != Tag::ClrAddress)
                return NULL;

            return static_cast<DkmClrInstructionAddress*>(pInstructionAddress);
        }

        /// <summary>
        /// Create a new DkmClrInstructionAddress object instance.
        /// </summary>
        /// <param name="pRuntimeInstance">
        /// [In] Represents a CLR instance running in a target process.
        /// </param>
        /// <param name="pModuleInstance">
        /// [In] The module containing the InstructionPointer.
        /// </param>
        /// <param name="MethodId">
        /// [In] The version/token pair for this method.
        /// </param>
        /// <param name="NativeOffset">
        /// [In] For the standard .NET Framework, NativeOffset is a byte offset relative to
        /// start of the method where the CPU instruction can be found. For the purpose of
        /// this value, the method should be treated as a contiguous block of bytes. If the
        /// method has not been Just-in-time compiled or if this address is being used to
        /// refer purely to the IL address, NativeOffset will be set to UInt32.MaxValue.
        ///
        /// For native-compiled .NET Framework modules,  this value is the RVA of the native
        /// instruction in the module.
        /// </param>
        /// <param name="ILOffset">
        /// [In] ILOffset is the index of the IL instruction that this address represents.
        /// This value may be set to UInt32.MaxValue for an instruction that is within the
        /// given method, but not tied to a particular IL instruction. This is used for CLR
        /// native instructions that don't map to an IL instruction. (ICorDebugILFrame::GetIP
        /// indicates MAPPING_UNMAPPED_ADDRESS).
        /// </param>
        /// <param name="pCPUInstruction">
        /// [In,Optional] CPUInstruction provides the address that the CPU will execute. This
        /// is always provided for native instructions. It may be provided for CLR or custom
        /// addresses depending on how the address object was created.
        /// </param>
        /// <param name="ppCreatedObject">
        /// [Out] Result of this method call.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ Clr::DkmClrRuntimeInstance* pRuntimeInstance,
            _In_ Clr::DkmClrModuleInstance* pModuleInstance,
            _In_ const Clr::DkmClrMethodId& MethodId,
            _In_ UINT32 NativeOffset,
            _In_ UINT32 ILOffset,
            _In_opt_ const DkmInstructionAddress::CPUInstruction* pCPUInstruction,
            _Deref_out_ Clr::DkmClrInstructionAddress** ppCreatedObject
            );

        /// <summary>
        /// Obtains non user code status for this instruction address.
        /// </summary>
        /// <param name="pNonUserCodeFlags">
        /// [Out] The non user code status for this instruction address.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetNonUserCodeMetadataFlags(
            _Out_ Clr::DkmNonUserCodeFlags_t* pNonUserCodeFlags
            );

        /// <summary>
        /// Provides the map of how this method was compiled to native code.
        /// </summary>
        /// <param name="pStackFrame">
        /// [In,Optional] Stack frame where this address is from. This is necessary for CLR
        /// v2 support. This argument will be ignored for CLR v4.
        /// </param>
        /// <param name="pMap">
        /// [Out] Structure to define the IL instruction mapping for one or more native
        /// instructions.
        ///
        /// The memory for the DkmArray members is allocated by the method implementation
        /// using DkmAllocBytes/DkmAllocArray. It is freed by the caller using the
        /// CAutoDkmArray template or with DkmFreeMemory and manual element release.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetNativeCodeMap(
            _In_opt_ CallStack::DkmStackWalkFrame* pStackFrame,
            _Out_ DkmArray<Clr::DkmClrNativeCodeMapEntry>* pMap
            );

        #ifndef EXCLUDE_MONITOR_ONLY_APIS
        /// <summary>
        /// Provides direct access to the ICorDebugFunction object, which expression
        /// evaluators or other components can use to inspect the app domain.
        ///
        /// The returned interface may ONLY be used to inspect the target process, and should
        /// NEVER be used to control execution (no stepping, no breakpoints, no continue,
        /// etc). Doing so is unsupported and will result in undefined behavior.
        ///
        /// Location constraint: API must be called from a Monitor component (component level
        /// &lt; 100,000).
        /// </summary>
        /// <param name="ppCorFunction">
        /// [Out] ICorDebug interface representing an app domain inspection.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetCorFunction(
            _Deref_out_ ICorDebugFunction** ppCorFunction
            );
        #endif // #ifndef EXCLUDE_MONITOR_ONLY_APIS

        #ifndef EXCLUDE_MONITOR_ONLY_APIS
        /// <summary>
        /// Helper method implemented by the managed DM and used by the shim EE to determine
        /// if a method is user code while we're walking async return stacks. We won't want
        /// to use the regular IsUserCode() method because that method makes a round trip to
        /// the symbol provider to see if there's line info.  To avoid this, we use this
        /// method to have the managed DM do its other checks. Then, when the shim EE returns
        /// to the symbol provider, the symbol provider will then check for line info.  Doing
        /// it this way allows the entire managed return stack to be calculated in one round
        /// trip to the remote side, without the need for extra chatting back and forth just
        /// to determine if return stack frames are user code or not.
        ///
        /// Location constraint: API must be called from a Monitor component (component level
        /// &lt; 100,000).
        ///
        /// This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
        /// </summary>
        /// <param name="pUserCode">
        /// [Out] True if the provided instruction address is user code.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE IsUserCodeWithoutCheckingLineInfo(
            _Out_ bool* pUserCode
            );
        #endif // #ifndef EXCLUDE_MONITOR_ONLY_APIS
    }; // end of DkmClrInstructionAddress

    // DkmClrInstructionSymbol represents an IL instruction that runs under the Common
    // Language Runtime (CLR) in the target process. This object contains the method version
    // number. So in Edit-and-Continue scenarios, the instruction symbol would be different
    // for different versions of the method. This object does not contain information about
    // generic binding parameters. So different generic instantiations of a method (ex:
    // MyMethod<string> and MyMethod<int>) are represented by the same instruction symbol
    // since the CLR represents them with a single method token.
    //
    // Derived classes: DkmClrNcInstructionSymbol
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("8e7388ae-e3e2-122c-5560-09f77dfaed9d") DkmClrInstructionSymbol : public Symbols::DkmInstructionSymbol
    {
        // Use DkmClrInstructionSymbol::Create to create this object
        private: DkmClrInstructionSymbol();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmClrInstructionSymbol();
        // This object cannot be copied
        private: DkmClrInstructionSymbol& operator=(const DkmClrInstructionSymbol&);
        private: DkmClrInstructionSymbol(const DkmClrInstructionSymbol&);

        private: const Clr::DkmClrMethodId m_MethodId;
        private: const UINT32 m_ILOffset;
        private: void* m__pExtendedData;

        // The version/token pair for this method.
        public: DECLSPEC_NOTHROW const Clr::DkmClrMethodId& STDMETHODCALLTYPE MethodId(
            );

        // ILOffset is the index of the IL instruction that this symbol represents. This
        // value may be set to UInt32.MaxValue for an instruction that is within the given
        // method, but not tied to a particular instruction. This is used for CLR native
        // instructions that don't map to an IL instruction.
        public: DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE ILOffset(
            );

        // Attempt to cast a 'DkmInstructionSymbol' to a 'DkmClrInstructionSymbol'. Return
        // NULL if the path object is not a 'DkmClrInstructionSymbol'.
        // pClrInstruction : [In,Optional] Object to attempt to cast
        // Return Value : [Optional] Result of the cast.
        public: static DECLSPEC_NOTHROW DkmClrInstructionSymbol* TryCast(
            DkmInstructionSymbol* pInstruction
            )
        {
            if (pInstruction == NULL || pInstruction->TagValue() != Tag::ClrInstruction)
                return NULL;

            return static_cast<DkmClrInstructionSymbol*>(pInstruction);
        }

        /// <summary>
        /// Create a new DkmClrInstructionSymbol object instance.
        /// </summary>
        /// <param name="pModule">
        /// [In] The DkmModule class represents a code bundle (ex: dll or exe) which is or
        /// once was loaded into one or more processes. The DkmModule class is the central
        /// object to the symbol APIs, and is 1:1 with the symbol handler's notation of what
        /// is loaded. If a code bundle loads into three different processes (or the same
        /// process but with three different base addresses or three different app domains)
        /// but the symbol handler thinks of all of these as being identical, there will be
        /// only one module object.
        /// </param>
        /// <param name="MethodId">
        /// [In] The version/token pair for this method.
        /// </param>
        /// <param name="ILOffset">
        /// [In] ILOffset is the index of the IL instruction that this symbol represents.
        /// This value may be set to UInt32.MaxValue for an instruction that is within the
        /// given method, but not tied to a particular instruction. This is used for CLR
        /// native instructions that don't map to an IL instruction.
        /// </param>
        /// <param name="ppCreatedObject">
        /// [Out] Result of this method call.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ Symbols::DkmModule* pModule,
            _In_ const Clr::DkmClrMethodId& MethodId,
            _In_ UINT32 ILOffset,
            _Deref_out_ Clr::DkmClrInstructionSymbol** ppCreatedObject
            );

        /// <summary>
        /// Gets the location of the instruction symbol in it's method.
        /// </summary>
        /// <param name="pAsyncLocation">
        /// [Out] The location of the given instruction.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetAsyncMethodLocation(
            _Out_ Clr::DkmClrAsyncMethodLocation_t* pAsyncLocation
            );

        /// <summary>
        /// Gets the location of the instruction symbol in it's method.
        ///
        /// This method will append a new work item to the specified work list, and return
        /// once the work item has been appended. The actual processing of the work item is
        /// asynchronous. The caller will be notified that the request is complete through
        /// the completion routine.
        /// </summary>
        /// <param name="pWorkList">
        /// WorkList to append the new work item to.
        /// </param>
        /// <param name="pCompletionRoutine">
        /// Routine to fire when the request is complete. If the request is successfully
        /// appended to the work list, this will always fire (including when the operation is
        /// canceled). This will never fire if appending the work item fails.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetAsyncMethodLocation(
            _In_ DkmWorkList* pWorkList,
            _In_ IDkmCompletionRoutine<Clr::DkmGetAsyncMethodLocationAsyncResult>* pCompletionRoutine
            );

        /// <summary>
        /// Gets the yield and resume points contained within the statement surrounding the
        /// given instruction symbol.
        /// </summary>
        /// <param name="pAsyncExpressionInfo">
        /// [Out] An array of the yield and resume points for the statement.
        ///
        /// The memory for the DkmArray members is allocated by the method implementation
        /// using DkmAllocBytes/DkmAllocArray. It is freed by the caller using the
        /// CAutoDkmArray template or with DkmFreeMemory and manual element release.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetAllAwaitExpressionInfoForStatement(
            _Out_ DkmArray<Clr::DkmClrAwaitExpressionInfo>* pAsyncExpressionInfo
            );

        /// <summary>
        /// Gets the yield and resume points contained within the statement surrounding the
        /// given instruction symbol.
        ///
        /// This method will append a new work item to the specified work list, and return
        /// once the work item has been appended. The actual processing of the work item is
        /// asynchronous. The caller will be notified that the request is complete through
        /// the completion routine.
        /// </summary>
        /// <param name="pWorkList">
        /// WorkList to append the new work item to.
        /// </param>
        /// <param name="pCompletionRoutine">
        /// Routine to fire when the request is complete. If the request is successfully
        /// appended to the work list, this will always fire (including when the operation is
        /// canceled). This will never fire if appending the work item fails.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetAllAwaitExpressionInfoForStatement(
            _In_ DkmWorkList* pWorkList,
            _In_ IDkmCompletionRoutine<Clr::DkmGetAllAwaitExpressionInfoForStatementAsyncResult>* pCompletionRoutine
            );

        /// <summary>
        /// Gets the optional starting IL offset of an async method's generated catch
        /// handler.
        /// </summary>
        /// <param name="pHasCatchHandlerILOffset">
        /// [Out] True if async method has a catch handler IL offset in the PDB.
        /// </param>
        /// <param name="pCatchHandlerILOffset">
        /// [Out] The catch handler's starting IL offset.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetAsyncMethodCatchHandlerILOffset(
            _Out_ bool* pHasCatchHandlerILOffset,
            _Out_ UINT32* pCatchHandlerILOffset
            );

        /// <summary>
        /// Get the yield and resume information of the next await expression.
        /// </summary>
        /// <param name="pAwaitExpressionInfo">
        /// [Out] Next await expression info.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetNextAwaitExpressionInfo(
            _Out_ Clr::DkmClrAwaitExpressionInfo* pAwaitExpressionInfo
            );

        /// <summary>
        /// Get the yield and resume information of the next await expression.
        ///
        /// This method will append a new work item to the specified work list, and return
        /// once the work item has been appended. The actual processing of the work item is
        /// asynchronous. The caller will be notified that the request is complete through
        /// the completion routine.
        /// </summary>
        /// <param name="pWorkList">
        /// WorkList to append the new work item to.
        /// </param>
        /// <param name="pCompletionRoutine">
        /// Routine to fire when the request is complete. If the request is successfully
        /// appended to the work list, this will always fire (including when the operation is
        /// canceled). This will never fire if appending the work item fails.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetNextAwaitExpressionInfo(
            _In_ DkmWorkList* pWorkList,
            _In_ IDkmCompletionRoutine<Clr::DkmGetNextAwaitExpressionInfoAsyncResult>* pCompletionRoutine
            );

        /// <summary>
        /// If the current method is an async method then return the kickoff method for this
        /// async method.
        /// </summary>
        /// <param name="pKickoffMethodToken">
        /// [Out] Kickoff method token.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetAsyncKickoffMethod(
            _Out_ UINT32* pKickoffMethodToken
            );

        /// <summary>
        /// If the current method is an async method then return the kickoff method for this
        /// async method.
        ///
        /// This method will append a new work item to the specified work list, and return
        /// once the work item has been appended. The actual processing of the work item is
        /// asynchronous. The caller will be notified that the request is complete through
        /// the completion routine.
        /// </summary>
        /// <param name="pWorkList">
        /// WorkList to append the new work item to.
        /// </param>
        /// <param name="pCompletionRoutine">
        /// Routine to fire when the request is complete. If the request is successfully
        /// appended to the work list, this will always fire (including when the operation is
        /// canceled). This will never fire if appending the work item fails.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetAsyncKickoffMethod(
            _In_ DkmWorkList* pWorkList,
            _In_ IDkmCompletionRoutine<Clr::DkmGetAsyncKickoffMethodAsyncResult>* pCompletionRoutine
            );

        /// <summary>
        /// Returns the scopes within a method. There will always be at least one scope.
        ///
        /// Location constraint: This API will fail when called from an IDE component to
        /// query information for server-side compiled ASP.NET code, or dynamically compiled
        /// code.
        ///
        /// This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
        /// </summary>
        /// <param name="pScopes">
        /// [Out] DkmClrMethodScopeData[] describes a scope within a method. These are
        /// defined using ISymUnmanagedWriter::OpenScope/CloseScope.
        ///
        /// The memory for the DkmArray members is allocated by the method implementation
        /// using DkmAllocBytes/DkmAllocArray. It is freed by the caller using the
        /// CAutoDkmArray template or with DkmFreeMemory and manual element release.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetMethodLocalSymbols(
            _Out_ DkmArray<Clr::DkmClrMethodScopeData>* pScopes
            );

        /// <summary>
        /// Returns the scopes within a method. There will always be at least one scope.
        ///
        /// This method will append a new work item to the specified work list, and return
        /// once the work item has been appended. The actual processing of the work item is
        /// asynchronous. The caller will be notified that the request is complete through
        /// the completion routine.
        ///
        /// Location constraint: This API will fail when called from an IDE component to
        /// query information for server-side compiled ASP.NET code, or dynamically compiled
        /// code.
        ///
        /// This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
        /// </summary>
        /// <param name="pWorkList">
        /// WorkList to append the new work item to.
        /// </param>
        /// <param name="pCompletionRoutine">
        /// Routine to fire when the request is complete. If the request is successfully
        /// appended to the work list, this will always fire (including when the operation is
        /// canceled). This will never fire if appending the work item fails.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetMethodLocalSymbols(
            _In_ DkmWorkList* pWorkList,
            _In_ IDkmCompletionRoutine<Clr::DkmGetMethodLocalSymbolsAsyncResult>* pCompletionRoutine
            );

        /// <summary>
        /// Gets a custom attribute based upon its name. Not to be confused with Metadata
        /// custom attributes, these attributes are held in the symbol store.
        ///
        /// Location constraint: This API will fail when called from an IDE component to
        /// query information for server-side compiled ASP.NET code, or dynamically compiled
        /// code.
        ///
        /// This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
        /// </summary>
        /// <param name="pAttributeName">
        /// [In] The name of the attribute to find.
        /// </param>
        /// <param name="pData">
        /// [Out] The value of the requested symbol store attribute. This will be an empty
        /// array if the specified attribute name cannot be found.
        ///
        /// The memory for the DkmArray members is allocated by the method implementation
        /// using DkmAllocBytes/DkmAllocArray. It is freed by the caller using the
        /// CAutoDkmArray template or with DkmFreeMemory and manual element release.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetMethodSymbolStoreAttribute(
            _In_ DkmString* pAttributeName,
            _Out_ DkmArray<BYTE>* pData
            );

        /// <summary>
        /// Gets a custom attribute based upon its name. Not to be confused with Metadata
        /// custom attributes, these attributes are held in the symbol store.
        ///
        /// This method will append a new work item to the specified work list, and return
        /// once the work item has been appended. The actual processing of the work item is
        /// asynchronous. The caller will be notified that the request is complete through
        /// the completion routine.
        ///
        /// Location constraint: This API will fail when called from an IDE component to
        /// query information for server-side compiled ASP.NET code, or dynamically compiled
        /// code.
        ///
        /// This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
        /// </summary>
        /// <param name="pWorkList">
        /// WorkList to append the new work item to.
        /// </param>
        /// <param name="pAttributeName">
        /// [In] The name of the attribute to find.
        /// </param>
        /// <param name="pCompletionRoutine">
        /// Routine to fire when the request is complete. If the request is successfully
        /// appended to the work list, this will always fire (including when the operation is
        /// canceled). This will never fire if appending the work item fails.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetMethodSymbolStoreAttribute(
            _In_ DkmWorkList* pWorkList,
            _In_ DkmString* pAttributeName,
            _In_ IDkmCompletionRoutine<Clr::DkmGetMethodSymbolStoreAttributeAsyncResult>* pCompletionRoutine
            );
    }; // end of DkmClrInstructionSymbol

    // 'DkmClrModuleInstance' is used for modules which are loaded into the Common Language
    // Runtime.
    //
    // Derived classes: DkmClrNcModuleInstance
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("29da4ffa-6063-6232-46dd-64d14cf56ddf") DkmClrModuleInstance : public DkmModuleInstance
    {
        // Use DkmClrModuleInstance::Create to create this object
        private: DkmClrModuleInstance();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmClrModuleInstance();
        // This object cannot be copied
        private: DkmClrModuleInstance& operator=(const DkmClrModuleInstance&);
        private: DkmClrModuleInstance(const DkmClrModuleInstance&);

        // Contains additional fields of DkmClrModuleInstance which were added after the
        // class was initally introduced.
        private: struct ___ExtendedData
        {
            ___ExtendedData();

            // Specifies the size of the IL image of this module.
            const UINT32 ILImageSize;
        };

        private: const GUID m_Mvid;
        private: const Clr::DkmClrModuleFlags_t m_ClrFlags;
        private: Clr::DkmClrAppDomain* const m_pAppDomain;
        private: ___ExtendedData* const m__pExtendedData;

        // Represents a CLR instance running in a target process.
        public: _Ret_ DECLSPEC_NOTHROW Clr::DkmClrRuntimeInstance* STDMETHODCALLTYPE RuntimeInstance(
            );

        // Module Version Identifier from the loaded module. This is a unique value which is
        // embedded in an exe/dll by linkers/compilers when the dll/exe is built. A new value
        // is generated each time that the dll/exe is compiled.
        public: DECLSPEC_NOTHROW const GUID& STDMETHODCALLTYPE Mvid(
            );

        // Flags which indicates traits of a DkmModuleInstance which has been loaded by the
        // CLR.
        public: DECLSPEC_NOTHROW Clr::DkmClrModuleFlags_t STDMETHODCALLTYPE ClrFlags(
            );

        // DkmClrAppDomain represents a CLR app domain inside a process which is being
        // debugged.
        public: _Ret_ DECLSPEC_NOTHROW Clr::DkmClrAppDomain* STDMETHODCALLTYPE AppDomain(
            );

        // Specifies the size of the IL image of this module.
        //
        // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
        public: DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE ILImageSize(
            );

        // Attempt to cast a 'DkmModuleInstance' to a 'DkmClrModuleInstance'. Return
        // NULL if the path object is not a 'DkmClrModuleInstance'.
        // pClrModuleInstance : [In,Optional] Object to attempt to cast
        // Return Value : [Optional] Result of the cast.
        public: static DECLSPEC_NOTHROW DkmClrModuleInstance* TryCast(
            DkmModuleInstance* pModuleInstance
            )
        {
            if (pModuleInstance == NULL || pModuleInstance->TagValue() != Tag::ClrModuleInstance)
                return NULL;

            return static_cast<DkmClrModuleInstance*>(pModuleInstance);
        }

        /// <summary>
        /// Create a new DkmClrModuleInstance object instance.
        ///
        /// This method will send a ModuleInstanceLoad event.
        /// </summary>
        /// <param name="pName">
        /// [In] Short representation of the module name. For file-based modules, this  is
        /// the file name and extension (ex: kernel32.dll).
        /// </param>
        /// <param name="pFullName">
        /// [In] Fully qualified module name. For file-based modules, this is the full path
        /// to the module (ex: c:\windows\system32\kernel32.dll.
        /// </param>
        /// <param name="TimeDateStamp">
        /// [In] Date/Time of when the loaded module was built. This value is obtained from
        /// the IMAGE_NT_HEADERS of the loaded module. The unit of measurement is a  FILETIME
        /// value, which is a 64-bit value representing the number of 100-nanosecond
        /// intervals since January 1, 1601 (UTC).
        /// </param>
        /// <param name="pVersion">
        /// [In,Optional] File version information.
        /// </param>
        /// <param name="pSymbolFileId">
        /// [In,Optional] Contains information needed to locate symbols for this module. On
        /// Win32, this information is contained within the IMAGE_DEBUG_DIRECTORY.
        /// </param>
        /// <param name="Flags">
        /// [In] Flags which indicate traits of a DkmModuleInstance.
        /// </param>
        /// <param name="MemoryLayout">
        /// [In] Enumeration that indicates how a module is laid out in memory.
        /// </param>
        /// <param name="BaseAddress">
        /// [In,Optional] The starting memory address of where the module loaded. This value
        /// will be zero if the module did not load in a contiguous block of memory.
        /// </param>
        /// <param name="LoadOrder">
        /// [In] The integer count of the number of module instances that have loaded up to
        /// and including this module. Each runtime instance keeps track of its own load
        /// order count.
        /// </param>
        /// <param name="Size">
        /// [In,Optional] The number of bytes in the module's memory region. This value will
        /// be zero if the module did not load in a contiguous block of memory.
        /// </param>
        /// <param name="pLoadContext">
        /// [In] String description of the context under which this module has been loaded.
        /// ex: 'Win32' or 'CLR v2.0.50727: Default Domain'.
        /// </param>
        /// <param name="pRuntimeInstance">
        /// [In] Represents a CLR instance running in a target process.
        /// </param>
        /// <param name="Mvid">
        /// [In] Module Version Identifier from the loaded module. This is a unique value
        /// which is embedded in an exe/dll by linkers/compilers when the dll/exe is built. A
        /// new value is generated each time that the dll/exe is compiled.
        /// </param>
        /// <param name="ClrFlags">
        /// [In] Flags which indicates traits of a DkmModuleInstance which has been loaded by
        /// the CLR.
        /// </param>
        /// <param name="pAppDomain">
        /// [In] DkmClrAppDomain represents a CLR app domain inside a process which is being
        /// debugged.
        /// </param>
        /// <param name="IsDisabled">
        /// [In] Indicates if this module instance has been disabled. Disabled modules are
        /// largely ignored by the debugger. For native modules, the address range of the
        /// disabled module is treated as if it is unmapped. For CLR modules, any frames from
        /// these modules is hidden from the call stack.
        /// </param>
        /// <param name="pModule">
        /// [In,Optional] The symbol handler's representation of a module (DkmModule) which
        /// is associated with this module instance. This value is initially null, and is
        /// assigned if and when symbols are associated with this module instance.
        /// </param>
        /// <param name="pMinidumpInfo">
        /// [In,Optional] 'MinidumpInfo' is used to convey additional information about
        /// modules in a DkmProcess for a minidump.
        /// </param>
        /// <param name="DataItem">
        /// [In] Data object to add to the new DkmClrModuleInstance instance.
        /// DkmDataItem::Null() in the case that the caller doesn't need to add a data item.
        /// </param>
        /// <param name="ppCreatedObject">
        /// [Out] Result of this method call.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ DkmString* pName,
            _In_ DkmString* pFullName,
            _In_ UINT64 TimeDateStamp,
            _In_opt_ DkmModuleVersion* pVersion,
            _In_opt_ Symbols::DkmSymbolFileId* pSymbolFileId,
            _In_ DkmModuleFlags_t Flags,
            _In_ DkmModuleMemoryLayout_t MemoryLayout,
            _In_ UINT64 BaseAddress,
            _In_ UINT32 LoadOrder,
            _In_ UINT32 Size,
            _In_ DkmString* pLoadContext,
            _In_ Clr::DkmClrRuntimeInstance* pRuntimeInstance,
            _In_ const GUID& Mvid,
            _In_ Clr::DkmClrModuleFlags_t ClrFlags,
            _In_ Clr::DkmClrAppDomain* pAppDomain,
            _In_ bool IsDisabled,
            _In_opt_ Symbols::DkmModule* pModule,
            _In_opt_ const DkmModuleInstance::MinidumpInfo* pMinidumpInfo,
            _In_ const DkmDataItem& DataItem,
            _Deref_out_ Clr::DkmClrModuleInstance** ppCreatedObject
            );

        /// <summary>
        /// Create a new DkmClrModuleInstance object instance.
        ///
        /// This method will send a ModuleInstanceLoad event.
        ///
        /// This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
        /// </summary>
        /// <param name="pName">
        /// [In] Short representation of the module name. For file-based modules, this  is
        /// the file name and extension (ex: kernel32.dll).
        /// </param>
        /// <param name="pFullName">
        /// [In] Fully qualified module name. For file-based modules, this is the full path
        /// to the module (ex: c:\windows\system32\kernel32.dll.
        /// </param>
        /// <param name="TimeDateStamp">
        /// [In] Date/Time of when the loaded module was built. This value is obtained from
        /// the IMAGE_NT_HEADERS of the loaded module. The unit of measurement is a  FILETIME
        /// value, which is a 64-bit value representing the number of 100-nanosecond
        /// intervals since January 1, 1601 (UTC).
        /// </param>
        /// <param name="pVersion">
        /// [In,Optional] File version information.
        /// </param>
        /// <param name="pSymbolFileId">
        /// [In,Optional] Contains information needed to locate symbols for this module. On
        /// Win32, this information is contained within the IMAGE_DEBUG_DIRECTORY.
        /// </param>
        /// <param name="Flags">
        /// [In] Flags which indicate traits of a DkmModuleInstance.
        /// </param>
        /// <param name="MemoryLayout">
        /// [In] Enumeration that indicates how a module is laid out in memory.
        /// </param>
        /// <param name="BaseAddress">
        /// [In,Optional] The starting memory address of where the module loaded. This value
        /// will be zero if the module did not load in a contiguous block of memory.
        /// </param>
        /// <param name="LoadOrder">
        /// [In] The integer count of the number of module instances that have loaded up to
        /// and including this module. Each runtime instance keeps track of its own load
        /// order count.
        /// </param>
        /// <param name="Size">
        /// [In,Optional] The number of bytes in the module's memory region. This value will
        /// be zero if the module did not load in a contiguous block of memory.
        /// </param>
        /// <param name="pLoadContext">
        /// [In] String description of the context under which this module has been loaded.
        /// ex: 'Win32' or 'CLR v2.0.50727: Default Domain'.
        /// </param>
        /// <param name="pRuntimeInstance">
        /// [In] Represents a CLR instance running in a target process.
        /// </param>
        /// <param name="Mvid">
        /// [In] Module Version Identifier from the loaded module. This is a unique value
        /// which is embedded in an exe/dll by linkers/compilers when the dll/exe is built. A
        /// new value is generated each time that the dll/exe is compiled.
        /// </param>
        /// <param name="ClrFlags">
        /// [In] Flags which indicates traits of a DkmModuleInstance which has been loaded by
        /// the CLR.
        /// </param>
        /// <param name="pAppDomain">
        /// [In] DkmClrAppDomain represents a CLR app domain inside a process which is being
        /// debugged.
        /// </param>
        /// <param name="ILImageSize">
        /// [In] Specifies the size of the IL image of this module.
        /// </param>
        /// <param name="IsDisabled">
        /// [In] Indicates if this module instance has been disabled. Disabled modules are
        /// largely ignored by the debugger. For native modules, the address range of the
        /// disabled module is treated as if it is unmapped. For CLR modules, any frames from
        /// these modules is hidden from the call stack.
        /// </param>
        /// <param name="pModule">
        /// [In,Optional] The symbol handler's representation of a module (DkmModule) which
        /// is associated with this module instance. This value is initially null, and is
        /// assigned if and when symbols are associated with this module instance.
        /// </param>
        /// <param name="pMinidumpInfo">
        /// [In,Optional] 'MinidumpInfo' is used to convey additional information about
        /// modules in a DkmProcess for a minidump.
        /// </param>
        /// <param name="DataItem">
        /// [In] Data object to add to the new DkmClrModuleInstance instance.
        /// DkmDataItem::Null() in the case that the caller doesn't need to add a data item.
        /// </param>
        /// <param name="ppCreatedObject">
        /// [Out] Result of this method call.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ DkmString* pName,
            _In_ DkmString* pFullName,
            _In_ UINT64 TimeDateStamp,
            _In_opt_ DkmModuleVersion* pVersion,
            _In_opt_ Symbols::DkmSymbolFileId* pSymbolFileId,
            _In_ DkmModuleFlags_t Flags,
            _In_ DkmModuleMemoryLayout_t MemoryLayout,
            _In_ UINT64 BaseAddress,
            _In_ UINT32 LoadOrder,
            _In_ UINT32 Size,
            _In_ DkmString* pLoadContext,
            _In_ Clr::DkmClrRuntimeInstance* pRuntimeInstance,
            _In_ const GUID& Mvid,
            _In_ Clr::DkmClrModuleFlags_t ClrFlags,
            _In_ Clr::DkmClrAppDomain* pAppDomain,
            _In_ UINT32 ILImageSize,
            _In_ bool IsDisabled,
            _In_opt_ Symbols::DkmModule* pModule,
            _In_opt_ const DkmModuleInstance::MinidumpInfo* pMinidumpInfo,
            _In_ const DkmDataItem& DataItem,
            _Deref_out_ Clr::DkmClrModuleInstance** ppCreatedObject
            );

        /// <summary>
        /// Obtains the CLR metadata from a given module. See IMetaDataImport documentation
        /// in MSDN for more information on metadata.
        ///
        /// NOTE: Callers must take great care when consuming this API from managed code. The
        /// IMetaDataImport implementation may hold a file handle to a debuggee file, and the
        /// file handle will only be closed when the COM reference count hits zero. So it
        /// must be manually released (Marshal.IsComObject + Marshal.ReleaseComObject) rather
        /// than waiting for the GC to detect that the object can be released. When testing,
        /// be sure that the debuggee file has at least 64KB of metadata, as the metadata
        /// reader will not keep the file locked for reading when dealing with small files.
        /// </summary>
        /// <param name="ppMetaData">
        /// [Out] The IMetaDataImport interface for this managed module instance. When
        /// consuming this API from managed code, the RCW which wraps the native
        /// implementation will have its reference count increased by 1 by this API. The
        /// caller should use Marshal.IsComObject + Marshal.ReleaseComObject to release this
        /// reference.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetMetaDataImport(
            _Deref_out_ IUnknown** ppMetaData
            );

        /// <summary>
        /// Obtains the bytes of the CLR metadata from a given module. These bytes can then
        /// be passed to IMetaDataDispenser::OpenScope to decode the metadata.
        /// </summary>
        /// <param name="pMetaData">
        /// [Out] The raw metadata for this module.
        ///
        /// The memory for the DkmArray members is allocated by the method implementation
        /// using DkmAllocBytes/DkmAllocArray. It is freed by the caller using the
        /// CAutoDkmArray template or with DkmFreeMemory and manual element release.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetMetaDataBytes(
            _Out_ DkmArray<BYTE>* pMetaData
            );

        #ifndef EXCLUDE_MONITOR_ONLY_APIS
        /// <summary>
        /// Provides direct access to the ICorDebugModule object, which expression evaluators
        /// or other components can use to inspect the app domain.
        ///
        /// The returned interface may ONLY be used to inspect the target process, and should
        /// NEVER be used to control execution (no stepping, no breakpoints, no continue,
        /// etc). Doing so is unsupported and will result in undefined behavior.
        ///
        /// Location constraint: API must be called from a Monitor component (component level
        /// &lt; 100,000).
        /// </summary>
        /// <param name="ppCorModule">
        /// [Out] ICorDebug interface representing an app domain inspection.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetCorObject(
            _Deref_out_ ICorDebugModule** ppCorModule
            );
        #endif // #ifndef EXCLUDE_MONITOR_ONLY_APIS

        #ifndef EXCLUDE_MONITOR_ONLY_APIS
        /// <summary>
        /// Resolves a type name into a type.  If the type is generic, the generic parameters
        /// will not be instantiated.
        ///
        /// Location constraint: API must be called from a Monitor component (component level
        /// &lt; 100,000).
        ///
        /// This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
        /// </summary>
        /// <param name="pTypeName">
        /// [In] The name of the type.
        /// </param>
        /// <param name="pGenericParameters">
        /// [In,Optional] If the type is generic, specifies the generic parameters for the
        /// type.
        /// </param>
        /// <param name="ppResult">
        /// [Out] A DkmClrType describing the type.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ResolveTypeName(
            _In_ DkmString* pTypeName,
            _In_opt_ DkmReadOnlyCollection<Clr::DkmClrType*>* pGenericParameters,
            _Deref_out_ Clr::DkmClrType** ppResult
            );
        #endif // #ifndef EXCLUDE_MONITOR_ONLY_APIS

        #ifndef EXCLUDE_MONITOR_ONLY_APIS
        /// <summary>
        /// Simulates the execution of a method on an object by interpreting the method's
        /// MSIL code. The result of the method will be returned back to the caller.
        /// However, unlike a function evaluation, in which the method is actually running in
        /// the target, interpreting a method does not actually execute the method, but
        /// instead, merely simulates the behavior of the method.  Because the method never
        /// actually executes, any side effects resulting from the method's execution are
        /// discarded after the interpretation of the method is complete, leaving the target
        /// process in an identical state to that from before the call.
        ///
        /// Location constraint: API must be called from a Monitor component (component level
        /// &lt; 100,000).
        ///
        /// This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
        /// </summary>
        /// <param name="Method">
        /// [In] The method to be interpreted.  This function does not support interpreting
        /// certain types of methods, including, but not limited to: - Methods that consume
        /// ref or out parameters - Methods whose implementation calls into native code via
        /// P/Invoke, COM interop, or some other means.
        /// </param>
        /// <param name="pGenericTypeParameters">
        /// [In,Optional] If the method belongs to a generic class, specifies the
        /// instantiations of the type's generic parameters.
        /// </param>
        /// <param name="pGenericMethodParameters">
        /// [In,Optional] If the method is generic, specifies the instantiations of the
        /// method's generic parameters.
        /// </param>
        /// <param name="pThisParameter">
        /// [In,Optional] If the method to be interpreted is non-static, specifies the
        /// non-null object instance that the method should be called on. If the method to be
        /// interpreted is a class constructor, this can be either null or non-null.  A null
        /// this parameter on a class constructor will cause us to virtually create a new
        /// object and interpret the constructor. A non-null this parameter to a constructor
        /// will cause us to interpret the call to the constructor on the existing object.
        /// </param>
        /// <param name="pParameters">
        /// [In,Optional] Parameters to be passed into the function, excluding the 'this'
        /// parameter.  This may be null if the function to be interpreted takes no
        /// parameters. If the function takes parameters, the length of this array must be
        /// equal to the number of parameters specified in the method signature.
        /// </param>
        /// <param name="MaxInstructionCount">
        /// [In] The maximum number of total IL instructions that we are allowed to
        /// interpret.  The IL interpretation will be aborted with an error code of E_ABORT
        /// if the actual number of instructions exceeds this limit.  This limit prevents
        /// Visual Studio from hanging if the code being interpreted enters an infinite loop.
        /// </param>
        /// <param name="Options">
        /// [In] Additional options for the IL interpreter.
        /// </param>
        /// <param name="ppReturnValue">
        /// [Out,Optional] The return value of the method.  This will be null if the method
        /// returns void or throws an exception.
        /// </param>
        /// <param name="ppExceptionType">
        /// [Out,Optional] If the method throws an unhandled exception, the type of the
        /// exception that got thrown.
        /// </param>
        /// <returns>
        /// S_OK is returned if *ppReturnValue is non-NULL, S_FALSE is returned when
        /// *ppReturnValue is NULL, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE InterpretManagedMethod(
            _In_ const Clr::DkmClrMethodId& Method,
            _In_opt_ DkmReadOnlyCollection<Clr::DkmClrType*>* pGenericTypeParameters,
            _In_opt_ DkmReadOnlyCollection<Clr::DkmClrType*>* pGenericMethodParameters,
            _In_opt_ Clr::DkmILInterpreterValue* pThisParameter,
            _In_opt_ DkmReadOnlyCollection<Clr::DkmILInterpreterValue*>* pParameters,
            _In_ UINT32 MaxInstructionCount,
            _In_ Clr::DkmILInterpreterOptions_t Options,
            _Deref_out_opt_ Clr::DkmILInterpreterValue** ppReturnValue,
            _Deref_out_opt_ DkmString** ppExceptionType
            );
        #endif // #ifndef EXCLUDE_MONITOR_ONLY_APIS

        #ifndef EXCLUDE_MONITOR_ONLY_APIS
        /// <summary>
        /// Get metadata status.
        ///
        /// Location constraint: API must be called from a Monitor component (component level
        /// &lt; 100,000).
        ///
        /// This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
        /// </summary>
        /// <param name="pMetadataStatus">
        /// [Out] Metadata status.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetMetadataStatus(
            _Out_ Clr::DkmMetadataStatus_t* pMetadataStatus
            );
        #endif // #ifndef EXCLUDE_MONITOR_ONLY_APIS

        /// <summary>
        /// Get a pointer to the raw metadata bytes for the given module.
        ///
        /// NOTE:  This pointer value will become invalid if/when the module is unloaded or
        /// modified. To detect this, implement IDkmModuleInstanceUnloadNotification and
        /// IDkmClrModuleModifiedNotification, respectively.
        ///
        /// This API was introduced in Visual Studio 14 RTM (DkmApiVersion.VS14RTM).
        /// </summary>
        /// <param name="pSize">
        /// [Out] The size of the metadata buffer.
        /// </param>
        /// <param name="pMetaDataPtr">
        /// [Out] A pointer to the metadata buffer.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetMetaDataBytesPtr(
            _Out_ UINT32* pSize,
            _Out_ LPCVOID* pMetaDataPtr
            );

        /// <summary>
        /// Gets the signature token for a local variable signature given a method token.
        ///
        /// This API was introduced in Visual Studio 14 RTM (DkmApiVersion.VS14RTM).
        /// </summary>
        /// <param name="MethodToken">
        /// [In] Token of the method to get the local variable signature for.
        /// </param>
        /// <param name="pLocalSignatureToken">
        /// [Out] The local variable signature blob token.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetLocalSignatureToken(
            _In_ UINT32 MethodToken,
            _Out_ UINT32* pLocalSignatureToken
            );

        /// <summary>
        /// Provides a mechanism for obtaining metadata tokens for a method given a class.
        /// Equivalent to IMetaDataImport::EnumMethodsWithName.
        ///
        /// This API was introduced in Visual Studio 14 RTM (DkmApiVersion.VS14RTM).
        /// </summary>
        /// <param name="pClassName">
        /// [In] The name of the class containing the method.
        /// </param>
        /// <param name="pMethodName">
        /// [In] The name of the method.
        /// </param>
        /// <param name="pTokens">
        /// [Out] Array of tokens for the method.
        ///
        /// The memory for the DkmArray members is allocated by the method implementation
        /// using DkmAllocBytes/DkmAllocArray. It is freed by the caller using the
        /// CAutoDkmArray template or with DkmFreeMemory and manual element release.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetMethodTokens(
            _In_ DkmString* pClassName,
            _In_ DkmString* pMethodName,
            _Out_ DkmArray<UINT32>* pTokens
            );

        /// <summary>
        /// Provides a mechanism for obtaining metadata tokens for a method given a class.
        /// Equivalent to IMetaDataImport::EnumMethodsWithName.
        ///
        /// This method will append a new work item to the specified work list, and return
        /// once the work item has been appended. The actual processing of the work item is
        /// asynchronous. The caller will be notified that the request is complete through
        /// the completion routine.
        ///
        /// This API was introduced in Visual Studio 14 RTM (DkmApiVersion.VS14RTM).
        /// </summary>
        /// <param name="pWorkList">
        /// WorkList to append the new work item to.
        /// </param>
        /// <param name="pClassName">
        /// [In] The name of the class containing the method.
        /// </param>
        /// <param name="pMethodName">
        /// [In] The name of the method.
        /// </param>
        /// <param name="pCompletionRoutine">
        /// Routine to fire when the request is complete. If the request is successfully
        /// appended to the work list, this will always fire (including when the operation is
        /// canceled). This will never fire if appending the work item fails.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetMethodTokens(
            _In_ DkmWorkList* pWorkList,
            _In_ DkmString* pClassName,
            _In_ DkmString* pMethodName,
            _In_ IDkmCompletionRoutine<Clr::DkmGetMethodTokensAsyncResult>* pCompletionRoutine
            );
    }; // end of DkmClrModuleInstance

    // Represents a CLR instance running in a target process.
    //
    // Derived classes: DkmClrNcRuntimeInstance
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("ea234770-c86f-1706-8842-c6fb5311ba79") DkmClrRuntimeInstance : public DkmRuntimeInstance
    {
        // Use DkmClrRuntimeInstance::Create to create this object
        private: DkmClrRuntimeInstance();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmClrRuntimeInstance();
        // This object cannot be copied
        private: DkmClrRuntimeInstance& operator=(const DkmClrRuntimeInstance&);
        private: DkmClrRuntimeInstance(const DkmClrRuntimeInstance&);

        private: OPTIONAL DkmString* const m_pCORSystemDirectory;
        private: OPTIONAL DkmString* const m_pRuntimeVersion;
        private: void* m__pExtendedData;
        private: void* m_pAppDomainCollection0;
        private: void* m_pAppDomainCollection1;

        // [Optional] The installation directory of the common language runtime (CLR)
        // instance. For example 'c:\Windows\Microsoft.NET\Framework\v2.0.50727\'. This is
        // the same path returned from the GetCORSystemDirectory API, and it always includes
        // the trailing slash.
        public: _Ret_opt_ DECLSPEC_NOTHROW DkmString* STDMETHODCALLTYPE CORSystemDirectory(
            );

        // [Optional] The version string for the CLR instance (ex: 'v2.0.50727').
        public: _Ret_opt_ DECLSPEC_NOTHROW DkmString* STDMETHODCALLTYPE RuntimeVersion(
            );

        // Attempt to cast a 'DkmRuntimeInstance' to a 'DkmClrRuntimeInstance'. Return
        // NULL if the path object is not a 'DkmClrRuntimeInstance'.
        // pClrRuntimeInstance : [In,Optional] Object to attempt to cast
        // Return Value : [Optional] Result of the cast.
        public: static DECLSPEC_NOTHROW DkmClrRuntimeInstance* TryCast(
            DkmRuntimeInstance* pRuntimeInstance
            )
        {
            if (pRuntimeInstance == NULL || pRuntimeInstance->TagValue() != Tag::ClrRuntimeInstance)
                return NULL;

            return static_cast<DkmClrRuntimeInstance*>(pRuntimeInstance);
        }

        /// <summary>
        /// Creates a new runtime instance object from a debug monitor. This method must be
        /// called from the event thread when a debug monitor detects that a new runtime
        /// instance has loaded (for example, when the corresponding runtime dll loads in the
        /// target process).
        ///
        /// This method will send a RuntimeInstanceLoad event.
        /// </summary>
        /// <param name="pProcess">
        /// [In] DkmProcess represents a target process which is being debugged. The debugger
        /// debugs processes, so this is the basic unit of debugging. A DkmProcess can
        /// represent a system process or a virtual process such as minidumps.
        /// </param>
        /// <param name="Id">
        /// [In] Identifies a DkmRuntimeInstance object within a process.
        /// </param>
        /// <param name="pCORSystemDirectory">
        /// [In,Optional] The installation directory of the common language runtime (CLR)
        /// instance. For example 'c:\Windows\Microsoft.NET\Framework\v2.0.50727\'. This is
        /// the same path returned from the GetCORSystemDirectory API, and it always includes
        /// the trailing slash.
        /// </param>
        /// <param name="pRuntimeVersion">
        /// [In,Optional] The version string for the CLR instance (ex: 'v2.0.50727').
        /// </param>
        /// <param name="DataItem">
        /// [In] Data object to add to the new DkmClrRuntimeInstance instance.
        /// DkmDataItem::Null() in the case that the caller doesn't need to add a data item.
        /// </param>
        /// <param name="ppCreatedObject">
        /// [Out] Result of this method call.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ DkmProcess* pProcess,
            _In_ const DkmRuntimeInstanceId& Id,
            _In_opt_ DkmString* pCORSystemDirectory,
            _In_opt_ DkmString* pRuntimeVersion,
            _In_ const DkmDataItem& DataItem,
            _Deref_out_ Clr::DkmClrRuntimeInstance** ppCreatedObject
            );

        /// <summary>
        /// Creates a new runtime instance object from a debug monitor. This method must be
        /// called from the event thread when a debug monitor detects that a new runtime
        /// instance has loaded (for example, when the corresponding runtime dll loads in the
        /// target process).
        ///
        /// This method will send a RuntimeInstanceLoad event.
        ///
        /// This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
        /// </summary>
        /// <param name="pProcess">
        /// [In] DkmProcess represents a target process which is being debugged. The debugger
        /// debugs processes, so this is the basic unit of debugging. A DkmProcess can
        /// represent a system process or a virtual process such as minidumps.
        /// </param>
        /// <param name="Id">
        /// [In] Identifies a DkmRuntimeInstance object within a process.
        /// </param>
        /// <param name="Capabilities">
        /// [In] Enumeration of runtime capabilities.
        /// </param>
        /// <param name="pParentRuntime">
        /// [In,Optional] For runtimes that are implemented on top of another runtime, this
        /// can optionally be used to indicant the logical parent. This can then be used to
        /// request services from the parent when the child runtime doesn't implement the
        /// service. This is currently used only for obtaining the top stack frame to
        /// evaluate a conditional breakpoint when the child runtime doesn't walk stacks
        /// itself.
        /// </param>
        /// <param name="pCORSystemDirectory">
        /// [In,Optional] The installation directory of the common language runtime (CLR)
        /// instance. For example 'c:\Windows\Microsoft.NET\Framework\v2.0.50727\'. This is
        /// the same path returned from the GetCORSystemDirectory API, and it always includes
        /// the trailing slash.
        /// </param>
        /// <param name="pRuntimeVersion">
        /// [In,Optional] The version string for the CLR instance (ex: 'v2.0.50727').
        /// </param>
        /// <param name="DataItem">
        /// [In] Data object to add to the new DkmClrRuntimeInstance instance.
        /// DkmDataItem::Null() in the case that the caller doesn't need to add a data item.
        /// </param>
        /// <param name="ppCreatedObject">
        /// [Out] Result of this method call.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ DkmProcess* pProcess,
            _In_ const DkmRuntimeInstanceId& Id,
            _In_ DkmRuntimeCapabilities_t Capabilities,
            _In_opt_ DkmRuntimeInstance* pParentRuntime,
            _In_opt_ DkmString* pCORSystemDirectory,
            _In_opt_ DkmString* pRuntimeVersion,
            _In_ const DkmDataItem& DataItem,
            _Deref_out_ Clr::DkmClrRuntimeInstance** ppCreatedObject
            );

        /// <summary>
        /// Find a DkmClrAppDomain element within this DkmClrRuntimeInstance. If no element
        /// with the given input key is present, FindAppDomain will fail.
        /// </summary>
        /// <param name="Id">
        /// [In] Search key used to find the element.
        /// </param>
        /// <param name="ppAppDomain">
        /// [Out] Result of the search.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// E_XAPI_OBJECT_NOT_FOUND indicates that the search key cannot be found.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE FindAppDomain(
            _In_ UINT32 Id,
            _Deref_out_ Clr::DkmClrAppDomain** ppAppDomain
            );

        /// <summary>
        /// GetAppDomains enumerates the DkmClrAppDomain elements of this
        /// DkmClrRuntimeInstance object.
        /// </summary>
        /// <param name="pAppDomains">
        /// [Out] Array containing the enumerated elements.
        ///
        /// The memory for the DkmArray members is allocated by the method implementation
        /// using DkmAllocBytes/DkmAllocArray. It is freed by the caller using the
        /// CAutoDkmArray template or with DkmFreeMemory and manual element release.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetAppDomains(
            _Out_ DkmArray<Clr::DkmClrAppDomain*>* pAppDomains
            );

        #ifndef EXCLUDE_MONITOR_ONLY_APIS
        /// <summary>
        /// Obtains the DkmClrModuleInstance from an ICorDebugModule.
        ///
        /// Location constraint: API must be called from a Monitor component (component level
        /// &lt; 100,000).
        /// </summary>
        /// <param name="pCorModule">
        /// [In] The CLR module to get the module instance for.
        /// </param>
        /// <param name="ppResult">
        /// [Out] The DkmClrModuleInstance that matches the provided ICorDebugModule.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE FindClrModuleInstance(
            _In_ ICorDebugModule* pCorModule,
            _Deref_out_ Clr::DkmClrModuleInstance** ppResult
            );
        #endif // #ifndef EXCLUDE_MONITOR_ONLY_APIS

        #ifndef EXCLUDE_MONITOR_ONLY_APIS
        /// <summary>
        /// Provides direct access to the ICorDebugThread object, which expression evaluators
        /// or other components can use to inspect the app domain.
        ///
        /// The returned interface may ONLY be used to inspect the target process, and should
        /// NEVER be used to control execution (no stepping, no breakpoints, no continue,
        /// etc). Doing so is unsupported and will result in undefined behavior.
        ///
        /// Location constraint: API must be called from a Monitor component (component level
        /// &lt; 100,000).
        /// </summary>
        /// <param name="pThread">
        /// [In] DkmThread object that should be mapped to the CorDebug thread.
        /// </param>
        /// <param name="ppCorThread">
        /// [Out] ICorDebug interface representing an app domain inspection.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetCorThread(
            _In_ DkmThread* pThread,
            _Deref_out_ ICorDebugThread** ppCorThread
            );
        #endif // #ifndef EXCLUDE_MONITOR_ONLY_APIS

        #ifndef EXCLUDE_MONITOR_ONLY_APIS
        /// <summary>
        /// Provides direct access to the ICorDebugProcess object, which expression
        /// evaluators or other components can use for inspection.
        ///
        /// The returned interface may ONLY be used to inspect the target process, and should
        /// NEVER be used to control execution (no stepping, no breakpoints, no continue,
        /// etc). Doing so is unsupported and will result in undefined behavior.
        ///
        /// Location constraint: API must be called from a Monitor component (component level
        /// &lt; 100,000).
        /// </summary>
        /// <param name="ppCorProcess">
        /// [Out] ICorDebug interface representing a process.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetCorProcess(
            _Deref_out_ ICorDebugProcess** ppCorProcess
            );
        #endif // #ifndef EXCLUDE_MONITOR_ONLY_APIS

        #ifndef EXCLUDE_MONITOR_ONLY_APIS
        /// <summary>
        /// Checks to see if we should load the FEQA DLL.
        ///
        /// Location constraint: API must be called from a Monitor component (component level
        /// &lt; 100,000).
        /// </summary>
        /// <param name="pThread">
        /// [In] DkmThread represents a thread running in the target process.
        /// </param>
        /// <param name="pSkipLoad">
        /// [Out] Specifies if the FEQA DLL should be loaded. The hosting process could have
        /// loaded it already.
        /// </param>
        /// <param name="pMemoryAddress">
        /// [Out] Specifies the address in debuggee process. Valid only if AlreadyLoaded is
        /// false.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE PrepareForFuncEvalQuickAbort(
            _In_ DkmThread* pThread,
            _Out_ bool* pSkipLoad,
            _Out_ UINT64* pMemoryAddress
            );
        #endif // #ifndef EXCLUDE_MONITOR_ONLY_APIS

        #ifndef EXCLUDE_MONITOR_ONLY_APIS
        /// <summary>
        /// Notifies the result of the attempt to load the FEQA DLL.
        ///
        /// Location constraint: API must be called from a Monitor component (component level
        /// &lt; 100,000).
        /// </summary>
        /// <param name="pThread">
        /// [In] DkmThread represents a thread running in the target process.
        /// </param>
        /// <param name="Result">
        /// [In] Specifies if the FEQA DLL was successfully loaded.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE OnFuncEvalQuickAbortDllLoaded(
            _In_ DkmThread* pThread,
            _In_ bool Result
            );
        #endif // #ifndef EXCLUDE_MONITOR_ONLY_APIS

        #ifndef EXCLUDE_MONITOR_ONLY_APIS
        /// <summary>
        /// Continue the process and wait for a func-eval to complete.
        ///
        /// Location constraint: API must be called from a Monitor component (component level
        /// &lt; 100,000).
        /// </summary>
        /// <param name="pThread">
        /// [In] The thread for which to do the func-eval.
        /// </param>
        /// <param name="pCorEval">
        /// [In] The object.
        /// </param>
        /// <param name="FuncEvalFlags">
        /// [In] Function evaluation flags.
        /// </param>
        /// <param name="Timeout">
        /// [In] The timeout.
        /// </param>
        /// <param name="pEvaluationString">
        /// [In] The text being evaluated. Displayed in the call stack window if the function
        /// evaluation re-enters break mode.
        /// </param>
        /// <param name="pResult">
        /// [Out] The result of doing the function evaluation. S_OK if all went well. Other
        /// possible values include S_EVAL_TIMEDOUT, S_EVAL_ABORTED, or E_PROCESS_DESTROYED.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ContinueForFuncEval(
            _In_ DkmThread* pThread,
            _In_ ICorDebugEval* pCorEval,
            _In_ Evaluation::DkmFuncEvalFlags_t FuncEvalFlags,
            _In_ UINT32 Timeout,
            _In_ DkmString* pEvaluationString,
            _Out_ HRESULT* pResult
            );
        #endif // #ifndef EXCLUDE_MONITOR_ONLY_APIS

        #ifndef EXCLUDE_MONITOR_ONLY_APIS
        /// <summary>
        /// Checks if the given thread is in a state in which the CLR supports managed
        /// func-evals.
        ///
        /// Location constraint: API must be called from a Monitor component (component level
        /// &lt; 100,000).
        /// </summary>
        /// <param name="pThread">
        /// [In] DkmThread represents a thread running in the target process.
        /// </param>
        /// <param name="pResult">
        /// [Out] The result of doing the function evaluation. S_OK if all went well. Other
        /// possible values include E_EVAL_FUNCEVAL_IN_MINIDUMP or S_EVAL_BAD_THREAD_STATE.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE CanDoFuncEval(
            _In_ DkmThread* pThread,
            _Out_ HRESULT* pResult
            );
        #endif // #ifndef EXCLUDE_MONITOR_ONLY_APIS

        /// <summary>
        /// Gets the list of aliases that can currently be used in expressions.
        ///
        /// This API was introduced in Visual Studio 14 RTM (DkmApiVersion.VS14RTM).
        /// </summary>
        /// <param name="pInspectionContext">
        /// [In,Optional] The current InspectionContext.  If null, aliases that depend on the
        /// current thread or app domain will not be returned by this method.
        /// </param>
        /// <param name="ppResult">
        /// [Out] The list of alias that can currently be used in expressions.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetAliases(
            _In_opt_ Evaluation::DkmInspectionContext* pInspectionContext,
            _Deref_out_ DkmReadOnlyCollection<Clr::DkmClrAlias*>** ppResult
            );

        /// <summary>
        /// Get metadata for the "Intrinsic Methods Assembly". Intrinsic methods are special
        /// methods the debug engine understands when executing a CLR inspection query.
        /// Example: When evaluating "$exception" in the C# expression evaluator, the C#
        /// expression compiler will emit a call to GetException in the intrinsic methods
        /// assembly.  Instead of executing the call normally, the debugger will instead
        /// simulate the method call and return the exception on the current thread.
        ///
        /// This API was introduced in Visual Studio 14 RTM (DkmApiVersion.VS14RTM).
        /// </summary>
        /// <param name="pSize">
        /// [Out] The size of the metadata buffer.
        /// </param>
        /// <param name="pMetaDataPtr">
        /// [Out] A pointer to the metadata buffer.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetIntrinsicAssemblyMetaDataBytesPtr(
            _Out_ UINT32* pSize,
            _Out_ LPCVOID* pMetaDataPtr
            );

        /// <summary>
        /// GetCorFrame is used to obtain a ICorDebugFrame which a component can use to
        /// deeply inspect the stack frame.
        ///
        /// The returned interface may ONLY be used to inspect the target process, and should
        /// NEVER be used to control execution (no stepping, no breakpoints, no continue,
        /// etc). Doing so is unsupported and will result in undefined behavior.
        ///
        /// Location constraint: This API must be called from the same process where the
        /// target runtime implements stack walk. For managed debugging, this means that when
        /// debugging 64-bit or remote processes, this API must be called from a debug
        /// monitor component.
        ///
        /// This API was introduced in Visual Studio 14 RTM (DkmApiVersion.VS14RTM).
        /// </summary>
        /// <param name="pThread">
        /// [In] The thread the stack frame came from.
        /// </param>
        /// <param name="FrameBase">
        /// [In] The frame base of the stack frame to get the inspection interface for.
        /// </param>
        /// <param name="InterfaceID">
        /// [In] The GUID of the desired interface. IID_ICorDebugFrame can be used to obtain
        /// the CorDebug frame interface for a managed frame.
        /// </param>
        /// <param name="ppFrameInterface">
        /// [Out] Returned frame interface. This may be cast to the interface pointer
        /// corresponding to 'InterfaceID'.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetCorFrame(
            _In_ DkmThread* pThread,
            _In_ UINT64 FrameBase,
            _In_ const GUID& InterfaceID,
            _Deref_out_ IUnknown** ppFrameInterface
            );
    }; // end of DkmClrRuntimeInstance

    #ifndef EXCLUDE_MONITOR_ONLY_APIS
    // A primitive value or string.
    //
    // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("dd09d102-60f5-a71f-6a91-6d9770d907ca") DkmILInterpreterPrimitiveValue : public Clr::DkmILInterpreterValue
    {
        // Use DkmILInterpreterPrimitiveValue::Create to create this object
        private: DkmILInterpreterPrimitiveValue();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmILInterpreterPrimitiveValue();
        // This object cannot be copied
        private: DkmILInterpreterPrimitiveValue& operator=(const DkmILInterpreterPrimitiveValue&);
        private: DkmILInterpreterPrimitiveValue(const DkmILInterpreterPrimitiveValue&);

        private: DkmVariant* const m_pValue;
        private: void* m__pExtendedData;

        // The value to be passed into or returned from the interpreted method.
        //
        // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
        public: _Ret_ DECLSPEC_NOTHROW DkmVariant* STDMETHODCALLTYPE Value(
            );

        // Attempt to cast a 'DkmILInterpreterValue' to a 'DkmILInterpreterPrimitiveValue'. Return
        // NULL if the path object is not a 'DkmILInterpreterPrimitiveValue'.
        // pPrimitiveValue : [In,Optional] Object to attempt to cast
        // Return Value : [Optional] Result of the cast.
        public: static DECLSPEC_NOTHROW DkmILInterpreterPrimitiveValue* TryCast(
            DkmILInterpreterValue* pValue
            )
        {
            if (pValue == NULL || pValue->TagValue() != Tag::PrimitiveValue)
                return NULL;

            return static_cast<DkmILInterpreterPrimitiveValue*>(pValue);
        }

        /// <summary>
        /// Create a new DkmILInterpreterPrimitiveValue object instance.
        ///
        /// Location constraint: API must be called from a Monitor component (component level
        /// &lt; 100,000).
        ///
        /// This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
        /// </summary>
        /// <param name="pRuntimeInstance">
        /// [In] Represents a CLR instance running in a target process.
        /// </param>
        /// <param name="pValue">
        /// [In] The value to be passed into or returned from the interpreted method.
        /// </param>
        /// <param name="ppCreatedObject">
        /// [Out] Result of this method call.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ Clr::DkmClrRuntimeInstance* pRuntimeInstance,
            _In_ DkmVariant* pValue,
            _Deref_out_ Clr::DkmILInterpreterPrimitiveValue** ppCreatedObject
            );
    }; // end of DkmILInterpreterPrimitiveValue
    #endif // #ifndef EXCLUDE_MONITOR_ONLY_APIS

    #ifndef EXCLUDE_MONITOR_ONLY_APIS
    // A reference to an object in the debuggee's managed heap.
    //
    // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("cd724a8f-abd6-8297-c2f2-4e539e1512fd") DkmILInterpreterReferenceValue : public Clr::DkmILInterpreterValue
    {
        // Use DkmILInterpreterReferenceValue::Create to create this object
        private: DkmILInterpreterReferenceValue();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmILInterpreterReferenceValue();
        // This object cannot be copied
        private: DkmILInterpreterReferenceValue& operator=(const DkmILInterpreterReferenceValue&);
        private: DkmILInterpreterReferenceValue(const DkmILInterpreterReferenceValue&);

        private: OPTIONAL ICorDebugHandleValue* const m_pValue;
        private: void* m__pExtendedData;

        // [Optional] A reference to the object in the debuggee to be passed into or returned
        // from the interpreted method.  If the value refers to a null object reference,
        // ReferenceValue will be null.
        //
        // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
        public: _Ret_opt_ DECLSPEC_NOTHROW ICorDebugHandleValue* STDMETHODCALLTYPE Value(
            );

        // Attempt to cast a 'DkmILInterpreterValue' to a 'DkmILInterpreterReferenceValue'. Return
        // NULL if the path object is not a 'DkmILInterpreterReferenceValue'.
        // pReferenceValue : [In,Optional] Object to attempt to cast
        // Return Value : [Optional] Result of the cast.
        public: static DECLSPEC_NOTHROW DkmILInterpreterReferenceValue* TryCast(
            DkmILInterpreterValue* pValue
            )
        {
            if (pValue == NULL || pValue->TagValue() != Tag::ReferenceValue)
                return NULL;

            return static_cast<DkmILInterpreterReferenceValue*>(pValue);
        }

        /// <summary>
        /// Create a new DkmILInterpreterReferenceValue object instance.
        ///
        /// Location constraint: API must be called from a Monitor component (component level
        /// &lt; 100,000).
        ///
        /// This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
        /// </summary>
        /// <param name="pRuntimeInstance">
        /// [In] Represents a CLR instance running in a target process.
        /// </param>
        /// <param name="pValue">
        /// [In,Optional] A reference to the object in the debuggee to be passed into or
        /// returned from the interpreted method.  If the value refers to a null object
        /// reference, ReferenceValue will be null.
        /// </param>
        /// <param name="ppCreatedObject">
        /// [Out] Result of this method call.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ Clr::DkmClrRuntimeInstance* pRuntimeInstance,
            _In_opt_ ICorDebugHandleValue* pValue,
            _Deref_out_ Clr::DkmILInterpreterReferenceValue** ppCreatedObject
            );
    }; // end of DkmILInterpreterReferenceValue
    #endif // #ifndef EXCLUDE_MONITOR_ONLY_APIS

    // Managed return value of value type copy.
    //
    // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("78986f0d-1eec-5d34-51fd-88e48e04b5b2") DkmManagedReturnValueCopy : public Clr::DkmManagedReturnValueInfo
    {
        // Use DkmManagedReturnValueCopy::Create to create this object
        private: DkmManagedReturnValueCopy();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmManagedReturnValueCopy();
        // This object cannot be copied
        private: DkmManagedReturnValueCopy& operator=(const DkmManagedReturnValueCopy&);
        private: DkmManagedReturnValueCopy(const DkmManagedReturnValueCopy&);

        private: const UINT32 m_CorElementType;
        private: const UINT32 m_Size;
        private: const UINT64 m_Address;
        private: OPTIONAL DkmReadOnlyCollection<BYTE>* const m_pValueBuffer;
        private: void* m__pExtendedData;

        // [Optional] The CorElementType of the value type.
        //
        // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
        public: DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE CorElementType(
            );

        // [Optional] The size of the value type.
        //
        // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
        public: DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE Size(
            );

        // [Optional] The address of the value type.
        //
        // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
        public: DECLSPEC_NOTHROW UINT64 STDMETHODCALLTYPE Address(
            );

        // [Optional] The captured value type buffer.
        //
        // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
        public: _Ret_opt_ DECLSPEC_NOTHROW DkmReadOnlyCollection<BYTE>* STDMETHODCALLTYPE ValueBuffer(
            );

        // Attempt to cast a 'DkmManagedReturnValueInfo' to a 'DkmManagedReturnValueCopy'. Return
        // NULL if the path object is not a 'DkmManagedReturnValueCopy'.
        // pManagedReturnValueCopy : [In,Optional] Object to attempt to cast
        // Return Value : [Optional] Result of the cast.
        public: static DECLSPEC_NOTHROW DkmManagedReturnValueCopy* TryCast(
            DkmManagedReturnValueInfo* pManagedReturnValueInfo
            )
        {
            if (pManagedReturnValueInfo == NULL || pManagedReturnValueInfo->TagValue() != Tag::ManagedReturnValueCopy)
                return NULL;

            return static_cast<DkmManagedReturnValueCopy*>(pManagedReturnValueInfo);
        }

        /// <summary>
        /// Create a new DkmManagedReturnValueCopy object instance.
        ///
        /// Location constraint: The caller is required to be in the same process (IDE
        /// process or Monitor process) as the implementation component.
        ///
        /// This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
        /// </summary>
        /// <param name="pCorType">
        /// [In] ICorDebugType of the return value.
        /// </param>
        /// <param name="CorElementType">
        /// [In,Optional] The CorElementType of the value type.
        /// </param>
        /// <param name="Size">
        /// [In,Optional] The size of the value type.
        /// </param>
        /// <param name="Address">
        /// [In,Optional] The address of the value type.
        /// </param>
        /// <param name="pValueBuffer">
        /// [In,Optional] The captured value type buffer.
        /// </param>
        /// <param name="ppCreatedObject">
        /// [Out] Result of this method call.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ ICorDebugType* pCorType,
            _In_ UINT32 CorElementType,
            _In_ UINT32 Size,
            _In_ UINT64 Address,
            _In_opt_ DkmReadOnlyCollection<BYTE>* pValueBuffer,
            _Deref_out_ Clr::DkmManagedReturnValueCopy** ppCreatedObject
            );
    }; // end of DkmManagedReturnValueCopy

    // Managed return value of reference type.
    //
    // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("59b45a07-6a5f-6938-4039-e4e382aaa05e") DkmManagedReturnValueReference : public Clr::DkmManagedReturnValueInfo
    {
        // Use DkmManagedReturnValueReference::Create to create this object
        private: DkmManagedReturnValueReference();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmManagedReturnValueReference();
        // This object cannot be copied
        private: DkmManagedReturnValueReference& operator=(const DkmManagedReturnValueReference&);
        private: DkmManagedReturnValueReference(const DkmManagedReturnValueReference&);

        private: OPTIONAL ICorDebugValue* const m_pCorValue;
        private: void* m__pExtendedData;

        // [Optional] ICorDebugValue from CLR. It is null for value type.
        //
        // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
        public: _Ret_opt_ DECLSPEC_NOTHROW ICorDebugValue* STDMETHODCALLTYPE CorValue(
            );

        // Attempt to cast a 'DkmManagedReturnValueInfo' to a 'DkmManagedReturnValueReference'. Return
        // NULL if the path object is not a 'DkmManagedReturnValueReference'.
        // pManagedReturnValueReference : [In,Optional] Object to attempt to cast
        // Return Value : [Optional] Result of the cast.
        public: static DECLSPEC_NOTHROW DkmManagedReturnValueReference* TryCast(
            DkmManagedReturnValueInfo* pManagedReturnValueInfo
            )
        {
            if (pManagedReturnValueInfo == NULL || pManagedReturnValueInfo->TagValue() != Tag::ManagedReturnValueReference)
                return NULL;

            return static_cast<DkmManagedReturnValueReference*>(pManagedReturnValueInfo);
        }

        /// <summary>
        /// Create a new DkmManagedReturnValueReference object instance.
        ///
        /// Location constraint: The caller is required to be in the same process (IDE
        /// process or Monitor process) as the implementation component.
        ///
        /// This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
        /// </summary>
        /// <param name="pCorType">
        /// [In] ICorDebugType of the return value.
        /// </param>
        /// <param name="pCorValue">
        /// [In,Optional] ICorDebugValue from CLR. It is null for value type.
        /// </param>
        /// <param name="ppCreatedObject">
        /// [Out] Result of this method call.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ ICorDebugType* pCorType,
            _In_opt_ ICorDebugValue* pCorValue,
            _Deref_out_ Clr::DkmManagedReturnValueReference** ppCreatedObject
            );
    }; // end of DkmManagedReturnValueReference

}; // end namespace Clr

// Contains types specific to debugging code running under the native-compiled CLR.
namespace Clr { namespace NativeCompilation {
    // Information about an instance field for a managed class that is compiled into native
    // code.
    //
    // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("bb9283d5-b8d9-c1fc-fcdc-c798561b248e") DkmClrNcInstanceFieldSymbol : public IUnknown
    {
        private: ___ReferenceCount_t m_ReferenceCount;
        private: DkmDispatcherObjectFlags_t m_ObjectFlags;
        private: const GUID* m_pTypeId;
        private: size_t m_ObjectGCHandle;
        // Use DkmClrNcInstanceFieldSymbol::Create to create this object
        private: DkmClrNcInstanceFieldSymbol();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmClrNcInstanceFieldSymbol();
        // This object cannot be copied
        private: DkmClrNcInstanceFieldSymbol& operator=(const DkmClrNcInstanceFieldSymbol&);
        private: DkmClrNcInstanceFieldSymbol(const DkmClrNcInstanceFieldSymbol&);

        private: DkmString* const m_pName;
        private: const UINT32 m_Size;
        private: const UINT32 m_Offset;
        private: void* m__pExtendedData;

        // Field name.
        //
        // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
        public: _Ret_ DECLSPEC_NOTHROW DkmString* STDMETHODCALLTYPE Name(
            );

        // Size in bytes.
        //
        // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
        public: DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE Size(
            );

        // Byte offset in class.
        //
        // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
        public: DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE Offset(
            );

        /// <summary>
        /// Create a new DkmClrNcInstanceFieldSymbol object instance.
        ///
        /// This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
        /// </summary>
        /// <param name="pName">
        /// [In] Field name.
        /// </param>
        /// <param name="Size">
        /// [In] Size in bytes.
        /// </param>
        /// <param name="Offset">
        /// [In] Byte offset in class.
        /// </param>
        /// <param name="ppCreatedObject">
        /// [Out] Result of this method call.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ DkmString* pName,
            _In_ UINT32 Size,
            _In_ UINT32 Offset,
            _Deref_out_ Clr::NativeCompilation::DkmClrNcInstanceFieldSymbol** ppCreatedObject
            );
    }; // end of DkmClrNcInstanceFieldSymbol

    // Result of an asynchronous
    // DkmClrNcContainerModuleInstance.CreateInstructionAddressFromRva call.
    struct DkmCreateInstructionAddressFromRvaAsyncResult
    {
        // HRESULT code returned from the caller. This will be
        // DkmExceptionCode.COR_E_OPERATIONCANCELED (0x8013153B) if the operation was
        // canceled before processing was complete. E_UNKNOWN_CPU_INSTRUCTION indicates that
        // RVA doesn't map to a part of the image known to have code.
        HRESULT ErrorCode;

        // Created DkmClrNcInstructionAddress object.
        Clr::NativeCompilation::DkmClrNcInstructionAddress* pInstructionAddress;
    };

    // Result of an asynchronous
    // DkmClrNcModuleInstance.CreateInstructionAddressesFromILAddress call.
    struct DkmCreateInstructionAddressesFromILAddressAsyncResult
    {
        // HRESULT code returned from the caller. This will be
        // DkmExceptionCode.COR_E_OPERATIONCANCELED (0x8013153B) if the operation was
        // canceled before processing was complete.
        HRESULT ErrorCode;

        // Created DkmClrNcInstructionAddress object.
        DkmArray<Clr::NativeCompilation::DkmClrNcInstructionAddress*> InstructionAddresses;
    };

    // 'DkmClrNcContainerModuleInstance' is used to represent a module instance which is 1:1
    // with a physical native dll loaded by the target app. This native dll functions as a
    // logical container for one or more logical managed modules (DkmClrNcModuleInstance)
    // which are embedded inside it.
    //
    // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("a79c8888-83eb-5fa2-143f-7e9b42f77bed") DkmClrNcContainerModuleInstance : public DkmModuleInstance
    {
        // Use DkmClrNcContainerModuleInstance::Create to create this object
        private: DkmClrNcContainerModuleInstance();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmClrNcContainerModuleInstance();
        // This object cannot be copied
        private: DkmClrNcContainerModuleInstance& operator=(const DkmClrNcContainerModuleInstance&);
        private: DkmClrNcContainerModuleInstance(const DkmClrNcContainerModuleInstance&);

        private: void* m__pExtendedData;
        private: void* m_pEmbeddedModuleCollection0;

        // Represents a native-compiled CLR instance running in a target process.
        //
        // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
        public: _Ret_ DECLSPEC_NOTHROW Clr::NativeCompilation::DkmClrNcRuntimeInstance* STDMETHODCALLTYPE RuntimeInstance(
            );

        // Attempt to cast a 'DkmModuleInstance' to a 'DkmClrNcContainerModuleInstance'. Return
        // NULL if the path object is not a 'DkmClrNcContainerModuleInstance'.
        // pClrNcContainerModuleInstance : [In,Optional] Object to attempt to cast
        // Return Value : [Optional] Result of the cast.
        public: static DECLSPEC_NOTHROW DkmClrNcContainerModuleInstance* TryCast(
            DkmModuleInstance* pModuleInstance
            )
        {
            if (pModuleInstance == NULL || pModuleInstance->TagValue() != Tag::ClrNcContainerModuleInstance)
                return NULL;

            return static_cast<DkmClrNcContainerModuleInstance*>(pModuleInstance);
        }

        /// <summary>
        /// Find a DkmClrNcModuleInstance element within this
        /// DkmClrNcContainerModuleInstance. If no element with the given input key is
        /// present, FindEmbeddedModule will fail.
        ///
        /// This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
        /// </summary>
        /// <param name="Index">
        /// [In] Search key used to find the element.
        /// </param>
        /// <param name="ppEmbeddedModule">
        /// [Out] Result of the search.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// E_XAPI_OBJECT_NOT_FOUND indicates that the search key cannot be found.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE FindEmbeddedModule(
            _In_ UINT32 Index,
            _Deref_out_ Clr::NativeCompilation::DkmClrNcModuleInstance** ppEmbeddedModule
            );

        /// <summary>
        /// GetEmbeddedModules enumerates the DkmClrNcModuleInstance elements of this
        /// DkmClrNcContainerModuleInstance object.
        ///
        /// This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
        /// </summary>
        /// <param name="pEmbeddedModules">
        /// [Out] Array containing the enumerated elements.
        ///
        /// The memory for the DkmArray members is allocated by the method implementation
        /// using DkmAllocBytes/DkmAllocArray. It is freed by the caller using the
        /// CAutoDkmArray template or with DkmFreeMemory and manual element release.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetEmbeddedModules(
            _Out_ DkmArray<Clr::NativeCompilation::DkmClrNcModuleInstance*>* pEmbeddedModules
            );

        /// <summary>
        /// Returns the image bytes starting at a specified RVA. Implemented by symbol
        /// provider for managed DM.
        ///
        /// This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
        /// </summary>
        /// <param name="RVA">
        /// [In] Starting RVA from where bytes are requested.
        /// </param>
        /// <param name="BytesRequested">
        /// [In] Number of bytes requested.
        /// </param>
        /// <param name="pImageBytes">
        /// [Out] Image bytes.
        ///
        /// The memory for the DkmArray members is allocated by the method implementation
        /// using DkmAllocBytes/DkmAllocArray. It is freed by the caller using the
        /// CAutoDkmArray template or with DkmFreeMemory and manual element release.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetAssemblyImageBytes(
            _In_ UINT32 RVA,
            _In_ UINT32 BytesRequested,
            _Out_ DkmArray<BYTE>* pImageBytes
            );

        /// <summary>
        /// Retrieves the layout of the class.
        ///
        /// This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
        /// </summary>
        /// <param name="pClassSignature">
        /// [In] Signature of class.
        /// </param>
        /// <param name="pInstanceFields">
        /// [Out] Array of instance fields.
        ///
        /// The memory for the DkmArray members is allocated by the method implementation
        /// using DkmAllocBytes/DkmAllocArray. It is freed by the caller using the
        /// CAutoDkmArray template or with DkmFreeMemory and manual element release.
        /// </param>
        /// <param name="pSize">
        /// [Out] Size of the struct/class in bytes.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetClassInfo(
            _In_ DkmReadOnlyCollection<BYTE>* pClassSignature,
            _Out_ DkmArray<Clr::NativeCompilation::DkmClrNcInstanceFieldSymbol*>* pInstanceFields,
            _Out_ UINT32* pSize
            );

        /// <summary>
        /// Returns the image bytes for the ManagedNativeGenericInfo PDB stream.
        ///
        /// This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
        /// </summary>
        /// <param name="pManagedNativeGenericInfoBytes">
        /// [Out] Generic dictionary symbols stream bytes.
        ///
        /// The memory for the DkmArray members is allocated by the method implementation
        /// using DkmAllocBytes/DkmAllocArray. It is freed by the caller using the
        /// CAutoDkmArray template or with DkmFreeMemory and manual element release.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetGenericDictionaryInfo(
            _Out_ DkmArray<BYTE>* pManagedNativeGenericInfoBytes
            );

        /// <summary>
        /// Creates a DkmClrNcInstructionAddress from an RVA into the module.
        ///
        /// This method will append a new work item to the specified work list, and return
        /// once the work item has been appended. The actual processing of the work item is
        /// asynchronous. The caller will be notified that the request is complete through
        /// the completion routine.
        ///
        /// This API was introduced in Visual Studio 14 RTM (DkmApiVersion.VS14RTM).
        /// </summary>
        /// <param name="pWorkList">
        /// WorkList to append the new work item to.
        /// </param>
        /// <param name="Rva">
        /// [In] RVA of the instruction address.
        /// </param>
        /// <param name="pCompletionRoutine">
        /// Routine to fire when the request is complete. If the request is successfully
        /// appended to the work list, this will always fire (including when the operation is
        /// canceled). This will never fire if appending the work item fails.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE CreateInstructionAddressFromRva(
            _In_ DkmWorkList* pWorkList,
            _In_ UINT32 Rva,
            _In_ IDkmCompletionRoutine<Clr::NativeCompilation::DkmCreateInstructionAddressFromRvaAsyncResult>* pCompletionRoutine
            );
    }; // end of DkmClrNcContainerModuleInstance

    // DkmClrNcInstructionAddress is used to represent an addresses in native-compiled CLR
    // code. It contains the information about where the instruction is using both managed
    // concepts (DkmClrNcModuleInstance, method token, IL offset) and native concepts (
    // DkmClrNcContainerModuleInstance, RVA).
    //
    // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("377ece5a-e9ff-bb6a-1612-b5d9cc54755f") DkmClrNcInstructionAddress : public Clr::DkmClrInstructionAddress
    {
        // Use DkmClrNcInstructionAddress::Create to create this object
        private: DkmClrNcInstructionAddress();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmClrNcInstructionAddress();
        // This object cannot be copied
        private: DkmClrNcInstructionAddress& operator=(const DkmClrNcInstructionAddress&);
        private: DkmClrNcInstructionAddress(const DkmClrNcInstructionAddress&);

        private: Clr::NativeCompilation::DkmClrNcContainerModuleInstance* const m_pContainerModule;
        private: OPTIONAL DkmReadOnlyCollection<BYTE>* const m_pGenericParameters;
        private: void* m__pExtendedData;

        // Represents a native-compiled CLR instance running in a target process.
        //
        // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
        public: _Ret_ DECLSPEC_NOTHROW Clr::NativeCompilation::DkmClrNcRuntimeInstance* STDMETHODCALLTYPE RuntimeInstance(
            );

        // The managed module containing the InstructionPointer.
        //
        // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
        public: _Ret_ DECLSPEC_NOTHROW Clr::NativeCompilation::DkmClrNcModuleInstance* STDMETHODCALLTYPE ModuleInstance(
            );

        // The underlying container module (on-disk module) where this address is loaded.
        // Symbols (DkmModule) are accessed through this module instead of 'ModuleInstance'.
        //
        // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
        public: _Ret_ DECLSPEC_NOTHROW Clr::NativeCompilation::DkmClrNcContainerModuleInstance* STDMETHODCALLTYPE ContainerModule(
            );

        // [Optional] For generic methods, this provides the ECMA formatted TypeSpec
        // signature for each generic parameter. For non-generic methods, this will be null.
        //
        // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
        public: _Ret_opt_ DECLSPEC_NOTHROW DkmReadOnlyCollection<BYTE>* STDMETHODCALLTYPE GenericParameters(
            );

        /// <summary>
        /// Create a new DkmClrNcInstructionAddress object instance.
        ///
        /// This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
        /// </summary>
        /// <param name="MethodId">
        /// [In] The version/token pair for this method.
        /// </param>
        /// <param name="NativeOffset">
        /// [In] For the standard .NET Framework, NativeOffset is a byte offset relative to
        /// start of the method where the CPU instruction can be found. For the purpose of
        /// this value, the method should be treated as a contiguous block of bytes. If the
        /// method has not been Just-in-time compiled or if this address is being used to
        /// refer purely to the IL address, NativeOffset will be set to UInt32.MaxValue.
        ///
        /// For native-compiled .NET Framework modules,  this value is the RVA of the native
        /// instruction in the module.
        /// </param>
        /// <param name="ILOffset">
        /// [In] ILOffset is the index of the IL instruction that this address represents.
        /// This value may be set to UInt32.MaxValue for an instruction that is within the
        /// given method, but not tied to a particular IL instruction. This is used for CLR
        /// native instructions that don't map to an IL instruction. (ICorDebugILFrame::GetIP
        /// indicates MAPPING_UNMAPPED_ADDRESS).
        /// </param>
        /// <param name="pRuntimeInstance">
        /// [In] Represents a native-compiled CLR instance running in a target process.
        /// </param>
        /// <param name="pModuleInstance">
        /// [In] The managed module containing the InstructionPointer.
        /// </param>
        /// <param name="pContainerModule">
        /// [In] The underlying container module (on-disk module) where this address is
        /// loaded. Symbols (DkmModule) are accessed through this module instead of
        /// 'ModuleInstance'.
        /// </param>
        /// <param name="pGenericParameters">
        /// [In,Optional] For generic methods, this provides the ECMA formatted TypeSpec
        /// signature for each generic parameter. For non-generic methods, this will be null.
        /// </param>
        /// <param name="pCPUInstruction">
        /// [In,Optional] CPUInstruction provides the address that the CPU will execute. This
        /// is always provided for native instructions. It may be provided for CLR or custom
        /// addresses depending on how the address object was created.
        /// </param>
        /// <param name="ppCreatedObject">
        /// [Out] Result of this method call.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ const Clr::DkmClrMethodId& MethodId,
            _In_ UINT32 NativeOffset,
            _In_ UINT32 ILOffset,
            _In_ Clr::NativeCompilation::DkmClrNcRuntimeInstance* pRuntimeInstance,
            _In_ Clr::NativeCompilation::DkmClrNcModuleInstance* pModuleInstance,
            _In_ Clr::NativeCompilation::DkmClrNcContainerModuleInstance* pContainerModule,
            _In_opt_ DkmReadOnlyCollection<BYTE>* pGenericParameters,
            _In_opt_ const DkmInstructionAddress::CPUInstruction* pCPUInstruction,
            _Deref_out_ Clr::NativeCompilation::DkmClrNcInstructionAddress** ppCreatedObject
            );
    }; // end of DkmClrNcInstructionAddress

    // DkmClrNcInstructionSymbol represents an IL instruction that has been compiled to
    // native code and is running under the native-compiled CLR. DkmClrNcInstructionSymbol is
    // in a hybrid of a native and CLR instruction symbols - like a CLR instruction symbol,
    // it contains enough information to bind the symbol to the managed IL instruction
    // address concepts. Like a native symbol, it contains enough information to bind it to a
    // native CPU address.
    //
    // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("19d8a807-38c8-4b6d-a89a-4e4b00a604d7") DkmClrNcInstructionSymbol : public Clr::DkmClrInstructionSymbol
    {
        // Use DkmClrNcInstructionSymbol::Create to create this object
        private: DkmClrNcInstructionSymbol();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmClrNcInstructionSymbol();
        // This object cannot be copied
        private: DkmClrNcInstructionSymbol& operator=(const DkmClrNcInstructionSymbol&);
        private: DkmClrNcInstructionSymbol(const DkmClrNcInstructionSymbol&);

        private: const UINT32 m_EmbeddedModuleIndex;
        private: const UINT32 m_NativeOffset;
        private: OPTIONAL DkmReadOnlyCollection<BYTE>* const m_pGenericParameters;
        private: void* m__pExtendedData;

        // Identifier of the embedded module within the container where this function
        // resides.
        //
        // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
        public: DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE EmbeddedModuleIndex(
            );

        // This value is the RVA of the native instruction from the beginning of the native
        // module that contains this instruction.
        //
        // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
        public: DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE NativeOffset(
            );

        // [Optional] For generic methods, this provides the ECMA formatted TypeSpec
        // signature for each generic parameter. For non-generic methods, this will be null.
        //
        // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
        public: _Ret_opt_ DECLSPEC_NOTHROW DkmReadOnlyCollection<BYTE>* STDMETHODCALLTYPE GenericParameters(
            );

        /// <summary>
        /// Create a new DkmClrNcInstructionSymbol object instance.
        ///
        /// This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
        /// </summary>
        /// <param name="pModule">
        /// [In] The DkmModule class represents a code bundle (ex: dll or exe) which is or
        /// once was loaded into one or more processes. The DkmModule class is the central
        /// object to the symbol APIs, and is 1:1 with the symbol handler's notation of what
        /// is loaded. If a code bundle loads into three different processes (or the same
        /// process but with three different base addresses or three different app domains)
        /// but the symbol handler thinks of all of these as being identical, there will be
        /// only one module object.
        /// </param>
        /// <param name="MethodId">
        /// [In] The version/token pair for this method.
        /// </param>
        /// <param name="ILOffset">
        /// [In] ILOffset is the index of the IL instruction that this symbol represents.
        /// This value may be set to UInt32.MaxValue for an instruction that is within the
        /// given method, but not tied to a particular instruction. This is used for CLR
        /// native instructions that don't map to an IL instruction.
        /// </param>
        /// <param name="EmbeddedModuleIndex">
        /// [In] Identifier of the embedded module within the container where this function
        /// resides.
        /// </param>
        /// <param name="NativeOffset">
        /// [In] This value is the RVA of the native instruction from the beginning of the
        /// native module that contains this instruction.
        /// </param>
        /// <param name="pGenericParameters">
        /// [In,Optional] For generic methods, this provides the ECMA formatted TypeSpec
        /// signature for each generic parameter. For non-generic methods, this will be null.
        /// </param>
        /// <param name="ppCreatedObject">
        /// [Out] Result of this method call.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ Symbols::DkmModule* pModule,
            _In_ const Clr::DkmClrMethodId& MethodId,
            _In_ UINT32 ILOffset,
            _In_ UINT32 EmbeddedModuleIndex,
            _In_ UINT32 NativeOffset,
            _In_opt_ DkmReadOnlyCollection<BYTE>* pGenericParameters,
            _Deref_out_ Clr::NativeCompilation::DkmClrNcInstructionSymbol** ppCreatedObject
            );
    }; // end of DkmClrNcInstructionSymbol

    // 'DkmClrNcModuleInstance' is used for managed modules which are compiled to native code
    // and embedded inside of a native module. Like DkmClrModuleInstance, these are 1:1 with
    // an ICorDebugModule.
    //
    // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("f85a173b-616b-91d3-319d-24cf9030c023") DkmClrNcModuleInstance : public Clr::DkmClrModuleInstance
    {
        // Use DkmClrNcModuleInstance::Create to create this object
        private: DkmClrNcModuleInstance();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmClrNcModuleInstance();
        // This object cannot be copied
        private: DkmClrNcModuleInstance& operator=(const DkmClrNcModuleInstance&);
        private: DkmClrNcModuleInstance(const DkmClrNcModuleInstance&);

        private: Clr::NativeCompilation::DkmClrNcContainerModuleInstance* const m_pContainerModule;
        private: const UINT32 m_Index;
        private: void* m__pExtendedData;

        // Represents a native-compiled CLR instance running in a target process.
        //
        // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
        public: _Ret_ DECLSPEC_NOTHROW Clr::NativeCompilation::DkmClrNcRuntimeInstance* STDMETHODCALLTYPE RuntimeInstance(
            );

        // The container (physical) module instance that this embedded (virtual) module is
        // built into.
        //
        // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
        public: _Ret_ DECLSPEC_NOTHROW Clr::NativeCompilation::DkmClrNcContainerModuleInstance* STDMETHODCALLTYPE ContainerModule(
            );

        // The identifier for this embedded module within the container. This is used as a
        // prefix on type names in the container module to indicate which embedded module a
        // type belongs to.
        //
        // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
        public: DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE Index(
            );

        /// <summary>
        /// Creates one or more DkmClrNcInstructionAddress from a method token + IL offset.
        /// There can be multiple addresses if either that IL offset maps to multiple
        /// instruction blocks or if this is a generic method and there are multiple
        /// instantiations.
        ///
        /// This method will append a new work item to the specified work list, and return
        /// once the work item has been appended. The actual processing of the work item is
        /// asynchronous. The caller will be notified that the request is complete through
        /// the completion routine.
        ///
        /// This API was introduced in Visual Studio 14 RTM (DkmApiVersion.VS14RTM).
        /// </summary>
        /// <param name="pWorkList">
        /// WorkList to append the new work item to.
        /// </param>
        /// <param name="MethodId">
        /// [In] The method id of the IL method.
        /// </param>
        /// <param name="ILOffset">
        /// [In] The IL offset of the instruction to map.
        /// </param>
        /// <param name="pCompletionRoutine">
        /// Routine to fire when the request is complete. If the request is successfully
        /// appended to the work list, this will always fire (including when the operation is
        /// canceled). This will never fire if appending the work item fails.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE CreateInstructionAddressesFromILAddress(
            _In_ DkmWorkList* pWorkList,
            _In_ const Clr::DkmClrMethodId& MethodId,
            _In_ UINT32 ILOffset,
            _In_ IDkmCompletionRoutine<Clr::NativeCompilation::DkmCreateInstructionAddressesFromILAddressAsyncResult>* pCompletionRoutine
            );
    }; // end of DkmClrNcModuleInstance

    // Represents a native-compiled CLR instance running in a target process.
    //
    // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("a1a355e8-c42b-c18f-c5e6-42f06d6aa8c5") DkmClrNcRuntimeInstance : public Clr::DkmClrRuntimeInstance
    {
        // Use DkmClrNcRuntimeInstance::Create to create this object
        private: DkmClrNcRuntimeInstance();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmClrNcRuntimeInstance();
        // This object cannot be copied
        private: DkmClrNcRuntimeInstance& operator=(const DkmClrNcRuntimeInstance&);
        private: DkmClrNcRuntimeInstance(const DkmClrNcRuntimeInstance&);

        private: void* m__pExtendedData;

        /// <summary>
        /// Creates a new runtime instance object from a debug monitor. This method must be
        /// called from the event thread when a debug monitor detects that a new runtime
        /// instance has loaded (for example, when the corresponding runtime dll loads in the
        /// target process).
        ///
        /// This method will send a RuntimeInstanceLoad event.
        ///
        /// This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
        /// </summary>
        /// <param name="pProcess">
        /// [In] DkmProcess represents a target process which is being debugged. The debugger
        /// debugs processes, so this is the basic unit of debugging. A DkmProcess can
        /// represent a system process or a virtual process such as minidumps.
        /// </param>
        /// <param name="Id">
        /// [In] Identifies a DkmRuntimeInstance object within a process.
        /// </param>
        /// <param name="Capabilities">
        /// [In] Enumeration of runtime capabilities.
        /// </param>
        /// <param name="pParentRuntime">
        /// [In,Optional] For runtimes that are implemented on top of another runtime, this
        /// can optionally be used to indicant the logical parent. This can then be used to
        /// request services from the parent when the child runtime doesn't implement the
        /// service. This is currently used only for obtaining the top stack frame to
        /// evaluate a conditional breakpoint when the child runtime doesn't walk stacks
        /// itself.
        /// </param>
        /// <param name="pRuntimeVersion">
        /// [In,Optional] The version string for the CLR instance (ex: 'v2.0.50727').
        /// </param>
        /// <param name="DataItem">
        /// [In] Data object to add to the new DkmClrNcRuntimeInstance instance.
        /// DkmDataItem::Null() in the case that the caller doesn't need to add a data item.
        /// </param>
        /// <param name="ppCreatedObject">
        /// [Out] Result of this method call.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ DkmProcess* pProcess,
            _In_ const DkmRuntimeInstanceId& Id,
            _In_ DkmRuntimeCapabilities_t Capabilities,
            _In_opt_ DkmRuntimeInstance* pParentRuntime,
            _In_opt_ DkmString* pRuntimeVersion,
            _In_ const DkmDataItem& DataItem,
            _Deref_out_ Clr::NativeCompilation::DkmClrNcRuntimeInstance** ppCreatedObject
            );
    }; // end of DkmClrNcRuntimeInstance

};}; // end namespace Clr::NativeCompilation

// Contains types specific to debugging native code.
namespace Native {
    // Extended information about a CPP exception thrown while debugging a windows runtime
    // application.
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("dcee9b3e-138b-d26c-42fd-4bfd99a3955b") DkmCppWinRTExceptionInformation : public IUnknown
    {
        private: ___ReferenceCount_t m_ReferenceCount;
        private: DkmDispatcherObjectFlags_t m_ObjectFlags;
        private: const GUID* m_pTypeId;
        private: size_t m_ObjectGCHandle;
        // Use DkmCppWinRTExceptionInformation::Create to create this object
        private: DkmCppWinRTExceptionInformation();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmCppWinRTExceptionInformation();
        // This object cannot be copied
        private: DkmCppWinRTExceptionInformation& operator=(const DkmCppWinRTExceptionInformation&);
        private: DkmCppWinRTExceptionInformation(const DkmCppWinRTExceptionInformation&);

        // Contains additional fields of DkmCppWinRTExceptionInformation which were added
        // after the class was initally introduced.
        private: struct ___ExtendedData
        {
            ___ExtendedData();

            // The address of the IErrorInfo object associated with the exception.  This is
            // used to retrieve captured stack.
            const UINT64 ErrorInfoAddress;

            // [Optional] If the exception contains a captured stack trace, specifies the
            // addresses of the captured frames.
            OPTIONAL DkmReadOnlyCollection<DkmInstructionAddress*>* const pCapturedStack;
        };

        private: DkmString* const m_pDescription;
        private: DkmString* const m_pRestrictedDescription;
        private: DkmString* const m_pRestrictedReference;
        private: DkmString* const m_pRestrictedCapabilitySid;
        private: const HRESULT m_ExceptionHR;
        private: ___ExtendedData* const m__pExtendedData;

        // Basic non-restricted description of the exception.
        public: _Ret_ DECLSPEC_NOTHROW DkmString* STDMETHODCALLTYPE Description(
            );

        // Restricted description of the exception.
        public: _Ret_ DECLSPEC_NOTHROW DkmString* STDMETHODCALLTYPE RestrictedDescription(
            );

        // Reference string used as a key to find restricted information when
        // RestrictedReference is missing.
        public: _Ret_ DECLSPEC_NOTHROW DkmString* STDMETHODCALLTYPE RestrictedReference(
            );

        // Security identifier of a missing capability if this exception was thrown for that
        // reason.
        public: _Ret_ DECLSPEC_NOTHROW DkmString* STDMETHODCALLTYPE RestrictedCapabilitySid(
            );

        // The failed HRESULT value that caused this exception to be thrown.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ExceptionHR(
            );

        // The address of the IErrorInfo object associated with the exception.  This is used
        // to retrieve captured stack.
        //
        // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
        public: DECLSPEC_NOTHROW UINT64 STDMETHODCALLTYPE ErrorInfoAddress(
            );

        // [Optional] If the exception contains a captured stack trace, specifies the
        // addresses of the captured frames.
        //
        // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
        public: _Ret_opt_ DECLSPEC_NOTHROW DkmReadOnlyCollection<DkmInstructionAddress*>* STDMETHODCALLTYPE CapturedStack(
            );

        /// <summary>
        /// Create a new DkmCppWinRTExceptionInformation object instance.
        /// </summary>
        /// <param name="pDescription">
        /// [In] Basic non-restricted description of the exception.
        /// </param>
        /// <param name="pRestrictedDescription">
        /// [In] Restricted description of the exception.
        /// </param>
        /// <param name="pRestrictedReference">
        /// [In] Reference string used as a key to find restricted information when
        /// RestrictedReference is missing.
        /// </param>
        /// <param name="pRestrictedCapabilitySid">
        /// [In] Security identifier of a missing capability if this exception was thrown for
        /// that reason.
        /// </param>
        /// <param name="ExceptionHR">
        /// [In] The failed HRESULT value that caused this exception to be thrown.
        /// </param>
        /// <param name="ppCreatedObject">
        /// [Out] Result of this method call.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ DkmString* pDescription,
            _In_ DkmString* pRestrictedDescription,
            _In_ DkmString* pRestrictedReference,
            _In_ DkmString* pRestrictedCapabilitySid,
            _In_ HRESULT ExceptionHR,
            _Deref_out_ Native::DkmCppWinRTExceptionInformation** ppCreatedObject
            );

        /// <summary>
        /// Create a new DkmCppWinRTExceptionInformation object instance.
        ///
        /// This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
        /// </summary>
        /// <param name="pDescription">
        /// [In] Basic non-restricted description of the exception.
        /// </param>
        /// <param name="pRestrictedDescription">
        /// [In] Restricted description of the exception.
        /// </param>
        /// <param name="pRestrictedReference">
        /// [In] Reference string used as a key to find restricted information when
        /// RestrictedReference is missing.
        /// </param>
        /// <param name="pRestrictedCapabilitySid">
        /// [In] Security identifier of a missing capability if this exception was thrown for
        /// that reason.
        /// </param>
        /// <param name="ExceptionHR">
        /// [In] The failed HRESULT value that caused this exception to be thrown.
        /// </param>
        /// <param name="ErrorInfoAddress">
        /// [In] The address of the IErrorInfo object associated with the exception.  This is
        /// used to retrieve captured stack.
        /// </param>
        /// <param name="pCapturedStack">
        /// [In,Optional] If the exception contains a captured stack trace, specifies the
        /// addresses of the captured frames.
        /// </param>
        /// <param name="ppCreatedObject">
        /// [Out] Result of this method call.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ DkmString* pDescription,
            _In_ DkmString* pRestrictedDescription,
            _In_ DkmString* pRestrictedReference,
            _In_ DkmString* pRestrictedCapabilitySid,
            _In_ HRESULT ExceptionHR,
            _In_ UINT64 ErrorInfoAddress,
            _In_opt_ DkmReadOnlyCollection<DkmInstructionAddress*>* pCapturedStack,
            _Deref_out_ Native::DkmCppWinRTExceptionInformation** ppCreatedObject
            );
    }; // end of DkmCppWinRTExceptionInformation

    // Result of an asynchronous DkmNativeModuleInstance.FindExportName call.
    struct DkmFindExportNameAsyncResult
    {
        // HRESULT code returned from the caller. This will be
        // DkmExceptionCode.COR_E_OPERATIONCANCELED (0x8013153B) if the operation was
        // canceled before processing was complete.
        HRESULT ErrorCode;

        // [Optional] If the export was found in the specified module, this will contain the
        // target address. Note that this instruction address object may be in a different
        // module than the searched module. This can happen if the export was forwarded and
        // the destination module is already loaded. If the destination module is not loaded,
        // the export will be ignored.
        OPTIONAL Native::DkmNativeInstructionAddress* pAddress;
    };

    // Result of an asynchronous DkmNativeInstructionAddress.FindNearestExport call.
    struct DkmFindNearestExportAsyncResult
    {
        // HRESULT code returned from the caller. This will be
        // DkmExceptionCode.COR_E_OPERATIONCANCELED (0x8013153B) if the operation was
        // canceled before processing was complete.
        HRESULT ErrorCode;

        // [Optional] Name of the export.
        OPTIONAL DkmString* pExportName;

        // Byte offset from the start of the export.
        INT32 ByteOffset;
    };

    // DkmNativeAddressMetadata represents symbol based metadata about addresses. This
    // includes if the address is a thunk, a prolog, or a trampoline.
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("4d17e81c-cff2-58f7-7973-87f40be51fc0") DkmNativeAddressMetadata : public IUnknown
    {
        private: ___ReferenceCount_t m_ReferenceCount;
        private: DkmDispatcherObjectFlags_t m_ObjectFlags;
        private: const GUID* m_pTypeId;
        private: size_t m_ObjectGCHandle;
        // Use DkmNativeAddressMetadata::Create to create this object
        private: DkmNativeAddressMetadata();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmNativeAddressMetadata();
        // This object cannot be copied
        private: DkmNativeAddressMetadata& operator=(const DkmNativeAddressMetadata&);
        private: DkmNativeAddressMetadata(const DkmNativeAddressMetadata&);

        private: const Native::DkmNativeAddressType_t m_AddressType;
        private: const Native::DkmNativeAddressStepType_t m_StepType;
        private: const UINT32 m_AddressTypeLength;
        private: void* m__pExtendedData;

        // A value from the DkmNativeAddressType enumeration describing what this address is
        // in the debuggee.
        public: DECLSPEC_NOTHROW Native::DkmNativeAddressType_t STDMETHODCALLTYPE AddressType(
            );

        // A value from the DkmNativeAddressStepType enumeration describing how the native
        // steppers should tread this address when a step encounters it.
        public: DECLSPEC_NOTHROW Native::DkmNativeAddressStepType_t STDMETHODCALLTYPE StepType(
            );

        // The length of the current address type.
        public: DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE AddressTypeLength(
            );

        /// <summary>
        /// Create a new DkmNativeAddressMetadata object instance.
        /// </summary>
        /// <param name="AddressType">
        /// [In] A value from the DkmNativeAddressType enumeration describing what this
        /// address is in the debuggee.
        /// </param>
        /// <param name="StepType">
        /// [In] A value from the DkmNativeAddressStepType enumeration describing how the
        /// native steppers should tread this address when a step encounters it.
        /// </param>
        /// <param name="AddressTypeLength">
        /// [In] The length of the current address type.
        /// </param>
        /// <param name="ppCreatedObject">
        /// [Out] Result of this method call.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ Native::DkmNativeAddressType_t AddressType,
            _In_ Native::DkmNativeAddressStepType_t StepType,
            _In_ UINT32 AddressTypeLength,
            _Deref_out_ Native::DkmNativeAddressMetadata** ppCreatedObject
            );
    }; // end of DkmNativeAddressMetadata

    // DkmNativeAddressStepType describes how the native range steppers should treat this
    // location. Used during step-in and step-out.
    DEFINE_SCOPED_ENUM(DkmNativeAddressStepType)
    {
        // No special treatment for this location.
        None = 0,
        // Stopping at this address does not make sense. Continue stepping past it.
        ContinueStep = 1
    };

    // DkmNativeAddressType describes if an address represents a special location in the
    // debuggee instruction stream.
    DEFINE_SCOPED_ENUM(DkmNativeAddressType)
    {
        // The address has native symbols and is at a normal location.
        Native = 0,
        // The address has native symbols but has no source information.
        NativeNoSource = 1,
        // The address represents a thunk in the target process.
        Thunk = 2,
        // The address represents a prolog to a function in the target process.
        Prolog = 3,
        // The address represents a epilog to a function in the target process.
        Epilog = 4,
        // The address represents a trampoline in the target process.
        Trampoline = 5,
        // The address represents code telling debugger do not stop and step into for any
        // call.
        NonStopStepIntoCode = 6,
        // The address is at the label _NLG_Return or _NLG_Return2.
        NlgReturn = 7,
        // The address represents a custom location in the debuggee.
        Custom = 8,
        // The address does not have native symbols.
        NoNativeSymbols = 9,
        // The address has native symbols but should not be stepped into.
        NativeNoStepInto = 10,
        // The address represents compiler generated WinRT glue code.
        CompilerGeneratedGlueCode = 11
    };

    // Provides information about a C++ exception which was raised in the target process.
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("8d9e3c4f-e264-47d5-0e02-7d5bf93c4659") DkmCppExceptionInformation : public Exceptions::DkmExceptionInformation
    {
        // Use DkmCppExceptionInformation::Create to create this object
        private: DkmCppExceptionInformation();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmCppExceptionInformation();
        // This object cannot be copied
        private: DkmCppExceptionInformation& operator=(const DkmCppExceptionInformation&);
        private: DkmCppExceptionInformation(const DkmCppExceptionInformation&);

        private: const UINT64 m_ExceptionObjectPointer;
        private: const UINT64 m_Address;
        private: OPTIONAL Native::DkmCppWinRTExceptionInformation* const m_pWinRTExceptionInfo;
        private: void* m__pExtendedData;

        // Type name of the exception. Example: 'std::exception'.
        public: _Ret_ DECLSPEC_NOTHROW DkmString* STDMETHODCALLTYPE Name(
            );

        // Address within the target process of the thrown object.
        public: DECLSPEC_NOTHROW UINT64 STDMETHODCALLTYPE ExceptionObjectPointer(
            );

        // The address where the exception occurred.
        public: DECLSPEC_NOTHROW UINT64 STDMETHODCALLTYPE Address(
            );

        // [Optional] Extended information about a WinRT exception if it exists.
        public: _Ret_opt_ DECLSPEC_NOTHROW Native::DkmCppWinRTExceptionInformation* STDMETHODCALLTYPE WinRTExceptionInfo(
            );

        // Attempt to cast a 'DkmExceptionInformation' to a 'DkmCppExceptionInformation'. Return
        // NULL if the path object is not a 'DkmCppExceptionInformation'.
        // pCppException : [In,Optional] Object to attempt to cast
        // Return Value : [Optional] Result of the cast.
        public: static DECLSPEC_NOTHROW DkmCppExceptionInformation* TryCast(
            DkmExceptionInformation* pException
            )
        {
            if (pException == NULL || pException->TagValue() != Tag::CppException)
                return NULL;

            return static_cast<DkmCppExceptionInformation*>(pException);
        }

        /// <summary>
        /// Create a new DkmCppExceptionInformation object instance.
        /// </summary>
        /// <param name="pRuntimeInstance">
        /// [In] The DkmRuntimeInstance class represents an execution environment which is
        /// loaded into a DkmProcess and which contains code to be debugged.
        /// </param>
        /// <param name="pThread">
        /// [In] DkmThread represents a thread running in the target process.
        /// </param>
        /// <param name="pInstructionAddress">
        /// [In,Optional] Address where the exception occurred. This will always be present
        /// for C++ and Win32 exceptions. It may be missing from CLR exceptions or MDAs as
        /// these may originate from inside the runtime.
        /// </param>
        /// <param name="ProcessingStage">
        /// [In] The debugger receives notifications from the target process at various
        /// stages within exception processing (ex: exception thrown, exception unhandled).
        /// This enumeration indicates the stage(s) for a notification.
        /// </param>
        /// <param name="pImplementationException">
        /// [In,Optional] Information about the underlying exception used to implement a
        /// higher level exception. For example, CLR and C++ exceptions may be implemented on
        /// top of Win32 exceptions. So this may store the DkmWin32ExceptionInformation for
        /// CLR or C++ exceptions.
        /// </param>
        /// <param name="pName">
        /// [In] Type name of the exception. Example: 'std::exception'.
        /// </param>
        /// <param name="ExceptionObjectPointer">
        /// [In] Address within the target process of the thrown object.
        /// </param>
        /// <param name="Address">
        /// [In] The address where the exception occurred.
        /// </param>
        /// <param name="pWinRTExceptionInfo">
        /// [In,Optional] Extended information about a WinRT exception if it exists.
        /// </param>
        /// <param name="ppCreatedObject">
        /// [Out] Result of this method call.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ DkmRuntimeInstance* pRuntimeInstance,
            _In_ DkmThread* pThread,
            _In_opt_ DkmInstructionAddress* pInstructionAddress,
            _In_ Exceptions::DkmExceptionProcessingStage_t ProcessingStage,
            _In_opt_ Exceptions::DkmExceptionInformation* pImplementationException,
            _In_ DkmString* pName,
            _In_ UINT64 ExceptionObjectPointer,
            _In_ UINT64 Address,
            _In_opt_ Native::DkmCppWinRTExceptionInformation* pWinRTExceptionInfo,
            _Deref_out_ Native::DkmCppExceptionInformation** ppCreatedObject
            );
    }; // end of DkmCppExceptionInformation

    // DkmNativeInstructionAddress is used for addresses that resolve to within a native
    // module. This is used regardless as to if there are symbols for the module.
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("a1e2e4ab-463a-e8a1-3e68-1f49e6945d9e") DkmNativeInstructionAddress : public DkmInstructionAddress
    {
        // Use DkmNativeInstructionAddress::Create to create this object
        private: DkmNativeInstructionAddress();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmNativeInstructionAddress();
        // This object cannot be copied
        private: DkmNativeInstructionAddress& operator=(const DkmNativeInstructionAddress&);
        private: DkmNativeInstructionAddress(const DkmNativeInstructionAddress&);

        private: const UINT32 m_RVA;
        private: void* m__pExtendedData;

        // Represents the native code executing in a target process.
        public: _Ret_ DECLSPEC_NOTHROW Native::DkmNativeRuntimeInstance* STDMETHODCALLTYPE RuntimeInstance(
            );

        // The module containing the InstructionPointer.
        public: _Ret_ DECLSPEC_NOTHROW Native::DkmNativeModuleInstance* STDMETHODCALLTYPE ModuleInstance(
            );

        // The RVA of InstructionPointer within Module.
        public: DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE RVA(
            );

        // Attempt to cast a 'DkmInstructionAddress' to a 'DkmNativeInstructionAddress'. Return
        // NULL if the path object is not a 'DkmNativeInstructionAddress'.
        // pNativeAddress : [In,Optional] Object to attempt to cast
        // Return Value : [Optional] Result of the cast.
        public: static DECLSPEC_NOTHROW DkmNativeInstructionAddress* TryCast(
            DkmInstructionAddress* pInstructionAddress
            )
        {
            if (pInstructionAddress == NULL || pInstructionAddress->TagValue() != Tag::NativeAddress)
                return NULL;

            return static_cast<DkmNativeInstructionAddress*>(pInstructionAddress);
        }

        /// <summary>
        /// Create a new DkmNativeInstructionAddress object instance.
        /// </summary>
        /// <param name="pRuntimeInstance">
        /// [In] Represents the native code executing in a target process.
        /// </param>
        /// <param name="pModuleInstance">
        /// [In] The module containing the InstructionPointer.
        /// </param>
        /// <param name="RVA">
        /// [In] The RVA of InstructionPointer within Module.
        /// </param>
        /// <param name="pCPUInstruction">
        /// [In,Optional] CPUInstruction provides the address that the CPU will execute. This
        /// is always provided for native instructions. It may be provided for CLR or custom
        /// addresses depending on how the address object was created.
        /// </param>
        /// <param name="ppCreatedObject">
        /// [Out] Result of this method call.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ Native::DkmNativeRuntimeInstance* pRuntimeInstance,
            _In_ Native::DkmNativeModuleInstance* pModuleInstance,
            _In_ UINT32 RVA,
            _In_opt_ const DkmInstructionAddress::CPUInstruction* pCPUInstruction,
            _Deref_out_ Native::DkmNativeInstructionAddress** ppCreatedObject
            );

        /// <summary>
        /// Finds the nearest module export from the specified instruction address. The
        /// export could either be a function or data export, though function exports are far
        /// more common. Because exports do not have address ranges, the specified address
        /// may not actually be associated with the returned export.
        /// </summary>
        /// <param name="ppExportName">
        /// [Out,Optional] Name of the export.
        /// </param>
        /// <param name="pByteOffset">
        /// [Out] Byte offset from the start of the export.
        /// </param>
        /// <returns>
        /// S_OK is returned if *ppExportName is non-NULL, S_FALSE is returned when
        /// *ppExportName is NULL, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE FindNearestExport(
            _Deref_out_opt_ DkmString** ppExportName,
            _Out_ INT32* pByteOffset
            );

        /// <summary>
        /// Finds the nearest module export from the specified instruction address. The
        /// export could either be a function or data export, though function exports are far
        /// more common. Because exports do not have address ranges, the specified address
        /// may not actually be associated with the returned export.
        ///
        /// This method will append a new work item to the specified work list, and return
        /// once the work item has been appended. The actual processing of the work item is
        /// asynchronous. The caller will be notified that the request is complete through
        /// the completion routine.
        /// </summary>
        /// <param name="pWorkList">
        /// WorkList to append the new work item to.
        /// </param>
        /// <param name="pCompletionRoutine">
        /// Routine to fire when the request is complete. If the request is successfully
        /// appended to the work list, this will always fire (including when the operation is
        /// canceled). This will never fire if appending the work item fails.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE FindNearestExport(
            _In_ DkmWorkList* pWorkList,
            _In_ IDkmCompletionRoutine<Native::DkmFindNearestExportAsyncResult>* pCompletionRoutine
            );

        #ifndef EXCLUDE_IDE_ONLY_APIS
        /// <summary>
        /// GetSteppingCallSites is called to get call sites reachable from an instruction.
        ///
        /// Location constraint: API must be called from an IDE component (component level
        /// &gt; 100,000).
        /// </summary>
        /// <param name="SteppingRanges">
        /// [In] The stepping ranges to evaluate for call sites.
        ///
        /// The memory for the DkmArray members is allocated by the caller, and can be from
        /// any source (stack memory, static buffer, heap, etc). The implementation should
        /// not modify the members.
        /// </param>
        /// <param name="pCallSites">
        /// [Out] DkmNativeSteppingCallSite[] specifies a call instruction and it's target..
        ///
        /// The memory for the DkmArray members is allocated by the method implementation
        /// using DkmAllocBytes/DkmAllocArray. It is freed by the caller using the
        /// CAutoDkmArray template or with DkmFreeMemory and manual element release.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetSteppingCallSites(
            _In_ const DkmArray<Symbols::DkmSteppingRange>& SteppingRanges,
            _Out_ DkmArray<Stepping::DkmNativeSteppingCallSite*>* pCallSites
            );
        #endif // #ifndef EXCLUDE_IDE_ONLY_APIS
    }; // end of DkmNativeInstructionAddress

    // DkmNativeInstructionSymbol represents a native instruction within a module of the
    // target process. DkmNativeInstructionSymbol are 1:1 with the underlying native
    // instructions. So if there are two template instantiations of a method (ex:
    // MyMethod<CString> and MyMethod<int>) if the linker merges the two instantiations into
    // a single function through COMDAT folding then the methods will be identical. If the
    // linker isn't able to merge the two instantiations then both user-level functions will
    // appear as one DkmNativeInstructionSymbol.
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("0eb834ca-c591-449c-66ad-e016093977d2") DkmNativeInstructionSymbol : public Symbols::DkmInstructionSymbol
    {
        // Use DkmNativeInstructionSymbol::Create to create this object
        private: DkmNativeInstructionSymbol();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmNativeInstructionSymbol();
        // This object cannot be copied
        private: DkmNativeInstructionSymbol& operator=(const DkmNativeInstructionSymbol&);
        private: DkmNativeInstructionSymbol(const DkmNativeInstructionSymbol&);

        private: const UINT32 m_RVA;
        private: void* m__pExtendedData;

        // The RVA of InstructionPointer within Module.
        public: DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE RVA(
            );

        // Attempt to cast a 'DkmInstructionSymbol' to a 'DkmNativeInstructionSymbol'. Return
        // NULL if the path object is not a 'DkmNativeInstructionSymbol'.
        // pNativeInstruction : [In,Optional] Object to attempt to cast
        // Return Value : [Optional] Result of the cast.
        public: static DECLSPEC_NOTHROW DkmNativeInstructionSymbol* TryCast(
            DkmInstructionSymbol* pInstruction
            )
        {
            if (pInstruction == NULL || pInstruction->TagValue() != Tag::NativeInstruction)
                return NULL;

            return static_cast<DkmNativeInstructionSymbol*>(pInstruction);
        }

        /// <summary>
        /// Create a new DkmNativeInstructionSymbol object instance.
        /// </summary>
        /// <param name="pModule">
        /// [In] The DkmModule class represents a code bundle (ex: dll or exe) which is or
        /// once was loaded into one or more processes. The DkmModule class is the central
        /// object to the symbol APIs, and is 1:1 with the symbol handler's notation of what
        /// is loaded. If a code bundle loads into three different processes (or the same
        /// process but with three different base addresses or three different app domains)
        /// but the symbol handler thinks of all of these as being identical, there will be
        /// only one module object.
        /// </param>
        /// <param name="RVA">
        /// [In] The RVA of InstructionPointer within Module.
        /// </param>
        /// <param name="ppCreatedObject">
        /// [Out] Result of this method call.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ Symbols::DkmModule* pModule,
            _In_ UINT32 RVA,
            _Deref_out_ Native::DkmNativeInstructionSymbol** ppCreatedObject
            );

        /// <summary>
        /// Returns address information to the native debug monitor.
        /// </summary>
        /// <param name="pInstructionAddress">
        /// [In,Optional] Abstract representation of an executable code location (ex: EIP
        /// value). If resolved, an Instruction Address will be within a particular module
        /// instance. An Instruction Address is always within a particular Runtime Instance.
        /// </param>
        /// <param name="ppMetadata">
        /// [Out,Optional] DkmNativeAddressMetadata represents symbol based metadata about
        /// addresses. This includes if the address is a thunk, a prolog, or a trampoline.
        /// </param>
        /// <returns>
        /// S_OK is returned if *ppMetadata is non-NULL, S_FALSE is returned when *ppMetadata
        /// is NULL, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetNativeInstructionMetadataCallback(
            _In_opt_ DkmInstructionAddress* pInstructionAddress,
            _Deref_out_opt_ Native::DkmNativeAddressMetadata** ppMetadata
            );

        #ifndef EXCLUDE_MONITOR_ONLY_APIS
        /// <summary>
        /// Queries the symbol provider to determine the ranges of instructions which the
        /// base debug monitor should step through to implement a step.
        ///
        /// Location constraint: API must be called from a Monitor component (component level
        /// &lt; 100,000).
        ///
        /// This API was introduced in Visual Studio 14 RTM (DkmApiVersion.VS14RTM).
        /// </summary>
        /// <param name="pModuleInstance">
        /// [In] Module instance which contains the current instruction symbol.
        /// </param>
        /// <param name="pStepStartingAddress">
        /// [In,Optional] Instruction where the step began. May be null in unusual
        /// situations, such as beginning the step with no frames on the stack. Note that
        /// this is not necessarily a native instruction.
        /// </param>
        /// <param name="RangeBoundary">
        /// [In] Indicates to the symbol provider the type of instructions to include in the
        /// 'no-step' regions.
        /// </param>
        /// <param name="IncludeInline">
        /// [In] True if the symbol provider should stop the stepping range when it
        /// encounters an inline functions. False otherwise. The Native DM will pass true for
        /// a step in so steps will stop in inline functions. It will pass false when doing a
        /// step-over so the stepper will not stop in inline functions.
        /// </param>
        /// <param name="pRanges">
        /// [Out] Array of ranges to step through. This array will be empty if there is no
        /// source information for the given instruction.
        ///
        /// The memory for the DkmArray members is allocated by the method implementation
        /// using DkmAllocBytes/DkmAllocArray. It is freed by the caller using the
        /// CAutoDkmArray template or with DkmFreeMemory and manual element release.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetSteppingRanges(
            _In_ DkmModuleInstance* pModuleInstance,
            _In_opt_ DkmInstructionAddress* pStepStartingAddress,
            _In_ Symbols::DkmSteppingRangeBoundary_t RangeBoundary,
            _In_ bool IncludeInline,
            _Out_ DkmArray<Symbols::DkmSteppingRange>* pRanges
            );
        #endif // #ifndef EXCLUDE_MONITOR_ONLY_APIS

        #ifndef EXCLUDE_MONITOR_ONLY_APIS
        /// <summary>
        /// Called by the native DM to fetch data about an instruction which is used to
        /// decide how this instruction should be stepped.
        ///
        /// Location constraint: API must be called from a Monitor component (component level
        /// &lt; 100,000).
        ///
        /// This API was introduced in Visual Studio 14 RTM (DkmApiVersion.VS14RTM).
        /// </summary>
        /// <param name="pModuleInstance">
        /// [In] Module instance which contains the current instruction symbol.
        /// </param>
        /// <param name="pStepStartingAddress">
        /// [In,Optional] Instruction where the step began. May be null in unusual
        /// situations, such as beginning the step with no frames on the stack.  Note that
        /// this is not necessarily a native instruction.
        /// </param>
        /// <param name="ppMetadata">
        /// [Out,Optional] DkmNativeAddressMetadata represents symbol based metadata about
        /// addresses. This includes if the address is a thunk, a prolog, or a trampoline.
        /// </param>
        /// <returns>
        /// S_OK is returned if *ppMetadata is non-NULL, S_FALSE is returned when *ppMetadata
        /// is NULL, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetSteppingNativeInstructionMetadata(
            _In_ DkmModuleInstance* pModuleInstance,
            _In_opt_ DkmInstructionAddress* pStepStartingAddress,
            _Deref_out_opt_ Native::DkmNativeAddressMetadata** ppMetadata
            );
        #endif // #ifndef EXCLUDE_MONITOR_ONLY_APIS
    }; // end of DkmNativeInstructionSymbol

    // 'DkmNativeModuleInstance' is used for modules which contain CPU code and/or are loaded
    // by the Win32 loader.
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("b7de7beb-acab-76c4-bd78-fbba698e4b65") DkmNativeModuleInstance : public DkmModuleInstance
    {
        // Use DkmNativeModuleInstance::Create to create this object
        private: DkmNativeModuleInstance();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmNativeModuleInstance();
        // This object cannot be copied
        private: DkmNativeModuleInstance& operator=(const DkmNativeModuleInstance&);
        private: DkmNativeModuleInstance(const DkmNativeModuleInstance&);

        private: const Clr::DkmClrHeaderStatus_t m_ClrHeaderStatus;
        private: void* m__pExtendedData;

        // Represents the native code executing in a target process.
        public: _Ret_ DECLSPEC_NOTHROW Native::DkmNativeRuntimeInstance* STDMETHODCALLTYPE RuntimeInstance(
            );

        // The starting memory address of where the module is loaded. This value should
        // always be valid.
        public: DECLSPEC_NOTHROW UINT64 STDMETHODCALLTYPE BaseAddress(
            );

        // The number of bytes in the module's memory region.
        public: DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE Size(
            );

        // Contains information from the 'Flags' field of the IMAGE_COR20_HEADER of the
        // loaded module. This indicates which type of binary was loaded.
        public: DECLSPEC_NOTHROW Clr::DkmClrHeaderStatus_t STDMETHODCALLTYPE ClrHeaderStatus(
            );

        // Attempt to cast a 'DkmModuleInstance' to a 'DkmNativeModuleInstance'. Return
        // NULL if the path object is not a 'DkmNativeModuleInstance'.
        // pNativeModuleInstance : [In,Optional] Object to attempt to cast
        // Return Value : [Optional] Result of the cast.
        public: static DECLSPEC_NOTHROW DkmNativeModuleInstance* TryCast(
            DkmModuleInstance* pModuleInstance
            )
        {
            if (pModuleInstance == NULL || pModuleInstance->TagValue() != Tag::NativeModuleInstance)
                return NULL;

            return static_cast<DkmNativeModuleInstance*>(pModuleInstance);
        }

        /// <summary>
        /// Create a new DkmNativeModuleInstance object instance.
        ///
        /// This method will send a ModuleInstanceLoad event.
        /// </summary>
        /// <param name="pName">
        /// [In] Short representation of the module name. For file-based modules, this  is
        /// the file name and extension (ex: kernel32.dll).
        /// </param>
        /// <param name="pFullName">
        /// [In] Fully qualified module name. For file-based modules, this is the full path
        /// to the module (ex: c:\windows\system32\kernel32.dll.
        /// </param>
        /// <param name="TimeDateStamp">
        /// [In] Date/Time of when the loaded module was built. This value is obtained from
        /// the IMAGE_NT_HEADERS of the loaded module. The unit of measurement is a  FILETIME
        /// value, which is a 64-bit value representing the number of 100-nanosecond
        /// intervals since January 1, 1601 (UTC).
        /// </param>
        /// <param name="pVersion">
        /// [In,Optional] File version information.
        /// </param>
        /// <param name="pSymbolFileId">
        /// [In,Optional] Contains information needed to locate symbols for this module. On
        /// Win32, this information is contained within the IMAGE_DEBUG_DIRECTORY.
        /// </param>
        /// <param name="Flags">
        /// [In] Flags which indicate traits of a DkmModuleInstance.
        /// </param>
        /// <param name="MemoryLayout">
        /// [In] Enumeration that indicates how a module is laid out in memory.
        /// </param>
        /// <param name="LoadOrder">
        /// [In] The integer count of the number of module instances that have loaded up to
        /// and including this module. Each runtime instance keeps track of its own load
        /// order count.
        /// </param>
        /// <param name="pLoadContext">
        /// [In] String description of the context under which this module has been loaded.
        /// ex: 'Win32' or 'CLR v2.0.50727: Default Domain'.
        /// </param>
        /// <param name="pRuntimeInstance">
        /// [In] Represents the native code executing in a target process.
        /// </param>
        /// <param name="BaseAddress">
        /// [In] The starting memory address of where the module is loaded. This value should
        /// always be valid.
        /// </param>
        /// <param name="Size">
        /// [In] The number of bytes in the module's memory region.
        /// </param>
        /// <param name="ClrHeaderStatus">
        /// [In] Contains information from the 'Flags' field of the IMAGE_COR20_HEADER of the
        /// loaded module. This indicates which type of binary was loaded.
        /// </param>
        /// <param name="IsDisabled">
        /// [In] Indicates if this module instance has been disabled. Disabled modules are
        /// largely ignored by the debugger. For native modules, the address range of the
        /// disabled module is treated as if it is unmapped. For CLR modules, any frames from
        /// these modules is hidden from the call stack.
        /// </param>
        /// <param name="pModule">
        /// [In,Optional] The symbol handler's representation of a module (DkmModule) which
        /// is associated with this module instance. This value is initially null, and is
        /// assigned if and when symbols are associated with this module instance.
        /// </param>
        /// <param name="pMinidumpInfo">
        /// [In,Optional] 'MinidumpInfo' is used to convey additional information about
        /// modules in a DkmProcess for a minidump.
        /// </param>
        /// <param name="DataItem">
        /// [In] Data object to add to the new DkmNativeModuleInstance instance.
        /// DkmDataItem::Null() in the case that the caller doesn't need to add a data item.
        /// </param>
        /// <param name="ppCreatedObject">
        /// [Out] Result of this method call.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ DkmString* pName,
            _In_ DkmString* pFullName,
            _In_ UINT64 TimeDateStamp,
            _In_opt_ DkmModuleVersion* pVersion,
            _In_opt_ Symbols::DkmSymbolFileId* pSymbolFileId,
            _In_ DkmModuleFlags_t Flags,
            _In_ DkmModuleMemoryLayout_t MemoryLayout,
            _In_ UINT32 LoadOrder,
            _In_ DkmString* pLoadContext,
            _In_ Native::DkmNativeRuntimeInstance* pRuntimeInstance,
            _In_ UINT64 BaseAddress,
            _In_ UINT32 Size,
            _In_ Clr::DkmClrHeaderStatus_t ClrHeaderStatus,
            _In_ bool IsDisabled,
            _In_opt_ Symbols::DkmModule* pModule,
            _In_opt_ const DkmModuleInstance::MinidumpInfo* pMinidumpInfo,
            _In_ const DkmDataItem& DataItem,
            _Deref_out_ Native::DkmNativeModuleInstance** ppCreatedObject
            );

        /// <summary>
        /// Obtain the function table entry for the passed address. The format of the engine
        /// is dependent on the debuggee architecture.
        /// </summary>
        /// <param name="Address">
        /// [In] The address to search the function table for. Normally, each entry contains
        /// a start and an end address. Implementations should return the entry whose address
        /// range contains the requested address.
        /// </param>
        /// <param name="ppEntry">
        /// [Out] The contents of the function table entry.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetFunctionTableEntry(
            _In_ UINT64 Address,
            _Deref_out_ DkmReadOnlyCollection<BYTE>** ppEntry
            );

        /// <summary>
        /// Finds the address of the specified named exported function (or data export).
        /// </summary>
        /// <param name="pName">
        /// [In] The export name to search for in the module's export table.
        /// </param>
        /// <param name="IgnoreDataExports">
        /// [In] If true, the implementation will ignore any export which is in
        /// non-executable memory.
        /// </param>
        /// <param name="ppAddress">
        /// [Out,Optional] If the export was found in the specified module, this will contain
        /// the target address. Note that this instruction address object may be in a
        /// different module than the searched module. This can happen if the export was
        /// forwarded and the destination module is already loaded. If the destination module
        /// is not loaded, the export will be ignored.
        /// </param>
        /// <returns>
        /// S_OK is returned if *ppAddress is non-NULL, S_FALSE is returned when *ppAddress
        /// is NULL, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE FindExportName(
            _In_ DkmString* pName,
            _In_ bool IgnoreDataExports,
            _Deref_out_opt_ Native::DkmNativeInstructionAddress** ppAddress
            );

        /// <summary>
        /// Finds the address of the specified named exported function (or data export).
        ///
        /// This method will append a new work item to the specified work list, and return
        /// once the work item has been appended. The actual processing of the work item is
        /// asynchronous. The caller will be notified that the request is complete through
        /// the completion routine.
        /// </summary>
        /// <param name="pWorkList">
        /// WorkList to append the new work item to.
        /// </param>
        /// <param name="pName">
        /// [In] The export name to search for in the module's export table.
        /// </param>
        /// <param name="IgnoreDataExports">
        /// [In] If true, the implementation will ignore any export which is in
        /// non-executable memory.
        /// </param>
        /// <param name="pCompletionRoutine">
        /// Routine to fire when the request is complete. If the request is successfully
        /// appended to the work list, this will always fire (including when the operation is
        /// canceled). This will never fire if appending the work item fails.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE FindExportName(
            _In_ DkmWorkList* pWorkList,
            _In_ DkmString* pName,
            _In_ bool IgnoreDataExports,
            _In_ IDkmCompletionRoutine<Native::DkmFindExportNameAsyncResult>* pCompletionRoutine
            );
    }; // end of DkmNativeModuleInstance

    // Represents the native code executing in a target process.
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("d7d75a72-5477-dcc3-e306-8e31a8e7fd7e") DkmNativeRuntimeInstance : public DkmRuntimeInstance
    {
        // Use DkmNativeRuntimeInstance::Create to create this object
        private: DkmNativeRuntimeInstance();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmNativeRuntimeInstance();
        // This object cannot be copied
        private: DkmNativeRuntimeInstance& operator=(const DkmNativeRuntimeInstance&);
        private: DkmNativeRuntimeInstance(const DkmNativeRuntimeInstance&);

        private: void* m__pExtendedData;
        private: void* m_pNativeModuleInstanceCollection0;

        // Attempt to cast a 'DkmRuntimeInstance' to a 'DkmNativeRuntimeInstance'. Return
        // NULL if the path object is not a 'DkmNativeRuntimeInstance'.
        // pNativeRuntimeInstance : [In,Optional] Object to attempt to cast
        // Return Value : [Optional] Result of the cast.
        public: static DECLSPEC_NOTHROW DkmNativeRuntimeInstance* TryCast(
            DkmRuntimeInstance* pRuntimeInstance
            )
        {
            if (pRuntimeInstance == NULL || pRuntimeInstance->TagValue() != Tag::NativeRuntimeInstance)
                return NULL;

            return static_cast<DkmNativeRuntimeInstance*>(pRuntimeInstance);
        }

        /// <summary>
        /// Creates a new runtime instance object from a debug monitor. This method must be
        /// called from the event thread when a debug monitor detects that a new runtime
        /// instance has loaded (for example, when the corresponding runtime dll loads in the
        /// target process).
        ///
        /// This method will send a RuntimeInstanceLoad event.
        /// </summary>
        /// <param name="pProcess">
        /// [In] DkmProcess represents a target process which is being debugged. The debugger
        /// debugs processes, so this is the basic unit of debugging. A DkmProcess can
        /// represent a system process or a virtual process such as minidumps.
        /// </param>
        /// <param name="Id">
        /// [In] Identifies a DkmRuntimeInstance object within a process.
        /// </param>
        /// <param name="DataItem">
        /// [In] Data object to add to the new DkmNativeRuntimeInstance instance.
        /// DkmDataItem::Null() in the case that the caller doesn't need to add a data item.
        /// </param>
        /// <param name="ppCreatedObject">
        /// [Out] Result of this method call.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ DkmProcess* pProcess,
            _In_ const DkmRuntimeInstanceId& Id,
            _In_ const DkmDataItem& DataItem,
            _Deref_out_ Native::DkmNativeRuntimeInstance** ppCreatedObject
            );

        /// <summary>
        /// Creates a new runtime instance object from a debug monitor. This method must be
        /// called from the event thread when a debug monitor detects that a new runtime
        /// instance has loaded (for example, when the corresponding runtime dll loads in the
        /// target process).
        ///
        /// This method will send a RuntimeInstanceLoad event.
        ///
        /// This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
        /// </summary>
        /// <param name="pProcess">
        /// [In] DkmProcess represents a target process which is being debugged. The debugger
        /// debugs processes, so this is the basic unit of debugging. A DkmProcess can
        /// represent a system process or a virtual process such as minidumps.
        /// </param>
        /// <param name="Id">
        /// [In] Identifies a DkmRuntimeInstance object within a process.
        /// </param>
        /// <param name="Capabilities">
        /// [In] Enumeration of runtime capabilities.
        /// </param>
        /// <param name="pParentRuntime">
        /// [In,Optional] For runtimes that are implemented on top of another runtime, this
        /// can optionally be used to indicant the logical parent. This can then be used to
        /// request services from the parent when the child runtime doesn't implement the
        /// service. This is currently used only for obtaining the top stack frame to
        /// evaluate a conditional breakpoint when the child runtime doesn't walk stacks
        /// itself.
        /// </param>
        /// <param name="DataItem">
        /// [In] Data object to add to the new DkmNativeRuntimeInstance instance.
        /// DkmDataItem::Null() in the case that the caller doesn't need to add a data item.
        /// </param>
        /// <param name="ppCreatedObject">
        /// [Out] Result of this method call.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ DkmProcess* pProcess,
            _In_ const DkmRuntimeInstanceId& Id,
            _In_ DkmRuntimeCapabilities_t Capabilities,
            _In_opt_ DkmRuntimeInstance* pParentRuntime,
            _In_ const DkmDataItem& DataItem,
            _Deref_out_ Native::DkmNativeRuntimeInstance** ppCreatedObject
            );

        /// <summary>
        /// Find a DkmNativeModuleInstance element within this DkmNativeRuntimeInstance. If
        /// no element with the given input key is present, FindNativeModuleInstance will
        /// fail.
        /// </summary>
        /// <param name="BaseAddress">
        /// [In] Search key used to find the element.
        /// </param>
        /// <param name="ppNativeModuleInstance">
        /// [Out] Result of the search.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// E_XAPI_OBJECT_NOT_FOUND indicates that the search key cannot be found.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE FindNativeModuleInstance(
            _In_ UINT64 BaseAddress,
            _Deref_out_ Native::DkmNativeModuleInstance** ppNativeModuleInstance
            );

        /// <summary>
        /// GetNativeModuleInstances enumerates the DkmNativeModuleInstance elements of this
        /// DkmNativeRuntimeInstance object.
        /// </summary>
        /// <param name="pNativeModuleInstances">
        /// [Out] Array containing the enumerated elements.
        ///
        /// The memory for the DkmArray members is allocated by the method implementation
        /// using DkmAllocBytes/DkmAllocArray. It is freed by the caller using the
        /// CAutoDkmArray template or with DkmFreeMemory and manual element release.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetNativeModuleInstances(
            _Out_ DkmArray<Native::DkmNativeModuleInstance*>* pNativeModuleInstances
            );

        #ifndef EXCLUDE_IDE_ONLY_APIS
        /// <summary>
        /// Validate and merge code/symbols for the previous added pending edit compiland.
        /// Note: All the code/symbols merging are pending in memory and no debuggee is
        /// modified until Commit() is called.
        ///
        /// Location constraint: API must be called from an IDE component (component level
        /// &gt; 100,000).
        ///
        /// This API was introduced in Visual Studio 14 RTM (DkmApiVersion.VS14RTM).
        /// </summary>
        /// <param name="ModifiedStackIPAddresses">
        /// [In] The IPs of the stack frames that have been modified. Required to use the
        /// line hints for IP remapping.
        ///
        /// The memory for the DkmArray members is allocated by the caller, and can be from
        /// any source (stack memory, static buffer, heap, etc). The implementation should
        /// not modify the members.
        /// </param>
        /// <param name="LineHints">
        /// [In] The 1-based source line number hints for the edited stack IPs.
        ///
        /// The memory for the DkmArray members is allocated by the caller, and can be from
        /// any source (stack memory, static buffer, heap, etc). The implementation should
        /// not modify the members.
        /// </param>
        /// <param name="ppWarnings">
        /// [Out,Optional] Warning messages, if any.
        /// </param>
        /// <param name="ppErrors">
        /// [Out,Optional] Error messages, if any.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ApplyCodeChange(
            _In_ const DkmArray<Native::DkmNativeInstructionAddress*>& ModifiedStackIPAddresses,
            _In_ const DkmArray<UINT32>& LineHints,
            _Deref_out_opt_ DkmReadOnlyCollection<DkmString*>** ppWarnings,
            _Deref_out_opt_ DkmReadOnlyCollection<DkmString*>** ppErrors
            );
        #endif // #ifndef EXCLUDE_IDE_ONLY_APIS

        #ifndef EXCLUDE_IDE_ONLY_APIS
        /// <summary>
        /// Commit all the pending in-memory edit to debuggee.
        ///
        /// Location constraint: API must be called from an IDE component (component level
        /// &gt; 100,000).
        ///
        /// This API was introduced in Visual Studio 14 RTM (DkmApiVersion.VS14RTM).
        /// </summary>
        /// <param name="ppWarnings">
        /// [Out,Optional] Warning messages, if any.
        /// </param>
        /// <param name="ppErrors">
        /// [Out,Optional] Error messages, if any.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE CommitCodeChange(
            _Deref_out_opt_ DkmReadOnlyCollection<DkmString*>** ppWarnings,
            _Deref_out_opt_ DkmReadOnlyCollection<DkmString*>** ppErrors
            );
        #endif // #ifndef EXCLUDE_IDE_ONLY_APIS
    }; // end of DkmNativeRuntimeInstance

    // Provides information about a Win32 exception which was raised in the target process.
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("8ca1a5b5-5cbb-f33f-6476-ae67ac9417fa") DkmWin32ExceptionInformation : public Exceptions::DkmExceptionInformation
    {
        // Use DkmWin32ExceptionInformation::Create to create this object
        private: DkmWin32ExceptionInformation();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmWin32ExceptionInformation();
        // This object cannot be copied
        private: DkmWin32ExceptionInformation& operator=(const DkmWin32ExceptionInformation&);
        private: DkmWin32ExceptionInformation(const DkmWin32ExceptionInformation&);

        private: const UINT32 m_ExceptionFlags;
        private: const UINT64 m_ParentExceptionRecordAddress;
        private: const UINT64 m_Address;
        private: DkmReadOnlyCollection<UINT64>* const m_pExceptionParameters;
        private: void* m__pExtendedData;

        // The exception flags. This can be either zero to indicate a continuable exception,
        // or EXCEPTION_NONCONTINUABLE to indicate a noncontinuable exception.
        public: DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE ExceptionFlags(
            );

        // Address within the target process where the parent EXCEPTION_RECORD pointer can be
        // found. This is commonly zero.
        public: DECLSPEC_NOTHROW UINT64 STDMETHODCALLTYPE ParentExceptionRecordAddress(
            );

        // The address where the exception occurred.
        public: DECLSPEC_NOTHROW UINT64 STDMETHODCALLTYPE Address(
            );

        // Parameters passed when the exception was raised. These parameters may be passed
        // from the Kernel as part of handling a hardware fault (ex: access violation), or
        // they may be passed from kernel32!RaiseException for software exceptions.
        public: _Ret_ DECLSPEC_NOTHROW DkmReadOnlyCollection<UINT64>* STDMETHODCALLTYPE ExceptionParameters(
            );

        // Attempt to cast a 'DkmExceptionInformation' to a 'DkmWin32ExceptionInformation'. Return
        // NULL if the path object is not a 'DkmWin32ExceptionInformation'.
        // pWin32Exception : [In,Optional] Object to attempt to cast
        // Return Value : [Optional] Result of the cast.
        public: static DECLSPEC_NOTHROW DkmWin32ExceptionInformation* TryCast(
            DkmExceptionInformation* pException
            )
        {
            if (pException == NULL || pException->TagValue() != Tag::Win32Exception)
                return NULL;

            return static_cast<DkmWin32ExceptionInformation*>(pException);
        }

        /// <summary>
        /// Create a new DkmWin32ExceptionInformation object instance.
        /// </summary>
        /// <param name="pRuntimeInstance">
        /// [In] The DkmRuntimeInstance class represents an execution environment which is
        /// loaded into a DkmProcess and which contains code to be debugged.
        /// </param>
        /// <param name="pThread">
        /// [In] DkmThread represents a thread running in the target process.
        /// </param>
        /// <param name="pInstructionAddress">
        /// [In,Optional] Address where the exception occurred. This will always be present
        /// for C++ and Win32 exceptions. It may be missing from CLR exceptions or MDAs as
        /// these may originate from inside the runtime.
        /// </param>
        /// <param name="Code">
        /// [In] 32-bit integer code for the exception. For Win32 exceptions, this is the
        /// code passed to RaiseException (ex:EXCEPTION_ACCESS_VIOLATION). This value is zero
        /// for exception categories that identify exceptions by string (ex: CLR).
        /// </param>
        /// <param name="ProcessingStage">
        /// [In] The debugger receives notifications from the target process at various
        /// stages within exception processing (ex: exception thrown, exception unhandled).
        /// This enumeration indicates the stage(s) for a notification.
        /// </param>
        /// <param name="ExceptionFlags">
        /// [In] The exception flags. This can be either zero to indicate a continuable
        /// exception, or EXCEPTION_NONCONTINUABLE to indicate a noncontinuable exception.
        /// </param>
        /// <param name="ParentExceptionRecordAddress">
        /// [In] Address within the target process where the parent EXCEPTION_RECORD pointer
        /// can be found. This is commonly zero.
        /// </param>
        /// <param name="Address">
        /// [In] The address where the exception occurred.
        /// </param>
        /// <param name="pExceptionParameters">
        /// [In] Parameters passed when the exception was raised. These parameters may be
        /// passed from the Kernel as part of handling a hardware fault (ex: access
        /// violation), or they may be passed from kernel32!RaiseException for software
        /// exceptions.
        /// </param>
        /// <param name="ppCreatedObject">
        /// [Out] Result of this method call.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ DkmRuntimeInstance* pRuntimeInstance,
            _In_ DkmThread* pThread,
            _In_opt_ DkmInstructionAddress* pInstructionAddress,
            _In_ UINT32 Code,
            _In_ Exceptions::DkmExceptionProcessingStage_t ProcessingStage,
            _In_ UINT32 ExceptionFlags,
            _In_ UINT64 ParentExceptionRecordAddress,
            _In_ UINT64 Address,
            _In_ DkmReadOnlyCollection<UINT64>* pExceptionParameters,
            _Deref_out_ Native::DkmWin32ExceptionInformation** ppCreatedObject
            );
    }; // end of DkmWin32ExceptionInformation

}; // end namespace Native

// Contains types specific to debugging script code.
namespace Script {
    // Result of an asynchronous DkmScriptRuntimeInstance.OnScriptCriticalError call.
    struct DkmOnScriptCriticalErrorAsyncResult
    {
        // HRESULT code returned from the caller. This will be
        // DkmExceptionCode.COR_E_OPERATIONCANCELED (0x8013153B) if the operation was
        // canceled before processing was complete.
        HRESULT ErrorCode;
    };

    // Provides the content and position of a block of code in a mixed-content document (ex:
    // .aspx file). This can be used to map the block from source to generated document.
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("95e15cff-d9eb-8030-0b43-da52cd1b977b") DkmScriptBlockMappingInfo : public IUnknown
    {
        private: ___ReferenceCount_t m_ReferenceCount;
        private: DkmDispatcherObjectFlags_t m_ObjectFlags;
        private: const GUID* m_pTypeId;
        private: size_t m_ObjectGCHandle;
        // Use DkmScriptBlockMappingInfo::Create to create this object
        private: DkmScriptBlockMappingInfo();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmScriptBlockMappingInfo();
        // This object cannot be copied
        private: DkmScriptBlockMappingInfo& operator=(const DkmScriptBlockMappingInfo&);
        private: DkmScriptBlockMappingInfo(const DkmScriptBlockMappingInfo&);

        private: DkmString* const m_pCodeText;
        private: const Symbols::DkmTextSpan m_TextSpan;
        private: void* m__pExtendedData;

        // Text of the code in the script block.
        public: _Ret_ DECLSPEC_NOTHROW DkmString* STDMETHODCALLTYPE CodeText(
            );

        // The text span of this script block.
        public: DECLSPEC_NOTHROW const Symbols::DkmTextSpan& STDMETHODCALLTYPE TextSpan(
            );

        /// <summary>
        /// Create a new DkmScriptBlockMappingInfo object instance.
        /// </summary>
        /// <param name="pCodeText">
        /// [In] Text of the code in the script block.
        /// </param>
        /// <param name="TextSpan">
        /// [In] The text span of this script block.
        /// </param>
        /// <param name="ppCreatedObject">
        /// [Out] Result of this method call.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ DkmString* pCodeText,
            _In_ const Symbols::DkmTextSpan& TextSpan,
            _Deref_out_ Script::DkmScriptBlockMappingInfo** ppCreatedObject
            );
    }; // end of DkmScriptBlockMappingInfo

    // Indicates the content type of the underlying script document.
    //
    // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
    DEFINE_SCOPED_ENUM(DkmScriptDocumentContentType)
    {
        // Document kind could not be determined.
        Unknown = 0,
        // Document is JavaScript.
        Script = 1,
        // Document is HTML.
        Html = 2
    };

    // Flag properties of a script document.
    DEFINE_SCOPED_ENUM(DkmScriptDocumentFlags)
    {
        // No flags are set.
        None = 0x0,
        // Document represents a container which aggregated together many sub-documents. For
        // JavaScript, this is use for 'eval code' and 'Function code' documents.
        AggregateDocument = 0x1
    };
    DEFINE_SCOPED_ENUM_FLAG_OPERATORS(DkmScriptDocumentFlags_t);

    // The Just-My-Code state of the document exposed via the DkmScriptDocument.JmcState
    // variable. The JMC state of the document is ignored if JMC is not enabled and all
    // documents are treated as user code.
    //
    // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
    DEFINE_SCOPED_ENUM(DkmScriptDocumentJmcState)
    {
        // The project system and/or runtime engine does not know whether the script document
        // is user code.  Unsure means the engine will continuing querying the rest of the
        // project systems until one of them returns something other than Unsure. If all
        // project systems return Unsure, the script will be treated by the engine as though
        // it is user code (see MyCode state).
        Unsure = 0,
        // The script document is user code and should not be hidden from the user in any
        // way.  All script documents behave as MyCode when JMC is not enabled.
        MyCode = 1,
        // The script document is library code.  Unhandled exceptions and first chance
        // exceptions where the call stack contains user code are exposed to the user. Step
        // operations bypass the non-user code unless the step originates in non-user code.
        // Stack frames in library code are collapsed to [External Code].
        LibraryCode = 2,
        // The script document is unrelated to any user code.  Unhandled exceptions and first
        // chance exceptions are not visible to the user.  Embedded script breakpoints are
        // also not visible to the user.
        UnrelatedCode = 3
    };

    // Represents a node in the 'Script Documents' virtual tree within solution explorer.
    // Nodes may either be a virtual container, or they can be a document. In the latter
    // case, they will be a DkmScriptDocument.
    //
    // Derived classes: DkmScriptDocument
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("df65fb73-d375-49e7-06f9-0e5613dba3f3") DkmScriptDocumentTreeNode : public DkmDataContainer
    {
        // Use DkmScriptDocumentTreeNode::Create to create this object
        private: DkmScriptDocumentTreeNode();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmScriptDocumentTreeNode();
        // This object cannot be copied
        private: DkmScriptDocumentTreeNode& operator=(const DkmScriptDocumentTreeNode&);
        private: DkmScriptDocumentTreeNode(const DkmScriptDocumentTreeNode&);

        private: DkmRuntimeInstance* const m_pRuntimeInstance;
        private: OPTIONAL Script::DkmScriptDocumentTreeNode* const m_pParent;
        private: const GUID m_UniqueId;
        private: DkmString* const m_pTitle;
        private: void* m__pExtendedData;

        // The runtime which produced this container.
        public: _Ret_ DECLSPEC_NOTHROW DkmRuntimeInstance* STDMETHODCALLTYPE RuntimeInstance(
            );

        // [Optional] Parent in the script document tree. This will be null for the root
        // application container.
        public: _Ret_opt_ DECLSPEC_NOTHROW Script::DkmScriptDocumentTreeNode* STDMETHODCALLTYPE Parent(
            );

        // Guid which uniquely identifies this script document folder object.
        public: DECLSPEC_NOTHROW const GUID& STDMETHODCALLTYPE UniqueId(
            );

        // Title of the node.
        public: _Ret_ DECLSPEC_NOTHROW DkmString* STDMETHODCALLTYPE Title(
            );

        // DkmProcess represents a target process which is being debugged. The debugger
        // debugs processes, so this is the basic unit of debugging. A DkmProcess can
        // represent a system process or a virtual process such as minidumps.
        public: _Ret_ DECLSPEC_NOTHROW DkmProcess* STDMETHODCALLTYPE Process(
            );

        /// <summary>
        /// Create a new DkmScriptDocumentTreeNode object instance.
        ///
        /// This method will send a ScriptDocumentTreeNodeCreate event.
        /// </summary>
        /// <param name="pRuntimeInstance">
        /// [In] The runtime which produced this container.
        /// </param>
        /// <param name="pParent">
        /// [In,Optional] Parent in the script document tree. This will be null for the root
        /// application container.
        /// </param>
        /// <param name="pTitle">
        /// [In] Title of the node.
        /// </param>
        /// <param name="DataItem">
        /// [In] Data object to add to the new DkmScriptDocumentTreeNode instance.
        /// DkmDataItem::Null() in the case that the caller doesn't need to add a data item.
        /// </param>
        /// <param name="ppCreatedObject">
        /// [Out] Result of this method call.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ DkmRuntimeInstance* pRuntimeInstance,
            _In_opt_ Script::DkmScriptDocumentTreeNode* pParent,
            _In_ DkmString* pTitle,
            _In_ const DkmDataItem& DataItem,
            _Deref_out_ Script::DkmScriptDocumentTreeNode** ppCreatedObject
            );

        /// <summary>
        /// Invoked by a script document provide to fire a ScriptDocumentTreeNodeUnload
        /// event.
        ///
        /// This method may only be called by the component which created the object.
        /// </summary>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Unload(
            );
    }; // end of DkmScriptDocumentTreeNode

    // Indicates the kind of embedded document (or none if not an embedded document). The
    // type can be eval code, function code, or script block.
    //
    // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
    DEFINE_SCOPED_ENUM(DkmScriptEmbeddedDocumentKind)
    {
        // This is not an embedded script document.
        None = 0,
        // Document is eval code.
        EvalCode = 1,
        // Document is function code.
        FunctionCode = 2,
        // Document is a script block.
        ScriptBlock = 3
    };

    // The source project system item for a script document.
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("554a3b31-dbb1-1b82-b0a4-8854519691c7") DkmScriptSourceProjectItem : public IUnknown
    {
        private: ___ReferenceCount_t m_ReferenceCount;
        private: DkmDispatcherObjectFlags_t m_ObjectFlags;
        private: const GUID* m_pTypeId;
        private: size_t m_ObjectGCHandle;
        // Use DkmScriptSourceProjectItem::Create to create this object
        private: DkmScriptSourceProjectItem();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmScriptSourceProjectItem();
        // This object cannot be copied
        private: DkmScriptSourceProjectItem& operator=(const DkmScriptSourceProjectItem&);
        private: DkmScriptSourceProjectItem(const DkmScriptSourceProjectItem&);

        private: DkmString* const m_pPath;
        private: const bool m_IsGenerated;
        private: void* m__pExtendedData;

        // Moniker of the project item returned from MapDeployedURLToProjectItem. Project
        // systems can plug into this through IsDocumentInProject.
        public: _Ret_ DECLSPEC_NOTHROW DkmString* STDMETHODCALLTYPE Path(
            );

        // True if the script document is expected to be a generated client-side document, so
        // the project item cannot be directly mapped.
        public: DECLSPEC_NOTHROW bool STDMETHODCALLTYPE IsGenerated(
            );

        /// <summary>
        /// Create a new DkmScriptSourceProjectItem object instance.
        /// </summary>
        /// <param name="pPath">
        /// [In] Moniker of the project item returned from MapDeployedURLToProjectItem.
        /// Project systems can plug into this through IsDocumentInProject.
        /// </param>
        /// <param name="IsGenerated">
        /// [In] True if the script document is expected to be a generated client-side
        /// document, so the project item cannot be directly mapped.
        /// </param>
        /// <param name="ppCreatedObject">
        /// [Out] Result of this method call.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ DkmString* pPath,
            _In_ bool IsGenerated,
            _Deref_out_ Script::DkmScriptSourceProjectItem** ppCreatedObject
            );
    }; // end of DkmScriptSourceProjectItem

    // Value returned from IDkmScriptSymbolCallback.GetNextSteppingAction which indicates the
    // next action that the script DM should take.
    DEFINE_SCOPED_ENUM(DkmScriptSymbolNextSteppingAction)
    {
        // Step has landed at non-hidden code which maps to the same statement/line
        // (depending on the IsSteppingByLine value) as where the step was originated.
        CompleteStep = 0,
        // Step completed at a hidden statement, or at a statement which is still part of the
        // same statement/line (depending on the IsSteppingByLine value) as the
        // StartingInstruction. The debug monitor should step again. If it is a performing a
        // step into, the debug monitor should resume with a step into. Otherwise a step over
        // should be performed.
        SkipStatement = 1,
        // Step completed at a hidden statement, or at a statement which is still part of the
        // same statement/line (depending on the IsSteppingByLine value) as the
        // StartingInstruction. The debug monitor should step again with a step over (even if
        // the original operation was a step into).
        SkipMethodCall = 2,
        // Step completed in a hidden method, or the remainder of the method is hidden code.
        // The debug monitor should step out of the method.
        SkipCurrentMethod = 3
    };

    // Result of an asynchronous DkmScriptDocument.SetRaiseSymbolEvents call.
    struct DkmSetRaiseSymbolEventsAsyncResult
    {
        // HRESULT code returned from the caller. This will be
        // DkmExceptionCode.COR_E_OPERATIONCANCELED (0x8013153B) if the operation was
        // canceled before processing was complete.
        HRESULT ErrorCode;
    };

    // Represents a document which is executing in a script runtime environment. For example,
    // the Microsoft JavaScript engine.
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("5df7092d-153e-3a9e-6a9c-01d70ae57148") DkmScriptDocument : public Script::DkmScriptDocumentTreeNode
    {
        // Use DkmScriptDocument::Create to create this object
        private: DkmScriptDocument();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmScriptDocument();
        // This object cannot be copied
        private: DkmScriptDocument& operator=(const DkmScriptDocument&);
        private: DkmScriptDocument(const DkmScriptDocument&);

        // Contains additional fields of DkmScriptDocument which were added after the class
        // was initally introduced.
        private: struct ___ExtendedData
        {
            ___ExtendedData();

            // Indicates the content type of the underlying script document.
            const Script::DkmScriptDocumentContentType_t ContentType;

            // Indicates the kind of embedded document (or none if not an embedded document).
            // The type can be eval code, function code, or script block.
            const Script::DkmScriptEmbeddedDocumentKind_t EmbeddedDocumentKind;

            // The Just-My-Code state of the document. To update the value of this variable,
            // call DkmScriptDocument.SetJmcState.
            Script::DkmScriptDocumentJmcState_t JmcState;
        };

        private: Symbols::DkmModule* const m_pModule;
        private: OPTIONAL DkmString* const m_pUrl;
        private: OPTIONAL DkmString* const m_pFilePath;
        private: const Script::DkmScriptDocumentFlags_t m_Flags;
        private: OPTIONAL Script::DkmScriptSourceProjectItem* m_pSourceProjectItem;
        private: ___ExtendedData* const m__pExtendedData;

        // Guid which uniquely identifies this script document folder object.
        public: DECLSPEC_NOTHROW const GUID& STDMETHODCALLTYPE UniqueId(
            );

        // The symbol container which owns this document.
        public: _Ret_ DECLSPEC_NOTHROW Symbols::DkmModule* STDMETHODCALLTYPE Module(
            );

        // [Optional] URL of the script document. This may be null if the document has no
        // URL.
        public: _Ret_opt_ DECLSPEC_NOTHROW DkmString* STDMETHODCALLTYPE Url(
            );

        // [Optional] File path (ex: c:\myfolder\file.js) of the script document. This will
        // be null if the document has no URL, or has a non-'file://' URL.
        public: _Ret_opt_ DECLSPEC_NOTHROW DkmString* STDMETHODCALLTYPE FilePath(
            );

        // Flag properties of a script document.
        public: DECLSPEC_NOTHROW Script::DkmScriptDocumentFlags_t STDMETHODCALLTYPE Flags(
            );

        // Indicates the content type of the underlying script document.
        //
        // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
        public: DECLSPEC_NOTHROW Script::DkmScriptDocumentContentType_t STDMETHODCALLTYPE ContentType(
            );

        // Indicates the kind of embedded document (or none if not an embedded document). The
        // type can be eval code, function code, or script block.
        //
        // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
        public: DECLSPEC_NOTHROW Script::DkmScriptEmbeddedDocumentKind_t STDMETHODCALLTYPE EmbeddedDocumentKind(
            );

        // [Optional] The project item which matches this document.
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetSourceProjectItem(
            _Deref_out_opt_ Script::DkmScriptSourceProjectItem** ppValue);

        // The Just-My-Code state of the document. To update the value of this variable, call
        // DkmScriptDocument.SetJmcState.
        //
        // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
        public: DECLSPEC_NOTHROW Script::DkmScriptDocumentJmcState_t STDMETHODCALLTYPE JmcState(
            );

        /// <summary>
        /// Create a new DkmScriptDocument object instance.
        ///
        /// This method will send a ScriptDocumentTreeNodeCreate event.
        /// </summary>
        /// <param name="pRuntimeInstance">
        /// [In] The runtime which produced this container.
        /// </param>
        /// <param name="pParent">
        /// [In,Optional] Parent in the script document tree. This will be null for the root
        /// application container.
        /// </param>
        /// <param name="pTitle">
        /// [In] Title of the node.
        /// </param>
        /// <param name="pModule">
        /// [In] The symbol container which owns this document.
        /// </param>
        /// <param name="pUrl">
        /// [In,Optional] URL of the script document. This may be null if the document has no
        /// URL.
        /// </param>
        /// <param name="pFilePath">
        /// [In,Optional] File path (ex: c:\myfolder\file.js) of the script document. This
        /// will be null if the document has no URL, or has a non-'file://' URL.
        /// </param>
        /// <param name="Flags">
        /// [In] Flag properties of a script document.
        /// </param>
        /// <param name="pSourceProjectItem">
        /// [In,Optional] The project item which matches this document.
        /// </param>
        /// <param name="DataItem">
        /// [In] Data object to add to the new DkmScriptDocument instance.
        /// DkmDataItem::Null() in the case that the caller doesn't need to add a data item.
        /// </param>
        /// <param name="ppCreatedObject">
        /// [Out] Result of this method call.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ DkmRuntimeInstance* pRuntimeInstance,
            _In_opt_ Script::DkmScriptDocumentTreeNode* pParent,
            _In_ DkmString* pTitle,
            _In_ Symbols::DkmModule* pModule,
            _In_opt_ DkmString* pUrl,
            _In_opt_ DkmString* pFilePath,
            _In_ Script::DkmScriptDocumentFlags_t Flags,
            _In_opt_ Script::DkmScriptSourceProjectItem* pSourceProjectItem,
            _In_ const DkmDataItem& DataItem,
            _Deref_out_ Script::DkmScriptDocument** ppCreatedObject
            );

        /// <summary>
        /// Create a new DkmScriptDocument object instance.
        ///
        /// This method will send a ScriptDocumentTreeNodeCreate event.
        ///
        /// This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
        /// </summary>
        /// <param name="pRuntimeInstance">
        /// [In] The runtime which produced this container.
        /// </param>
        /// <param name="pParent">
        /// [In,Optional] Parent in the script document tree. This will be null for the root
        /// application container.
        /// </param>
        /// <param name="pTitle">
        /// [In] Title of the node.
        /// </param>
        /// <param name="pModule">
        /// [In] The symbol container which owns this document.
        /// </param>
        /// <param name="pUrl">
        /// [In,Optional] URL of the script document. This may be null if the document has no
        /// URL.
        /// </param>
        /// <param name="pFilePath">
        /// [In,Optional] File path (ex: c:\myfolder\file.js) of the script document. This
        /// will be null if the document has no URL, or has a non-'file://' URL.
        /// </param>
        /// <param name="Flags">
        /// [In] Flag properties of a script document.
        /// </param>
        /// <param name="ContentType">
        /// [In] Indicates the content type of the underlying script document.
        /// </param>
        /// <param name="EmbeddedDocumentKind">
        /// [In] Indicates the kind of embedded document (or none if not an embedded
        /// document). The type can be eval code, function code, or script block.
        /// </param>
        /// <param name="pSourceProjectItem">
        /// [In,Optional] The project item which matches this document.
        /// </param>
        /// <param name="JmcState">
        /// [In] The Just-My-Code state of the document. To update the value of this
        /// variable, call DkmScriptDocument.SetJmcState.
        /// </param>
        /// <param name="DataItem">
        /// [In] Data object to add to the new DkmScriptDocument instance.
        /// DkmDataItem::Null() in the case that the caller doesn't need to add a data item.
        /// </param>
        /// <param name="ppCreatedObject">
        /// [Out] Result of this method call.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ DkmRuntimeInstance* pRuntimeInstance,
            _In_opt_ Script::DkmScriptDocumentTreeNode* pParent,
            _In_ DkmString* pTitle,
            _In_ Symbols::DkmModule* pModule,
            _In_opt_ DkmString* pUrl,
            _In_opt_ DkmString* pFilePath,
            _In_ Script::DkmScriptDocumentFlags_t Flags,
            _In_ Script::DkmScriptDocumentContentType_t ContentType,
            _In_ Script::DkmScriptEmbeddedDocumentKind_t EmbeddedDocumentKind,
            _In_opt_ Script::DkmScriptSourceProjectItem* pSourceProjectItem,
            _In_ Script::DkmScriptDocumentJmcState_t JmcState,
            _In_ const DkmDataItem& DataItem,
            _Deref_out_ Script::DkmScriptDocument** ppCreatedObject
            );

        /// <summary>
        /// Provides the current content of the specified document object.
        /// </summary>
        /// <param name="EnableContentEvents">
        /// [In] If true, the script document provider should raise events when the content
        /// of this document changes. Passing true is equivalent to calling
        /// SetRaiseContentEvents(true). If false, the RaiseContentEvent state remains the
        /// same.
        /// </param>
        /// <param name="ppContent">
        /// [Out] The current content of this document.
        /// </param>
        /// <param name="pSectionDividers">
        /// [Out] For aggregate documents (DkmScriptDocumentFlags.AggregateDocument is set),
        /// this is the 1-based line numbers for where the section dividers should be drawn.
        /// For standard documents, an empty array is returned.
        ///
        /// The memory for the DkmArray members is allocated by the method implementation
        /// using DkmAllocBytes/DkmAllocArray. It is freed by the caller using the
        /// CAutoDkmArray template or with DkmFreeMemory and manual element release.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetContent(
            _In_ bool EnableContentEvents,
            _Deref_out_ DkmString** ppContent,
            _Out_ DkmArray<UINT32>* pSectionDividers
            );

        /// <summary>
        /// Enables or disables raising events when the content of the document is changed.
        /// By default, documents do not generate content events. So this method should be
        /// called by any component that wishes to receive content events. The script
        /// document manager maintains a count of the number of calls to enable content
        /// events, and will raise events whenever this count is greater than 0. Callers
        /// should take care to ensure that SetRaiseContentEvents(false) is called ONLY after
        /// a successful call to SetRaiseContentEvents(true). Content events are
        /// automatically disabled when the document is unloaded.
        /// </summary>
        /// <param name="Enable">
        /// [In] If true, content events should be enabled for this document. If false, the
        /// count of content event listeners is decremented. When the count reaches zero, no
        /// further events will be sent.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE SetRaiseContentEvents(
            _In_ bool Enable
            );

        #ifndef EXCLUDE_IDE_ONLY_APIS
        /// <summary>
        /// This method is called when a script document is created or when the project item
        /// path is set to try and bind breakpoints against the given script document.
        ///
        /// Location constraint: API must be called from an IDE component (component level
        /// &gt; 100,000).
        /// </summary>
        /// <param name="pSourceFileId">
        /// [In] Identifies a source file and provides the information which a symbol handler
        /// could use to search a symbol file (PDB) for information on this source file.
        /// </param>
        /// <param name="ppResolvedDocument">
        /// [Out,Optional] If the given script document matches the given source file id,
        /// this returns a DkmResolvedDocument for the match. Otherwise, null is returned.
        /// </param>
        /// <returns>
        /// S_OK is returned if *ppResolvedDocument is non-NULL, S_FALSE is returned when
        /// *ppResolvedDocument is NULL, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE TryResolve(
            _In_ Symbols::DkmSourceFileId* pSourceFileId,
            _Deref_out_opt_ Symbols::DkmResolvedDocument** ppResolvedDocument
            );
        #endif // #ifndef EXCLUDE_IDE_ONLY_APIS

        /// <summary>
        /// Enables or disables raising ScriptSymbolsUpdated when symbols in the document are
        /// changed. By default, documents do not generate symbol events. So this method
        /// should be called by any component that wishes to receive symbol events. The
        /// script document manager maintains a count of the number of calls to enable symbol
        /// events, and will raise events whenever this count is greater than 0. Callers
        /// should take care to ensure that SetRaiseSymbolEvents(false) is called ONLY after
        /// a successful call to SetRaiseSymbolEvents(true). Symbol events are automatically
        /// disabled when the document is unloaded.
        /// </summary>
        /// <param name="Enable">
        /// [In] If true, symbol events should be enabled for this document. If false, the
        /// count of symbol event listeners is decremented. When the count reaches zero, no
        /// further events will be sent.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE SetRaiseSymbolEvents(
            _In_ bool Enable
            );

        /// <summary>
        /// Enables or disables raising ScriptSymbolsUpdated when symbols in the document are
        /// changed. By default, documents do not generate symbol events. So this method
        /// should be called by any component that wishes to receive symbol events. The
        /// script document manager maintains a count of the number of calls to enable symbol
        /// events, and will raise events whenever this count is greater than 0. Callers
        /// should take care to ensure that SetRaiseSymbolEvents(false) is called ONLY after
        /// a successful call to SetRaiseSymbolEvents(true). Symbol events are automatically
        /// disabled when the document is unloaded.
        ///
        /// This method will append a new work item to the specified work list, and return
        /// once the work item has been appended. The actual processing of the work item is
        /// asynchronous. The caller will be notified that the request is complete through
        /// the completion routine.
        /// </summary>
        /// <param name="pWorkList">
        /// WorkList to append the new work item to.
        /// </param>
        /// <param name="Enable">
        /// [In] If true, symbol events should be enabled for this document. If false, the
        /// count of symbol event listeners is decremented. When the count reaches zero, no
        /// further events will be sent.
        /// </param>
        /// <param name="pCompletionRoutine">
        /// Routine to fire when the request is complete. If the request is successfully
        /// appended to the work list, this will always fire (including when the operation is
        /// canceled). This will never fire if appending the work item fails.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE SetRaiseSymbolEvents(
            _In_ DkmWorkList* pWorkList,
            _In_ bool Enable,
            _In_ IDkmCompletionRoutine<Script::DkmSetRaiseSymbolEventsAsyncResult>* pCompletionRoutine
            );

        #ifndef EXCLUDE_IDE_ONLY_APIS
        /// <summary>
        /// Queries the language service (IVsLanguageDebugInfoScript) to obtain script block
        /// information from the associated project item of the specified script document.
        ///
        /// Location constraint: API must be called from an IDE component (component level
        /// &gt; 100,000).
        /// </summary>
        /// <param name="ppScriptBlocks">
        /// [Out] Set of script blocks returned from the language service.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetProjectItemScriptBlocks(
            _Deref_out_ DkmReadOnlyCollection<Script::DkmScriptBlockMappingInfo*>** ppScriptBlocks
            );
        #endif // #ifndef EXCLUDE_IDE_ONLY_APIS

        /// <summary>
        /// Raises a ScriptDocumentContentInsert event. The script document provider will
        /// only raise this event if events have been enabled for this document.
        ///
        /// This method may only be called by the component which created the object.
        /// </summary>
        /// <param name="Span">
        /// [In] The text span of the inserted text. For aggregate documents
        /// (DkmScriptDocumentFlags.AggregateDocument is set), this must start on a new line,
        /// and at at the end of a line immediately before a new section would begin.
        /// </param>
        /// <param name="pNewText">
        /// [In] The new text content which is inserted into the document.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE OnContentInsert(
            _In_ const Symbols::DkmTextSpan& Span,
            _In_ DkmString* pNewText
            );

        /// <summary>
        /// Raises a ScriptDocumentContentRemove event. The script document provider will
        /// only raise this event if events have been enabled for this document.
        ///
        /// This method may only be called by the component which created the object.
        /// </summary>
        /// <param name="Span">
        /// [In] The text span of the removed text. For aggregate documents
        /// (DkmScriptDocumentFlags.AggregateDocument is set), this must start at the begging
        /// of a line, and correspond to a previously added section.
        /// </param>
        /// <param name="CharsToRemove">
        /// [In] Number of characters within the section to remove.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE OnContentRemove(
            _In_ const Symbols::DkmTextSpan& Span,
            _In_ UINT32 CharsToRemove
            );

        /// <summary>
        /// Sets the JMC state for the  script document.  If the value is "Unsure", the
        /// script debug monitor can make its own determination of the JMC state or ask a
        /// project system for the JMC state.
        ///
        /// This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
        /// </summary>
        /// <param name="NewValue">
        /// [In] The Just-My-Code state of the document exposed via the
        /// DkmScriptDocument.JmcState variable. The JMC state of the document is ignored if
        /// JMC is not enabled and all documents are treated as user code.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE SetJmcState(
            _In_ Script::DkmScriptDocumentJmcState_t NewValue
            );
    }; // end of DkmScriptDocument

    // DkmScriptInstructionAddress is used to represent an executable statement in a
    // script-based runtime environment such the Microsoft JavaScript engine.
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("6b4814ba-827e-19cf-d178-ecab171f2d30") DkmScriptInstructionAddress : public DkmInstructionAddress
    {
        // Use DkmScriptInstructionAddress::Create to create this object
        private: DkmScriptInstructionAddress();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmScriptInstructionAddress();
        // This object cannot be copied
        private: DkmScriptInstructionAddress& operator=(const DkmScriptInstructionAddress&);
        private: DkmScriptInstructionAddress(const DkmScriptInstructionAddress&);

        private: Script::DkmScriptDocument* const m_pDocument;
        private: const UINT32 m_Revision;
        private: const UINT32 m_StartIndex;
        private: const UINT32 m_StatementLength;
        private: OPTIONAL DkmReadOnlyCollection<BYTE>* const m_pAdditionalData;
        private: void* m__pExtendedData;

        // Represents a script-based execution environment executing in a target process.
        public: _Ret_ DECLSPEC_NOTHROW Script::DkmScriptRuntimeInstance* STDMETHODCALLTYPE RuntimeInstance(
            );

        // Document containing this instruction.
        public: _Ret_ DECLSPEC_NOTHROW Script::DkmScriptDocument* STDMETHODCALLTYPE Document(
            );

        // Indicates the revision number which inserted the statement represented by this
        // object. Typically, this will be zero for non-dynamic documents.
        public: DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE Revision(
            );

        // Indicates the starting character index of this statement, relative  to the start
        // of revision which inserted this statement.
        public: DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE StartIndex(
            );

        // Length of the statement (in characters).
        public: DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE StatementLength(
            );

        // [Optional] Additional runtime-specific data associated with an address. This data
        // will not be used when comparing addresses.
        public: _Ret_opt_ DECLSPEC_NOTHROW DkmReadOnlyCollection<BYTE>* STDMETHODCALLTYPE AdditionalData(
            );

        // Attempt to cast a 'DkmInstructionAddress' to a 'DkmScriptInstructionAddress'. Return
        // NULL if the path object is not a 'DkmScriptInstructionAddress'.
        // pScriptAddress : [In,Optional] Object to attempt to cast
        // Return Value : [Optional] Result of the cast.
        public: static DECLSPEC_NOTHROW DkmScriptInstructionAddress* TryCast(
            DkmInstructionAddress* pInstructionAddress
            )
        {
            if (pInstructionAddress == NULL || pInstructionAddress->TagValue() != Tag::ScriptAddress)
                return NULL;

            return static_cast<DkmScriptInstructionAddress*>(pInstructionAddress);
        }

        /// <summary>
        /// Create a new DkmScriptInstructionAddress object instance.
        /// </summary>
        /// <param name="pModuleInstance">
        /// [In,Optional] The module containing this address. Addresses without a module
        /// cannot have symbols (even for custom addresses). CLR addresses will always have a
        /// module. Native addresses will not have a module if either the CPU jumped to an
        /// invalid address (ex: NULL), or if the CPU is executing dynamically-emitted code.
        /// </param>
        /// <param name="pRuntimeInstance">
        /// [In] Represents a script-based execution environment executing in a target
        /// process.
        /// </param>
        /// <param name="pDocument">
        /// [In] Document containing this instruction.
        /// </param>
        /// <param name="Revision">
        /// [In] Indicates the revision number which inserted the statement represented by
        /// this object. Typically, this will be zero for non-dynamic documents.
        /// </param>
        /// <param name="StartIndex">
        /// [In] Indicates the starting character index of this statement, relative  to the
        /// start of revision which inserted this statement.
        /// </param>
        /// <param name="StatementLength">
        /// [In] Length of the statement (in characters).
        /// </param>
        /// <param name="pAdditionalData">
        /// [In,Optional] Additional runtime-specific data associated with an address. This
        /// data will not be used when comparing addresses.
        /// </param>
        /// <param name="pCPUInstruction">
        /// [In,Optional] CPUInstruction provides the address that the CPU will execute. This
        /// is always provided for native instructions. It may be provided for CLR or custom
        /// addresses depending on how the address object was created.
        /// </param>
        /// <param name="ppCreatedObject">
        /// [Out] Result of this method call.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_opt_ DkmModuleInstance* pModuleInstance,
            _In_ Script::DkmScriptRuntimeInstance* pRuntimeInstance,
            _In_ Script::DkmScriptDocument* pDocument,
            _In_ UINT32 Revision,
            _In_ UINT32 StartIndex,
            _In_ UINT32 StatementLength,
            _In_opt_ DkmReadOnlyCollection<BYTE>* pAdditionalData,
            _In_opt_ const DkmInstructionAddress::CPUInstruction* pCPUInstruction,
            _Deref_out_ Script::DkmScriptInstructionAddress** ppCreatedObject
            );
    }; // end of DkmScriptInstructionAddress

    // DkmScriptInstructionSymbol is used to represent an executable statement in a
    // script-based runtime environment such the Microsoft JavaScript engine.
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("aebaa0af-6437-2ecf-aaf1-86c58eba9447") DkmScriptInstructionSymbol : public Symbols::DkmInstructionSymbol
    {
        // Use DkmScriptInstructionSymbol::Create to create this object
        private: DkmScriptInstructionSymbol();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmScriptInstructionSymbol();
        // This object cannot be copied
        private: DkmScriptInstructionSymbol& operator=(const DkmScriptInstructionSymbol&);
        private: DkmScriptInstructionSymbol(const DkmScriptInstructionSymbol&);

        private: Script::DkmScriptDocument* const m_pDocument;
        private: const UINT32 m_Revision;
        private: const UINT32 m_StartIndex;
        private: const UINT32 m_StatementLength;
        private: OPTIONAL DkmReadOnlyCollection<BYTE>* const m_pAdditionalData;
        private: void* m__pExtendedData;

        // Document containing this instruction.
        public: _Ret_ DECLSPEC_NOTHROW Script::DkmScriptDocument* STDMETHODCALLTYPE Document(
            );

        // Indicates the revision number which inserted the statement represented by this
        // object. Typically, this will be zero for non-dynamic documents.
        public: DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE Revision(
            );

        // Indicates the starting character index of this statement, relative  to the start
        // of revision which inserted this statement.
        public: DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE StartIndex(
            );

        // Length of the statement (in characters).
        public: DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE StatementLength(
            );

        // [Optional] Additional runtime-specific data associated with an address. This data
        // will not be used when comparing addresses.
        public: _Ret_opt_ DECLSPEC_NOTHROW DkmReadOnlyCollection<BYTE>* STDMETHODCALLTYPE AdditionalData(
            );

        // Attempt to cast a 'DkmInstructionSymbol' to a 'DkmScriptInstructionSymbol'. Return
        // NULL if the path object is not a 'DkmScriptInstructionSymbol'.
        // pScriptInstruction : [In,Optional] Object to attempt to cast
        // Return Value : [Optional] Result of the cast.
        public: static DECLSPEC_NOTHROW DkmScriptInstructionSymbol* TryCast(
            DkmInstructionSymbol* pInstruction
            )
        {
            if (pInstruction == NULL || pInstruction->TagValue() != Tag::ScriptInstruction)
                return NULL;

            return static_cast<DkmScriptInstructionSymbol*>(pInstruction);
        }

        /// <summary>
        /// Create a new DkmScriptInstructionSymbol object instance.
        /// </summary>
        /// <param name="pModule">
        /// [In] The DkmModule class represents a code bundle (ex: dll or exe) which is or
        /// once was loaded into one or more processes. The DkmModule class is the central
        /// object to the symbol APIs, and is 1:1 with the symbol handler's notation of what
        /// is loaded. If a code bundle loads into three different processes (or the same
        /// process but with three different base addresses or three different app domains)
        /// but the symbol handler thinks of all of these as being identical, there will be
        /// only one module object.
        /// </param>
        /// <param name="RuntimeType">
        /// [In] The Runtime Id identifies the execution environment for a particular piece
        /// of code. Runtime Ids are used by the dispatcher to decide which monitor to
        /// dispatch to. Note that the ordering of the runtime ID Guids is somewhat
        /// significant as this dictates which runtime gets the first shot during
        /// arbitration. Thus, if one wants to declare a new runtime instance which is built
        /// on the CLR, the runtime id should be less than DkmRuntimeId.Clr.
        /// </param>
        /// <param name="pDocument">
        /// [In] Document containing this instruction.
        /// </param>
        /// <param name="Revision">
        /// [In] Indicates the revision number which inserted the statement represented by
        /// this object. Typically, this will be zero for non-dynamic documents.
        /// </param>
        /// <param name="StartIndex">
        /// [In] Indicates the starting character index of this statement, relative  to the
        /// start of revision which inserted this statement.
        /// </param>
        /// <param name="StatementLength">
        /// [In] Length of the statement (in characters).
        /// </param>
        /// <param name="pAdditionalData">
        /// [In,Optional] Additional runtime-specific data associated with an address. This
        /// data will not be used when comparing addresses.
        /// </param>
        /// <param name="ppCreatedObject">
        /// [Out] Result of this method call.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ Symbols::DkmModule* pModule,
            _In_ const GUID& RuntimeType,
            _In_ Script::DkmScriptDocument* pDocument,
            _In_ UINT32 Revision,
            _In_ UINT32 StartIndex,
            _In_ UINT32 StatementLength,
            _In_opt_ DkmReadOnlyCollection<BYTE>* pAdditionalData,
            _Deref_out_ Script::DkmScriptInstructionSymbol** ppCreatedObject
            );

        #ifndef EXCLUDE_MONITOR_ONLY_APIS
        /// <summary>
        /// Call back implemented by the script symbol provider to tell the script debug
        /// monitor what to do next when stepping.
        ///
        /// Location constraint: API must be called from a Monitor component (component level
        /// &lt; 100,000).
        /// </summary>
        /// <param name="pStartingInstruction">
        /// [In,Optional] The instruction symbol of the process at the time this step
        /// started. This will be NULL if the step originated on a thread with no frames.
        /// </param>
        /// <param name="IsSteppingByLine">
        /// [In] true if the step is by line (instead of by statement).
        /// </param>
        /// <param name="pResult">
        /// [Out] Enum value indicating the next action that the script dm should perform.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// NotImplementedException/E_NOTIMPL indicates that no symbol provider is available
        /// for the script symbol.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetNextSteppingAction(
            _In_opt_ Script::DkmScriptInstructionSymbol* pStartingInstruction,
            _In_ bool IsSteppingByLine,
            _Out_ Script::DkmScriptSymbolNextSteppingAction_t* pResult
            );
        #endif // #ifndef EXCLUDE_MONITOR_ONLY_APIS
    }; // end of DkmScriptInstructionSymbol

    // Represents a script-based execution environment executing in a target process.
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("f6cb156c-9ad9-c01d-29e0-cb77e45fa254") DkmScriptRuntimeInstance : public DkmRuntimeInstance
    {
        // Use DkmScriptRuntimeInstance::Create to create this object
        private: DkmScriptRuntimeInstance();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmScriptRuntimeInstance();
        // This object cannot be copied
        private: DkmScriptRuntimeInstance& operator=(const DkmScriptRuntimeInstance&);
        private: DkmScriptRuntimeInstance(const DkmScriptRuntimeInstance&);

        // Contains additional fields of DkmScriptRuntimeInstance which were added after the
        // class was initally introduced.
        private: struct ___ExtendedData
        {
            ___ExtendedData();

            // A flag indicating whether the current loaded dll is EdgeHtml.dll or not.
            const bool IsEdgeHtmlDll;

            // File version of the script host dll. This will be 0 if it cannot be obtained.
            // The top 16 bits are the major version, followed by 16 bits for the minor
            // version, followed by 16 bits for the build number followed by 16 bits for the
            // build revision.
            const UINT64 ScriptHostVersion;
        };

        private: const UINT32 m_LoadOrderIndex;
        private: ___ExtendedData* const m__pExtendedData;

        // Index indicating the relative load order of this script runtime instance to other
        // script runtime instances within the target process. The first runtime instance to
        // load will be given an index of zero.
        public: DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE LoadOrderIndex(
            );

        // A flag indicating whether the current loaded dll is EdgeHtml.dll or not.
        //
        // This API was introduced in Visual Studio 14 RTM (DkmApiVersion.VS14RTM).
        public: DECLSPEC_NOTHROW bool STDMETHODCALLTYPE IsEdgeHtmlDll(
            );

        // File version of the script host dll. This will be 0 if it cannot be obtained. The
        // top 16 bits are the major version, followed by 16 bits for the minor version,
        // followed by 16 bits for the build number followed by 16 bits for the build
        // revision.
        //
        // This API was introduced in Visual Studio 14 RTM (DkmApiVersion.VS14RTM).
        public: DECLSPEC_NOTHROW UINT64 STDMETHODCALLTYPE ScriptHostVersion(
            );

        // Attempt to cast a 'DkmRuntimeInstance' to a 'DkmScriptRuntimeInstance'. Return
        // NULL if the path object is not a 'DkmScriptRuntimeInstance'.
        // pScriptRuntimeInstance : [In,Optional] Object to attempt to cast
        // Return Value : [Optional] Result of the cast.
        public: static DECLSPEC_NOTHROW DkmScriptRuntimeInstance* TryCast(
            DkmRuntimeInstance* pRuntimeInstance
            )
        {
            if (pRuntimeInstance == NULL || pRuntimeInstance->TagValue() != Tag::ScriptRuntimeInstance)
                return NULL;

            return static_cast<DkmScriptRuntimeInstance*>(pRuntimeInstance);
        }

        /// <summary>
        /// Creates a new runtime instance object from a debug monitor. This method must be
        /// called from the event thread when a debug monitor detects that a new runtime
        /// instance has loaded (for example, when the corresponding runtime dll loads in the
        /// target process).
        ///
        /// This method will send a RuntimeInstanceLoad event.
        /// </summary>
        /// <param name="pProcess">
        /// [In] DkmProcess represents a target process which is being debugged. The debugger
        /// debugs processes, so this is the basic unit of debugging. A DkmProcess can
        /// represent a system process or a virtual process such as minidumps.
        /// </param>
        /// <param name="Id">
        /// [In] Identifies a DkmRuntimeInstance object within a process.
        /// </param>
        /// <param name="LoadOrderIndex">
        /// [In] Index indicating the relative load order of this script runtime instance to
        /// other script runtime instances within the target process. The first runtime
        /// instance to load will be given an index of zero.
        /// </param>
        /// <param name="DataItem">
        /// [In] Data object to add to the new DkmScriptRuntimeInstance instance.
        /// DkmDataItem::Null() in the case that the caller doesn't need to add a data item.
        /// </param>
        /// <param name="ppCreatedObject">
        /// [Out] Result of this method call.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ DkmProcess* pProcess,
            _In_ const DkmRuntimeInstanceId& Id,
            _In_ UINT32 LoadOrderIndex,
            _In_ const DkmDataItem& DataItem,
            _Deref_out_ Script::DkmScriptRuntimeInstance** ppCreatedObject
            );

        /// <summary>
        /// Creates a new runtime instance object from a debug monitor. This method must be
        /// called from the event thread when a debug monitor detects that a new runtime
        /// instance has loaded (for example, when the corresponding runtime dll loads in the
        /// target process).
        ///
        /// This method will send a RuntimeInstanceLoad event.
        ///
        /// This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
        /// </summary>
        /// <param name="pProcess">
        /// [In] DkmProcess represents a target process which is being debugged. The debugger
        /// debugs processes, so this is the basic unit of debugging. A DkmProcess can
        /// represent a system process or a virtual process such as minidumps.
        /// </param>
        /// <param name="Id">
        /// [In] Identifies a DkmRuntimeInstance object within a process.
        /// </param>
        /// <param name="Capabilities">
        /// [In] Enumeration of runtime capabilities.
        /// </param>
        /// <param name="pParentRuntime">
        /// [In,Optional] For runtimes that are implemented on top of another runtime, this
        /// can optionally be used to indicant the logical parent. This can then be used to
        /// request services from the parent when the child runtime doesn't implement the
        /// service. This is currently used only for obtaining the top stack frame to
        /// evaluate a conditional breakpoint when the child runtime doesn't walk stacks
        /// itself.
        /// </param>
        /// <param name="LoadOrderIndex">
        /// [In] Index indicating the relative load order of this script runtime instance to
        /// other script runtime instances within the target process. The first runtime
        /// instance to load will be given an index of zero.
        /// </param>
        /// <param name="DataItem">
        /// [In] Data object to add to the new DkmScriptRuntimeInstance instance.
        /// DkmDataItem::Null() in the case that the caller doesn't need to add a data item.
        /// </param>
        /// <param name="ppCreatedObject">
        /// [Out] Result of this method call.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ DkmProcess* pProcess,
            _In_ const DkmRuntimeInstanceId& Id,
            _In_ DkmRuntimeCapabilities_t Capabilities,
            _In_opt_ DkmRuntimeInstance* pParentRuntime,
            _In_ UINT32 LoadOrderIndex,
            _In_ const DkmDataItem& DataItem,
            _Deref_out_ Script::DkmScriptRuntimeInstance** ppCreatedObject
            );

        /// <summary>
        /// Creates a new runtime instance object from a debug monitor. This method must be
        /// called from the event thread when a debug monitor detects that a new runtime
        /// instance has loaded (for example, when the corresponding runtime dll loads in the
        /// target process).
        ///
        /// This method will send a RuntimeInstanceLoad event.
        ///
        /// This API was introduced in Visual Studio 14 RTM (DkmApiVersion.VS14RTM).
        /// </summary>
        /// <param name="pProcess">
        /// [In] DkmProcess represents a target process which is being debugged. The debugger
        /// debugs processes, so this is the basic unit of debugging. A DkmProcess can
        /// represent a system process or a virtual process such as minidumps.
        /// </param>
        /// <param name="Id">
        /// [In] Identifies a DkmRuntimeInstance object within a process.
        /// </param>
        /// <param name="Capabilities">
        /// [In] Enumeration of runtime capabilities.
        /// </param>
        /// <param name="pParentRuntime">
        /// [In,Optional] For runtimes that are implemented on top of another runtime, this
        /// can optionally be used to indicant the logical parent. This can then be used to
        /// request services from the parent when the child runtime doesn't implement the
        /// service. This is currently used only for obtaining the top stack frame to
        /// evaluate a conditional breakpoint when the child runtime doesn't walk stacks
        /// itself.
        /// </param>
        /// <param name="LoadOrderIndex">
        /// [In] Index indicating the relative load order of this script runtime instance to
        /// other script runtime instances within the target process. The first runtime
        /// instance to load will be given an index of zero.
        /// </param>
        /// <param name="IsEdgeHtmlDll">
        /// [In] A flag indicating whether the current loaded dll is EdgeHtml.dll or not.
        /// </param>
        /// <param name="ScriptHostVersion">
        /// [In] File version of the script host dll. This will be 0 if it cannot be
        /// obtained. The top 16 bits are the major version, followed by 16 bits for the
        /// minor version, followed by 16 bits for the build number followed by 16 bits for
        /// the build revision.
        /// </param>
        /// <param name="DataItem">
        /// [In] Data object to add to the new DkmScriptRuntimeInstance instance.
        /// DkmDataItem::Null() in the case that the caller doesn't need to add a data item.
        /// </param>
        /// <param name="ppCreatedObject">
        /// [Out] Result of this method call.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ DkmProcess* pProcess,
            _In_ const DkmRuntimeInstanceId& Id,
            _In_ DkmRuntimeCapabilities_t Capabilities,
            _In_opt_ DkmRuntimeInstance* pParentRuntime,
            _In_ UINT32 LoadOrderIndex,
            _In_ bool IsEdgeHtmlDll,
            _In_ UINT64 ScriptHostVersion,
            _In_ const DkmDataItem& DataItem,
            _Deref_out_ Script::DkmScriptRuntimeInstance** ppCreatedObject
            );

        #ifndef EXCLUDE_MONITOR_ONLY_APIS
        /// <summary>
        /// Allows a caller to obtain a direct access to the IRemoteDebugApplication
        /// interface from the target process. This can be used to load dlls into the target
        /// application, or inspect the target application. Note that this should never be
        /// used for execution control, breakpoints, or evaluation.
        ///
        /// Location constraint: API must be called from a Monitor component (component level
        /// &lt; 100,000).
        /// </summary>
        /// <param name="ppApplication">
        /// [Out] Debug application interface from the debugged process.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetRemoteDebugApplication(
            _Deref_out_ IRemoteDebugApplication** ppApplication
            );
        #endif // #ifndef EXCLUDE_MONITOR_ONLY_APIS

        /// <summary>
        /// API which is called from break mode which tells the script runtime that execution
        /// should be aborted when resuming (BREAKRESUMEACTION_ABORT). This API requires an
        /// MSHTML v10+ target execution environment.
        /// </summary>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE AbortExecutionOnResume(
            );

        #ifndef EXCLUDE_MONITOR_ONLY_APIS
        /// <summary>
        /// Provides notification to the user that a critical error has happened in the
        /// target process. This method will complete once the critical error UI has been
        /// dismissed.
        ///
        /// This method will append a new work item to the specified work list, and return
        /// once the work item has been appended. The actual processing of the work item is
        /// asynchronous. The caller will be notified that the request is complete through
        /// the completion routine.
        ///
        /// Location constraint: API must be called from a Monitor component (component level
        /// &lt; 100,000).
        /// </summary>
        /// <param name="pWorkList">
        /// WorkList to append the new work item to.
        /// </param>
        /// <param name="pSource">
        /// [In] Specifies to the web developer what aspect of their page the issue pertains
        /// to. Ex: "HTML", "DOM", "SCRIPT", etc.
        /// </param>
        /// <param name="MessageId">
        /// [In] Indicates an error code. Source + MessageId should uniquely identify the
        /// message so that information about the error can be found in help.
        /// </param>
        /// <param name="pMessage">
        /// [In] Message to display to users.
        /// </param>
        /// <param name="pInstructionAddress">
        /// [In,Optional] When known, the script instruction address where the error
        /// occurred.
        /// </param>
        /// <param name="pSourcePosition">
        /// [In,Optional] When InstructionAddress is non-null, this contains the current
        /// source position of this instruction.
        /// </param>
        /// <param name="pCompletionRoutine">
        /// Routine to fire when the request is complete. If the request is successfully
        /// appended to the work list, this will always fire (including when the operation is
        /// canceled). This will never fire if appending the work item fails.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE OnScriptCriticalError(
            _In_ DkmWorkList* pWorkList,
            _In_ DkmString* pSource,
            _In_ UINT32 MessageId,
            _In_ DkmString* pMessage,
            _In_opt_ Script::DkmScriptInstructionAddress* pInstructionAddress,
            _In_opt_ Symbols::DkmSourcePosition* pSourcePosition,
            _In_ IDkmCompletionRoutine<Script::DkmOnScriptCriticalErrorAsyncResult>* pCompletionRoutine
            );
        #endif // #ifndef EXCLUDE_MONITOR_ONLY_APIS

        /// <summary>
        /// Raises the notification that one or more script documents have been updated.
        /// </summary>
        /// <param name="Documents">
        /// [In] Set of documents which have been updated.
        ///
        /// The memory for the DkmArray members is allocated by the caller, and can be from
        /// any source (stack memory, static buffer, heap, etc). The implementation should
        /// not modify the members.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE OnScriptSymbolsUpdated(
            _In_ const DkmArray<Script::DkmScriptDocument*>& Documents
            );
    }; // end of DkmScriptRuntimeInstance

}; // end namespace Script

// Contains types specific to GPU debugging.
namespace GPU {
    // Collection of properties of GPU compute kernel.
    struct DECLSPEC_UUID("a6792ede-1d69-7729-4e5b-f6de0e3afb3b") DkmComputeProperty
    {
        // Property Name.
        DkmString* pName;

        // Property value.
        DkmString* pValue;

        // Release all reference-counted fields within the DkmComputeProperty structure.
        static DECLSPEC_NOTHROW void STDMETHODCALLTYPE Release(
            _In_ DkmComputeProperty* pItem
            );
    };

    // Collection of properties of GPU compute threads.
    struct DECLSPEC_UUID("30645692-f6be-eb65-a2b8-719fb033e020") DkmComputeThreadInfo
    {
        // The number of threads represented by this object, could be greater than one if
        // returned in a group by call.
        UINT32 ThreadCount;

        // Vector index.
        UINT32 VectorId;

        // Thread group ID, unique to kernel.
        UINT64 ThreadGroupId;

        // Thread ID, unique to kernel.
        UINT64 ThreadId;

        // The IP of the compute thread.
        UINT64 InstructionPointer;

        // State of the compute thread.
        GPU::DkmComputeThreadState_t ThreadState;

        // Flagged state of the compute thread.
        bool FlaggedState;

        // Frozen state of the compute thread.
        bool FrozenState;

        // Release all reference-counted fields within the DkmComputeThreadInfo structure.
        static DECLSPEC_NOTHROW void STDMETHODCALLTYPE Release(
            _In_ DkmComputeThreadInfo* pItem
            )
        {
            // structure requires no cleanup
        }
    };

    // The description of GPU registers for a GPU compute thread.
    struct DECLSPEC_UUID("5b4f9bea-1b43-64a4-e441-8b61f377d417") DkmGPURegisterDescription
    {
        // The GPU register type.
        UINT32 RegisterType;

        // The index of a GPU register.
        UINT32 RegisterIndex;

        // The size of a GPU register in bytes.
        UINT64 RegisterSize;

        // The value bytes of a GPU register. This is normally 16 bytes.
        DkmReadOnlyCollection<BYTE>* pRegisterValue;

        // Release all reference-counted fields within the DkmGPURegisterDescription structure.
        static DECLSPEC_NOTHROW void STDMETHODCALLTYPE Release(
            _In_ DkmGPURegisterDescription* pItem
            );
    };

    // A structure used as a where clause when querying compute thread info.
    struct DECLSPEC_UUID("0365513d-4d3c-8674-f02e-af9db38d12f5") DkmWhereClause
    {
        // Flags specifying columns in a where clause.
        GPU::DkmQueryComputeThreadInfoFlags_t ColumnFlags;

        // Values of the columns specified in ColumnFlags.
        GPU::DkmComputeThreadInfo Values;

        // Release all reference-counted fields within the DkmWhereClause structure.
        static DECLSPEC_NOTHROW void STDMETHODCALLTYPE Release(
            _In_ DkmWhereClause* pItem
            )
        {
            // structure requires no cleanup
        }
    };

    // The model type that a compute kernel uses.
    DEFINE_SCOPED_ENUM(DkmComputeKernelModel)
    {
        // Compute kernel uses flat model.
        Flat = 0,
        // Compute kernel uses tile model.
        Tile = 1,
        // Compute kernel uses three-dimensional HLSL model.
        HLSL = 2
    };

    // Compute thread state flags.
    DEFINE_SCOPED_ENUM(DkmComputeThreadState)
    {
        // Not a valid compute thread state.
        Unknown = 0x0,
        // Compute thread is active.
        Active = 0x1,
        // Compute thread is divergent.
        Divergent = 0x2,
        // Compute thread is blocked.
        Blocked = 0x4,
        // Compute thread is unused.
        Unused = 0x8,
        // Compute thread is not started.
        NotStarted = 0x10,
        // Compute thread is completed.
        Completed = 0x20
    };
    DEFINE_SCOPED_ENUM_FLAG_OPERATORS(DkmComputeThreadState_t);

    // DkmGPUAddressType describes if an address represents a special location in the GPU
    // debuggee's byte code.
    DEFINE_SCOPED_ENUM(DkmGPUAddressType)
    {
        // No type flat is set.
        None = 0x1,
        // The address is at the inline function call site, that is, the instruction just
        // before inline function.
        FunctionCall = 0x2,
        // The address has symbols but should not be stepped into.
        NoStepInto = 0x4
    };
    DEFINE_SCOPED_ENUM_FLAG_OPERATORS(DkmGPUAddressType_t);

    // Flags for describing GPU breakpoint behavior.
    DEFINE_SCOPED_ENUM(DkmGPUBreakpointBehaviorFlags)
    {
        // No specific behavior.
        None = 0,
        // Break once per warp.
        BreakOncePerWarp = 1,
        // Break for every thread.
        BreakForEveryThread = 2,
        // Break on first or default warp.
        BreakOnFirstDefaultWarp = 3
    };

    // DkmGPUComputeKernel represents a GPU compute kernel running in the target process.
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("944cc867-86e7-9c78-724c-d929d98ce82d") DkmGPUComputeKernel : public DkmDataContainer
    {
        // Use DkmGPUComputeKernel::Create to create this object
        private: DkmGPUComputeKernel();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmGPUComputeKernel();
        // This object cannot be copied
        private: DkmGPUComputeKernel& operator=(const DkmGPUComputeKernel&);
        private: DkmGPUComputeKernel(const DkmGPUComputeKernel&);

        private: const UINT32 m_DispatchId;
        private: const UINT64 m_GPUDevice;
        private: const UINT64 m_GPUShader;
        private: const UINT64 m_GPUShaderDispatch;
        private: DkmReadOnlyCollection<UINT32>* const m_pGroupDimensions;
        private: const UINT64 m_NumberOfGroups;
        private: DkmReadOnlyCollection<UINT32>* const m_pThreadDimensions;
        private: const UINT32 m_NumberOfThreads;
        private: const GUID m_UniqueId;
        private: DkmProcess* const m_pProcess;
        private: void* m__pExtendedData;
        private: void* m_pComputeThreadCollection0;

        // The GPU dispatch id for this kernel object.
        public: DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE DispatchId(
            );

        // The GPU device this compute kernel runs on.
        public: DECLSPEC_NOTHROW UINT64 STDMETHODCALLTYPE GPUDevice(
            );

        // A compute kernel is a running instance of this GPU shader.
        public: DECLSPEC_NOTHROW UINT64 STDMETHODCALLTYPE GPUShader(
            );

        // The handle of the executing GPU shader corresponding to this compute kernel.
        public: DECLSPEC_NOTHROW UINT64 STDMETHODCALLTYPE GPUShaderDispatch(
            );

        // Thread group dimensions in a compute kernel.
        public: _Ret_ DECLSPEC_NOTHROW DkmReadOnlyCollection<UINT32>* STDMETHODCALLTYPE GroupDimensions(
            );

        // Number of thread groups in a compute kernel.
        public: DECLSPEC_NOTHROW UINT64 STDMETHODCALLTYPE NumberOfGroups(
            );

        // Thread dimensions in a compute kernel.
        public: _Ret_ DECLSPEC_NOTHROW DkmReadOnlyCollection<UINT32>* STDMETHODCALLTYPE ThreadDimensions(
            );

        // Number of compute threads in a thread group of compute kernel.
        public: DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE NumberOfThreads(
            );

        // Guid which uniquely identifies this compute kernel object.
        public: DECLSPEC_NOTHROW const GUID& STDMETHODCALLTYPE UniqueId(
            );

        // DkmProcess represents a target process which is being debugged. The debugger
        // debugs processes, so this is the basic unit of debugging. A DkmProcess can
        // represent a system process or a virtual process such as minidumps.
        public: _Ret_ DECLSPEC_NOTHROW DkmProcess* STDMETHODCALLTYPE Process(
            );

        // This represents a connection between the monitor and the IDE. It can either be a
        // local connection if the monitor is running in the same process as the IDE, or it
        // can be a remote connection. In the monitor process, there is only one connection.
        public: _Ret_ DECLSPEC_NOTHROW DefaultPort::DkmTransportConnection* STDMETHODCALLTYPE Connection(
            );

        /// <summary>
        /// DkmGPUComputeKernel is called by a debug monitor to create a new
        /// DkmGPUComputeKernel instance. DkmGPUComputeKernel objects for GPU compute kernels
        /// are created by the base debug monitor.
        /// </summary>
        /// <param name="DispatchId">
        /// [In] The GPU dispatch id for this kernel object.
        /// </param>
        /// <param name="GPUDevice">
        /// [In] The GPU device this compute kernel runs on.
        /// </param>
        /// <param name="GPUShader">
        /// [In] A compute kernel is a running instance of this GPU shader.
        /// </param>
        /// <param name="GPUShaderDispatch">
        /// [In] The handle of the executing GPU shader corresponding to this compute kernel.
        /// </param>
        /// <param name="pGroupDimensions">
        /// [In] Thread group dimensions in a compute kernel.
        /// </param>
        /// <param name="NumberOfGroups">
        /// [In] Number of thread groups in a compute kernel.
        /// </param>
        /// <param name="pThreadDimensions">
        /// [In] Thread dimensions in a compute kernel.
        /// </param>
        /// <param name="NumberOfThreads">
        /// [In] Number of compute threads in a thread group of compute kernel.
        /// </param>
        /// <param name="pProcess">
        /// [In] DkmProcess represents a target process which is being debugged. The debugger
        /// debugs processes, so this is the basic unit of debugging. A DkmProcess can
        /// represent a system process or a virtual process such as minidumps.
        /// </param>
        /// <param name="DataItem">
        /// [In] Data object to add to the new DkmGPUComputeKernel instance.
        /// DkmDataItem::Null() in the case that the caller doesn't need to add a data item.
        /// </param>
        /// <param name="ppCreatedObject">
        /// [Out] Result of this method call.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ UINT32 DispatchId,
            _In_ UINT64 GPUDevice,
            _In_ UINT64 GPUShader,
            _In_ UINT64 GPUShaderDispatch,
            _In_ DkmReadOnlyCollection<UINT32>* pGroupDimensions,
            _In_ UINT64 NumberOfGroups,
            _In_ DkmReadOnlyCollection<UINT32>* pThreadDimensions,
            _In_ UINT32 NumberOfThreads,
            _In_ DkmProcess* pProcess,
            _In_ const DkmDataItem& DataItem,
            _Deref_out_ GPU::DkmGPUComputeKernel** ppCreatedObject
            );

        /// <summary>
        /// ComputeKernelExit is sent by the dispatcher when DkmGPUComputeKernel::Unload is
        /// invoked by the monitor.
        ///
        /// This method may only be called by the component which created the object.
        /// </summary>
        /// <param name="ExitCode">
        /// [In] 32-bit value that the compute kernel returned on exit.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Unload(
            _In_ UINT32 ExitCode
            );

        /// <summary>
        /// Find a DkmGPUComputeThread element within this DkmGPUComputeKernel. If no element
        /// with the given input key is present, FindComputeThread will fail.
        /// </summary>
        /// <param name="GlobalThreadIndex">
        /// [In] Search key used to find the element.
        /// </param>
        /// <param name="ppComputeThread">
        /// [Out] Result of the search.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// E_XAPI_OBJECT_NOT_FOUND indicates that the search key cannot be found.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE FindComputeThread(
            _In_ UINT64 GlobalThreadIndex,
            _Deref_out_ GPU::DkmGPUComputeThread** ppComputeThread
            );

        /// <summary>
        /// Obtain the warp size of the hardware or emulator.
        /// </summary>
        /// <param name="pWidth">
        /// [Out] Width of the hardware.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetComputeVectorWidth(
            _Out_ UINT32* pWidth
            );

        /// <summary>
        /// Obtain the active thread groups from the compute kernel.
        /// </summary>
        /// <param name="pActiveThreadGroups">
        /// [Out] List of global Thread group id of all active thread groups.
        ///
        /// The memory for the DkmArray members is allocated by the method implementation
        /// using DkmAllocBytes/DkmAllocArray. It is freed by the caller using the
        /// CAutoDkmArray template or with DkmFreeMemory and manual element release.
        /// </param>
        /// <param name="pNumberOfGroups">
        /// [Out] Number of active thread groups in the compute kernel.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetActiveThreadGroups(
            _Out_ DkmArray<UINT64>* pActiveThreadGroups,
            _Out_ UINT32* pNumberOfGroups
            );

        /// <summary>
        /// Get the dimension of the thread block.
        /// </summary>
        /// <param name="pThreadDimensions">
        /// [Out] Thread group dimensions.
        ///
        /// The memory for the DkmArray members is allocated by the method implementation
        /// using DkmAllocBytes/DkmAllocArray. It is freed by the caller using the
        /// CAutoDkmArray template or with DkmFreeMemory and manual element release.
        /// </param>
        /// <param name="pNumberOfDimensions">
        /// [Out] Number of Thread block dimensions.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetCurrentThreadDimensions(
            _Out_ DkmArray<UINT32>* pThreadDimensions,
            _Out_ UINT32* pNumberOfDimensions
            );

        /// <summary>
        /// Get the dimension of the thread block.
        /// </summary>
        /// <param name="pGroupDimensions">
        /// [Out] Grid Dimensions.
        ///
        /// The memory for the DkmArray members is allocated by the method implementation
        /// using DkmAllocBytes/DkmAllocArray. It is freed by the caller using the
        /// CAutoDkmArray template or with DkmFreeMemory and manual element release.
        /// </param>
        /// <param name="pNumberOfDimensions">
        /// [Out] Number of Grid dimensions.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetCurrentGroupDimensions(
            _Out_ DkmArray<UINT32>* pGroupDimensions,
            _Out_ UINT32* pNumberOfDimensions
            );

        /// <summary>
        /// Get the name of compute kernel.
        /// </summary>
        /// <param name="ppComputeKernelName">
        /// [Out] Name of the ComputeKernel that is launched.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetComputeKernelName(
            _Deref_out_ DkmString** ppComputeKernelName
            );

        /// <summary>
        /// Get properties of the compute kernel.
        /// </summary>
        /// <param name="pComputeProperties">
        /// [Out] List of Compute kernel properties.
        ///
        /// The memory for the DkmArray members is allocated by the method implementation
        /// using DkmAllocBytes/DkmAllocArray. It is freed by the caller using the
        /// CAutoDkmArray template or with DkmFreeMemory and manual element release.
        /// </param>
        /// <param name="pNumberOfProperties">
        /// [Out] Number of properties in the compute kernel.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetComputeKernelProperties(
            _Out_ DkmArray<GPU::DkmComputeProperty>* pComputeProperties,
            _Out_ UINT32* pNumberOfProperties
            );

        /// <summary>
        /// Runs the select query on thread info objects.
        /// </summary>
        /// <param name="pFrom">
        /// [In] From clause specification for selection (can be empty to select from all
        /// available threads).
        /// </param>
        /// <param name="Where">
        /// [In] Where clause specification for selection.
        /// </param>
        /// <param name="pThreadInfoArray">
        /// [Out] The result set of compute thread info objects.
        ///
        /// The memory for the DkmArray members is allocated by the method implementation
        /// using DkmAllocBytes/DkmAllocArray. It is freed by the caller using the
        /// CAutoDkmArray template or with DkmFreeMemory and manual element release.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Select(
            _In_ DkmReadOnlyCollection<UINT64>* pFrom,
            _In_ const GPU::DkmWhereClause& Where,
            _Out_ DkmArray<GPU::DkmComputeThreadInfo>* pThreadInfoArray
            );

        /// <summary>
        /// Runs the group by query on thread info objects.
        /// </summary>
        /// <param name="GroupByFlags">
        /// [In] Flags specifying on which columns the group by is run.
        /// </param>
        /// <param name="pFrom">
        /// [In] From clause specification for selection (can be empty to select from all
        /// available threads).
        /// </param>
        /// <param name="Where">
        /// [In] Where clause specification for group by.
        /// </param>
        /// <param name="pThreadInfoArray">
        /// [Out] The result set of compute thread info objects.
        ///
        /// The memory for the DkmArray members is allocated by the method implementation
        /// using DkmAllocBytes/DkmAllocArray. It is freed by the caller using the
        /// CAutoDkmArray template or with DkmFreeMemory and manual element release.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GroupBy(
            _In_ GPU::DkmQueryComputeThreadInfoFlags_t GroupByFlags,
            _In_ DkmReadOnlyCollection<UINT64>* pFrom,
            _In_ const GPU::DkmWhereClause& Where,
            _Out_ DkmArray<GPU::DkmComputeThreadInfo>* pThreadInfoArray
            );

        /// <summary>
        /// Get all threads that hit breakpoint.
        /// </summary>
        /// <param name="pThreadIdArray">
        /// [Out] The result set of compute thread ids that hit breakpoint.
        ///
        /// The memory for the DkmArray members is allocated by the method implementation
        /// using DkmAllocBytes/DkmAllocArray. It is freed by the caller using the
        /// CAutoDkmArray template or with DkmFreeMemory and manual element release.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetStoppedThreads(
            _Out_ DkmArray<UINT64>* pThreadIdArray
            );

        /// <summary>
        /// Gets the DkmGPUComputeThread object for a given thread ID.
        /// </summary>
        /// <param name="ThreadId">
        /// [In] ID of the thread to return.
        /// </param>
        /// <param name="ppThread">
        /// [Out] Thread object that matches the given thread ID.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetThreadFromId(
            _In_ UINT64 ThreadId,
            _Deref_out_ GPU::DkmGPUComputeThread** ppThread
            );

        /// <summary>
        /// Update flagged state of compute threads.
        /// </summary>
        /// <param name="Where">
        /// [In] Where clause specification for update.
        /// </param>
        /// <param name="Flagged">
        /// [In] The value to update with.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE UpdateFlaggedState(
            _In_ const GPU::DkmWhereClause& Where,
            _In_ bool Flagged
            );

        /// <summary>
        /// Update frozen state of compute threads.
        /// </summary>
        /// <param name="Where">
        /// [In] Where clause specification for update.
        /// </param>
        /// <param name="Frozen">
        /// [In] The value to update with.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE UpdateFrozenState(
            _In_ const GPU::DkmWhereClause& Where,
            _In_ bool Frozen
            );

        /// <summary>
        /// Get the dimension of the thread block.
        /// </summary>
        /// <param name="pFlatThreadDimensions">
        /// [Out] Thread group dimensions.
        ///
        /// The memory for the DkmArray members is allocated by the method implementation
        /// using DkmAllocBytes/DkmAllocArray. It is freed by the caller using the
        /// CAutoDkmArray template or with DkmFreeMemory and manual element release.
        /// </param>
        /// <param name="pFlatIndexBase">
        /// [Out] Thread group dimensions.
        ///
        /// The memory for the DkmArray members is allocated by the method implementation
        /// using DkmAllocBytes/DkmAllocArray. It is freed by the caller using the
        /// CAutoDkmArray template or with DkmFreeMemory and manual element release.
        /// </param>
        /// <param name="pNumberOfDimensions">
        /// [Out] Number of Thread block dimensions.
        /// </param>
        /// <param name="pModel">
        /// [Out] Model Type.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetFlatComputeKernelDimensions(
            _Out_ DkmArray<UINT32>* pFlatThreadDimensions,
            _Out_ DkmArray<INT32>* pFlatIndexBase,
            _Out_ UINT32* pNumberOfDimensions,
            _Out_ GPU::DkmComputeKernelModel_t* pModel
            );
    }; // end of DkmGPUComputeKernel

    // Indicates which parts of a thread or group ID should be used.
    DEFINE_SCOPED_ENUM(DkmHlslThreadIdComponents)
    {
        // The X portion of the id vector.
        X = 0x1,
        // The Y portion of the id vector.
        Y = 0x2,
        // The Z portion of the id vector.
        Z = 0x4
    };
    DEFINE_SCOPED_ENUM_FLAG_OPERATORS(DkmHlslThreadIdComponents_t);

    // Options for how to query compute thread info.
    DEFINE_SCOPED_ENUM(DkmQueryComputeThreadInfoFlags)
    {
        // No query option flags are set.
        None = 0x0,
        // Do the query by ThreadGroupId.
        ThreadGroupId = 0x1,
        // Do the query by VectorId.
        VectorId = 0x2,
        // Do the query by ThreadId.
        ThreadId = 0x4,
        // Do the query by ThreadState.
        ThreadState = 0x8,
        // Do the query by FlagState.
        FlaggedState = 0x10,
        // Do the query by InstructionPointer.
        InstructionPointer = 0x20,
        // Do the query by FrozenState.
        FrozenState = 0x40
    };
    DEFINE_SCOPED_ENUM_FLAG_OPERATORS(DkmQueryComputeThreadInfoFlags_t);

    // DkmGPUComputeThread represents a compute thread running in the GPU target process.
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("40cbb26d-05f5-dc30-49f9-797b17f2ab9e") DkmGPUComputeThread : public DkmThread
    {
        // Use DkmGPUComputeThread::Create to create this object
        private: DkmGPUComputeThread();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmGPUComputeThread();
        // This object cannot be copied
        private: DkmGPUComputeThread& operator=(const DkmGPUComputeThread&);
        private: DkmGPUComputeThread(const DkmGPUComputeThread&);

        // Contains additional fields of DkmGPUComputeThread which were added after the class
        // was initally introduced.
        private: struct ___ExtendedData
        {
            ___ExtendedData();

            // [Optional] The native thread on which an exception is raised to notify the
            // debugger that a GPU debug event is available.
            OPTIONAL DkmThread* const pNativeThread;
        };

        private: const UINT64 m_GlobalThreadIndex;
        private: GPU::DkmGPUComputeKernel* const m_pComputeKernel;
        private: ___ExtendedData* const m__pExtendedData;

        // Unique to kernel compute thread index.
        public: DECLSPEC_NOTHROW UINT64 STDMETHODCALLTYPE GlobalThreadIndex(
            );

        // DkmGPUComputeKernel represents a GPU compute kernel running in the target process.
        public: _Ret_ DECLSPEC_NOTHROW GPU::DkmGPUComputeKernel* STDMETHODCALLTYPE ComputeKernel(
            );

        // [Optional] The native thread on which an exception is raised to notify the
        // debugger that a GPU debug event is available.
        //
        // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
        public: _Ret_opt_ DECLSPEC_NOTHROW DkmThread* STDMETHODCALLTYPE NativeThread(
            );

        /// <summary>
        /// Create a new DkmGPUComputeThread object instance.
        /// </summary>
        /// <param name="pProcess">
        /// [In] DkmProcess represents a target process which is being debugged. The debugger
        /// debugs processes, so this is the basic unit of debugging. A DkmProcess can
        /// represent a system process or a virtual process such as minidumps.
        /// </param>
        /// <param name="NativeStartAddress">
        /// [In] If available, this is the Win32 start address of this thread (value passed
        /// to the CreateThread API). The value will not always be available, for example, it
        /// is generally not available in scenarios where the thread was started after the
        /// debugger attached, or in minidumps.
        /// </param>
        /// <param name="IsMainThread">
        /// [In] True if this is the main thread of this process. The main thread is the
        /// first thread to start.
        /// </param>
        /// <param name="GlobalThreadIndex">
        /// [In] Unique to kernel compute thread index.
        /// </param>
        /// <param name="pComputeKernel">
        /// [In] DkmGPUComputeKernel represents a GPU compute kernel running in the target
        /// process.
        /// </param>
        /// <param name="pSystem">
        /// [In,Optional] Describes traits of the thread which are relevant to a full Win32
        /// thread. Currently, this value is required, and all threads will have a 'System'
        /// block. In the future, this value may be NULL if the DkmThread represents
        /// something other than a full Win32 thread.
        /// </param>
        /// <param name="DataItem">
        /// [In] Data object to add to the new DkmGPUComputeThread instance.
        /// DkmDataItem::Null() in the case that the caller doesn't need to add a data item.
        /// </param>
        /// <param name="ppCreatedObject">
        /// [Out] Result of this method call.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ DkmProcess* pProcess,
            _In_ UINT64 NativeStartAddress,
            _In_ bool IsMainThread,
            _In_ UINT64 GlobalThreadIndex,
            _In_ GPU::DkmGPUComputeKernel* pComputeKernel,
            _In_opt_ const DkmThread::System* pSystem,
            _In_ const DkmDataItem& DataItem,
            _Deref_out_ GPU::DkmGPUComputeThread** ppCreatedObject
            );

        /// <summary>
        /// Create a new DkmGPUComputeThread object instance.
        ///
        /// This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
        /// </summary>
        /// <param name="pProcess">
        /// [In] DkmProcess represents a target process which is being debugged. The debugger
        /// debugs processes, so this is the basic unit of debugging. A DkmProcess can
        /// represent a system process or a virtual process such as minidumps.
        /// </param>
        /// <param name="NativeStartAddress">
        /// [In] If available, this is the Win32 start address of this thread (value passed
        /// to the CreateThread API). The value will not always be available, for example, it
        /// is generally not available in scenarios where the thread was started after the
        /// debugger attached, or in minidumps.
        /// </param>
        /// <param name="IsMainThread">
        /// [In] True if this is the main thread of this process. The main thread is the
        /// first thread to start.
        /// </param>
        /// <param name="GlobalThreadIndex">
        /// [In] Unique to kernel compute thread index.
        /// </param>
        /// <param name="pComputeKernel">
        /// [In] DkmGPUComputeKernel represents a GPU compute kernel running in the target
        /// process.
        /// </param>
        /// <param name="pNativeThread">
        /// [In,Optional] The native thread on which an exception is raised to notify the
        /// debugger that a GPU debug event is available.
        /// </param>
        /// <param name="pSystem">
        /// [In,Optional] Describes traits of the thread which are relevant to a full Win32
        /// thread. Currently, this value is required, and all threads will have a 'System'
        /// block. In the future, this value may be NULL if the DkmThread represents
        /// something other than a full Win32 thread.
        /// </param>
        /// <param name="DataItem">
        /// [In] Data object to add to the new DkmGPUComputeThread instance.
        /// DkmDataItem::Null() in the case that the caller doesn't need to add a data item.
        /// </param>
        /// <param name="ppCreatedObject">
        /// [Out] Result of this method call.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ DkmProcess* pProcess,
            _In_ UINT64 NativeStartAddress,
            _In_ bool IsMainThread,
            _In_ UINT64 GlobalThreadIndex,
            _In_ GPU::DkmGPUComputeKernel* pComputeKernel,
            _In_opt_ DkmThread* pNativeThread,
            _In_opt_ const DkmThread::System* pSystem,
            _In_ const DkmDataItem& DataItem,
            _Deref_out_ GPU::DkmGPUComputeThread** ppCreatedObject
            );

        /// <summary>
        /// Get the dimension of the thread block.
        /// </summary>
        /// <param name="pThreadDimensions">
        /// [Out] Thread group dimensions.
        ///
        /// The memory for the DkmArray members is allocated by the method implementation
        /// using DkmAllocBytes/DkmAllocArray. It is freed by the caller using the
        /// CAutoDkmArray template or with DkmFreeMemory and manual element release.
        /// </param>
        /// <param name="pNumberOfDimensions">
        /// [Out] Number of Thread block dimensions.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetThisThreadDimension(
            _Out_ DkmArray<UINT32>* pThreadDimensions,
            _Out_ UINT32* pNumberOfDimensions
            );

        /// <summary>
        /// Get the dimension of the thread block.
        /// </summary>
        /// <param name="pGroupDimensions">
        /// [Out] Grid dimensions.
        ///
        /// The memory for the DkmArray members is allocated by the method implementation
        /// using DkmAllocBytes/DkmAllocArray. It is freed by the caller using the
        /// CAutoDkmArray template or with DkmFreeMemory and manual element release.
        /// </param>
        /// <param name="pNumberOfDimensions">
        /// [Out] Number of Grid dimensions.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetThisGroupDimension(
            _Out_ DkmArray<UINT32>* pGroupDimensions,
            _Out_ UINT32* pNumberOfDimensions
            );

        /// <summary>
        /// Get the dimension of the thread block.
        /// </summary>
        /// <param name="pThreadDimensions">
        /// [Out] Thread group dimensions.
        ///
        /// The memory for the DkmArray members is allocated by the method implementation
        /// using DkmAllocBytes/DkmAllocArray. It is freed by the caller using the
        /// CAutoDkmArray template or with DkmFreeMemory and manual element release.
        /// </param>
        /// <param name="pNumberOfDimensions">
        /// [Out] Number of Thread block dimensions.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetThreadId(
            _Out_ DkmArray<UINT32>* pThreadDimensions,
            _Out_ UINT32* pNumberOfDimensions
            );

        /// <summary>
        /// Get the dimension of the thread block.
        /// </summary>
        /// <param name="pGroupDimensions">
        /// [Out] Grid dimensions.
        ///
        /// The memory for the DkmArray members is allocated by the method implementation
        /// using DkmAllocBytes/DkmAllocArray. It is freed by the caller using the
        /// CAutoDkmArray template or with DkmFreeMemory and manual element release.
        /// </param>
        /// <param name="pNumberOfDimensions">
        /// [Out] Number of Grid dimensions.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetGroupId(
            _Out_ DkmArray<UINT32>* pGroupDimensions,
            _Out_ UINT32* pNumberOfDimensions
            );

        /// <summary>
        /// Read the memory of the target GPU process. The method is on DkmGPUComputeThread
        /// because it may read thread local memory, group shared memory or global memory.
        /// </summary>
        /// <param name="Address">
        /// [In] The address from which to read the target GPU process's memory.
        /// </param>
        /// <param name="InstructionPointer">
        /// [In] The instruction pointer where to resolve address to register location.
        /// </param>
        /// <param name="Flags">
        /// [In] Flags controlling the behavior of DkmProcess.ReadMemory and
        /// DkmProcess.ReadMemoryString.
        /// </param>
        /// <param name="pBuffer">
        /// [In,Out] A buffer that receives the contents from the address space of the target
        /// process. On failure, the content of this buffer is unspecified.
        /// </param>
        /// <param name="Size">
        /// [In] The number of bytes to be read from the process. In scenarios where the call
        /// is marshalled to the remote debugger from the IDE, this must be less than 25 MBs.
        /// </param>
        /// <param name="pBytesRead">
        /// [Out,Optional] Indicates the number of bytes read from the target GPU process. If
        /// DkmReadMemoryFlags.AllowPartialRead is clear, on success this value will always
        /// be exactly equal to the input size. If DkmReadMemoryFlags.AllowPartialRead is
        /// specified, on success, this value will be greater than zero.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ReadMemory(
            _In_ UINT64 Address,
            _In_ UINT64 InstructionPointer,
            _In_ DkmReadMemoryFlags_t Flags,
            _Out_capcount_(Size) void* pBuffer,
            _In_ UINT32 Size,
            _Out_ UINT32* pBytesRead
            );

        /// <summary>
        /// Writes memory to the target GPU process. The method is on DkmGPUComputeThread
        /// because it may write thread local memory, group shared memory or global memory.
        /// </summary>
        /// <param name="Address">
        /// [In] The base address from which to write the target GPU process's memory.
        /// </param>
        /// <param name="InstructionPointer">
        /// [In] The instruction pointer where to resolve address to register location.
        /// </param>
        /// <param name="Data">
        /// [In] Data to be written in the address space of the specified GPU process.
        ///
        /// The memory for the DkmArray members is allocated by the caller, and can be from
        /// any source (stack memory, static buffer, heap, etc). The implementation should
        /// not modify the members.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE WriteMemory(
            _In_ UINT64 Address,
            _In_ UINT64 InstructionPointer,
            _In_ const DkmArray<BYTE>& Data
            );

        /// <summary>
        /// Checks if a tag for a buffer has been forwarded for this kernel execution.
        /// </summary>
        /// <param name="InputTag">
        /// [In] The C++ AMP pointer tag.
        /// </param>
        /// <param name="pForwardedTag">
        /// [Out] The forwarded tag value.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE UpdateBufferTag(
            _In_ UINT32 InputTag,
            _Out_ UINT32* pForwardedTag
            );

        /// <summary>
        /// Validate the specified GPU memory address.
        /// </summary>
        /// <param name="Address">
        /// [In] The address to validate.
        /// </param>
        /// <param name="pIsValidGpuMemoryAddress">
        /// [Out] True if the specified address is a valid GPU memory address, false
        /// otherwise.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ValidateAddress(
            _In_ UINT64 Address,
            _Out_ bool* pIsValidGpuMemoryAddress
            );

        /// <summary>
        /// Obtain the list of all register descriptions from the GPU compute thread.
        /// </summary>
        /// <param name="pRegisterDescriptions">
        /// [Out] The list of all register descriptions from the GPU compute thread.
        ///
        /// The memory for the DkmArray members is allocated by the method implementation
        /// using DkmAllocBytes/DkmAllocArray. It is freed by the caller using the
        /// CAutoDkmArray template or with DkmFreeMemory and manual element release.
        /// </param>
        /// <returns>
        /// S_OK is returned if pRegisterDescriptions contains any elements, S_FALSE is
        /// indicates the array is empty, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetRegisterDescriptions(
            _Out_ DkmArray<GPU::DkmGPURegisterDescription>* pRegisterDescriptions
            );

        /// <summary>
        /// Set the value of a register in the GPU compute thread.
        /// </summary>
        /// <param name="RegisterDescription">
        /// [In] The description of a register from the GPU compute thread.
        /// </param>
        /// <param name="pRegisterValue">
        /// [In] The value bytes of a register to be written in the GPU compute thread.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE SetRegisterValue(
            _In_ const GPU::DkmGPURegisterDescription& RegisterDescription,
            _In_ DkmReadOnlyCollection<BYTE>* pRegisterValue
            );
    }; // end of DkmGPUComputeThread

    // Represents an address in GPU data. The high 32-bit in Value is tag and the low 32-bit
    // in Value is offset.
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("5d7ae46a-0766-92b7-31f0-466dabc07582") DkmGPUDataAddress : public Evaluation::DkmDataAddress
    {
        // Use DkmGPUDataAddress::Create to create this object
        private: DkmGPUDataAddress();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmGPUDataAddress();
        // This object cannot be copied
        private: DkmGPUDataAddress& operator=(const DkmGPUDataAddress&);
        private: DkmGPUDataAddress(const DkmGPUDataAddress&);

        private: GPU::DkmGPUComputeThread* const m_pComputeThread;
        private: const UINT64 m_InstructionPointer;
        private: void* m__pExtendedData;

        // DkmGPUComputeThread represents a compute thread running in the GPU target process.
        public: _Ret_ DECLSPEC_NOTHROW GPU::DkmGPUComputeThread* STDMETHODCALLTYPE ComputeThread(
            );

        // GPU data address may correspond to different register location at different
        // instruction pointer.
        public: DECLSPEC_NOTHROW UINT64 STDMETHODCALLTYPE InstructionPointer(
            );

        /// <summary>
        /// Create a new DkmGPUDataAddress object instance.
        /// </summary>
        /// <param name="pRuntimeInstance">
        /// [In] The DkmRuntimeInstance class represents an execution environment which is
        /// loaded into a DkmProcess and which contains code to be debugged.
        /// </param>
        /// <param name="Value">
        /// [In] Data address.
        /// </param>
        /// <param name="pInstructionAddress">
        /// [In,Optional] Set when the data address is an instruction address.
        /// </param>
        /// <param name="pComputeThread">
        /// [In] DkmGPUComputeThread represents a compute thread running in the GPU target
        /// process.
        /// </param>
        /// <param name="InstructionPointer">
        /// [In] GPU data address may correspond to different register location at different
        /// instruction pointer.
        /// </param>
        /// <param name="ppCreatedObject">
        /// [Out] Result of this method call.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ DkmRuntimeInstance* pRuntimeInstance,
            _In_ UINT64 Value,
            _In_opt_ DkmInstructionAddress* pInstructionAddress,
            _In_ GPU::DkmGPUComputeThread* pComputeThread,
            _In_ UINT64 InstructionPointer,
            _Deref_out_ GPU::DkmGPUDataAddress** ppCreatedObject
            );
    }; // end of DkmGPUDataAddress

    // Provides information about a GPU memory access exception which was raised in the
    // target process.
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("1930c922-5906-c29d-d51b-a59e5c8d4227") DkmGPUMemoryAccessExceptionInformation : public Exceptions::DkmExceptionInformation
    {
        // Use DkmGPUMemoryAccessExceptionInformation::Create to create this object
        private: DkmGPUMemoryAccessExceptionInformation();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmGPUMemoryAccessExceptionInformation();
        // This object cannot be copied
        private: DkmGPUMemoryAccessExceptionInformation& operator=(const DkmGPUMemoryAccessExceptionInformation&);
        private: DkmGPUMemoryAccessExceptionInformation(const DkmGPUMemoryAccessExceptionInformation&);

        private: const UINT64 m_ConflictingInstructionAddress;
        private: const UINT64 m_ConflictingThreadGlobalIndex;
        private: void* m__pExtendedData;

        // The address of the conflicting instruction.
        public: DECLSPEC_NOTHROW UINT64 STDMETHODCALLTYPE ConflictingInstructionAddress(
            );

        // The global id of the conflicting thread.
        public: DECLSPEC_NOTHROW UINT64 STDMETHODCALLTYPE ConflictingThreadGlobalIndex(
            );

        // Attempt to cast a 'DkmExceptionInformation' to a 'DkmGPUMemoryAccessExceptionInformation'. Return
        // NULL if the path object is not a 'DkmGPUMemoryAccessExceptionInformation'.
        // pGPUMemoryAccessException : [In,Optional] Object to attempt to cast
        // Return Value : [Optional] Result of the cast.
        public: static DECLSPEC_NOTHROW DkmGPUMemoryAccessExceptionInformation* TryCast(
            DkmExceptionInformation* pException
            )
        {
            if (pException == NULL || pException->TagValue() != Tag::GPUMemoryAccessException)
                return NULL;

            return static_cast<DkmGPUMemoryAccessExceptionInformation*>(pException);
        }

        /// <summary>
        /// Create a new DkmGPUMemoryAccessExceptionInformation object instance.
        /// </summary>
        /// <param name="pRuntimeInstance">
        /// [In] The DkmRuntimeInstance class represents an execution environment which is
        /// loaded into a DkmProcess and which contains code to be debugged.
        /// </param>
        /// <param name="pThread">
        /// [In] DkmThread represents a thread running in the target process.
        /// </param>
        /// <param name="pInstructionAddress">
        /// [In,Optional] Address where the exception occurred. This will always be present
        /// for C++ and Win32 exceptions. It may be missing from CLR exceptions or MDAs as
        /// these may originate from inside the runtime.
        /// </param>
        /// <param name="pName">
        /// [In,Optional] Name of the exception. For C++ or CLR exceptions, this is the type
        /// name. This value will be null for exception categories that identify exceptions
        /// by code (ex: Win32).
        /// </param>
        /// <param name="Code">
        /// [In] 32-bit integer code for the exception. For Win32 exceptions, this is the
        /// code passed to RaiseException (ex:EXCEPTION_ACCESS_VIOLATION). This value is zero
        /// for exception categories that identify exceptions by string (ex: CLR).
        /// </param>
        /// <param name="ProcessingStage">
        /// [In] The debugger receives notifications from the target process at various
        /// stages within exception processing (ex: exception thrown, exception unhandled).
        /// This enumeration indicates the stage(s) for a notification.
        /// </param>
        /// <param name="ConflictingInstructionAddress">
        /// [In] The address of the conflicting instruction.
        /// </param>
        /// <param name="ConflictingThreadGlobalIndex">
        /// [In] The global id of the conflicting thread.
        /// </param>
        /// <param name="ppCreatedObject">
        /// [Out] Result of this method call.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ DkmRuntimeInstance* pRuntimeInstance,
            _In_ DkmThread* pThread,
            _In_opt_ DkmInstructionAddress* pInstructionAddress,
            _In_opt_ DkmString* pName,
            _In_ UINT32 Code,
            _In_ Exceptions::DkmExceptionProcessingStage_t ProcessingStage,
            _In_ UINT64 ConflictingInstructionAddress,
            _In_ UINT64 ConflictingThreadGlobalIndex,
            _Deref_out_ GPU::DkmGPUMemoryAccessExceptionInformation** ppCreatedObject
            );
    }; // end of DkmGPUMemoryAccessExceptionInformation

}; // end namespace GPU

// Contains types specific to extending the debugger to support a custom execution
// environment.
namespace CustomRuntimes {
    // Provides information about an exception which was raised in the target process. Custom
    // exceptions are used for C++ Runtime checks, Managed Debugging Assistant failures, and
    // exceptions from 3rd party runtimes.
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("7572c08d-ef31-438a-9324-21d72ad99c65") DkmCustomExceptionInformation : public Exceptions::DkmExceptionInformation
    {
        // Use DkmCustomExceptionInformation::Create to create this object
        private: DkmCustomExceptionInformation();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmCustomExceptionInformation();
        // This object cannot be copied
        private: DkmCustomExceptionInformation& operator=(const DkmCustomExceptionInformation&);
        private: DkmCustomExceptionInformation(const DkmCustomExceptionInformation&);

        private: OPTIONAL DkmReadOnlyCollection<BYTE>* const m_pAdditionalInformation;
        private: void* m__pExtendedData;

        // [Optional] Additional data about this custom exception. Format is defined by the
        // custom exception type.
        public: _Ret_opt_ DECLSPEC_NOTHROW DkmReadOnlyCollection<BYTE>* STDMETHODCALLTYPE AdditionalInformation(
            );

        // Attempt to cast a 'DkmExceptionInformation' to a 'DkmCustomExceptionInformation'. Return
        // NULL if the path object is not a 'DkmCustomExceptionInformation'.
        // pCustomException : [In,Optional] Object to attempt to cast
        // Return Value : [Optional] Result of the cast.
        public: static DECLSPEC_NOTHROW DkmCustomExceptionInformation* TryCast(
            DkmExceptionInformation* pException
            )
        {
            if (pException == NULL || pException->TagValue() != Tag::CustomException)
                return NULL;

            return static_cast<DkmCustomExceptionInformation*>(pException);
        }

        /// <summary>
        /// Create a new DkmCustomExceptionInformation object instance.
        /// </summary>
        /// <param name="pRuntimeInstance">
        /// [In] The DkmRuntimeInstance class represents an execution environment which is
        /// loaded into a DkmProcess and which contains code to be debugged.
        /// </param>
        /// <param name="ExceptionCategory">
        /// [In] Indicates the type of exception.
        /// </param>
        /// <param name="pThread">
        /// [In] DkmThread represents a thread running in the target process.
        /// </param>
        /// <param name="pInstructionAddress">
        /// [In,Optional] Address where the exception occurred. This will always be present
        /// for C++ and Win32 exceptions. It may be missing from CLR exceptions or MDAs as
        /// these may originate from inside the runtime.
        /// </param>
        /// <param name="pName">
        /// [In,Optional] Name of the exception. For C++ or CLR exceptions, this is the type
        /// name. This value will be null for exception categories that identify exceptions
        /// by code (ex: Win32).
        /// </param>
        /// <param name="Code">
        /// [In] 32-bit integer code for the exception. For Win32 exceptions, this is the
        /// code passed to RaiseException (ex:EXCEPTION_ACCESS_VIOLATION). This value is zero
        /// for exception categories that identify exceptions by string (ex: CLR).
        /// </param>
        /// <param name="ProcessingStage">
        /// [In] The debugger receives notifications from the target process at various
        /// stages within exception processing (ex: exception thrown, exception unhandled).
        /// This enumeration indicates the stage(s) for a notification.
        /// </param>
        /// <param name="pImplementationException">
        /// [In,Optional] Information about the underlying exception used to implement a
        /// higher level exception. For example, CLR and C++ exceptions may be implemented on
        /// top of Win32 exceptions. So this may store the DkmWin32ExceptionInformation for
        /// CLR or C++ exceptions.
        /// </param>
        /// <param name="pAdditionalInformation">
        /// [In,Optional] Additional data about this custom exception. Format is defined by
        /// the custom exception type.
        /// </param>
        /// <param name="ppCreatedObject">
        /// [Out] Result of this method call.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ DkmRuntimeInstance* pRuntimeInstance,
            _In_ const GUID& ExceptionCategory,
            _In_ DkmThread* pThread,
            _In_opt_ DkmInstructionAddress* pInstructionAddress,
            _In_opt_ DkmString* pName,
            _In_ UINT32 Code,
            _In_ Exceptions::DkmExceptionProcessingStage_t ProcessingStage,
            _In_opt_ Exceptions::DkmExceptionInformation* pImplementationException,
            _In_opt_ DkmReadOnlyCollection<BYTE>* pAdditionalInformation,
            _Deref_out_ CustomRuntimes::DkmCustomExceptionInformation** ppCreatedObject
            );
    }; // end of DkmCustomExceptionInformation

    // DkmCustomInstructionAddress is used for addresses from a custom runtime environment
    // (not native or CLR-based). For example, this could be used in a custom interpreter or
    // Just-In-Time compiler.
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("9205f0c6-3471-83dc-bd08-54c4c7d5dbc8") DkmCustomInstructionAddress : public DkmInstructionAddress
    {
        // Use DkmCustomInstructionAddress::Create to create this object
        private: DkmCustomInstructionAddress();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmCustomInstructionAddress();
        // This object cannot be copied
        private: DkmCustomInstructionAddress& operator=(const DkmCustomInstructionAddress&);
        private: DkmCustomInstructionAddress(const DkmCustomInstructionAddress&);

        private: OPTIONAL DkmReadOnlyCollection<BYTE>* const m_pEntityId;
        private: const UINT64 m_Offset;
        private: OPTIONAL DkmReadOnlyCollection<BYTE>* const m_pAdditionalData;
        private: void* m__pExtendedData;

        // The module containing the InstructionPointer.
        public: _Ret_ DECLSPEC_NOTHROW CustomRuntimes::DkmCustomModuleInstance* STDMETHODCALLTYPE ModuleInstance(
            );

        // [Optional] This is a runtime-specific data structure which custom runtimes may use
        // to store the location of this instruction. Along with 'offset', this field will
        // used to compare two instructions from the same module.
        public: _Ret_opt_ DECLSPEC_NOTHROW DkmReadOnlyCollection<BYTE>* STDMETHODCALLTYPE EntityId(
            );

        // Along with 'EntityId' the 'Offset' field is used to uniquely identity an
        // instruction. This could hold a pointer value (such as a pointer to the
        // instruction) or an offset from the start of the function/module.
        public: DECLSPEC_NOTHROW UINT64 STDMETHODCALLTYPE Offset(
            );

        // [Optional] Additional runtime-specific data associated with an address. This data
        // will not be used when comparing addresses.
        public: _Ret_opt_ DECLSPEC_NOTHROW DkmReadOnlyCollection<BYTE>* STDMETHODCALLTYPE AdditionalData(
            );

        // Attempt to cast a 'DkmInstructionAddress' to a 'DkmCustomInstructionAddress'. Return
        // NULL if the path object is not a 'DkmCustomInstructionAddress'.
        // pCustomAddress : [In,Optional] Object to attempt to cast
        // Return Value : [Optional] Result of the cast.
        public: static DECLSPEC_NOTHROW DkmCustomInstructionAddress* TryCast(
            DkmInstructionAddress* pInstructionAddress
            )
        {
            if (pInstructionAddress == NULL || pInstructionAddress->TagValue() != Tag::CustomAddress)
                return NULL;

            return static_cast<DkmCustomInstructionAddress*>(pInstructionAddress);
        }

        /// <summary>
        /// Create a new DkmCustomInstructionAddress object instance.
        /// </summary>
        /// <param name="pRuntimeInstance">
        /// [In] The DkmRuntimeInstance class represents an execution environment which is
        /// loaded into a DkmProcess and which contains code to be debugged.
        /// </param>
        /// <param name="pModuleInstance">
        /// [In] The module containing the InstructionPointer.
        /// </param>
        /// <param name="pEntityId">
        /// [In,Optional] This is a runtime-specific data structure which custom runtimes may
        /// use to store the location of this instruction. Along with 'offset', this field
        /// will used to compare two instructions from the same module.
        /// </param>
        /// <param name="Offset">
        /// [In] Along with 'EntityId' the 'Offset' field is used to uniquely identity an
        /// instruction. This could hold a pointer value (such as a pointer to the
        /// instruction) or an offset from the start of the function/module.
        /// </param>
        /// <param name="pAdditionalData">
        /// [In,Optional] Additional runtime-specific data associated with an address. This
        /// data will not be used when comparing addresses.
        /// </param>
        /// <param name="pCPUInstruction">
        /// [In,Optional] CPUInstruction provides the address that the CPU will execute. This
        /// is always provided for native instructions. It may be provided for CLR or custom
        /// addresses depending on how the address object was created.
        /// </param>
        /// <param name="ppCreatedObject">
        /// [Out] Result of this method call.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ DkmRuntimeInstance* pRuntimeInstance,
            _In_ CustomRuntimes::DkmCustomModuleInstance* pModuleInstance,
            _In_opt_ DkmReadOnlyCollection<BYTE>* pEntityId,
            _In_ UINT64 Offset,
            _In_opt_ DkmReadOnlyCollection<BYTE>* pAdditionalData,
            _In_opt_ const DkmInstructionAddress::CPUInstruction* pCPUInstruction,
            _Deref_out_ CustomRuntimes::DkmCustomInstructionAddress** ppCreatedObject
            );
    }; // end of DkmCustomInstructionAddress

    // DkmCustomInstructionSymbol is used to represent an executable statement in any type of
    // custom runtime environment.
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("c154cde9-82a7-6e6f-f4f4-8dbb776da068") DkmCustomInstructionSymbol : public Symbols::DkmInstructionSymbol
    {
        // Use DkmCustomInstructionSymbol::Create to create this object
        private: DkmCustomInstructionSymbol();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmCustomInstructionSymbol();
        // This object cannot be copied
        private: DkmCustomInstructionSymbol& operator=(const DkmCustomInstructionSymbol&);
        private: DkmCustomInstructionSymbol(const DkmCustomInstructionSymbol&);

        private: OPTIONAL DkmReadOnlyCollection<BYTE>* const m_pEntityId;
        private: const UINT64 m_Offset;
        private: OPTIONAL DkmReadOnlyCollection<BYTE>* const m_pAdditionalData;
        private: void* m__pExtendedData;

        // [Optional] This is a runtime-specific data structure which custom runtimes may use
        // to store the location of this instruction. Along with 'offset', this field will
        // used to compare two instructions from the same module.
        public: _Ret_opt_ DECLSPEC_NOTHROW DkmReadOnlyCollection<BYTE>* STDMETHODCALLTYPE EntityId(
            );

        // Along with 'EntityId' the 'Offset' field is used to uniquely identity an
        // instruction. This could hold a pointer value (such as a pointer to the
        // instruction) or an offset from the start of the function/module.
        public: DECLSPEC_NOTHROW UINT64 STDMETHODCALLTYPE Offset(
            );

        // [Optional] Additional runtime-specific data associated with an address. This data
        // will not be used when comparing addresses.
        public: _Ret_opt_ DECLSPEC_NOTHROW DkmReadOnlyCollection<BYTE>* STDMETHODCALLTYPE AdditionalData(
            );

        // Attempt to cast a 'DkmInstructionSymbol' to a 'DkmCustomInstructionSymbol'. Return
        // NULL if the path object is not a 'DkmCustomInstructionSymbol'.
        // pCustomInstruction : [In,Optional] Object to attempt to cast
        // Return Value : [Optional] Result of the cast.
        public: static DECLSPEC_NOTHROW DkmCustomInstructionSymbol* TryCast(
            DkmInstructionSymbol* pInstruction
            )
        {
            if (pInstruction == NULL || pInstruction->TagValue() != Tag::CustomInstruction)
                return NULL;

            return static_cast<DkmCustomInstructionSymbol*>(pInstruction);
        }

        /// <summary>
        /// Create a new DkmCustomInstructionSymbol object instance.
        /// </summary>
        /// <param name="pModule">
        /// [In] The DkmModule class represents a code bundle (ex: dll or exe) which is or
        /// once was loaded into one or more processes. The DkmModule class is the central
        /// object to the symbol APIs, and is 1:1 with the symbol handler's notation of what
        /// is loaded. If a code bundle loads into three different processes (or the same
        /// process but with three different base addresses or three different app domains)
        /// but the symbol handler thinks of all of these as being identical, there will be
        /// only one module object.
        /// </param>
        /// <param name="RuntimeType">
        /// [In] The Runtime Id identifies the execution environment for a particular piece
        /// of code. Runtime Ids are used by the dispatcher to decide which monitor to
        /// dispatch to. Note that the ordering of the runtime ID Guids is somewhat
        /// significant as this dictates which runtime gets the first shot during
        /// arbitration. Thus, if one wants to declare a new runtime instance which is built
        /// on the CLR, the runtime id should be less than DkmRuntimeId.Clr.
        /// </param>
        /// <param name="pEntityId">
        /// [In,Optional] This is a runtime-specific data structure which custom runtimes may
        /// use to store the location of this instruction. Along with 'offset', this field
        /// will used to compare two instructions from the same module.
        /// </param>
        /// <param name="Offset">
        /// [In] Along with 'EntityId' the 'Offset' field is used to uniquely identity an
        /// instruction. This could hold a pointer value (such as a pointer to the
        /// instruction) or an offset from the start of the function/module.
        /// </param>
        /// <param name="pAdditionalData">
        /// [In,Optional] Additional runtime-specific data associated with an address. This
        /// data will not be used when comparing addresses.
        /// </param>
        /// <param name="ppCreatedObject">
        /// [Out] Result of this method call.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ Symbols::DkmModule* pModule,
            _In_ const GUID& RuntimeType,
            _In_opt_ DkmReadOnlyCollection<BYTE>* pEntityId,
            _In_ UINT64 Offset,
            _In_opt_ DkmReadOnlyCollection<BYTE>* pAdditionalData,
            _Deref_out_ CustomRuntimes::DkmCustomInstructionSymbol** ppCreatedObject
            );
    }; // end of DkmCustomInstructionSymbol

    // 'DkmCustomModuleInstance' is used for modules from a custom runtime environment (not
    // native or CLR-based). For example, this could be used in a custom interpreter or
    // Just-In-Time compiler.
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("28a2ee07-bdcf-31f8-66e9-09b958e66fe8") DkmCustomModuleInstance : public DkmModuleInstance
    {
        // Use DkmCustomModuleInstance::Create to create this object
        private: DkmCustomModuleInstance();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmCustomModuleInstance();
        // This object cannot be copied
        private: DkmCustomModuleInstance& operator=(const DkmCustomModuleInstance&);
        private: DkmCustomModuleInstance(const DkmCustomModuleInstance&);

        private: void* m__pExtendedData;

        // Attempt to cast a 'DkmModuleInstance' to a 'DkmCustomModuleInstance'. Return
        // NULL if the path object is not a 'DkmCustomModuleInstance'.
        // pCustomModuleInstance : [In,Optional] Object to attempt to cast
        // Return Value : [Optional] Result of the cast.
        public: static DECLSPEC_NOTHROW DkmCustomModuleInstance* TryCast(
            DkmModuleInstance* pModuleInstance
            )
        {
            if (pModuleInstance == NULL || pModuleInstance->TagValue() != Tag::CustomModuleInstance)
                return NULL;

            return static_cast<DkmCustomModuleInstance*>(pModuleInstance);
        }

        /// <summary>
        /// Create a new DkmCustomModuleInstance object instance.
        ///
        /// This method will send a ModuleInstanceLoad event.
        /// </summary>
        /// <param name="pName">
        /// [In] Short representation of the module name. For file-based modules, this  is
        /// the file name and extension (ex: kernel32.dll).
        /// </param>
        /// <param name="pFullName">
        /// [In] Fully qualified module name. For file-based modules, this is the full path
        /// to the module (ex: c:\windows\system32\kernel32.dll.
        /// </param>
        /// <param name="TimeDateStamp">
        /// [In] Date/Time of when the loaded module was built. This value is obtained from
        /// the IMAGE_NT_HEADERS of the loaded module. The unit of measurement is a  FILETIME
        /// value, which is a 64-bit value representing the number of 100-nanosecond
        /// intervals since January 1, 1601 (UTC).
        /// </param>
        /// <param name="pRuntimeInstance">
        /// [In] The DkmRuntimeInstance class represents an execution environment which is
        /// loaded into a DkmProcess and which contains code to be debugged.
        /// </param>
        /// <param name="pVersion">
        /// [In,Optional] File version information.
        /// </param>
        /// <param name="pSymbolFileId">
        /// [In,Optional] Contains information needed to locate symbols for this module. On
        /// Win32, this information is contained within the IMAGE_DEBUG_DIRECTORY.
        /// </param>
        /// <param name="Flags">
        /// [In] Flags which indicate traits of a DkmModuleInstance.
        /// </param>
        /// <param name="MemoryLayout">
        /// [In] Enumeration that indicates how a module is laid out in memory.
        /// </param>
        /// <param name="BaseAddress">
        /// [In,Optional] The starting memory address of where the module loaded. This value
        /// will be zero if the module did not load in a contiguous block of memory.
        /// </param>
        /// <param name="LoadOrder">
        /// [In] The integer count of the number of module instances that have loaded up to
        /// and including this module. Each runtime instance keeps track of its own load
        /// order count.
        /// </param>
        /// <param name="Size">
        /// [In,Optional] The number of bytes in the module's memory region. This value will
        /// be zero if the module did not load in a contiguous block of memory.
        /// </param>
        /// <param name="pLoadContext">
        /// [In] String description of the context under which this module has been loaded.
        /// ex: 'Win32' or 'CLR v2.0.50727: Default Domain'.
        /// </param>
        /// <param name="IsDisabled">
        /// [In] Indicates if this module instance has been disabled. Disabled modules are
        /// largely ignored by the debugger. For native modules, the address range of the
        /// disabled module is treated as if it is unmapped. For CLR modules, any frames from
        /// these modules is hidden from the call stack.
        /// </param>
        /// <param name="pModule">
        /// [In,Optional] The symbol handler's representation of a module (DkmModule) which
        /// is associated with this module instance. This value is initially null, and is
        /// assigned if and when symbols are associated with this module instance.
        /// </param>
        /// <param name="pMinidumpInfo">
        /// [In,Optional] 'MinidumpInfo' is used to convey additional information about
        /// modules in a DkmProcess for a minidump.
        /// </param>
        /// <param name="DataItem">
        /// [In] Data object to add to the new DkmCustomModuleInstance instance.
        /// DkmDataItem::Null() in the case that the caller doesn't need to add a data item.
        /// </param>
        /// <param name="ppCreatedObject">
        /// [Out] Result of this method call.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ DkmString* pName,
            _In_ DkmString* pFullName,
            _In_ UINT64 TimeDateStamp,
            _In_ DkmRuntimeInstance* pRuntimeInstance,
            _In_opt_ DkmModuleVersion* pVersion,
            _In_opt_ Symbols::DkmSymbolFileId* pSymbolFileId,
            _In_ DkmModuleFlags_t Flags,
            _In_ DkmModuleMemoryLayout_t MemoryLayout,
            _In_ UINT64 BaseAddress,
            _In_ UINT32 LoadOrder,
            _In_ UINT32 Size,
            _In_ DkmString* pLoadContext,
            _In_ bool IsDisabled,
            _In_opt_ Symbols::DkmModule* pModule,
            _In_opt_ const DkmModuleInstance::MinidumpInfo* pMinidumpInfo,
            _In_ const DkmDataItem& DataItem,
            _Deref_out_ CustomRuntimes::DkmCustomModuleInstance** ppCreatedObject
            );
    }; // end of DkmCustomModuleInstance

    // Represents the custom execution environment executing in the target process.
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("83e44dea-5cac-3e7d-c980-118728716623") DkmCustomRuntimeInstance : public DkmRuntimeInstance
    {
        // Use DkmCustomRuntimeInstance::Create to create this object
        private: DkmCustomRuntimeInstance();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmCustomRuntimeInstance();
        // This object cannot be copied
        private: DkmCustomRuntimeInstance& operator=(const DkmCustomRuntimeInstance&);
        private: DkmCustomRuntimeInstance(const DkmCustomRuntimeInstance&);

        private: void* m__pExtendedData;

        // Attempt to cast a 'DkmRuntimeInstance' to a 'DkmCustomRuntimeInstance'. Return
        // NULL if the path object is not a 'DkmCustomRuntimeInstance'.
        // pCustomRuntimeInstance : [In,Optional] Object to attempt to cast
        // Return Value : [Optional] Result of the cast.
        public: static DECLSPEC_NOTHROW DkmCustomRuntimeInstance* TryCast(
            DkmRuntimeInstance* pRuntimeInstance
            )
        {
            if (pRuntimeInstance == NULL || pRuntimeInstance->TagValue() != Tag::CustomRuntimeInstance)
                return NULL;

            return static_cast<DkmCustomRuntimeInstance*>(pRuntimeInstance);
        }

        /// <summary>
        /// Creates a new runtime instance object from a debug monitor. This method must be
        /// called from the event thread when a debug monitor detects that a new runtime
        /// instance has loaded (for example, when the corresponding runtime dll loads in the
        /// target process).
        ///
        /// This method will send a RuntimeInstanceLoad event.
        /// </summary>
        /// <param name="pProcess">
        /// [In] DkmProcess represents a target process which is being debugged. The debugger
        /// debugs processes, so this is the basic unit of debugging. A DkmProcess can
        /// represent a system process or a virtual process such as minidumps.
        /// </param>
        /// <param name="Id">
        /// [In] Identifies a DkmRuntimeInstance object within a process.
        /// </param>
        /// <param name="DataItem">
        /// [In] Data object to add to the new DkmCustomRuntimeInstance instance.
        /// DkmDataItem::Null() in the case that the caller doesn't need to add a data item.
        /// </param>
        /// <param name="ppCreatedObject">
        /// [Out] Result of this method call.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ DkmProcess* pProcess,
            _In_ const DkmRuntimeInstanceId& Id,
            _In_ const DkmDataItem& DataItem,
            _Deref_out_ CustomRuntimes::DkmCustomRuntimeInstance** ppCreatedObject
            );

        /// <summary>
        /// Creates a new runtime instance object from a debug monitor. This method must be
        /// called from the event thread when a debug monitor detects that a new runtime
        /// instance has loaded (for example, when the corresponding runtime dll loads in the
        /// target process).
        ///
        /// This method will send a RuntimeInstanceLoad event.
        ///
        /// This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
        /// </summary>
        /// <param name="pProcess">
        /// [In] DkmProcess represents a target process which is being debugged. The debugger
        /// debugs processes, so this is the basic unit of debugging. A DkmProcess can
        /// represent a system process or a virtual process such as minidumps.
        /// </param>
        /// <param name="Id">
        /// [In] Identifies a DkmRuntimeInstance object within a process.
        /// </param>
        /// <param name="Capabilities">
        /// [In] Enumeration of runtime capabilities.
        /// </param>
        /// <param name="pParentRuntime">
        /// [In,Optional] For runtimes that are implemented on top of another runtime, this
        /// can optionally be used to indicant the logical parent. This can then be used to
        /// request services from the parent when the child runtime doesn't implement the
        /// service. This is currently used only for obtaining the top stack frame to
        /// evaluate a conditional breakpoint when the child runtime doesn't walk stacks
        /// itself.
        /// </param>
        /// <param name="DataItem">
        /// [In] Data object to add to the new DkmCustomRuntimeInstance instance.
        /// DkmDataItem::Null() in the case that the caller doesn't need to add a data item.
        /// </param>
        /// <param name="ppCreatedObject">
        /// [Out] Result of this method call.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ DkmProcess* pProcess,
            _In_ const DkmRuntimeInstanceId& Id,
            _In_ DkmRuntimeCapabilities_t Capabilities,
            _In_opt_ DkmRuntimeInstance* pParentRuntime,
            _In_ const DkmDataItem& DataItem,
            _Deref_out_ CustomRuntimes::DkmCustomRuntimeInstance** ppCreatedObject
            );
    }; // end of DkmCustomRuntimeInstance

}; // end namespace CustomRuntimes

// Contains types specific to runtime environment agnostic disassembly.
namespace Disassembly {
    // An effective address for an instruction. The effective address is the calculated
    // address that an instruction operand represents. For instance, on x86, an instruction
    // may be of the form dwordptr [esp-12]. The effective address of this operand will be
    // the result of subtracting 12 from esp. The number of operands and effective addresses
    // are architecture specific.
    struct DECLSPEC_UUID("143e24fc-8dcd-826c-1008-a3578f617a79") DkmEffectiveAddress
    {
        // The effective address for the operand.
        UINT64 EffectiveAddress;

        // The size of the operand this address applies to.
        UINT32 OperandSize;

        // Set if the the segment register is FS. Only used on x86.
        Disassembly::DkmEffectiveAddressFlags_t Flags;

        // Release all reference-counted fields within the DkmEffectiveAddress structure.
        static DECLSPEC_NOTHROW void STDMETHODCALLTYPE Release(
            _In_ DkmEffectiveAddress* pItem
            )
        {
            // structure requires no cleanup
        }
    };

    #ifndef EXCLUDE_IDE_ONLY_APIS
    // Contains information about a disassembled instruction in the debuggee. Objects are
    // returned from DkmProcess.Disassemble.
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("0d808671-5c47-a9c5-fffb-5aecb558b2b4") DkmDisassembledInstruction : public IUnknown
    {
        private: ___ReferenceCount_t m_ReferenceCount;
        private: DkmDispatcherObjectFlags_t m_ObjectFlags;
        private: const GUID* m_pTypeId;
        private: size_t m_ObjectGCHandle;
        // Use DkmDisassembledInstruction::Create to create this object
        private: DkmDisassembledInstruction();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmDisassembledInstruction();
        // This object cannot be copied
        private: DkmDisassembledInstruction& operator=(const DkmDisassembledInstruction&);
        private: DkmDisassembledInstruction(const DkmDisassembledInstruction&);

        private: DkmProcess* const m_pProcess;
        private: const UINT64 m_InstructionPointer;
        private: const UINT32 m_InstructionLength;
        private: DkmString* const m_pAddress;
        private: DkmString* const m_pAddressOffset;
        private: DkmString* const m_pCodeBytes;
        private: DkmString* const m_pRawOpcode;
        private: DkmString* const m_pRawOperands;
        private: DkmString* const m_pFormattedOpcode;
        private: DkmString* const m_pFormattedOperands;
        private: OPTIONAL DkmString* const m_pSymbol;
        private: OPTIONAL Symbols::DkmSourcePosition* const m_pDocumentPosition;
        private: const UINT32 m_ByteOffset;
        private: DkmReadOnlyCollection<CV_HREG_e>* const m_pRegisterOperands;
        private: const bool m_ValidInstruction;
        private: void* m__pExtendedData;

        // DkmProcess represents a target process which is being debugged. The debugger
        // debugs processes, so this is the basic unit of debugging. A DkmProcess can
        // represent a system process or a virtual process such as minidumps.
        public: _Ret_ DECLSPEC_NOTHROW DkmProcess* STDMETHODCALLTYPE Process(
            );

        // The address of this instruction in the debuggee address space.
        public: DECLSPEC_NOTHROW UINT64 STDMETHODCALLTYPE InstructionPointer(
            );

        // The length of the instruction in bytes.
        public: DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE InstructionLength(
            );

        // The formatted address of this instruction in the debuggee address space.
        public: _Ret_ DECLSPEC_NOTHROW DkmString* STDMETHODCALLTYPE Address(
            );

        // The address as an offset from some starting point, usually the beginning of the
        // associated function.
        public: _Ret_ DECLSPEC_NOTHROW DkmString* STDMETHODCALLTYPE AddressOffset(
            );

        // The code bytes for this instruction.
        public: _Ret_ DECLSPEC_NOTHROW DkmString* STDMETHODCALLTYPE CodeBytes(
            );

        // The raw opcode for this instruction with no symbolic lookups.
        public: _Ret_ DECLSPEC_NOTHROW DkmString* STDMETHODCALLTYPE RawOpcode(
            );

        // The raw operands for this instruction with no symbolic lookups.
        public: _Ret_ DECLSPEC_NOTHROW DkmString* STDMETHODCALLTYPE RawOperands(
            );

        // The opcode for this instruction including resolved symbol names. If nothing is
        // resolved, this is the same as RawOpcode.
        public: _Ret_ DECLSPEC_NOTHROW DkmString* STDMETHODCALLTYPE FormattedOpcode(
            );

        // The operands for this instruction including resolved symbol names. If nothing is
        // resolved, this is the same as RawOperands.
        public: _Ret_ DECLSPEC_NOTHROW DkmString* STDMETHODCALLTYPE FormattedOperands(
            );

        // [Optional] The symbol name, if any, associated with the address (public symbol,
        // label, and so on).
        public: _Ret_opt_ DECLSPEC_NOTHROW DkmString* STDMETHODCALLTYPE Symbol(
            );

        // [Optional] An optional reference to the document and text position this
        // instruction belongs to in the source document.
        public: _Ret_opt_ DECLSPEC_NOTHROW Symbols::DkmSourcePosition* STDMETHODCALLTYPE DocumentPosition(
            );

        // The number of bytes from the beginning of the corresponding source statement.
        public: DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE ByteOffset(
            );

        // A read only collection of CV constants representing any register arguments in the
        // disassembled instruction.
        public: _Ret_ DECLSPEC_NOTHROW DkmReadOnlyCollection<CV_HREG_e>* STDMETHODCALLTYPE RegisterOperands(
            );

        // True if this instruction was successfully disassembled. False if it is a filler
        // instruction used by heuristic unwinders when an invalid op code is encountered.
        // Most disassembly providers will fill the op code with question marks when this is
        // set to true to indicate a bogus instruction.
        public: DECLSPEC_NOTHROW bool STDMETHODCALLTYPE ValidInstruction(
            );

        /// <summary>
        /// Create a new DkmDisassembledInstruction object instance.
        ///
        /// Location constraint: API must be called from an IDE component (component level
        /// &gt; 100,000).
        /// </summary>
        /// <param name="pProcess">
        /// [In] DkmProcess represents a target process which is being debugged. The debugger
        /// debugs processes, so this is the basic unit of debugging. A DkmProcess can
        /// represent a system process or a virtual process such as minidumps.
        /// </param>
        /// <param name="InstructionPointer">
        /// [In] The address of this instruction in the debuggee address space.
        /// </param>
        /// <param name="InstructionLength">
        /// [In] The length of the instruction in bytes.
        /// </param>
        /// <param name="pAddress">
        /// [In] The formatted address of this instruction in the debuggee address space.
        /// </param>
        /// <param name="pAddressOffset">
        /// [In] The address as an offset from some starting point, usually the beginning of
        /// the associated function.
        /// </param>
        /// <param name="pCodeBytes">
        /// [In] The code bytes for this instruction.
        /// </param>
        /// <param name="pRawOpcode">
        /// [In] The raw opcode for this instruction with no symbolic lookups.
        /// </param>
        /// <param name="pRawOperands">
        /// [In] The raw operands for this instruction with no symbolic lookups.
        /// </param>
        /// <param name="pFormattedOpcode">
        /// [In] The opcode for this instruction including resolved symbol names. If nothing
        /// is resolved, this is the same as RawOpcode.
        /// </param>
        /// <param name="pFormattedOperands">
        /// [In] The operands for this instruction including resolved symbol names. If
        /// nothing is resolved, this is the same as RawOperands.
        /// </param>
        /// <param name="pSymbol">
        /// [In,Optional] The symbol name, if any, associated with the address (public
        /// symbol, label, and so on).
        /// </param>
        /// <param name="pDocumentPosition">
        /// [In,Optional] An optional reference to the document and text position this
        /// instruction belongs to in the source document.
        /// </param>
        /// <param name="ByteOffset">
        /// [In] The number of bytes from the beginning of the corresponding source
        /// statement.
        /// </param>
        /// <param name="pRegisterOperands">
        /// [In] A read only collection of CV constants representing any register arguments
        /// in the disassembled instruction.
        /// </param>
        /// <param name="ValidInstruction">
        /// [In] True if this instruction was successfully disassembled. False if it is a
        /// filler instruction used by heuristic unwinders when an invalid op code is
        /// encountered. Most disassembly providers will fill the op code with question marks
        /// when this is set to true to indicate a bogus instruction.
        /// </param>
        /// <param name="ppCreatedObject">
        /// [Out] Result of this method call.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ DkmProcess* pProcess,
            _In_ UINT64 InstructionPointer,
            _In_ UINT32 InstructionLength,
            _In_ DkmString* pAddress,
            _In_ DkmString* pAddressOffset,
            _In_ DkmString* pCodeBytes,
            _In_ DkmString* pRawOpcode,
            _In_ DkmString* pRawOperands,
            _In_ DkmString* pFormattedOpcode,
            _In_ DkmString* pFormattedOperands,
            _In_opt_ DkmString* pSymbol,
            _In_opt_ Symbols::DkmSourcePosition* pDocumentPosition,
            _In_ UINT32 ByteOffset,
            _In_ DkmReadOnlyCollection<CV_HREG_e>* pRegisterOperands,
            _In_ bool ValidInstruction,
            _Deref_out_ Disassembly::DkmDisassembledInstruction** ppCreatedObject
            );
    }; // end of DkmDisassembledInstruction
    #endif // #ifndef EXCLUDE_IDE_ONLY_APIS

    // Flags that impact the effective address.
    DEFINE_SCOPED_ENUM(DkmEffectiveAddressFlags)
    {
        // No flags applied.
        None = 0x0,
        // Indicates that the segment register is FS. Used only on x86.
        SegmentIsFS = 0x1
    };
    DEFINE_SCOPED_ENUM_FLAG_OPERATORS(DkmEffectiveAddressFlags_t);

}; // end namespace Disassembly

// Contains types used to describe properties of threads running in the target process.
namespace ThreadProperties {
    // Result of an asynchronous DkmThread.GetManagedThreadProperties call.
    struct DkmGetManagedThreadPropertiesAsyncResult
    {
        // HRESULT code returned from the caller. This will be
        // DkmExceptionCode.COR_E_OPERATIONCANCELED (0x8013153B) if the operation was
        // canceled before processing was complete.
        HRESULT ErrorCode;

        // The managed thread id of the thread.
        INT32 ManagedThreadId;
    };

    // Result of an asynchronous DkmRuntimeInstance.GetThreadDisplayProperties call.
    struct DkmGetThreadDisplayPropertiesAsyncResult
    {
        // HRESULT code returned from the caller. This will be
        // DkmExceptionCode.COR_E_OPERATIONCANCELED (0x8013153B) if the operation was
        // canceled before processing was complete.
        HRESULT ErrorCode;

        // [Optional] The Thread Display Name.
        OPTIONAL DkmString* pDisplayName;

        // [Optional] The Thread Name Priority: Values are from DISPLAY_NAME_PRI as defined
        // in MSDBG100.
        UINT32 DisplayNamePriority;

        // [Optional] Values are from THREADCATEGORY as defined in EnvDTE90.dll/.tlb.
        UINT32 ThreadCategory;
    };

    // Result of an asynchronous DkmRuntimeInstance.GetThreadName call.
    struct DkmGetThreadNameAsyncResult
    {
        // HRESULT code returned from the caller. This will be
        // DkmExceptionCode.COR_E_OPERATIONCANCELED (0x8013153B) if the operation was
        // canceled before processing was complete.
        HRESULT ErrorCode;

        // [Optional] The Thread Name.
        OPTIONAL DkmString* pName;
    };

    // Result of an asynchronous DkmThread.GetVolatileFlags call.
    struct DkmGetVolatileFlagsAsyncResult
    {
        // HRESULT code returned from the caller. This will be
        // DkmExceptionCode.COR_E_OPERATIONCANCELED (0x8013153B) if the operation was
        // canceled before processing was complete.
        HRESULT ErrorCode;

        // Volatile flags that apply to a thread. These values are expected to change over
        // time and should not be cached by callers.
        ThreadProperties::DkmVolatileThreadFlags_t Flags;
    };

    // Result of an asynchronous DkmThread.GetVolatileProperties call.
    struct DkmGetVolatilePropertiesAsyncResult
    {
        // HRESULT code returned from the caller. This will be
        // DkmExceptionCode.COR_E_OPERATIONCANCELED (0x8013153B) if the operation was
        // canceled before processing was complete.
        HRESULT ErrorCode;

        // The priority of the thread. The values returned correspond directly to the values
        // defined for kernel32!GetThreadPriority.
        INT32 Priority;

        // The affinity mask of the thread. The values returned correspond directly to the
        // values defined for kernel32!SetThreadAffinityMask.
        UINT64 AffinityMask;
    };

    // Volatile flags that apply to a thread. These values are expected to change over time
    // and should not be cached by callers.
    DEFINE_SCOPED_ENUM(DkmVolatileThreadFlags)
    {
        // No flags are set.
        None = 0x0,
        // The thread is a user-mode scheduled helper or scheduler thread.
        UserModeScheduled = 0x1
    };
    DEFINE_SCOPED_ENUM_FLAG_OPERATORS(DkmVolatileThreadFlags_t);

}; // end namespace ThreadProperties

// Contains types used to provide data to the 'Parallel Tasks' and 'Parallel Stacks'
// debugger windows. Types in this namespace are subject to change in future versions of
// Visual Studio.
namespace ParallelTasks {
    // Represents stack segment that task applies to. AddressOriginalMin <= AddressMin <=
    // AddressMax <= AddressOriginalMax.
    struct DECLSPEC_UUID("9fdf4025-864e-58e3-84c9-5f0e5a82e49f") DkmTaskStackSegment
    {
        // Trimmed  minimum address on stack.
        UINT64 AddressMin;

        // Trimmed  maximum address on stack.
        UINT64 AddressMax;

        // original minimum address on stack.
        UINT64 AddressOriginalMin;

        // original maximum address on stack.
        UINT64 AddressOriginalMax;

        // OS thread id.
        UINT32 ThreadId;

        // Release all reference-counted fields within the DkmTaskStackSegment structure.
        static DECLSPEC_NOTHROW void STDMETHODCALLTYPE Release(
            _In_ DkmTaskStackSegment* pItem
            )
        {
            // structure requires no cleanup
        }
    };

    // Properties of the task.
    struct DECLSPEC_UUID("d0fc2053-8661-2602-078e-13207a8b6727") DkmTaskProperties
    {
        // [Optional] Name of task.
        OPTIONAL DkmString* pName;

        // [Optional] TODO.
        OPTIONAL DkmString* pLocation;

        // [Optional] TODO.
        OPTIONAL DkmString* pProperty1;

        // [Optional] TODO.
        OPTIONAL DkmString* pProperty2;

        // [Optional] TODO.
        OPTIONAL DkmString* pProperty3;

        // TODO.
        enum_TASKSTATE_TYPE State;

        // TODO.
        enum_TASKLOAD_FLAGS Flags;

        // TODO.
        UINT32 Fields;

        // Release all reference-counted fields within the DkmTaskProperties structure.
        static DECLSPEC_NOTHROW void STDMETHODCALLTYPE Release(
            _In_ DkmTaskProperties* pItem
            );
    };

    // Information about a managed task that is obtained via inspection.
    //
    // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
    struct DECLSPEC_UUID("00083cf7-83a6-88c5-bf6e-c4fc451fa49c") DkmManagedTaskInfo
    {
        // The task ID.
        UINT32 Id;

        // The ID of this tasks parent.
        UINT32 ParentId;

        // [Optional] String representing the AsyncState property of the task.
        OPTIONAL DkmString* pAsyncState;

        // The state flags stored in the task object.
        UINT32 StateFlags;

        // Release all reference-counted fields within the DkmManagedTaskInfo structure.
        static DECLSPEC_NOTHROW void STDMETHODCALLTYPE Release(
            _In_ DkmManagedTaskInfo* pItem
            );
    };

    // DkmJsAsyncStackFrame is used to represent a JS async stack frame.
    //
    // This API was introduced in Visual Studio 14 RTM (DkmApiVersion.VS14RTM).
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("f2718442-b256-1321-a580-ea28fb8f1ec9") DkmJsAsyncStackFrame : public IUnknown
    {
        private: ___ReferenceCount_t m_ReferenceCount;
        private: DkmDispatcherObjectFlags_t m_ObjectFlags;
        private: const GUID* m_pTypeId;
        private: size_t m_ObjectGCHandle;
        // Use DkmJsAsyncStackFrame::Create to create this object
        private: DkmJsAsyncStackFrame();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmJsAsyncStackFrame();
        // This object cannot be copied
        private: DkmJsAsyncStackFrame& operator=(const DkmJsAsyncStackFrame&);
        private: DkmJsAsyncStackFrame(const DkmJsAsyncStackFrame&);

        private: const UINT64 m_DocumentId;
        private: const UINT32 m_SourceLocationStartIndex;
        private: const UINT32 m_SourceLocationLength;
        private: DkmString* const m_pName;
        private: void* m__pExtendedData;

        // Pointer to the IDebugDocumentText implementation for the document where the source
        // location resides.
        //
        // This API was introduced in Visual Studio 14 RTM (DkmApiVersion.VS14RTM).
        public: DECLSPEC_NOTHROW UINT64 STDMETHODCALLTYPE DocumentId(
            );

        // 0-based index into the document.
        //
        // This API was introduced in Visual Studio 14 RTM (DkmApiVersion.VS14RTM).
        public: DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE SourceLocationStartIndex(
            );

        // Length of the current source position.
        //
        // This API was introduced in Visual Studio 14 RTM (DkmApiVersion.VS14RTM).
        public: DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE SourceLocationLength(
            );

        // Name of the stack frame.
        //
        // This API was introduced in Visual Studio 14 RTM (DkmApiVersion.VS14RTM).
        public: _Ret_ DECLSPEC_NOTHROW DkmString* STDMETHODCALLTYPE Name(
            );

        /// <summary>
        /// Create a new DkmJsAsyncStackFrame object instance.
        ///
        /// This API was introduced in Visual Studio 14 RTM (DkmApiVersion.VS14RTM).
        /// </summary>
        /// <param name="DocumentId">
        /// [In] Pointer to the IDebugDocumentText implementation for the document where the
        /// source location resides.
        /// </param>
        /// <param name="SourceLocationStartIndex">
        /// [In] 0-based index into the document.
        /// </param>
        /// <param name="SourceLocationLength">
        /// [In] Length of the current source position.
        /// </param>
        /// <param name="pName">
        /// [In] Name of the stack frame.
        /// </param>
        /// <param name="ppCreatedObject">
        /// [Out] Result of this method call.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ UINT64 DocumentId,
            _In_ UINT32 SourceLocationStartIndex,
            _In_ UINT32 SourceLocationLength,
            _In_ DkmString* pName,
            _Deref_out_ ParallelTasks::DkmJsAsyncStackFrame** ppCreatedObject
            );
    }; // end of DkmJsAsyncStackFrame

    // Represents either a managed TPL task or a native Concurrency Runtime task.
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("91470324-c843-bec3-2050-7c9e644c28d7") DkmTask : public DkmDataContainer
    {
        // Use DkmTask::Create to create this object
        private: DkmTask();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmTask();
        // This object cannot be copied
        private: DkmTask& operator=(const DkmTask&);
        private: DkmTask(const DkmTask&);

        // Contains additional fields of DkmTask which were added after the class was
        // initally introduced.
        private: struct ___ExtendedData
        {
            ___ExtendedData();

            // The return status of the task or unknown if the task has not completed.
            const ParallelTasks::DkmTaskReturnStatus_t ReturnStatus;

            // The time since debugging started that this task started.  The time is in
            // seconds.
            const double StartTime;

            // The time since debugging started that this task completed.  The time is in
            // seconds.
            const double CompletedTime;

            // The current task duration in seconds.
            const double Duration;
        };

        private: ParallelTasks::DkmTaskProvider* const m_pTaskProvider;
        private: OPTIONAL DkmThread* const m_pThread;
        private: const UINT64 m_TaskId;
        private: const UINT64 m_ParentTaskId;
        private: const ParallelTasks::DkmTaskStackSegment m_StackSegment;
        private: ___ExtendedData* const m__pExtendedData;
        private: void* m_pTaskSyncObjectCollection0;

        // Represents a task provider which is loaded into the target process.
        public: _Ret_ DECLSPEC_NOTHROW ParallelTasks::DkmTaskProvider* STDMETHODCALLTYPE TaskProvider(
            );

        // [Optional] DkmThread represents a thread running in the target process.
        public: _Ret_opt_ DECLSPEC_NOTHROW DkmThread* STDMETHODCALLTYPE Thread(
            );

        // Identifier for this particular instance.
        public: DECLSPEC_NOTHROW UINT64 STDMETHODCALLTYPE TaskId(
            );

        // ID of parent task, 0 if there is no parent task.
        public: DECLSPEC_NOTHROW UINT64 STDMETHODCALLTYPE ParentTaskId(
            );

        // Represents stack segment that task applies to. AddressOriginalMin <= AddressMin <=
        // AddressMax <= AddressOriginalMax.
        public: DECLSPEC_NOTHROW const ParallelTasks::DkmTaskStackSegment& STDMETHODCALLTYPE StackSegment(
            );

        // The return status of the task or unknown if the task has not completed.
        //
        // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
        public: DECLSPEC_NOTHROW ParallelTasks::DkmTaskReturnStatus_t STDMETHODCALLTYPE ReturnStatus(
            );

        // The time since debugging started that this task started.  The time is in seconds.
        //
        // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
        public: DECLSPEC_NOTHROW double STDMETHODCALLTYPE StartTime(
            );

        // The time since debugging started that this task completed.  The time is in
        // seconds.
        //
        // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
        public: DECLSPEC_NOTHROW double STDMETHODCALLTYPE CompletedTime(
            );

        // The current task duration in seconds.
        //
        // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
        public: DECLSPEC_NOTHROW double STDMETHODCALLTYPE Duration(
            );

        /// <summary>
        /// Closes a DkmTask object instance. This will release any resources associated with
        /// this object across all components. This includes resources across computer or
        /// managed/native marshalling boundaries.
        ///
        /// DkmTask objects are automatically closed when their associated DkmTaskProvider
        /// object is closed.
        /// </summary>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Close(
            );

        /// <summary>
        /// This method is called to represent a task on a specific thread.
        /// </summary>
        /// <param name="pTaskProvider">
        /// [In] Represents a task provider which is loaded into the target process.
        /// </param>
        /// <param name="pThread">
        /// [In,Optional] DkmThread represents a thread running in the target process.
        /// </param>
        /// <param name="TaskId">
        /// [In] Identifier for this particular instance.
        /// </param>
        /// <param name="ParentTaskId">
        /// [In] ID of parent task, 0 if there is no parent task.
        /// </param>
        /// <param name="StackSegment">
        /// [In] Represents stack segment that task applies to. AddressOriginalMin &lt;=
        /// AddressMin &lt;= AddressMax &lt;= AddressOriginalMax.
        /// </param>
        /// <param name="DataItem">
        /// [In] Data object to add to the new DkmTask instance. DkmDataItem::Null() in the
        /// case that the caller doesn't need to add a data item.
        /// </param>
        /// <param name="ppCreatedObject">
        /// [Out] Result of this method call.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ ParallelTasks::DkmTaskProvider* pTaskProvider,
            _In_opt_ DkmThread* pThread,
            _In_ UINT64 TaskId,
            _In_ UINT64 ParentTaskId,
            _In_ const ParallelTasks::DkmTaskStackSegment& StackSegment,
            _In_ const DkmDataItem& DataItem,
            _Deref_out_ ParallelTasks::DkmTask** ppCreatedObject
            );

        /// <summary>
        /// This method is called to represent a task on a specific thread.
        ///
        /// This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
        /// </summary>
        /// <param name="pTaskProvider">
        /// [In] Represents a task provider which is loaded into the target process.
        /// </param>
        /// <param name="pThread">
        /// [In,Optional] DkmThread represents a thread running in the target process.
        /// </param>
        /// <param name="TaskId">
        /// [In] Identifier for this particular instance.
        /// </param>
        /// <param name="ParentTaskId">
        /// [In] ID of parent task, 0 if there is no parent task.
        /// </param>
        /// <param name="StackSegment">
        /// [In] Represents stack segment that task applies to. AddressOriginalMin &lt;=
        /// AddressMin &lt;= AddressMax &lt;= AddressOriginalMax.
        /// </param>
        /// <param name="ReturnStatus">
        /// [In] The return status of the task or unknown if the task has not completed.
        /// </param>
        /// <param name="StartTime">
        /// [In] The time since debugging started that this task started.  The time is in
        /// seconds.
        /// </param>
        /// <param name="CompletedTime">
        /// [In] The time since debugging started that this task completed.  The time is in
        /// seconds.
        /// </param>
        /// <param name="Duration">
        /// [In] The current task duration in seconds.
        /// </param>
        /// <param name="DataItem">
        /// [In] Data object to add to the new DkmTask instance. DkmDataItem::Null() in the
        /// case that the caller doesn't need to add a data item.
        /// </param>
        /// <param name="ppCreatedObject">
        /// [Out] Result of this method call.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ ParallelTasks::DkmTaskProvider* pTaskProvider,
            _In_opt_ DkmThread* pThread,
            _In_ UINT64 TaskId,
            _In_ UINT64 ParentTaskId,
            _In_ const ParallelTasks::DkmTaskStackSegment& StackSegment,
            _In_ ParallelTasks::DkmTaskReturnStatus_t ReturnStatus,
            _In_ double StartTime,
            _In_ double CompletedTime,
            _In_ double Duration,
            _In_ const DkmDataItem& DataItem,
            _Deref_out_ ParallelTasks::DkmTask** ppCreatedObject
            );

        #ifndef EXCLUDE_IDE_ONLY_APIS
        /// <summary>
        /// Returns children tasks.
        ///
        /// Location constraint: API must be called from an IDE component (component level
        /// &gt; 100,000).
        /// </summary>
        /// <param name="pItems">
        /// [Out] TODO.
        ///
        /// The memory for the DkmArray members is allocated by the method implementation
        /// using DkmAllocBytes/DkmAllocArray. It is freed by the caller using the
        /// CAutoDkmArray template or with DkmFreeMemory and manual element release.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetChildTasks(
            _Out_ DkmArray<ParallelTasks::DkmTask*>* pItems
            );
        #endif // #ifndef EXCLUDE_IDE_ONLY_APIS

        #ifndef EXCLUDE_IDE_ONLY_APIS
        /// <summary>
        /// Returns task properties.
        ///
        /// Location constraint: API must be called from an IDE component (component level
        /// &gt; 100,000).
        /// </summary>
        /// <param name="Radix">
        /// [In] TODO.
        /// </param>
        /// <param name="Fields">
        /// [In] TODO.
        /// </param>
        /// <param name="pProperties">
        /// [Out] TODO.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetTaskProperties(
            _In_ UINT32 Radix,
            _In_ UINT32 Fields,
            _Out_ ParallelTasks::DkmTaskProperties* pProperties
            );
        #endif // #ifndef EXCLUDE_IDE_ONLY_APIS

        #ifndef EXCLUDE_IDE_ONLY_APIS
        /// <summary>
        /// TODO.
        ///
        /// Location constraint: API must be called from an IDE component (component level
        /// &gt; 100,000).
        /// </summary>
        /// <param name="pItems">
        /// [Out] TODO.
        ///
        /// The memory for the DkmArray members is allocated by the method implementation
        /// using DkmAllocBytes/DkmAllocArray. It is freed by the caller using the
        /// CAutoDkmArray template or with DkmFreeMemory and manual element release.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetSynchronizationObjects(
            _Out_ DkmArray<ParallelTasks::DkmTaskSynchronizationObject*>* pItems
            );
        #endif // #ifndef EXCLUDE_IDE_ONLY_APIS
    }; // end of DkmTask

    // Represents a task provider which is loaded into the target process.
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("9df33d71-fb30-91b6-43fd-15c2bdda7236") DkmTaskProvider : public DkmDataContainer
    {
        // Use DkmTaskProvider::Create to create this object
        private: DkmTaskProvider();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmTaskProvider();
        // This object cannot be copied
        private: DkmTaskProvider& operator=(const DkmTaskProvider&);
        private: DkmTaskProvider(const DkmTaskProvider&);

        // Contains additional fields of DkmTaskProvider which were added after the class was
        // initally introduced.
        private: struct ___ExtendedData
        {
            ___ExtendedData();

            // Flags describing additional information that this Task Provider can supply,
            // such as timestamps.
            const ParallelTasks::DkmTaskProviderCapabilityFlags_t AdditionalCapabilities;
        };

        private: const GUID m_TaskProviderId;
        private: DkmString* const m_pName;
        private: const GUID m_UniqueId;
        private: DkmRuntimeInstance* const m_pRuntimeInstance;
        private: ___ExtendedData* const m__pExtendedData;
        private: void* m_pTaskCollection0;

        // Extensible GUID indicating the task provider which a task is from.
        public: DECLSPEC_NOTHROW const GUID& STDMETHODCALLTYPE TaskProviderId(
            );

        // Task name e.g. Chore or Task.
        public: _Ret_ DECLSPEC_NOTHROW DkmString* STDMETHODCALLTYPE Name(
            );

        // Identifier for this particular instance.
        public: DECLSPEC_NOTHROW const GUID& STDMETHODCALLTYPE UniqueId(
            );

        // The DkmRuntimeInstance class represents an execution environment which is loaded
        // into a DkmProcess and which contains code to be debugged.
        public: _Ret_ DECLSPEC_NOTHROW DkmRuntimeInstance* STDMETHODCALLTYPE RuntimeInstance(
            );

        // Flags describing additional information that this Task Provider can supply, such
        // as timestamps.
        //
        // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
        public: DECLSPEC_NOTHROW ParallelTasks::DkmTaskProviderCapabilityFlags_t STDMETHODCALLTYPE AdditionalCapabilities(
            );

        // DkmProcess represents a target process which is being debugged. The debugger
        // debugs processes, so this is the basic unit of debugging. A DkmProcess can
        // represent a system process or a virtual process such as minidumps.
        public: _Ret_ DECLSPEC_NOTHROW DkmProcess* STDMETHODCALLTYPE Process(
            );

        /// <summary>
        /// Closes a DkmTaskProvider object instance. This will release any resources
        /// associated with this object across all components. This includes resources across
        /// computer or managed/native marshalling boundaries.
        ///
        /// DkmTaskProvider objects are automatically closed when their associated
        /// DkmRuntimeInstance object is closed.
        /// </summary>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Close(
            );

        /// <summary>
        /// This method is called a task provider component to create a DkmTaskProvider
        /// object. It may be called in response to a call to InitializeTaskProviders call,
        /// or to a module/app domain load event.
        ///
        /// This method will send a TaskProviderCreate event.
        /// </summary>
        /// <param name="TaskProviderId">
        /// [In] Extensible GUID indicating the task provider which a task is from.
        /// </param>
        /// <param name="pName">
        /// [In] Task name e.g. Chore or Task.
        /// </param>
        /// <param name="pRuntimeInstance">
        /// [In] The DkmRuntimeInstance class represents an execution environment which is
        /// loaded into a DkmProcess and which contains code to be debugged.
        /// </param>
        /// <param name="DataItem">
        /// [In] Data object to add to the new DkmTaskProvider instance. DkmDataItem::Null()
        /// in the case that the caller doesn't need to add a data item.
        /// </param>
        /// <param name="ppCreatedObject">
        /// [Out] Result of this method call.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ const GUID& TaskProviderId,
            _In_ DkmString* pName,
            _In_ DkmRuntimeInstance* pRuntimeInstance,
            _In_ const DkmDataItem& DataItem,
            _Deref_out_ ParallelTasks::DkmTaskProvider** ppCreatedObject
            );

        /// <summary>
        /// This method is called a task provider component to create a DkmTaskProvider
        /// object. It may be called in response to a call to InitializeTaskProviders call,
        /// or to a module/app domain load event.
        ///
        /// This method will send a TaskProviderCreate event.
        ///
        /// This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
        /// </summary>
        /// <param name="TaskProviderId">
        /// [In] Extensible GUID indicating the task provider which a task is from.
        /// </param>
        /// <param name="pName">
        /// [In] Task name e.g. Chore or Task.
        /// </param>
        /// <param name="pRuntimeInstance">
        /// [In] The DkmRuntimeInstance class represents an execution environment which is
        /// loaded into a DkmProcess and which contains code to be debugged.
        /// </param>
        /// <param name="AdditionalCapabilities">
        /// [In] Flags describing additional information that this Task Provider can supply,
        /// such as timestamps.
        /// </param>
        /// <param name="DataItem">
        /// [In] Data object to add to the new DkmTaskProvider instance. DkmDataItem::Null()
        /// in the case that the caller doesn't need to add a data item.
        /// </param>
        /// <param name="ppCreatedObject">
        /// [Out] Result of this method call.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ const GUID& TaskProviderId,
            _In_ DkmString* pName,
            _In_ DkmRuntimeInstance* pRuntimeInstance,
            _In_ ParallelTasks::DkmTaskProviderCapabilityFlags_t AdditionalCapabilities,
            _In_ const DkmDataItem& DataItem,
            _Deref_out_ ParallelTasks::DkmTaskProvider** ppCreatedObject
            );

        /// <summary>
        /// Find a DkmTask element within this DkmTaskProvider. If no element with the given
        /// input key is present, FindTask will fail.
        /// </summary>
        /// <param name="TaskId">
        /// [In] Search key used to find the element.
        /// </param>
        /// <param name="ppTask">
        /// [Out] Result of the search.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// E_XAPI_OBJECT_NOT_FOUND indicates that the search key cannot be found.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE FindTask(
            _In_ UINT64 TaskId,
            _Deref_out_ ParallelTasks::DkmTask** ppTask
            );

        #ifndef EXCLUDE_IDE_ONLY_APIS
        /// <summary>
        /// Enumerates the current set of tasks running in the target process.
        ///
        /// Location constraint: API must be called from an IDE component (component level
        /// &gt; 100,000).
        /// </summary>
        /// <param name="IsRoot">
        /// [In] TODO.
        /// </param>
        /// <param name="RequestCount">
        /// [In] Count of tasks requested.
        /// </param>
        /// <param name="pScheduledTaskCount">
        /// [Out] Number of scheduled tasks.
        /// </param>
        /// <param name="pItems">
        /// [Out] Array contained the found tasks.
        ///
        /// The memory for the DkmArray members is allocated by the method implementation
        /// using DkmAllocBytes/DkmAllocArray. It is freed by the caller using the
        /// CAutoDkmArray template or with DkmFreeMemory and manual element release.
        /// </param>
        /// <param name="pTaskEnumFlags">
        /// [Out] TODO.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetTasks(
            _In_ bool IsRoot,
            _In_ UINT32 RequestCount,
            _Out_ UINT32* pScheduledTaskCount,
            _Out_ DkmArray<ParallelTasks::DkmTask*>* pItems,
            _Out_ UINT32* pTaskEnumFlags
            );
        #endif // #ifndef EXCLUDE_IDE_ONLY_APIS

        #ifndef EXCLUDE_IDE_ONLY_APIS
        /// <summary>
        /// TODO.
        ///
        /// Location constraint: API must be called from an IDE component (component level
        /// &gt; 100,000).
        /// </summary>
        /// <param name="pNames">
        /// [Out] TODO.
        ///
        /// The memory for the DkmArray members is allocated by the method implementation
        /// using DkmAllocBytes/DkmAllocArray. It is freed by the caller using the
        /// CAutoDkmArray template or with DkmFreeMemory and manual element release.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetPropertyNames(
            _Out_ DkmArray<DkmString*>* pNames
            );
        #endif // #ifndef EXCLUDE_IDE_ONLY_APIS
    }; // end of DkmTaskProvider

    // Flags indicating additional capabilities a Task Provider can have.
    //
    // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
    DEFINE_SCOPED_ENUM(DkmTaskProviderCapabilityFlags)
    {
        // No additional capabilities.
        None = 0x0,
        // Can provide timestamps for Tasks, i.e. Creation Time.
        Timestamps = 0x1,
        // Can provide the return value of completed tasks.
        ReturnStatus = 0x2
    };
    DEFINE_SCOPED_ENUM_FLAG_OPERATORS(DkmTaskProviderCapabilityFlags_t);

    // Extensible GUID indicating the task provider which a task is from.
    struct DkmTaskProviderId
    {
        // Task provider for Microsoft Task Parallel Library (TPL) for managed.
        // TPL is defined as {319f6cb1-11fa-407c-bd93-eddc1f5e3af0}.
        static const GUID TPL;
        // Task provider for Microsoft Concurrency Runtime programming framework for C++.
        // ConcurrencyRuntime is defined as {f02925c6-752c-48f6-bfc0-3bf2118e2c9e}.
        static const GUID ConcurrencyRuntime;
        // Task provider for JavaScript runtime.
        // JavaScript is defined as {d1d9b74c-1396-4610-b28c-9e56d96cea58}.
        static const GUID JavaScript;
        // Task provider for Managed TPL tasks based on ETW.
        // ManagedEtw is defined as {0b39b84c-597e-421c-b04c-7561735bcf8c}.
        static const GUID ManagedEtw;
        // Task provider for Native PPL tasks based on ETW.
        // NativeEtw is defined as {80b5df72-4b63-4e24-980a-67b4b4689f09}.
        static const GUID NativeEtw;
    };
    __declspec(selectany) const GUID DkmTaskProviderId::TPL = { 0x319f6cb1, 0x11fa, 0x407c, { 0xbd, 0x93, 0xed, 0xdc, 0x1f, 0x5e, 0x3a, 0xf0 } };
    __declspec(selectany) const GUID DkmTaskProviderId::ConcurrencyRuntime = { 0xf02925c6, 0x752c, 0x48f6, { 0xbf, 0xc0, 0x3b, 0xf2, 0x11, 0x8e, 0x2c, 0x9e } };
    __declspec(selectany) const GUID DkmTaskProviderId::JavaScript = { 0xd1d9b74c, 0x1396, 0x4610, { 0xb2, 0x8c, 0x9e, 0x56, 0xd9, 0x6c, 0xea, 0x58 } };
    __declspec(selectany) const GUID DkmTaskProviderId::ManagedEtw = { 0xb39b84c, 0x597e, 0x421c, { 0xb0, 0x4c, 0x75, 0x61, 0x73, 0x5b, 0xcf, 0x8c } };
    __declspec(selectany) const GUID DkmTaskProviderId::NativeEtw = { 0x80b5df72, 0x4b63, 0x4e24, { 0x98, 0xa, 0x67, 0xb4, 0xb4, 0x68, 0x9f, 0x9 } };

    // The return status for the task.  If the task hasn't completed yet, the status is
    // unknown.
    //
    // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
    DEFINE_SCOPED_ENUM(DkmTaskReturnStatus)
    {
        // The return status is unknown because the task has not completed.
        Unknown = 0,
        // The task succeeded.
        Success = 1,
        // There was an error executing the task.
        Error = 2,
        // The task has been cancelled.
        Cancelled = 3
    };

    // Represents a synchronization object.
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("ceeeb968-317e-47e7-f0e7-42d12f5bb406") DkmTaskSynchronizationObject : public DkmDataContainer
    {
        // Use DkmTaskSynchronizationObject::Create to create this object
        private: DkmTaskSynchronizationObject();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmTaskSynchronizationObject();
        // This object cannot be copied
        private: DkmTaskSynchronizationObject& operator=(const DkmTaskSynchronizationObject&);
        private: DkmTaskSynchronizationObject(const DkmTaskSynchronizationObject&);

        private: ParallelTasks::DkmTask* const m_pTask;
        private: OPTIONAL DkmThread* const m_pOwningThread;
        private: const GUID m_UniqueId;
        private: OPTIONAL DkmString* const m_pDecimalName;
        private: OPTIONAL DkmString* const m_pHexidecimalName;
        private: OPTIONAL DkmString* const m_pType;
        private: const UINT32 m_WaitTime;
        private: const UINT32 m_Timeout;
        private: void* m__pExtendedData;

        // Represents either a managed TPL task or a native Concurrency Runtime task.
        public: _Ret_ DECLSPEC_NOTHROW ParallelTasks::DkmTask* STDMETHODCALLTYPE Task(
            );

        // [Optional] The owning thread.
        public: _Ret_opt_ DECLSPEC_NOTHROW DkmThread* STDMETHODCALLTYPE OwningThread(
            );

        // Identifier for this particular instance.
        public: DECLSPEC_NOTHROW const GUID& STDMETHODCALLTYPE UniqueId(
            );

        // [Optional] Name of the object, in base 10.
        public: _Ret_opt_ DECLSPEC_NOTHROW DkmString* STDMETHODCALLTYPE DecimalName(
            );

        // [Optional] Name of the object, in base 16.
        public: _Ret_opt_ DECLSPEC_NOTHROW DkmString* STDMETHODCALLTYPE HexidecimalName(
            );

        // [Optional] TODO.
        public: _Ret_opt_ DECLSPEC_NOTHROW DkmString* STDMETHODCALLTYPE Type(
            );

        // TODO.
        public: DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE WaitTime(
            );

        // TODO.
        public: DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE Timeout(
            );

        /// <summary>
        /// Closes a DkmTaskSynchronizationObject object instance. This will release any
        /// resources associated with this object across all components. This includes
        /// resources across computer or managed/native marshalling boundaries.
        ///
        /// DkmTaskSynchronizationObject objects are automatically closed when their
        /// associated DkmTask object is closed.
        /// </summary>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Close(
            );

        /// <summary>
        /// Create a new DkmTaskSynchronizationObject object instance.
        /// </summary>
        /// <param name="pTask">
        /// [In] Represents either a managed TPL task or a native Concurrency Runtime task.
        /// </param>
        /// <param name="pOwningThread">
        /// [In,Optional] The owning thread.
        /// </param>
        /// <param name="pDecimalName">
        /// [In,Optional] Name of the object, in base 10.
        /// </param>
        /// <param name="pHexidecimalName">
        /// [In,Optional] Name of the object, in base 16.
        /// </param>
        /// <param name="pType">
        /// [In,Optional] TODO.
        /// </param>
        /// <param name="WaitTime">
        /// [In] TODO.
        /// </param>
        /// <param name="Timeout">
        /// [In] TODO.
        /// </param>
        /// <param name="DataItem">
        /// [In] Data object to add to the new DkmTaskSynchronizationObject instance.
        /// DkmDataItem::Null() in the case that the caller doesn't need to add a data item.
        /// </param>
        /// <param name="ppCreatedObject">
        /// [Out] Result of this method call.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ ParallelTasks::DkmTask* pTask,
            _In_opt_ DkmThread* pOwningThread,
            _In_opt_ DkmString* pDecimalName,
            _In_opt_ DkmString* pHexidecimalName,
            _In_opt_ DkmString* pType,
            _In_ UINT32 WaitTime,
            _In_ UINT32 Timeout,
            _In_ const DkmDataItem& DataItem,
            _Deref_out_ ParallelTasks::DkmTaskSynchronizationObject** ppCreatedObject
            );
    }; // end of DkmTaskSynchronizationObject

}; // end namespace ParallelTasks

// Contains types specific to edit and continue feature.
namespace Enc {
    // Native edit and continue notification.
    //
    // This API was introduced in Visual Studio 14 RTM (DkmApiVersion.VS14RTM).
    DEFINE_SCOPED_ENUM(DkmNativeEncNotify)
    {
        // Compilation starts.
        CompileStart = 0,
        // Compilation stops.
        CompileEnd = 1
    };

}; // end namespace Enc

// Contains types which are Microsoft-internal and subject to change.
namespace Internal {
    // Internal object for accessing visualizer information from the target computer.
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("81492227-e68b-4398-eea2-12c86fd2be52") DkmEELocalObject : public DkmDataContainer
    {
        // Use DkmEELocalObject::Create to create this object
        private: DkmEELocalObject();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmEELocalObject();
        // This object cannot be copied
        private: DkmEELocalObject& operator=(const DkmEELocalObject&);
        private: DkmEELocalObject(const DkmEELocalObject&);

        private: const GUID m_UniqueId;
        private: DkmProcess* const m_pProcess;
        private: void* m__pExtendedData;

        // Guid which uniquely identifies this DkmEELocalObject.
        public: DECLSPEC_NOTHROW const GUID& STDMETHODCALLTYPE UniqueId(
            );

        // DkmProcess represents a target process which is being debugged. The debugger
        // debugs processes, so this is the basic unit of debugging. A DkmProcess can
        // represent a system process or a virtual process such as minidumps.
        public: _Ret_ DECLSPEC_NOTHROW DkmProcess* STDMETHODCALLTYPE Process(
            );

        /// <summary>
        /// Create a new DkmEELocalObject object instance.
        /// </summary>
        /// <param name="pProcess">
        /// [In] DkmProcess represents a target process which is being debugged. The debugger
        /// debugs processes, so this is the basic unit of debugging. A DkmProcess can
        /// represent a system process or a virtual process such as minidumps.
        /// </param>
        /// <param name="DataItem">
        /// [In] Data object to add to the new DkmEELocalObject instance. DkmDataItem::Null()
        /// in the case that the caller doesn't need to add a data item.
        /// </param>
        /// <param name="ppCreatedObject">
        /// [Out] Result of this method call.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ DkmProcess* pProcess,
            _In_ const DkmDataItem& DataItem,
            _Deref_out_ Internal::DkmEELocalObject** ppCreatedObject
            );

        #ifndef EXCLUDE_MONITOR_ONLY_APIS
        /// <summary>
        /// Initializes the visualizer cache on the IDE computer.
        ///
        /// Location constraint: API must be called from a Monitor component (component level
        /// &lt; 100,000).
        /// </summary>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE InitCache(
            );
        #endif // #ifndef EXCLUDE_MONITOR_ONLY_APIS

        #ifndef EXCLUDE_MONITOR_ONLY_APIS
        /// <summary>
        /// Returns visualizer information for a class.
        ///
        /// Location constraint: API must be called from a Monitor component (component level
        /// &lt; 100,000).
        /// </summary>
        /// <param name="pName">
        /// [In] Name of the class.
        /// </param>
        /// <param name="AssemblyCookie">
        /// [In] Assembly cookie.
        /// </param>
        /// <param name="pCookie">
        /// [Out] Class cookie.
        /// </param>
        /// <param name="pValueAttributeCount">
        /// [Out] ValueAttributeCount.
        /// </param>
        /// <param name="pViewerAttributeCount">
        /// [Out] ViewerAttributeCount.
        /// </param>
        /// <param name="pVisualizerAttributeCount">
        /// [Out] VisualizerAttributeCount.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetTargetClass(
            _In_ DkmString* pName,
            _In_ UINT32 AssemblyCookie,
            _Out_ UINT32* pCookie,
            _Out_ UINT32* pValueAttributeCount,
            _Out_ UINT32* pViewerAttributeCount,
            _Out_ UINT32* pVisualizerAttributeCount
            );
        #endif // #ifndef EXCLUDE_MONITOR_ONLY_APIS

        #ifndef EXCLUDE_MONITOR_ONLY_APIS
        /// <summary>
        /// GetTargetAssembly.
        ///
        /// Location constraint: API must be called from a Monitor component (component level
        /// &lt; 100,000).
        /// </summary>
        /// <param name="pName">
        /// [In] Name.
        /// </param>
        /// <param name="pCookie">
        /// [Out] Cookie.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetTargetAssembly(
            _In_ DkmString* pName,
            _Out_ UINT32* pCookie
            );
        #endif // #ifndef EXCLUDE_MONITOR_ONLY_APIS

        #ifndef EXCLUDE_MONITOR_ONLY_APIS
        /// <summary>
        /// GetAssembly.
        ///
        /// Location constraint: API must be called from a Monitor component (component level
        /// &lt; 100,000).
        /// </summary>
        /// <param name="AssemblyCookie">
        /// [In] Assembly cookie.
        /// </param>
        /// <param name="Flags">
        /// [In] GETASSEMBLY flags.
        /// </param>
        /// <param name="pFlagsOut">
        /// [Out,Optional] ASSEMBLYFLAGS flags.
        /// </param>
        /// <param name="ppName">
        /// [Out,Optional] name.
        /// </param>
        /// <param name="pAssemblyBytes">
        /// [Out] Bytes of the visualizer assembly.
        ///
        /// The memory for the DkmArray members is allocated by the method implementation
        /// using DkmAllocBytes/DkmAllocArray. It is freed by the caller using the
        /// CAutoDkmArray template or with DkmFreeMemory and manual element release.
        /// </param>
        /// <param name="pPdbBytes">
        /// [Out] Bytes of the visualizer assembly's PDB.
        ///
        /// The memory for the DkmArray members is allocated by the method implementation
        /// using DkmAllocBytes/DkmAllocArray. It is freed by the caller using the
        /// CAutoDkmArray template or with DkmFreeMemory and manual element release.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetAssembly(
            _In_ UINT32 AssemblyCookie,
            _In_ UINT32 Flags,
            _Out_ UINT32* pFlagsOut,
            _Deref_out_opt_ DkmString** ppName,
            _Out_ DkmArray<BYTE>* pAssemblyBytes,
            _Out_ DkmArray<BYTE>* pPdbBytes
            );
        #endif // #ifndef EXCLUDE_MONITOR_ONLY_APIS

        #ifndef EXCLUDE_MONITOR_ONLY_APIS
        /// <summary>
        /// GetHostAssembly.
        ///
        /// Location constraint: API must be called from a Monitor component (component level
        /// &lt; 100,000).
        /// </summary>
        /// <param name="Flags">
        /// [In] Flags.
        /// </param>
        /// <param name="pAssemblyBytes">
        /// [Out] Assembly bytes.
        ///
        /// The memory for the DkmArray members is allocated by the method implementation
        /// using DkmAllocBytes/DkmAllocArray. It is freed by the caller using the
        /// CAutoDkmArray template or with DkmFreeMemory and manual element release.
        /// </param>
        /// <param name="pPdbBytes">
        /// [Out] Bytes of the visualizer assembly's PDB.
        ///
        /// The memory for the DkmArray members is allocated by the method implementation
        /// using DkmAllocBytes/DkmAllocArray. It is freed by the caller using the
        /// CAutoDkmArray template or with DkmFreeMemory and manual element release.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetHostAssembly(
            _In_ UINT32 Flags,
            _Out_ DkmArray<BYTE>* pAssemblyBytes,
            _Out_ DkmArray<BYTE>* pPdbBytes
            );
        #endif // #ifndef EXCLUDE_MONITOR_ONLY_APIS

        #ifndef EXCLUDE_MONITOR_ONLY_APIS
        /// <summary>
        /// GetValueAttributeProps.
        ///
        /// Location constraint: API must be called from a Monitor component (component level
        /// &lt; 100,000).
        /// </summary>
        /// <param name="ClassCookie">
        /// [In] Class cookie.
        /// </param>
        /// <param name="Ordinal">
        /// [In] Ordinal.
        /// </param>
        /// <param name="ppTargetedAssembly">
        /// [Out,Optional] Target assembly.
        /// </param>
        /// <param name="pAssemblyLocation">
        /// [Out,Optional] Assembly location.
        /// </param>
        /// <param name="ppName">
        /// [Out,Optional] Name.
        /// </param>
        /// <param name="ppValue">
        /// [Out,Optional] Value.
        /// </param>
        /// <param name="ppType">
        /// [Out,Optional] Type.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetValueAttributeProps(
            _In_ UINT32 ClassCookie,
            _In_ UINT32 Ordinal,
            _Deref_out_opt_ DkmString** ppTargetedAssembly,
            _Out_ UINT32* pAssemblyLocation,
            _Deref_out_opt_ DkmString** ppName,
            _Deref_out_opt_ DkmString** ppValue,
            _Deref_out_opt_ DkmString** ppType
            );
        #endif // #ifndef EXCLUDE_MONITOR_ONLY_APIS

        #ifndef EXCLUDE_MONITOR_ONLY_APIS
        /// <summary>
        /// GetViewerAttributeProps.
        ///
        /// Location constraint: API must be called from a Monitor component (component level
        /// &lt; 100,000).
        /// </summary>
        /// <param name="ClassCookie">
        /// [In] Class cookie.
        /// </param>
        /// <param name="Ordinal">
        /// [In] Ordinal.
        /// </param>
        /// <param name="ppTargetedAssembly">
        /// [Out,Optional] Target assembly.
        /// </param>
        /// <param name="pAssemblyLocation">
        /// [Out,Optional] Assembly location.
        /// </param>
        /// <param name="ppClassName">
        /// [Out,Optional] Class name.
        /// </param>
        /// <param name="pClassAssemblyLocation">
        /// [Out,Optional] ClassAssemblyLocation.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetViewerAttributeProps(
            _In_ UINT32 ClassCookie,
            _In_ UINT32 Ordinal,
            _Deref_out_opt_ DkmString** ppTargetedAssembly,
            _Out_ UINT32* pAssemblyLocation,
            _Deref_out_opt_ DkmString** ppClassName,
            _Out_ UINT32* pClassAssemblyLocation
            );
        #endif // #ifndef EXCLUDE_MONITOR_ONLY_APIS

        #ifndef EXCLUDE_MONITOR_ONLY_APIS
        /// <summary>
        /// GetVisualizerAttributeProps.
        ///
        /// Location constraint: API must be called from a Monitor component (component level
        /// &lt; 100,000).
        /// </summary>
        /// <param name="ClassCookie">
        /// [In] Class cookie.
        /// </param>
        /// <param name="Ordinal">
        /// [In] Ordinal.
        /// </param>
        /// <param name="ppTargetedAssembly">
        /// [Out,Optional] Target assembly.
        /// </param>
        /// <param name="pAssemblyLocation">
        /// [Out,Optional] Assembly location.
        /// </param>
        /// <param name="ppDisplayClassName">
        /// [Out,Optional] Display class name.
        /// </param>
        /// <param name="pDisplayClassAssemblyLocation">
        /// [Out,Optional] DisplayClassAssemblyLocation.
        /// </param>
        /// <param name="ppProxyClassName">
        /// [Out,Optional] Proxy class name.
        /// </param>
        /// <param name="pProxyClassAssemblyLocation">
        /// [Out,Optional] ProxyClassAssemblyLocation.
        /// </param>
        /// <param name="ppDescription">
        /// [Out,Optional] Description.
        /// </param>
        /// <param name="pType">
        /// [Out,Optional] Type.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetVisualizerAttributeProps(
            _In_ UINT32 ClassCookie,
            _In_ UINT32 Ordinal,
            _Deref_out_opt_ DkmString** ppTargetedAssembly,
            _Out_ UINT32* pAssemblyLocation,
            _Deref_out_opt_ DkmString** ppDisplayClassName,
            _Out_ UINT32* pDisplayClassAssemblyLocation,
            _Deref_out_opt_ DkmString** ppProxyClassName,
            _Out_ UINT32* pProxyClassAssemblyLocation,
            _Deref_out_opt_ DkmString** ppDescription,
            _Out_ UINT32* pType
            );
        #endif // #ifndef EXCLUDE_MONITOR_ONLY_APIS
    }; // end of DkmEELocalObject

    // Concord wrapper around IPropertyProxyEESide.
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("26a761e2-09ad-2a3e-6c9f-cc799df30828") DkmPropertyProxy : public DkmDataContainer
    {
        // Use DkmPropertyProxy::Create to create this object
        private: DkmPropertyProxy();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmPropertyProxy();
        // This object cannot be copied
        private: DkmPropertyProxy& operator=(const DkmPropertyProxy&);
        private: DkmPropertyProxy(const DkmPropertyProxy&);

        private: const UINT32 m_Id;
        private: Evaluation::DkmSuccessEvaluationResult* const m_pEvaluationResult;
        private: const GUID m_UniqueId;
        private: void* m__pExtendedData;

        // Not described (internal API).
        public: DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE Id(
            );

        // The evaluation result this proxy is based on.
        public: _Ret_ DECLSPEC_NOTHROW Evaluation::DkmSuccessEvaluationResult* STDMETHODCALLTYPE EvaluationResult(
            );

        // Guid which uniquely identifies this DkmPropertyProxy.
        public: DECLSPEC_NOTHROW const GUID& STDMETHODCALLTYPE UniqueId(
            );

        /// <summary>
        /// Create a new DkmPropertyProxy object instance.
        /// </summary>
        /// <param name="Id">
        /// [In] Not described (internal API).
        /// </param>
        /// <param name="pEvaluationResult">
        /// [In] The evaluation result this proxy is based on.
        /// </param>
        /// <param name="DataItem">
        /// [In] Data object to add to the new DkmPropertyProxy instance. DkmDataItem::Null()
        /// in the case that the caller doesn't need to add a data item.
        /// </param>
        /// <param name="ppCreatedObject">
        /// [Out] Result of this method call.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ UINT32 Id,
            _In_ Evaluation::DkmSuccessEvaluationResult* pEvaluationResult,
            _In_ const DkmDataItem& DataItem,
            _Deref_out_ Internal::DkmPropertyProxy** ppCreatedObject
            );

        #ifndef EXCLUDE_IDE_ONLY_APIS
        /// <summary>
        /// Not described (internal API).
        ///
        /// Location constraint: API must be called from an IDE component (component level
        /// &gt; 100,000).
        /// </summary>
        /// <param name="ppDataOut">
        /// [Out,Optional] the result bytes.
        /// </param>
        /// <returns>
        /// S_OK is returned if *ppDataOut is non-NULL, S_FALSE is returned when *ppDataOut
        /// is NULL, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE InitSourceDataProvider(
            _Deref_out_opt_ DkmReadOnlyCollection<BYTE>** ppDataOut
            );
        #endif // #ifndef EXCLUDE_IDE_ONLY_APIS

        #ifndef EXCLUDE_IDE_ONLY_APIS
        /// <summary>
        /// Not described (internal API).
        ///
        /// Location constraint: API must be called from an IDE component (component level
        /// &gt; 100,000).
        /// </summary>
        /// <param name="ppAssemblyName">
        /// [Out,Optional] Not described (internal API).
        /// </param>
        /// <param name="ppAssemblyBytes">
        /// [Out,Optional] Not described (internal API).
        /// </param>
        /// <param name="ppAssemblyPdb">
        /// [Out,Optional] Not described (internal API).
        /// </param>
        /// <param name="ppClassName">
        /// [Out,Optional] class name.
        /// </param>
        /// <param name="pAssemblyResolution">
        /// [Out] enum_ASSEMBLYLOCRESOLUTION enumeration.
        /// </param>
        /// <param name="pReplacementOk">
        /// [Out] replacement ok.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetManagedViewerCreationData(
            _Deref_out_opt_ DkmString** ppAssemblyName,
            _Deref_out_opt_ DkmReadOnlyCollection<BYTE>** ppAssemblyBytes,
            _Deref_out_opt_ DkmReadOnlyCollection<BYTE>** ppAssemblyPdb,
            _Deref_out_opt_ DkmString** ppClassName,
            _Out_ UINT32* pAssemblyResolution,
            _Out_ bool* pReplacementOk
            );
        #endif // #ifndef EXCLUDE_IDE_ONLY_APIS

        #ifndef EXCLUDE_IDE_ONLY_APIS
        /// <summary>
        /// Not described (internal API).
        ///
        /// Location constraint: API must be called from an IDE component (component level
        /// &gt; 100,000).
        /// </summary>
        /// <param name="DataIn">
        /// [In] Not described (internal API).
        ///
        /// The memory for the DkmArray members is allocated by the caller, and can be from
        /// any source (stack memory, static buffer, heap, etc). The implementation should
        /// not modify the members.
        /// </param>
        /// <param name="ppDataOut">
        /// [Out,Optional] Not described (internal API).
        /// </param>
        /// <returns>
        /// S_OK is returned if *ppDataOut is non-NULL, S_FALSE is returned when *ppDataOut
        /// is NULL, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE InPlaceUpdateObject(
            _In_ const DkmArray<BYTE>& DataIn,
            _Deref_out_opt_ DkmReadOnlyCollection<BYTE>** ppDataOut
            );
        #endif // #ifndef EXCLUDE_IDE_ONLY_APIS

        #ifndef EXCLUDE_IDE_ONLY_APIS
        /// <summary>
        /// Implements IPropertyProxyEESide::ResolveAssemblyReference().
        ///
        /// Location constraint: API must be called from an IDE component (component level
        /// &gt; 100,000).
        /// </summary>
        /// <param name="pAssemblyName">
        /// [In] Not described (internal API).
        /// </param>
        /// <param name="Flags">
        /// [In] GETASSEMBLY flags.
        /// </param>
        /// <param name="ppAssemblyBytes">
        /// [Out,Optional] Not described (internal API).
        /// </param>
        /// <param name="ppAssemblyPdb">
        /// [Out,Optional] Not described (internal API).
        /// </param>
        /// <param name="ppAssemblyLocation">
        /// [Out,Optional] Not described (internal API).
        /// </param>
        /// <param name="pAssemblyResolution">
        /// [Out] ASSEMBLYLOCRESOLUTION enum.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ResolveAssemblyReference(
            _In_ DkmString* pAssemblyName,
            _In_ UINT32 Flags,
            _Deref_out_opt_ DkmReadOnlyCollection<BYTE>** ppAssemblyBytes,
            _Deref_out_opt_ DkmReadOnlyCollection<BYTE>** ppAssemblyPdb,
            _Deref_out_opt_ DkmString** ppAssemblyLocation,
            _Out_ UINT32* pAssemblyResolution
            );
        #endif // #ifndef EXCLUDE_IDE_ONLY_APIS

        #ifndef EXCLUDE_IDE_ONLY_APIS
        /// <summary>
        /// Not described (internal API).
        ///
        /// Location constraint: API must be called from an IDE component (component level
        /// &gt; 100,000).
        ///
        /// This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
        /// </summary>
        /// <param name="ppDataOut">
        /// [Out,Optional] Not described (internal API).
        /// </param>
        /// <returns>
        /// S_OK is returned if *ppDataOut is non-NULL, S_FALSE is returned when *ppDataOut
        /// is NULL, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetInitialData(
            _Deref_out_opt_ DkmReadOnlyCollection<BYTE>** ppDataOut
            );
        #endif // #ifndef EXCLUDE_IDE_ONLY_APIS

        #ifndef EXCLUDE_IDE_ONLY_APIS
        /// <summary>
        /// Not described (internal API).
        ///
        /// Location constraint: API must be called from an IDE component (component level
        /// &gt; 100,000).
        ///
        /// This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
        /// </summary>
        /// <param name="DataIn">
        /// [In] Not described (internal API).
        ///
        /// The memory for the DkmArray members is allocated by the caller, and can be from
        /// any source (stack memory, static buffer, heap, etc). The implementation should
        /// not modify the members.
        /// </param>
        /// <param name="ppDataOut">
        /// [Out,Optional] Not described (internal API).
        /// </param>
        /// <returns>
        /// S_OK is returned if *ppDataOut is non-NULL, S_FALSE is returned when *ppDataOut
        /// is NULL, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE CreateReplacementObject(
            _In_ const DkmArray<BYTE>& DataIn,
            _Deref_out_opt_ DkmReadOnlyCollection<BYTE>** ppDataOut
            );
        #endif // #ifndef EXCLUDE_IDE_ONLY_APIS
    }; // end of DkmPropertyProxy

}; // end namespace Internal

// Contains types which are related to telemetry.
namespace Telemetry {
    // Represents an arbitrary name value pair.
    //
    // This API was introduced in Visual Studio 14 RTM (DkmApiVersion.VS14RTM).
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("45c37880-0ee9-689c-fb26-b3dfbf5cff3d") DkmNameValuePair : public IUnknown
    {
        private: ___ReferenceCount_t m_ReferenceCount;
        private: DkmDispatcherObjectFlags_t m_ObjectFlags;
        private: const GUID* m_pTypeId;
        private: size_t m_ObjectGCHandle;
        // Use DkmNameValuePair::Create to create this object
        private: DkmNameValuePair();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmNameValuePair();
        // This object cannot be copied
        private: DkmNameValuePair& operator=(const DkmNameValuePair&);
        private: DkmNameValuePair(const DkmNameValuePair&);

        private: DkmString* const m_pName;
        private: DkmVariant* const m_pValue;
        private: void* m__pExtendedData;

        // The name of this pair.
        //
        // This API was introduced in Visual Studio 14 RTM (DkmApiVersion.VS14RTM).
        public: _Ret_ DECLSPEC_NOTHROW DkmString* STDMETHODCALLTYPE Name(
            );

        // The value of this pair.
        //
        // This API was introduced in Visual Studio 14 RTM (DkmApiVersion.VS14RTM).
        public: _Ret_ DECLSPEC_NOTHROW DkmVariant* STDMETHODCALLTYPE Value(
            );

        /// <summary>
        /// Create a new DkmNameValuePair object instance.
        ///
        /// This API was introduced in Visual Studio 14 RTM (DkmApiVersion.VS14RTM).
        /// </summary>
        /// <param name="pName">
        /// [In] The name of this pair.
        /// </param>
        /// <param name="pValue">
        /// [In] The value of this pair.
        /// </param>
        /// <param name="ppCreatedObject">
        /// [Out] Result of this method call.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ DkmString* pName,
            _In_ DkmVariant* pValue,
            _Deref_out_ Telemetry::DkmNameValuePair** ppCreatedObject
            );
    }; // end of DkmNameValuePair

    // Result of an asynchronous DkmTelemetryEvent.Post call.
    struct DkmPostAsyncResult
    {
        // HRESULT code returned from the caller. This will be
        // DkmExceptionCode.COR_E_OPERATIONCANCELED (0x8013153B) if the operation was
        // canceled before processing was complete.
        HRESULT ErrorCode;
    };

    // This object represents a single telemetry event. It has an event name and a set of
    // properties.
    //
    // This API was introduced in Visual Studio 14 RTM (DkmApiVersion.VS14RTM).
    class DECLSPEC_NOVTABLE DECLSPEC_UUID("02237b74-d27c-db94-dfbd-18bfa838d7f5") DkmTelemetryEvent : public IUnknown
    {
        private: ___ReferenceCount_t m_ReferenceCount;
        private: DkmDispatcherObjectFlags_t m_ObjectFlags;
        private: const GUID* m_pTypeId;
        private: size_t m_ObjectGCHandle;
        // Use DkmTelemetryEvent::Create to create this object
        private: DkmTelemetryEvent();
        // This object is refcounted. It is deleted through Release
        protected: ~DkmTelemetryEvent();
        // This object cannot be copied
        private: DkmTelemetryEvent& operator=(const DkmTelemetryEvent&);
        private: DkmTelemetryEvent(const DkmTelemetryEvent&);

        private: DkmString* const m_pEventName;
        private: OPTIONAL DkmReadOnlyCollection<Telemetry::DkmNameValuePair*>* const m_pProperties;
        private: OPTIONAL DkmProcess* const m_pProcess;
        private: void* m__pExtendedData;

        // The name of the event.
        //
        // This API was introduced in Visual Studio 14 RTM (DkmApiVersion.VS14RTM).
        public: _Ret_ DECLSPEC_NOTHROW DkmString* STDMETHODCALLTYPE EventName(
            );

        // [Optional] A set of properties for this event. Each property consists of a Name
        // and a Variant type.
        //
        // This API was introduced in Visual Studio 14 RTM (DkmApiVersion.VS14RTM).
        public: _Ret_opt_ DECLSPEC_NOTHROW DkmReadOnlyCollection<Telemetry::DkmNameValuePair*>* STDMETHODCALLTYPE Properties(
            );

        // [Optional] Process to associate with this event.
        //
        // This API was introduced in Visual Studio 14 RTM (DkmApiVersion.VS14RTM).
        public: _Ret_opt_ DECLSPEC_NOTHROW DkmProcess* STDMETHODCALLTYPE Process(
            );

        /// <summary>
        /// Create a new DkmTelemetryEvent object instance.
        ///
        /// This API was introduced in Visual Studio 14 RTM (DkmApiVersion.VS14RTM).
        /// </summary>
        /// <param name="pEventName">
        /// [In] The name of the event.
        /// </param>
        /// <param name="pProperties">
        /// [In,Optional] A set of properties for this event. Each property consists of a
        /// Name and a Variant type.
        /// </param>
        /// <param name="pProcess">
        /// [In,Optional] Process to associate with this event.
        /// </param>
        /// <param name="ppCreatedObject">
        /// [Out] Result of this method call.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: static DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Create(
            _In_ DkmString* pEventName,
            _In_opt_ DkmReadOnlyCollection<Telemetry::DkmNameValuePair*>* pProperties,
            _In_opt_ DkmProcess* pProcess,
            _Deref_out_ Telemetry::DkmTelemetryEvent** ppCreatedObject
            );

        /// <summary>
        /// Send the Telemetry Event to the Visual Studio Telemetry Service.
        ///
        /// This API was introduced in Visual Studio 14 RTM (DkmApiVersion.VS14RTM).
        /// </summary>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Post(
            );

        /// <summary>
        /// Send the Telemetry Event to the Visual Studio Telemetry Service.
        ///
        /// This method will append a new work item to the specified work list, and return
        /// once the work item has been appended. The actual processing of the work item is
        /// asynchronous. The caller will be notified that the request is complete through
        /// the completion routine.
        ///
        /// This API was introduced in Visual Studio 14 RTM (DkmApiVersion.VS14RTM).
        /// </summary>
        /// <param name="pWorkList">
        /// WorkList to append the new work item to.
        /// </param>
        /// <param name="pCompletionRoutine">
        /// Routine to fire when the request is complete. If the request is successfully
        /// appended to the work list, this will always fire (including when the operation is
        /// canceled). This will never fire if appending the work item fails.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        public: DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Post(
            _In_ DkmWorkList* pWorkList,
            _In_ IDkmCompletionRoutine<Telemetry::DkmPostAsyncResult>* pCompletionRoutine
            );
    }; // end of DkmTelemetryEvent

}; // end namespace Telemetry



// Expression evaluators interfaces
// Expression Evaluators are components which are typically implemented by compiler
// vendors. They allow users to debug in the same language as the code was written. They
// do this by flavoring various debugger windows, such as the Watch, Call stack, and
// Function breakpoints to the language of the code.
//
// Expression evaluators may be loaded on either the Visual Studio computer or the target
// (remote) computer.
//
// The challenge with implementing expression evaluators on the Visual Studio computer is
// that in target debugging scenarios, it can be slow to access the memory of the target
// computer. To resolve this issue, expression evaluators should be implemented by
// sending a query to the target machine which can examine the state of the target
// process and return data. For debugging native code, this is implemented though
// DkmCompiledInspectionQuery.Execute. Expression evaluators loaded on the Visual Studio
// computer should have a component level of 9992000.
//
// The challenge with implementing expression evaluators on the target computer is that
// accesses to the symbol store may need to be remoted, and can therefore be expensive.
// This approach can be used in languages/runtimes where a large amount of the symbolic
// information is available on the target computer. For example, in most managed
// languages, metadata can be used to describe much of the program, so it's possible to
// implement expression evaluators for managed languages on the target computer.
// Expression evaluators that load on the target computer should have a component level
// of 65000.
namespace ComponentInterfaces
{
    // Instantiates the debuggee-side Custom Visualizer type in the debuggee and provides
    // methods to access/modify the visualized object ('Visualizer Object').
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // CompilerVendorId, EngineId, LanguageId, RuntimeId.
    //
    // This API was introduced in Visual Studio 14 RTM (DkmApiVersion.VS14RTM).
    #define IID_IDkmClrCustomVisualizerObjectProvider __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmClrCustomVisualizerObjectProvider)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("0727e58a-407a-67c0-137f-d3eec5e6e1df") IDkmClrCustomVisualizerObjectProvider : public IUnknown
    {
        /// <summary>
        /// Instantiates the debuggee-side Custom Visualizer type in the debuggee process.
        /// </summary>
        /// <param name="pSuccessResult">
        /// [In] The formatted result of a successful evaluation, ready to be displayed in an
        /// expression evaluation window.
        /// </param>
        /// <param name="SelectedVisualizerIndex">
        /// [In] The index of the selected visualizer.
        /// </param>
        /// <param name="ppExceptionType">
        /// [Out,Optional] The type of the exception thrown, if any.
        /// </param>
        /// <param name="ppExceptionStackTrace">
        /// [Out,Optional] The stack trace of the exception thrown, if any.
        /// </param>
        /// <param name="ppExceptionMessage">
        /// [Out,Optional] The exception message, if any.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE CreateDebuggeeSideVisualizerObject(
            _In_ Evaluation::DkmSuccessEvaluationResult* pSuccessResult,
            _In_ UINT32 SelectedVisualizerIndex,
            _Deref_out_opt_ DkmString** ppExceptionType,
            _Deref_out_opt_ DkmString** ppExceptionStackTrace,
            _Deref_out_opt_ DkmString** ppExceptionMessage
            ) = 0;

        /// <summary>
        /// Releases the debuggee-side Custom Visualizer type in the debuggee process.
        /// </summary>
        /// <param name="pSuccessResult">
        /// [In] The formatted result of a successful evaluation, ready to be displayed in an
        /// expression evaluation window.
        /// </param>
        /// <param name="pResult">
        /// [Out] If the handle was successfully removed, return true. If no handle, return
        /// false.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE DestroyDebuggeeSideVisualizerObject(
            _In_ Evaluation::DkmSuccessEvaluationResult* pSuccessResult,
            _Out_ bool* pResult
            ) = 0;

        /// <summary>
        /// Resolves an assembly name to the path of the assembly or to its raw bytes.
        /// </summary>
        /// <param name="pSuccessResult">
        /// [In] The formatted result of a successful evaluation, ready to be displayed in an
        /// expression evaluation window.
        /// </param>
        /// <param name="pAssemblyName">
        /// [In] The fully qualified name of the assembly to resolve.
        /// </param>
        /// <param name="ppAssemblyPath">
        /// [Out,Optional] The path of the resolved assembly for local debugging.
        /// </param>
        /// <param name="ppAssemblyBytes">
        /// [Out,Optional] The byte array of the resolved assembly for remote debugging.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE ResolveAssembly(
            _In_ Evaluation::DkmSuccessEvaluationResult* pSuccessResult,
            _In_ DkmString* pAssemblyName,
            _Deref_out_opt_ DkmString** ppAssemblyPath,
            _Deref_out_opt_ DkmReadOnlyCollection<BYTE>** ppAssemblyBytes
            ) = 0;

        /// <summary>
        /// Executes the debuggee-side Custom Visualizer type's GetData(...) method.
        /// </summary>
        /// <param name="pSuccessResult">
        /// [In] The formatted result of a successful evaluation, ready to be displayed in an
        /// expression evaluation window.
        /// </param>
        /// <param name="ppVisualizerObject">
        /// [Out,Optional] The raw bytes of the GetData(...) method marshalled as a byte
        /// array.
        /// </param>
        /// <param name="ppExceptionType">
        /// [Out,Optional] The type of the exception thrown, if any.
        /// </param>
        /// <param name="ppExceptionStackTrace">
        /// [Out,Optional] The stack trace of the exception thrown, if any.
        /// </param>
        /// <param name="ppExceptionMessage">
        /// [Out,Optional] The exception message, if any.
        /// </param>
        /// <returns>
        /// S_OK is returned if *ppVisualizerObject is non-NULL, S_FALSE is returned when
        /// *ppVisualizerObject is NULL, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE GetDataFromDebuggeeSideVisualizer(
            _In_ Evaluation::DkmSuccessEvaluationResult* pSuccessResult,
            _Deref_out_opt_ DkmReadOnlyCollection<BYTE>** ppVisualizerObject,
            _Deref_out_opt_ DkmString** ppExceptionType,
            _Deref_out_opt_ DkmString** ppExceptionStackTrace,
            _Deref_out_opt_ DkmString** ppExceptionMessage
            ) = 0;

        /// <summary>
        /// Executes the debuggee-side Custom Visualizer type's TransferData(...) method.
        /// </summary>
        /// <param name="pSuccessResult">
        /// [In] The formatted result of a successful evaluation, ready to be displayed in an
        /// expression evaluation window.
        /// </param>
        /// <param name="DataIn">
        /// [In] The data to transfer to the debuggee-side Visualizer class.
        ///
        /// The memory for the DkmArray members is allocated by the caller, and can be from
        /// any source (stack memory, static buffer, heap, etc). The implementation should
        /// not modify the members.
        /// </param>
        /// <param name="ppResponse">
        /// [Out,Optional] The raw bytes of the result of the TransferData(...) method
        /// marshalled as a byte array.
        /// </param>
        /// <param name="ppExceptionType">
        /// [Out,Optional] The type of the exception thrown, if any.
        /// </param>
        /// <param name="ppExceptionStackTrace">
        /// [Out,Optional] The stack trace of the exception thrown, if any.
        /// </param>
        /// <param name="ppExceptionMessage">
        /// [Out,Optional] The exception message, if any.
        /// </param>
        /// <returns>
        /// S_OK is returned if *ppResponse is non-NULL, S_FALSE is returned when *ppResponse
        /// is NULL, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE TransferDataToDebuggeeSideVisualizer(
            _In_ Evaluation::DkmSuccessEvaluationResult* pSuccessResult,
            _In_ const DkmArray<BYTE>& DataIn,
            _Deref_out_opt_ DkmReadOnlyCollection<BYTE>** ppResponse,
            _Deref_out_opt_ DkmString** ppExceptionType,
            _Deref_out_opt_ DkmString** ppExceptionStackTrace,
            _Deref_out_opt_ DkmString** ppExceptionMessage
            ) = 0;

        /// <summary>
        /// Executes the debuggee-side Custom Visualizer type's CreateReplacementObject(...)
        /// method, and writes the result to the visualized object handle.
        /// </summary>
        /// <param name="pSuccessResult">
        /// [In] The formatted result of a successful evaluation, ready to be displayed in an
        /// expression evaluation window.
        /// </param>
        /// <param name="DataIn">
        /// [In] The data to transfer to the debuggee-side Visualizer class.
        ///
        /// The memory for the DkmArray members is allocated by the caller, and can be from
        /// any source (stack memory, static buffer, heap, etc). The implementation should
        /// not modify the members.
        /// </param>
        /// <param name="ppExceptionType">
        /// [Out,Optional] The type of the exception thrown, if any.
        /// </param>
        /// <param name="ppExceptionStackTrace">
        /// [Out,Optional] The stack trace of the exception thrown, if any.
        /// </param>
        /// <param name="ppExceptionMessage">
        /// [Out,Optional] The exception message, if any.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE CreateReplacementObjectOnDebuggeeSideVisualizer(
            _In_ Evaluation::DkmSuccessEvaluationResult* pSuccessResult,
            _In_ const DkmArray<BYTE>& DataIn,
            _Deref_out_opt_ DkmString** ppExceptionType,
            _Deref_out_opt_ DkmString** ppExceptionStackTrace,
            _Deref_out_opt_ DkmString** ppExceptionMessage
            ) = 0;
    };

    // This interface is implemented the expression evaluator to allow an EE addin to
    // callback to the expression evaluator.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // EngineId, RuntimeId, SourceId, VisualizerId.
    #define IID_IDkmCustomVisualizerCallback __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmCustomVisualizerCallback)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("c36da556-bab7-7ca1-50e4-6372543a80fe") IDkmCustomVisualizerCallback : public IUnknown
    {
        /// <summary>
        /// Allows custom expression evaluator addins to obtain the symbol interface for the
        /// type being visualized. This is not stored in the DkmVisualizedExpression directly
        /// to enable addins that live on the remote machine and do not depend on symbols.
        /// </summary>
        /// <param name="pVisualizedExpression">
        /// [In] Dispatcher object used for custom visualization through a concord EE addin.
        /// </param>
        /// <param name="TypeSymbolInterfaceId">
        /// [In] The GUID of the TypeSymbolInterface interface requested from the caller. For
        /// the Microsoft native C++ expression evaluator, this should be IID_IDiaSymbol.
        /// </param>
        /// <param name="ppTypeSymbolInterface">
        /// [Out] The symbol interface of the type that was used to evaluate the expression.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE GetSymbolInterface(
            _In_ Evaluation::DkmVisualizedExpression* pVisualizedExpression,
            _In_ const GUID& TypeSymbolInterfaceId,
            _Deref_out_ IUnknown** ppTypeSymbolInterface
            ) = 0;

        /// <summary>
        /// This method allows a visualizer addin use the expression evaluator to compile and
        /// evaluate the default value for an expression. The addin can use this result as-is
        /// or override fields by creating a new result. The addin can also choose to use the
        /// expression evaluator for expansion using the the get children callbacks.
        /// </summary>
        /// <param name="pVisualizedExpression">
        /// [In] Dispatcher object used for custom visualization through a concord EE addin.
        /// </param>
        /// <param name="pInspectionContext">
        /// [In] The inspection context to use for this evaluation.
        /// </param>
        /// <param name="pExpression">
        /// [In] The expression the visualizer addin to would like the expression evaluator
        /// to evaluate.
        /// </param>
        /// <param name="pStackFrame">
        /// [In] Stack frame to evaluate the expression in.
        /// </param>
        /// <param name="ppResultObject">
        /// [Out] Object containing the result of the evaluation.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// E_PROCESS_DESTROYED indicates that the process exited while attempting to
        /// evaluate.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE EvaluateExpressionCallback(
            _In_ Evaluation::DkmVisualizedExpression* pVisualizedExpression,
            _In_ Evaluation::DkmInspectionContext* pInspectionContext,
            _In_ Evaluation::DkmLanguageExpression* pExpression,
            _In_ CallStack::DkmStackWalkFrame* pStackFrame,
            _Deref_out_ Evaluation::DkmEvaluationResult** ppResultObject
            ) = 0;

        /// <summary>
        /// This method will construct a default full name for a custom visualized child
        /// expression. This name will be the root expression's full name and an expand
        /// format string that will cause the expression evaluator to callback to the
        /// visualizer to obtain children. The DkmVisualizedExpression instance this is
        /// called on should be the parent visualized expression for a child and the root
        /// visualized expression for a root.
        /// </summary>
        /// <param name="pVisualizedExpression">
        /// [In] Dispatcher object used for custom visualization through a concord EE addin.
        /// </param>
        /// <param name="Index">
        /// [In] The index of child for which this full name is created. Ignored in the case
        /// of a root item.
        /// </param>
        /// <param name="ppFullName">
        /// [Out] The returned full name string.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE CreateDefaultChildFullName(
            _In_ Evaluation::DkmVisualizedExpression* pVisualizedExpression,
            _In_ INT32 Index,
            _Deref_out_ DkmString** ppFullName
            ) = 0;

        /// <summary>
        /// This method allows a visualizer addin use the expression evaluator for expansion.
        /// The evaluation result contained within the visualized expression must have come
        /// from the expression evaluator via EvaluateExpressionCallback.
        /// </summary>
        /// <param name="pVisualizedExpression">
        /// [In] Dispatcher object used for custom visualization through a concord EE addin.
        /// </param>
        /// <param name="pDefaultEvaluationResult">
        /// [In] The evaluation result returned from the expression evaluator for this
        /// expression. The expression evaluator can only control the expansion of
        /// evaluations it understands.
        /// </param>
        /// <param name="InitialRequestSize">
        /// [In] The initial number of children that the caller would like returned. This
        /// value can be zero if no children will be initially returned. This value may be
        /// larger than the number of children that this expression has, in which case all
        /// children should be returned. Very large or negative values should not be used as
        /// arrays can have extremely large sizes which would cause out-of-memory if all
        /// elements were requested.
        /// </param>
        /// <param name="pInspectionContext">
        /// [In] The inspection context to use for computing the children.  This may differ
        /// from the original inspection context with respect to settings, such as radix,
        /// evaluation flags, or timeout.
        /// </param>
        /// <param name="pInitialChildren">
        /// [Out] The initial children to return. Each child must be closed by the caller
        /// when the caller is done.
        ///
        /// The memory for the DkmArray members is allocated by the method implementation
        /// using DkmAllocBytes/DkmAllocArray. It is freed by the caller using the
        /// CAutoDkmArray template or with DkmFreeMemory and manual element release.
        /// </param>
        /// <param name="ppEnumContext">
        /// [Out] Context object used to enumerate the children. This object must be closed
        /// by the caller of this API when enumeration is complete.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE GetChildrenCallback(
            _In_ Evaluation::DkmVisualizedExpression* pVisualizedExpression,
            _In_ Evaluation::DkmEvaluationResult* pDefaultEvaluationResult,
            _In_ UINT32 InitialRequestSize,
            _In_ Evaluation::DkmInspectionContext* pInspectionContext,
            _Out_ DkmArray<Evaluation::DkmEvaluationResult*>* pInitialChildren,
            _Deref_out_ Evaluation::DkmEvaluationResultEnumContext** ppEnumContext
            ) = 0;

        /// <summary>
        /// This method allows a visualizer addin use the expression evaluator for expansion
        /// using the passed enumeration context. This is used to obtain local variables of a
        /// stack frame or child members from an evaluation result.
        /// </summary>
        /// <param name="pVisualizedExpression">
        /// [In] Dispatcher object used for custom visualization through a concord EE addin.
        /// </param>
        /// <param name="pEnumContext">
        /// [In] Context object used to enumerate the children.
        /// </param>
        /// <param name="StartIndex">
        /// [In] The zero-based index of the first item to obtain.
        /// </param>
        /// <param name="Count">
        /// [In] The number of items to try and return. This value may be larger than the
        /// total number of remaining items, in which case all remaining items should be
        /// returned. Very large or negative values should not be used as arrays can have
        /// extremely large sizes which would cause out-of-memory if all elements were
        /// requested.
        /// </param>
        /// <param name="pItems">
        /// [Out] The DkmEvaluationResult items to return. Each item must be closed by the
        /// caller when the caller is done.
        ///
        /// The memory for the DkmArray members is allocated by the method implementation
        /// using DkmAllocBytes/DkmAllocArray. It is freed by the caller using the
        /// CAutoDkmArray template or with DkmFreeMemory and manual element release.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE GetItemsCallback(
            _In_ Evaluation::DkmVisualizedExpression* pVisualizedExpression,
            _In_ Evaluation::DkmEvaluationResultEnumContext* pEnumContext,
            _In_ UINT32 StartIndex,
            _In_ UINT32 Count,
            _Out_ DkmArray<Evaluation::DkmEvaluationResult*>* pItems
            ) = 0;

        /// <summary>
        /// Modifies the value of the given evaluation result (assumed to be non-read-only)
        /// to match the given string. This is used after the user edits a value in any of
        /// the evaluation windows.
        /// </summary>
        /// <param name="pVisualizedExpression">
        /// [In] Dispatcher object used for custom visualization through a concord EE addin.
        /// </param>
        /// <param name="pDefaultEvaluationResult">
        /// [In] The evaluation result returned from the expression evaluator for this
        /// expression. The expression evaluator can only control evaluations it understands.
        /// </param>
        /// <param name="pValue">
        /// [In] Textual representation of value to assign to the evaluation result.
        /// </param>
        /// <param name="Timeout">
        /// [In] If a function evaluation is needed to assign the value, specifies the
        /// timeout to use.
        /// </param>
        /// <param name="ppErrorText">
        /// [Out,Optional] If the operation failed, this indicates the reason why. This value
        /// should be null if the operation succeeded. In native code, an S_OK return value
        /// is used when returning error text.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE SetValueAsStringCallback(
            _In_ Evaluation::DkmVisualizedExpression* pVisualizedExpression,
            _In_ Evaluation::DkmEvaluationResult* pDefaultEvaluationResult,
            _In_ DkmString* pValue,
            _In_ UINT32 Timeout,
            _Deref_out_opt_ DkmString** ppErrorText
            ) = 0;

        /// <summary>
        /// This method is used for evaluation results that include
        /// DkmEvaluationResultFlags.RawString to obtain the the underlying string, with no
        /// enclosing quotes or escape sequences. This is method is invoked to display one of
        /// the various string visualizers in an expression evaluation window (click the
        /// magnifying glass icon).
        /// </summary>
        /// <param name="pVisualizedExpression">
        /// [In] Dispatcher object used for custom visualization through a concord EE addin.
        /// </param>
        /// <param name="pDefaultEvaluationResult">
        /// [In] The evaluation result returned from the expression evaluator for this
        /// expression. The expression evaluator can only control evaluations it understands.
        /// </param>
        /// <param name="ppStringValue">
        /// [Out,Optional] The underlying string value.
        /// </param>
        /// <returns>
        /// S_OK is returned if *ppStringValue is non-NULL, S_FALSE is returned when
        /// *ppStringValue is NULL, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE GetUnderlyingStringCallback(
            _In_ Evaluation::DkmVisualizedExpression* pVisualizedExpression,
            _In_ Evaluation::DkmEvaluationResult* pDefaultEvaluationResult,
            _Deref_out_opt_ DkmString** ppStringValue
            ) = 0;
    };

    // This interface allows a language extension to provide the ability to evaluate
    // expressions on a group of threads. It should generally be implemented by all language
    // extensions.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // BaseDebugMonitorId, CompilerVendorId, EngineId, LanguageId, RuntimeId.
    #define IID_IDkmGroupLanguageExpressionEvaluator __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmGroupLanguageExpressionEvaluator)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("c3ae386f-e1b7-32a4-9d9e-3f8c317c2162") IDkmGroupLanguageExpressionEvaluator : public IUnknown
    {
        /// <summary>
        /// Bind the input expression and evaluate it. Then format the resulting value for
        /// display in the debugger. This is used for data tips, the watch windows, the
        /// immediate window, etc.
        /// </summary>
        /// <param name="pInspectionContext">
        /// [In] Options and target context to use while performing the inspection operation.
        /// </param>
        /// <param name="pWorkList">
        /// WorkList which is currently being processed. This value can be used to check for
        /// cancelation or to append additional work. New work items will not begin executing
        /// until after this function returns.
        /// </param>
        /// <param name="pThreads">
        /// [In] The compute threads to use when executing the query.
        /// </param>
        /// <param name="pStackFrame">
        /// [In] Stack frame to match on compute threads.
        /// </param>
        /// <param name="pExpression">
        /// [In] Expression to evaluate.
        /// </param>
        /// <param name="pCompletionRoutine">
        /// Routine to fire when the request is complete. This will be implicitly fired if
        /// the implementation returns failure from this interface method. The implementation
        /// must fire this method in all other scenarios.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE EvaluateExpressionOnThreads(
            _In_ Evaluation::DkmInspectionContext* pInspectionContext,
            _In_ DkmWorkList* pWorkList,
            _In_ DkmReadOnlyCollection<UINT64>* pThreads,
            _In_ CallStack::DkmStackWalkFrame* pStackFrame,
            _In_ Evaluation::DkmLanguageExpression* pExpression,
            _In_ IDkmCompletionRoutine<Evaluation::Group::DkmEvaluateExpressionOnThreadsAsyncResult>* pCompletionRoutine
            ) = 0;
    };

    // Resolves a DkmILFailureReason into an error message.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // CompiledInspectionQueryKind, CompilerVendorId, EngineId, LanguageId, RuntimeId.
    //
    // This API was introduced in Visual Studio 14 RTM (DkmApiVersion.VS14RTM).
    #define IID_IDkmILFailureReasonResolver __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmILFailureReasonResolver)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("3f67288e-460f-6e6e-2c73-d6341bc3f486") IDkmILFailureReasonResolver : public IUnknown
    {
        /// <summary>
        /// Resolves a DkmILFailureReason into an error message.  This is used to produce the
        /// error message for a condition breakpoint.
        /// </summary>
        /// <param name="pQuery">
        /// [In] Represents a query which is produced by an expression evaluator or similar
        /// component and set to the target computer to obtain information about the dynamic
        /// state of the program (ex: the current value of a register).  Consumers of
        /// inspection queries should call Close() once it is known that the inspection query
        /// will no longer execute.
        /// </param>
        /// <param name="ErrorCode">
        /// [In] Error code returned from execution of the IL stream.
        /// </param>
        /// <param name="ppErrorMessage">
        /// [Out] Human-readable error message describing the error.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE ResolveILFailureReason(
            _In_ Evaluation::DkmCompiledInspectionQuery* pQuery,
            _In_ Evaluation::IL::DkmILFailureReason_t ErrorCode,
            _Deref_out_ DkmString** ppErrorMessage
            ) = 0;
    };

    // This interface allows an expression evaluator to specify intrinsic operations to be
    // invoked through IL, which the EE is responsible for implementing.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // LanguageId, SourceId.
    #define IID_IDkmIntrinsicFunctionEvaluator __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmIntrinsicFunctionEvaluator)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("54090b06-0fa6-dba2-b7c7-b598f98f4b16") IDkmIntrinsicFunctionEvaluator : public IUnknown
    {
        /// <summary>
        /// Executes an intrinsic function.
        /// </summary>
        /// <param name="pExecuteIntrinsic">
        /// [In] Pops the arguments off the IL stack in reverse order (prior to the
        /// DkmILExecuteIntrinsic instruction, arguments should be pushed on the stack in
        /// order). Then, executes an EE-defined operation that makes use of these values.
        /// Then, pushes the result back onto the IL stack.
        /// </param>
        /// <param name="pILContext">
        /// [In] The stack frame context we are evaluating on.
        /// </param>
        /// <param name="Arguments">
        /// [In] The arguments supplied to the intrinsic function.
        ///
        /// The memory for the DkmArray members is allocated by the caller, and can be from
        /// any source (stack memory, static buffer, heap, etc). The implementation should
        /// not modify the members.
        /// </param>
        /// <param name="pSubroutines">
        /// [In,Optional] Optional array of IL-based subroutines that the intrinsic function
        /// may choose to invoke during its operation.
        /// </param>
        /// <param name="pResults">
        /// [Out] The results of the evaluation to be pushed onto the IL stack (in order).
        ///
        /// The memory for the DkmArray members is allocated by the method implementation
        /// using DkmAllocBytes/DkmAllocArray. It is freed by the caller using the
        /// CAutoDkmArray template or with DkmFreeMemory and manual element release.
        /// </param>
        /// <param name="pFailureReason">
        /// [Out] If an error occurs, specifies the reason for the error.  To indicate an
        /// error code whose meaning is specific to the particular intrinsic function being
        /// executed, return a value less than zero.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE Execute(
            _In_ Evaluation::IL::DkmILExecuteIntrinsic* pExecuteIntrinsic,
            _In_ Evaluation::DkmILContext* pILContext,
            _In_ const DkmArray<Evaluation::IL::DkmILEvaluationResult*>& Arguments,
            _In_opt_ DkmReadOnlyCollection<Evaluation::DkmCompiledInspectionQuery*>* pSubroutines,
            _Out_ DkmArray<Evaluation::IL::DkmILEvaluationResult*>* pResults,
            _Out_ Evaluation::IL::DkmILFailureReason_t* pFailureReason
            ) = 0;
    };

    // This interface allows an expression evaluator to specify intrinsic operations to be
    // invoked through IL, which the EE is responsible for implementing.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // LanguageId, SourceId.
    //
    // This API was introduced in Visual Studio 14 RTM (DkmApiVersion.VS14RTM).
    #define IID_IDkmIntrinsicFunctionEvaluator140 __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmIntrinsicFunctionEvaluator140)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("c4f66834-5baf-a623-334f-1bba5440f0b5") IDkmIntrinsicFunctionEvaluator140 : public IUnknown
    {
        /// <summary>
        /// Executes an intrinsic function.
        /// </summary>
        /// <param name="pExecuteIntrinsic">
        /// [In] Pops the arguments off the IL stack in reverse order (prior to the
        /// DkmILExecuteIntrinsic instruction, arguments should be pushed on the stack in
        /// order). Then, executes an EE-defined operation that makes use of these values.
        /// Then, pushes the result back onto the IL stack.
        /// </param>
        /// <param name="pILContext">
        /// [In] The stack frame context we are evaluating on.
        /// </param>
        /// <param name="pInspectionQuery">
        /// [In] Currently executing instruction query that this intrinsic function belongs
        /// to.
        /// </param>
        /// <param name="Arguments">
        /// [In] The arguments supplied to the intrinsic function.
        ///
        /// The memory for the DkmArray members is allocated by the caller, and can be from
        /// any source (stack memory, static buffer, heap, etc). The implementation should
        /// not modify the members.
        /// </param>
        /// <param name="pSubroutines">
        /// [In,Optional] Optional array of IL-based subroutines that the intrinsic function
        /// may choose to invoke during its operation.
        /// </param>
        /// <param name="pResults">
        /// [Out] The results of the evaluation to be pushed onto the IL stack (in order).
        ///
        /// The memory for the DkmArray members is allocated by the method implementation
        /// using DkmAllocBytes/DkmAllocArray. It is freed by the caller using the
        /// CAutoDkmArray template or with DkmFreeMemory and manual element release.
        /// </param>
        /// <param name="pFailureReason">
        /// [Out] If an error occurs, specifies the reason for the error.  To indicate an
        /// error code whose meaning is specific to the particular intrinsic function being
        /// executed, return a value less than zero.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE Execute(
            _In_ Evaluation::IL::DkmILExecuteIntrinsic* pExecuteIntrinsic,
            _In_ Evaluation::DkmILContext* pILContext,
            _In_ Evaluation::IL::DkmCompiledILInspectionQuery* pInspectionQuery,
            _In_ const DkmArray<Evaluation::IL::DkmILEvaluationResult*>& Arguments,
            _In_opt_ DkmReadOnlyCollection<Evaluation::DkmCompiledInspectionQuery*>* pSubroutines,
            _Out_ DkmArray<Evaluation::IL::DkmILEvaluationResult*>* pResults,
            _Out_ Evaluation::IL::DkmILFailureReason_t* pFailureReason
            ) = 0;
    };

    // This interface is implemented by languages to enable stepping behavior for async
    // methods.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // CompilerVendorId, EngineId, LanguageId, RuntimeId.
    #define IID_IDkmLanguageAsyncStepper __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmLanguageAsyncStepper)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("c2770199-bdf6-b971-47a9-e5d86ec4daf7") IDkmLanguageAsyncStepper : public IUnknown
    {
        /// <summary>
        /// This method returns the identity of an async method. This is used to set
        /// conditional breakpoints for stepping over an await expression.
        /// </summary>
        /// <param name="pLanguageInstructionAddress">
        /// [In] Pairing between an instruction address and the language that should be used
        /// to decode it.
        /// </param>
        /// <param name="pThread">
        /// [In] Stack frame that provides the context of in which to evaluate the
        /// expression.
        /// </param>
        /// <param name="ppIdentity">
        /// [Out] The identity of the async method.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE GetAsyncMethodIdentity(
            _In_ Evaluation::DkmLanguageInstructionAddress* pLanguageInstructionAddress,
            _In_ DkmThread* pThread,
            _Deref_out_ ICorDebugHandleValue** ppIdentity
            ) = 0;

        /// <summary>
        /// This method asks the language to set or clear a flag on the Task backing the
        /// async method. This flag enables stopping during step out of an async method.
        /// </summary>
        /// <param name="pLanguageInstructionAddress">
        /// [In] Pairing between an instruction address and the language that should be used
        /// to decode it.
        /// </param>
        /// <param name="pThread">
        /// [In] Stack frame that provides the context of in which to evaluate the
        /// expression.
        /// </param>
        /// <param name="Value">
        /// [In] If true set the flag, else clear the flag.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE SetStepOutFlag(
            _In_ Evaluation::DkmLanguageInstructionAddress* pLanguageInstructionAddress,
            _In_ DkmThread* pThread,
            _In_ bool Value
            ) = 0;
    };

    // This interface is implemented by expression evaluators which live or the target
    // computer and wish to support conditional breakpoints.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // CompilerVendorId, EngineId, LanguageId, RuntimeId.
    #define IID_IDkmLanguageConditionEvaluator __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmLanguageConditionEvaluator)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("c64e6bd6-39ac-04fb-ecd3-e2e41ed6d59a") IDkmLanguageConditionEvaluator : public IUnknown
    {
        /// <summary>
        /// Parses an input breakpoint condition so that it can later be evaluated. If the
        /// breakpoint condition uses DkmBreakpointConditionOperator.BreakWhenTrue, the
        /// expression evaluator should require that the specified condition evaluates to a
        /// Boolean value. The created query must return only a single result. For
        /// BreakWhenTrue conditions, this must be either a 4-byte or 1-byte value, and any
        /// non-zero value is considered true.
        /// </summary>
        /// <param name="pEvaluationCondition">
        /// [In] Represents a condition which is evaluated on the target computer. These
        /// objects are used for languages where the expression evaluator is implemented on
        /// the target.
        /// </param>
        /// <param name="ppErrorText">
        /// [Out,Optional] If the condition could not be parsed, this indicates the reason
        /// why. This value should be null if the compile succeeded.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE ParseCondition(
            _In_ Breakpoints::DkmEvaluationBreakpointCondition* pEvaluationCondition,
            _Deref_out_opt_ DkmString** ppErrorText
            ) = 0;

        /// <summary>
        /// Evaluates a condition to decide if the debugger should stop.
        /// </summary>
        /// <param name="pEvaluationCondition">
        /// [In] Represents a condition which is evaluated on the target computer. These
        /// objects are used for languages where the expression evaluator is implemented on
        /// the target.
        /// </param>
        /// <param name="pStackFrame">
        /// [In] The stack frame to use when evaluating the condition.
        /// </param>
        /// <param name="pStop">
        /// [Out] True if the breakpoint condition indicated that the IDE should stop.
        /// </param>
        /// <param name="ppErrorText">
        /// [Out,Optional] If the condition could not be evaluated, this indicates the reason
        /// why. This value should be null if the compile succeeded.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE EvaluateCondition(
            _In_ Breakpoints::DkmEvaluationBreakpointCondition* pEvaluationCondition,
            _In_ CallStack::DkmStackWalkFrame* pStackFrame,
            _Out_ bool* pStop,
            _Deref_out_opt_ DkmString** ppErrorText
            ) = 0;
    };

    // This interface allows a language extension to pre-compile breakpoint conditions so
    // that the same expression may be quickly evaluated when the breakpoint is hit.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // CompilerVendorId, EngineId, LanguageId, RuntimeId.
    #define IID_IDkmLanguageExpressionCompiler __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmLanguageExpressionCompiler)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("b8a50138-6bf6-e554-871c-186db6678991") IDkmLanguageExpressionCompiler : public IUnknown
    {
        /// <summary>
        /// This method is obsolete and should not be used.
        /// </summary>
        /// <param name="pLanguageInstructionAddress">
        /// [In] Pairing between an instruction address and the language that should be used
        /// to decode it.
        /// </param>
        /// <param name="pExpression">
        /// [In] Not used.
        /// </param>
        /// <param name="ppError">
        /// [Out,Optional] Not used.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE Compile(
            _In_ Evaluation::DkmLanguageInstructionAddress* pLanguageInstructionAddress,
            _In_ Evaluation::DkmLanguageExpression* pExpression,
            _Deref_out_opt_ Evaluation::DkmFailedEvaluationResult** ppError
            ) = 0;

        /// <summary>
        /// Compiles an input breakpoint condition into an inspection query which can be
        /// evaluated on the target computer. If the breakpoint condition uses
        /// DkmBreakpointConditionOperator.BreakWhenTrue, the expression evaluator should
        /// require that the specified condition evaluates to a Boolean value. The created
        /// query must return only a single result. For BreakWhenTrue conditions, this must
        /// be either a 4-byte or 1-byte value, and any non-zero value is considered true.
        /// </summary>
        /// <param name="pLanguageInstructionAddress">
        /// [In] Pairing between an instruction address and the language that should be used
        /// to decode it.
        /// </param>
        /// <param name="pCondition">
        /// [In] Breakpoint condition to compile.
        /// </param>
        /// <param name="ppCompiledCondition">
        /// [Out,Optional] The result of the compilation. This is null in the case that the
        /// compilation failed. In this case, ErrorText should indicate the reason for the
        /// failure.
        /// </param>
        /// <param name="ppErrorText">
        /// [Out,Optional] If the compilation failed, this indicates the reason why. This
        /// value should be null if the compile succeeded. If the compile does fail, S_FALSE
        /// is returned (native code only).
        /// </param>
        /// <returns>
        /// S_OK is returned if *ppCompiledCondition is non-NULL, S_FALSE is returned when
        /// *ppCompiledCondition is NULL, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE CompileCondition(
            _In_ Evaluation::DkmLanguageInstructionAddress* pLanguageInstructionAddress,
            _In_ Breakpoints::DkmBreakpointCondition* pCondition,
            _Deref_out_opt_ Evaluation::DkmCompiledInspectionQuery** ppCompiledCondition,
            _Deref_out_opt_ DkmString** ppErrorText
            ) = 0;
    };

    // This interface allows a language extension to provide the ability to evaluate
    // expressions in the various data inspection windows of the debugger (watch, autos,
    // immediate, memory, disassembly, etc). It should generally be implemented by all
    // language extensions.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // CompilerVendorId, EngineId, LanguageId, RuntimeId.
    #define IID_IDkmLanguageExpressionEvaluator __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmLanguageExpressionEvaluator)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("85b024d7-e6e5-1943-ac3c-9815e754cf8b") IDkmLanguageExpressionEvaluator : public IUnknown
    {
        /// <summary>
        /// Bind the input expression and evaluate it. Then format the resulting value for
        /// display in the debugger. This is used for data tips, the watch windows, the
        /// immediate window, etc.
        /// </summary>
        /// <param name="pInspectionContext">
        /// [In] Options and target context to use while performing the inspection operation.
        /// </param>
        /// <param name="pWorkList">
        /// WorkList which is currently being processed. This value can be used to check for
        /// cancelation or to append additional work. New work items will not begin executing
        /// until after this function returns.
        /// </param>
        /// <param name="pExpression">
        /// [In] DkmLanguageExpression represents an expression to be parsed and evaluated by
        /// an expression evaluator.
        /// </param>
        /// <param name="pStackFrame">
        /// [In] Stack frame to evaluate the expression in.
        /// </param>
        /// <param name="pCompletionRoutine">
        /// Routine to fire when the request is complete. This will be implicitly fired if
        /// the implementation returns failure from this interface method. The implementation
        /// must fire this method in all other scenarios.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE EvaluateExpression(
            _In_ Evaluation::DkmInspectionContext* pInspectionContext,
            _In_ DkmWorkList* pWorkList,
            _In_ Evaluation::DkmLanguageExpression* pExpression,
            _In_ CallStack::DkmStackWalkFrame* pStackFrame,
            _In_ IDkmCompletionRoutine<Evaluation::DkmEvaluateExpressionAsyncResult>* pCompletionRoutine
            ) = 0;

        /// <summary>
        /// Gets an enumeration context used to obtain the children of this evaluation
        /// result. This is used in all expression evaluation windows.
        /// </summary>
        /// <param name="pResult">
        /// [In] The formatted result of an evaluation, ready to be displayed in an
        /// expression evaluation window.
        /// </param>
        /// <param name="pWorkList">
        /// WorkList which is currently being processed. This value can be used to check for
        /// cancelation or to append additional work. New work items will not begin executing
        /// until after this function returns.
        /// </param>
        /// <param name="InitialRequestSize">
        /// [In] The initial number of children that the caller would like returned. This
        /// value can be zero if no children will be initially returned. This value may be
        /// larger than the number of children that this expression has, in which case all
        /// children should be returned. Very large or negative values should not be used as
        /// arrays can have extremely large sizes which would cause out-of-memory if all
        /// elements were requested.
        /// </param>
        /// <param name="pInspectionContext">
        /// [In] The inspection context to use for computing the children.  This may differ
        /// from the original inspection context with respect to settings, such as radix,
        /// evaluation flags, or timeout.
        /// </param>
        /// <param name="pCompletionRoutine">
        /// Routine to fire when the request is complete. This will be implicitly fired if
        /// the implementation returns failure from this interface method. The implementation
        /// must fire this method in all other scenarios.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE GetChildren(
            _In_ Evaluation::DkmEvaluationResult* pResult,
            _In_ DkmWorkList* pWorkList,
            _In_ UINT32 InitialRequestSize,
            _In_ Evaluation::DkmInspectionContext* pInspectionContext,
            _In_ IDkmCompletionRoutine<Evaluation::DkmGetChildrenAsyncResult>* pCompletionRoutine
            ) = 0;

        /// <summary>
        /// Gets an enumeration context used to obtain the local variables of this stack
        /// frame. This is used in computing the locals window.
        /// </summary>
        /// <param name="pInspectionContext">
        /// [In] Options and target context to use while performing the inspection operation.
        /// </param>
        /// <param name="pWorkList">
        /// WorkList which is currently being processed. This value can be used to check for
        /// cancelation or to append additional work. New work items will not begin executing
        /// until after this function returns.
        /// </param>
        /// <param name="pStackFrame">
        /// [In] Stack frame to evaluate the expression in.
        /// </param>
        /// <param name="pCompletionRoutine">
        /// Routine to fire when the request is complete. This will be implicitly fired if
        /// the implementation returns failure from this interface method. The implementation
        /// must fire this method in all other scenarios.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE GetFrameLocals(
            _In_ Evaluation::DkmInspectionContext* pInspectionContext,
            _In_ DkmWorkList* pWorkList,
            _In_ CallStack::DkmStackWalkFrame* pStackFrame,
            _In_ IDkmCompletionRoutine<Evaluation::DkmGetFrameLocalsAsyncResult>* pCompletionRoutine
            ) = 0;

        /// <summary>
        /// Provides information on the arguments of a stack frame. This is currently only
        /// exposed through the VS automation model (EnvDTE.StackFrame.Arguments).
        /// </summary>
        /// <param name="pInspectionContext">
        /// [In] Options and target context to use while performing the inspection operation.
        /// </param>
        /// <param name="pWorkList">
        /// WorkList which is currently being processed. This value can be used to check for
        /// cancelation or to append additional work. New work items will not begin executing
        /// until after this function returns.
        /// </param>
        /// <param name="pFrame">
        /// [In] Walked frames which the evaluator is requested to describe.
        /// </param>
        /// <param name="pCompletionRoutine">
        /// Routine to fire when the request is complete. This will be implicitly fired if
        /// the implementation returns failure from this interface method. The implementation
        /// must fire this method in all other scenarios.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE GetFrameArguments(
            _In_ Evaluation::DkmInspectionContext* pInspectionContext,
            _In_ DkmWorkList* pWorkList,
            _In_ CallStack::DkmStackWalkFrame* pFrame,
            _In_ IDkmCompletionRoutine<Evaluation::DkmGetFrameArgumentsAsyncResult>* pCompletionRoutine
            ) = 0;

        /// <summary>
        /// Obtain DkmEvaluationResult items from this enumeration context. This is used to
        /// obtain local variables of a stack frame or child members from an evaluation
        /// result.
        /// </summary>
        /// <param name="pEnumContext">
        /// [In] Context object used to enumerate child members of an evaluation result, or
        /// to enumerate local variables from a stack frame. This is logically similar to an
        /// enumerator, except that access to elements is index-based rather than sequential.
        /// </param>
        /// <param name="pWorkList">
        /// WorkList which is currently being processed. This value can be used to check for
        /// cancelation or to append additional work. New work items will not begin executing
        /// until after this function returns.
        /// </param>
        /// <param name="StartIndex">
        /// [In] The zero-based index of the first item to obtain.
        /// </param>
        /// <param name="Count">
        /// [In] The number of items to try and return. This value may be larger than the
        /// total number of remaining items, in which case all remaining items should be
        /// returned. Very large or negative values should not be used as arrays can have
        /// extremely large sizes which would cause out-of-memory if all elements were
        /// requested.
        /// </param>
        /// <param name="pCompletionRoutine">
        /// Routine to fire when the request is complete. This will be implicitly fired if
        /// the implementation returns failure from this interface method. The implementation
        /// must fire this method in all other scenarios.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE GetItems(
            _In_ Evaluation::DkmEvaluationResultEnumContext* pEnumContext,
            _In_ DkmWorkList* pWorkList,
            _In_ UINT32 StartIndex,
            _In_ UINT32 Count,
            _In_ IDkmCompletionRoutine<Evaluation::DkmEvaluationEnumAsyncResult>* pCompletionRoutine
            ) = 0;

        /// <summary>
        /// Modifies the value of the given evaluation result (assumed to be non-read-only)
        /// to match the given string. This is used after the user edits a value in any of
        /// the evaluation windows.
        /// </summary>
        /// <param name="pResult">
        /// [In] The formatted result of an evaluation, ready to be displayed in an
        /// expression evaluation window.
        /// </param>
        /// <param name="pValue">
        /// [In] Textual representation of value to assign to the evaluation result.
        /// </param>
        /// <param name="Timeout">
        /// [In] If a function evaluation is needed to assign the value, specifies the
        /// timeout to use.
        /// </param>
        /// <param name="ppErrorText">
        /// [Out,Optional] If the operation failed, this indicates the reason why. This value
        /// should be null if the operation succeeded. In native code, an S_OK return value
        /// is used when returning error text.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE SetValueAsString(
            _In_ Evaluation::DkmEvaluationResult* pResult,
            _In_ DkmString* pValue,
            _In_ UINT32 Timeout,
            _Deref_out_opt_ DkmString** ppErrorText
            ) = 0;

        /// <summary>
        /// This method is used for evaluation results that include
        /// DkmEvaluationResultFlags.RawString to obtain the the underlying string, with no
        /// enclosing quotes or escape sequences. This is method is invoked to display one of
        /// the various string visualizers in an expression evaluation window (click the
        /// magnifying glass icon).
        /// </summary>
        /// <param name="pResult">
        /// [In] The formatted result of an evaluation, ready to be displayed in an
        /// expression evaluation window.
        /// </param>
        /// <param name="ppStringValue">
        /// [Out,Optional] The underlying string value.
        /// </param>
        /// <returns>
        /// S_OK is returned if *ppStringValue is non-NULL, S_FALSE is returned when
        /// *ppStringValue is NULL, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE GetUnderlyingString(
            _In_ Evaluation::DkmEvaluationResult* pResult,
            _Deref_out_opt_ DkmString** ppStringValue
            ) = 0;
    };

    // This interface allows a language extension to format the display of function names in
    // the call stack window.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // BaseDebugMonitorId, CompilerVendorId, EngineId, LanguageId, RuntimeId.
    #define IID_IDkmLanguageFrameDecoder __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmLanguageFrameDecoder)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("9db8c089-484a-a5bb-8677-bacaaf15af1c") IDkmLanguageFrameDecoder : public IUnknown
    {
        /// <summary>
        /// Provides a text representation for a stack frame. This is used when building the
        /// formatted call stack.
        /// </summary>
        /// <param name="pInspectionContext">
        /// [In] Options and target context to use while performing the inspection operation.
        /// </param>
        /// <param name="pWorkList">
        /// WorkList which is currently being processed. This value can be used to check for
        /// cancelation or to append additional work. New work items will not begin executing
        /// until after this function returns.
        /// </param>
        /// <param name="pFrame">
        /// [In] Walked frames which the evaluator is requested to describe.
        /// </param>
        /// <param name="ArgumentFlags">
        /// [In] Flags to indicate what information about the arguments should be included in
        /// the frame name.
        /// </param>
        /// <param name="pCompletionRoutine">
        /// Routine to fire when the request is complete. This will be implicitly fired if
        /// the implementation returns failure from this interface method. The implementation
        /// must fire this method in all other scenarios.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE GetFrameName(
            _In_ Evaluation::DkmInspectionContext* pInspectionContext,
            _In_ DkmWorkList* pWorkList,
            _In_ CallStack::DkmStackWalkFrame* pFrame,
            _In_ Evaluation::DkmVariableInfoFlags_t ArgumentFlags,
            _In_ IDkmCompletionRoutine<Evaluation::DkmGetFrameNameAsyncResult>* pCompletionRoutine
            ) = 0;

        /// <summary>
        /// Provides a text representation of the return type for one or more stack frame.
        /// This is currently only exposed through the VS automation model
        /// (EnvDTE.StackFrame.ReturnType).
        /// </summary>
        /// <param name="pInspectionContext">
        /// [In] Options and target context to use while performing the inspection operation.
        /// </param>
        /// <param name="pWorkList">
        /// WorkList which is currently being processed. This value can be used to check for
        /// cancelation or to append additional work. New work items will not begin executing
        /// until after this function returns.
        /// </param>
        /// <param name="pFrame">
        /// [In] Walked frames which the evaluator is requested to describe.
        /// </param>
        /// <param name="pCompletionRoutine">
        /// Routine to fire when the request is complete. This will be implicitly fired if
        /// the implementation returns failure from this interface method. The implementation
        /// must fire this method in all other scenarios.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE GetFrameReturnType(
            _In_ Evaluation::DkmInspectionContext* pInspectionContext,
            _In_ DkmWorkList* pWorkList,
            _In_ CallStack::DkmStackWalkFrame* pFrame,
            _In_ IDkmCompletionRoutine<Evaluation::DkmGetFrameReturnTypeAsyncResult>* pCompletionRoutine
            ) = 0;
    };

    // This interface allows a language extension to format the display of the 'Function'
    // column in the breakpoints window, and other places that attempt to format an
    // instruction address.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // CompilerVendorId, EngineId, LanguageId, RuntimeId.
    #define IID_IDkmLanguageInstructionDecoder __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmLanguageInstructionDecoder)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("77e415d7-28b1-a27d-02ec-3b312ead337a") IDkmLanguageInstructionDecoder : public IUnknown
    {
        /// <summary>
        /// Provides a text representation for a method symbol. This is used when describing
        /// an address in the UI, for example the 'Function' column in the breakpoints
        /// window.
        /// </summary>
        /// <param name="pLanguageInstructionAddress">
        /// [In] Pairing between an instruction address and the language that should be used
        /// to decode it.
        /// </param>
        /// <param name="ArgumentFlags">
        /// [In] Flags to indicate what information about the arguments should be included in
        /// the method name.  As parameter values cannot be obtained without a stack frame
        /// and a stack frame is not available here, the "Values" flag will never be present.
        /// </param>
        /// <param name="ppMethodName">
        /// [Out] Language's representation of the name of this method.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE GetMethodName(
            _In_ Evaluation::DkmLanguageInstructionAddress* pLanguageInstructionAddress,
            _In_ Evaluation::DkmVariableInfoFlags_t ArgumentFlags,
            _Deref_out_ DkmString** ppMethodName
            ) = 0;
    };

    // This is an optional interface implemented by expression evaluators. It should be
    // implemented by expression evaluators which return evaluation results with the
    // 'CanHaveObjectId' flag.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // CompilerVendorId, EngineId, LanguageId, RuntimeId.
    #define IID_IDkmLanguageObjectIdProvider __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmLanguageObjectIdProvider)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("7a0d8562-b453-d19f-45f3-01dfa2f4e77e") IDkmLanguageObjectIdProvider : public IUnknown
    {
        /// <summary>
        /// Creates an object id for this particular expression.
        /// </summary>
        /// <param name="pResult">
        /// [In] The formatted result of an evaluation, ready to be displayed in an
        /// expression evaluation window.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE CreateObjectId(
            _In_ Evaluation::DkmEvaluationResult* pResult
            ) = 0;

        /// <summary>
        /// Destroys an object id for this particular expression.
        /// </summary>
        /// <param name="pResult">
        /// [In] The formatted result of an evaluation, ready to be displayed in an
        /// expression evaluation window.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE DestroyObjectId(
            _In_ Evaluation::DkmEvaluationResult* pResult
            ) = 0;
    };

    // This interface allows a language extension to evaluate return values as collected by a
    // runtime during stepping.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // BaseDebugMonitorId, CompilerVendorId, EngineId, LanguageId, RuntimeId.
    #define IID_IDkmLanguageReturnValueEvaluator __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmLanguageReturnValueEvaluator)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("dfec0557-0e74-2698-da4f-81678ea4834d") IDkmLanguageReturnValueEvaluator : public IUnknown
    {
        /// <summary>
        /// Evaluates and formats a given DkmRawReturnValue using solely the provided data.
        /// </summary>
        /// <param name="pInspectionContext">
        /// [In] Options and target context to use while performing the inspection operation.
        /// </param>
        /// <param name="pWorkList">
        /// WorkList which is currently being processed. This value can be used to check for
        /// cancelation or to append additional work. New work items will not begin executing
        /// until after this function returns.
        /// </param>
        /// <param name="pStackFrame">
        /// [In] Stack frame that provides the context of in which to evaluate the
        /// expression.
        /// </param>
        /// <param name="pRawReturnValue">
        /// [In] Return value target and cached context.
        /// </param>
        /// <param name="pCompletionRoutine">
        /// Routine to fire when the request is complete. This will be implicitly fired if
        /// the implementation returns failure from this interface method. The implementation
        /// must fire this method in all other scenarios.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE EvaluateReturnValue(
            _In_ Evaluation::DkmInspectionContext* pInspectionContext,
            _In_ DkmWorkList* pWorkList,
            _In_ CallStack::DkmStackWalkFrame* pStackFrame,
            _In_ Evaluation::DkmRawReturnValue* pRawReturnValue,
            _In_ IDkmCompletionRoutine<Evaluation::DkmEvaluateReturnValueAsyncResult>* pCompletionRoutine
            ) = 0;
    };

    // This interface allows a language extension to evaluate return values as collected by a
    // runtime during stepping. This is a replacement for IDkmLanguageReturnValueEvaluator
    // that allows components to retrieve data items associated with the return value.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // BaseDebugMonitorId, CompilerVendorId, EngineId, LanguageId, RuntimeId.
    //
    // This API was introduced in Visual Studio 14 RTM (DkmApiVersion.VS14RTM).
    #define IID_IDkmLanguageReturnValueEvaluator2 __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmLanguageReturnValueEvaluator2)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("2c09d247-657a-be65-ea0d-20f443799780") IDkmLanguageReturnValueEvaluator2 : public IUnknown
    {
        /// <summary>
        /// Evaluates and formats a given DkmRawReturnValue using solely the provided data.
        /// </summary>
        /// <param name="pInspectionContext">
        /// [In] Options and target context to use while performing the inspection operation.
        /// </param>
        /// <param name="pWorkList">
        /// WorkList which is currently being processed. This value can be used to check for
        /// cancelation or to append additional work. New work items will not begin executing
        /// until after this function returns.
        /// </param>
        /// <param name="pStackFrame">
        /// [In] Stack frame that provides the context of in which to evaluate the
        /// expression.
        /// </param>
        /// <param name="pRawReturnValue">
        /// [In] Return value target and cached context.
        /// </param>
        /// <param name="pCompletionRoutine">
        /// Routine to fire when the request is complete. This will be implicitly fired if
        /// the implementation returns failure from this interface method. The implementation
        /// must fire this method in all other scenarios.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE EvaluateReturnValue2(
            _In_ Evaluation::DkmInspectionContext* pInspectionContext,
            _In_ DkmWorkList* pWorkList,
            _In_ CallStack::DkmStackWalkFrame* pStackFrame,
            _In_ Evaluation::DkmRawReturnValueContainer* pRawReturnValue,
            _In_ IDkmCompletionRoutine<Evaluation::DkmEvaluateReturnValueAsyncResult2>* pCompletionRoutine
            ) = 0;
    };

    // This interface allows a language extension to affect the Step-Into behavior of the
    // native runtime.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // CompilerVendorId, EngineId, LanguageId, RuntimeId.
    #define IID_IDkmLanguageStepIntoFilterCallback __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmLanguageStepIntoFilterCallback)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("a70278a3-f362-06f0-2bf6-a4a57860cfd3") IDkmLanguageStepIntoFilterCallback : public IUnknown
    {
        /// <summary>
        /// Called during a Step-Into to determine special behavior for a particular
        /// function.
        /// </summary>
        /// <param name="pLanguageInstructionAddress">
        /// [In] Pairing between an instruction address and the language that should be used
        /// to decode it.
        /// </param>
        /// <param name="pStepIntoFlags">
        /// [Out] Flags which describe how to proceed with a Step-Into action.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE GetStepIntoFlags(
            _In_ Evaluation::DkmLanguageInstructionAddress* pLanguageInstructionAddress,
            _Out_ Stepping::DkmLanguageStepIntoFlags_t* pStepIntoFlags
            ) = 0;
    };

    // This interface is implemented by expression evaluators which are loaded on the target
    // computer to map between a function/address expression and the instructions which are
    // represented by it. This is used to bind function breakpoints. In addition to
    // expression evaluators, this interface may also be implemented by other components
    // which may want to bind function breakpoints using data from the target process (ex:
    // native export function breakpoints).
    //
    // Components filtering based on LanguageId and/or VendorId should ensure that Guid.Empty
    // is one of the accepted values in their filter. See
    // DkmRuntimeFunctionResolutionRequest.CompilerId for more information.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // BaseDebugMonitorId, CompilerVendorId, EngineId, LanguageId.
    #define IID_IDkmRuntimeFunctionResolver __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmRuntimeFunctionResolver)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("e0ecb64b-afec-5dea-f1c0-9d9d8cc83215") IDkmRuntimeFunctionResolver : public IUnknown
    {
        /// <summary>
        /// Called by the breakpoint manager to add a pending resolve request. Expression
        /// evaluators, or other components will immediately try to bind the breakpoint
        /// against current modules, and will bind the breakpoint to additional locations as
        /// modules load. The caller of this interface should implement
        /// IDkmRuntimeFunctionResolverClient to obtain the results of the resolution.
        ///
        /// Implementations of this interface should stop attempting to bind the breakpoint
        /// when the DkmRuntimeFunctionResolutionRequest object is closed.
        /// </summary>
        /// <param name="pRuntimeFunctionResolutionRequest">
        /// [In] DkmRuntimeFunctionResolutionRequest represents an expression to be parsed
        /// and evaluated by a runtime based expression evaluator and is bound to a
        /// particular process. Resolutions will send DkmModuleInstance::FunctionResolved
        /// events.
        /// </param>
        /// <param name="pWorkList">
        /// WorkList which is currently being processed. This value can be used to check for
        /// cancelation or to append additional work. New work items will not begin executing
        /// until after this function returns.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE EnableResolution(
            _In_ FunctionResolution::DkmRuntimeFunctionResolutionRequest* pRuntimeFunctionResolutionRequest,
            _In_ DkmWorkList* pWorkList
            ) = 0;
    };

    // This interface is implemented by symbol based expression evaluators to map between a
    // function/address expression and the instructions which are represented by it. This is
    // used to bind function breakpoints.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // BaseDebugMonitorId, CompilerVendorId, EngineId, LanguageId, SymbolProviderId.
    #define IID_IDkmSymbolFunctionResolver __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmSymbolFunctionResolver)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("61ec2e73-6713-54c4-bb59-e20f04313e6d") IDkmSymbolFunctionResolver : public IUnknown
    {
        /// <summary>
        /// Resolve an address string to zero or more address symbols. This is used to bind
        /// function breakpoints.
        /// </summary>
        /// <param name="pSymbolFunctionResolutionRequest">
        /// [In] DkmSymbolFunctionResolutionRequest represents an expression to be parsed and
        /// evaluated by a symbol based expression evaluator and is not bound to a particular
        /// process. Used to perform function breakpoint binds.
        /// </param>
        /// <param name="pAddresses">
        /// [Out] DkmInstructionSymbol[] represents a method in the target process.
        ///
        /// The memory for the DkmArray members is allocated by the method implementation
        /// using DkmAllocBytes/DkmAllocArray. It is freed by the caller using the
        /// CAutoDkmArray template or with DkmFreeMemory and manual element release.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE Resolve(
            _In_ FunctionResolution::DkmSymbolFunctionResolutionRequest* pSymbolFunctionResolutionRequest,
            _Out_ DkmArray<Symbols::DkmInstructionSymbol*>* pAddresses
            ) = 0;
    };

    // Optional interface to compiles an object visualization data from a human-readable form
    // into a DkmCompiledVisualizationData object.  Currently, this interface is implemented
    // only by C++.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // CompilerVendorId, LanguageId.
    //
    // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
    #define IID_IDkmVisualizationDataCompiler __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmVisualizationDataCompiler)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("c1ec72fb-6d26-fcd8-f4bb-8cd516c16110") IDkmVisualizationDataCompiler : public IUnknown
    {
        /// <summary>
        /// Compiles object visualization data from a human-readable form into a
        /// DkmCompiledVisualizationData object.
        /// </summary>
        /// <param name="pVisualizationDataObject">
        /// [In] Represents the results of parsing one or more visualization files.
        /// </param>
        /// <param name="VisualizationFiles">
        /// [In] List of full paths, on to the Visual Studio computer, that describe
        /// information to be used for object visualization. For C++, each item in the array
        /// should be the full path to a .natvis file you wish to use when formatting the
        /// results of the expression.
        ///
        /// The memory for the DkmArray members is allocated by the caller, and can be from
        /// any source (stack memory, static buffer, heap, etc). The implementation should
        /// not modify the members.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE InitializeVisualizationData(
            _In_ Evaluation::DkmCompiledVisualizationData* pVisualizationDataObject,
            _In_ const DkmArray<DkmString*>& VisualizationFiles
            ) = 0;
    };

}; // end of Expression evaluators interfaces


// Expression evaluator addins interfaces
// Expression evaluator addins are customizations that affect the view of objects in the
// various debugger expression windows. They can affect the value of the object as well
// as expansion scenarios. They must be below the standard expression evaluator component
// level.
namespace ComponentInterfaces
{
    // This interface is implemented by custom expression evaluator visualizers in order to
    // customize the view of an expression programmatically. This is normally done to support
    // visualizations that are not possible using the native visualizer syntax or to enable
    // visualization without full symbolic information. The visualizer can take complete
    // control of the expression including expansion of children, or it can obtain the
    // default expression from the expression evaluator, modify it slightly but defer other
    // operations such as expansion back to the EE.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // EngineId, RuntimeId, SourceId, VisualizerId.
    #define IID_IDkmCustomVisualizer __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmCustomVisualizer)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("f00e7f6d-fc66-d9a9-e3e5-83b32a0a9755") IDkmCustomVisualizer : public IUnknown
    {
        /// <summary>
        /// Evaluate a visualized expression returning a DkmEvaluationResult for it.
        /// </summary>
        /// <param name="pVisualizedExpression">
        /// [In] Dispatcher object used for custom visualization through a concord EE addin.
        /// </param>
        /// <param name="ppResultObject">
        /// [Out] Object containing the result of the evaluation. This object must be closed
        /// by the caller when the caller is done with the object. The expression evaluator
        /// reserves the right to override this instance so do not rely on storing data items
        /// in the DkmEvaluationResult instance. Use the DkmVisualizedExpression instance as
        /// a data container instead.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE EvaluateVisualizedExpression(
            _In_ Evaluation::DkmVisualizedExpression* pVisualizedExpression,
            _Deref_out_ Evaluation::DkmEvaluationResult** ppResultObject
            ) = 0;

        /// <summary>
        /// Called by the expression evaluator when a visualized expression's children are
        /// being expanded, the the value is being set, or the underlying string is being
        /// obtained. If the visualizer addin wants complete control of the expression it
        /// should return false. It will then receive calls to GetChildren, GetItems,
        /// SetValueAsString, and GetUnderlyingString. If the visualizer addin wants to
        /// completely defer these operations to the expression evaluator, it should return
        /// true. It must also give the expression evaluator back the instance of
        /// DkmEvaluationResult that came from the EE via one of the
        /// IDkmCustomVisualizerCallback methods. Note that the addin MUST have obtained the
        /// default DkmEvaluationResult from the EE if it wants the EE to control the object.
        /// Returning true from this method is primarily used by visualizer addins that just
        /// tweak something small like the view of a value but don't want to modify expansion
        /// or setting values.
        /// </summary>
        /// <param name="pVisualizedExpression">
        /// [In] Dispatcher object used for custom visualization through a concord EE addin.
        /// </param>
        /// <param name="pUseDefaultEvaluationBehavior">
        /// [Out] Return true to use default expansion, false otherwise.
        /// </param>
        /// <param name="ppDefaultEvaluationResult">
        /// [Out,Optional] The instance of DkmEvaluationResult returned from a call to one of
        /// the methods of IDkmCustomVisualizerCallback. The expression evaluator can only
        /// control DkmEvaluationResults it understands.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE UseDefaultEvaluationBehavior(
            _In_ Evaluation::DkmVisualizedExpression* pVisualizedExpression,
            _Out_ bool* pUseDefaultEvaluationBehavior,
            _Deref_out_opt_ Evaluation::DkmEvaluationResult** ppDefaultEvaluationResult
            ) = 0;

        /// <summary>
        /// Gets an enumeration context used to obtain the children of this evaluation
        /// result. This is used in all expression evaluation windows.
        /// </summary>
        /// <param name="pVisualizedExpression">
        /// [In] Dispatcher object used for custom visualization through a concord EE addin.
        /// </param>
        /// <param name="InitialRequestSize">
        /// [In] The initial number of children that the caller would like returned. This
        /// value can be zero if no children will be initially returned. This value may be
        /// larger than the number of children that this expression has, in which case all
        /// children should be returned. Very large or negative values should not be used as
        /// arrays can have extremely large sizes which would cause out-of-memory if all
        /// elements were requested.
        /// </param>
        /// <param name="pInspectionContext">
        /// [In] The inspection context to use for computing the children.  This may differ
        /// from the original inspection context with respect to settings, such as radix,
        /// evaluation flags, or timeout.
        /// </param>
        /// <param name="pInitialChildren">
        /// [Out] The initial children to return.
        ///
        /// The memory for the DkmArray members is allocated by the method implementation
        /// using DkmAllocBytes/DkmAllocArray. It is freed by the caller using the
        /// CAutoDkmArray template or with DkmFreeMemory and manual element release.
        /// </param>
        /// <param name="ppEnumContext">
        /// [Out] Context object used to enumerate the children. This object must be closed
        /// by the caller of this API when enumeration is complete.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE GetChildren(
            _In_ Evaluation::DkmVisualizedExpression* pVisualizedExpression,
            _In_ UINT32 InitialRequestSize,
            _In_ Evaluation::DkmInspectionContext* pInspectionContext,
            _Out_ DkmArray<Evaluation::DkmChildVisualizedExpression*>* pInitialChildren,
            _Deref_out_ Evaluation::DkmEvaluationResultEnumContext** ppEnumContext
            ) = 0;

        /// <summary>
        /// Called to obtain items from a instance of DkmEvaluationResultEnumContext created
        /// by an earlier call to GetChildren.
        /// </summary>
        /// <param name="pVisualizedExpression">
        /// [In] Dispatcher object used for custom visualization through a concord EE addin.
        /// </param>
        /// <param name="pEnumContext">
        /// [In] The enum context to use for this call. This instance will have been returned
        /// from a previous call to DkmVisualizedExpression.
        /// </param>
        /// <param name="StartIndex">
        /// [In] The zero-based index of the first item to obtain.
        /// </param>
        /// <param name="Count">
        /// [In] The number of items to try and return. This value may be larger than the
        /// total number of remaining items, in which case all remaining items should be
        /// returned. Very large or negative values should not be used as arrays can have
        /// extremely large sizes which would cause out-of-memory if all elements were
        /// requested.
        /// </param>
        /// <param name="pItems">
        /// [Out] The DkmChildVisualizedExpression items to return.
        ///
        /// The memory for the DkmArray members is allocated by the method implementation
        /// using DkmAllocBytes/DkmAllocArray. It is freed by the caller using the
        /// CAutoDkmArray template or with DkmFreeMemory and manual element release.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE GetItems(
            _In_ Evaluation::DkmVisualizedExpression* pVisualizedExpression,
            _In_ Evaluation::DkmEvaluationResultEnumContext* pEnumContext,
            _In_ UINT32 StartIndex,
            _In_ UINT32 Count,
            _Out_ DkmArray<Evaluation::DkmChildVisualizedExpression*>* pItems
            ) = 0;

        /// <summary>
        /// Modifies the value of the given evaluation result (assumed to be non-read-only)
        /// to match the given string. This is used after the user edits a value in any of
        /// the evaluation windows.
        /// </summary>
        /// <param name="pVisualizedExpression">
        /// [In] Dispatcher object used for custom visualization through a concord EE addin.
        /// </param>
        /// <param name="pValue">
        /// [In] Textual representation of value to assign to the evaluation result.
        /// </param>
        /// <param name="Timeout">
        /// [In] If a function evaluation is needed to assign the value, specifies the
        /// timeout to use.
        /// </param>
        /// <param name="ppErrorText">
        /// [Out,Optional] If the operation failed, this indicates the reason why. This value
        /// should be null if the operation succeeded. In native code, an S_OK return value
        /// is used when returning error text.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE SetValueAsString(
            _In_ Evaluation::DkmVisualizedExpression* pVisualizedExpression,
            _In_ DkmString* pValue,
            _In_ UINT32 Timeout,
            _Deref_out_opt_ DkmString** ppErrorText
            ) = 0;

        /// <summary>
        /// This method is used for evaluation results that include
        /// DkmEvaluationResultFlags.RawString to obtain the the underlying string, with no
        /// enclosing quotes or escape sequences. This is method is invoked to display one of
        /// the various string visualizers in an expression evaluation window (click the
        /// magnifying glass icon).
        /// </summary>
        /// <param name="pVisualizedExpression">
        /// [In] Dispatcher object used for custom visualization through a concord EE addin.
        /// </param>
        /// <param name="ppStringValue">
        /// [Out,Optional] The underlying string value.
        /// </param>
        /// <returns>
        /// S_OK is returned if *ppStringValue is non-NULL, S_FALSE is returned when
        /// *ppStringValue is NULL, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE GetUnderlyingString(
            _In_ Evaluation::DkmVisualizedExpression* pVisualizedExpression,
            _Deref_out_opt_ DkmString** ppStringValue
            ) = 0;
    };

}; // end of Expression evaluator addins interfaces


// CLR Result Formatters interfaces
// CLR expression evaluators separate out the formatter to allow compiler vendors to
// customize the way evaluation results are presented to the user. Result Formatters
// convert raw evaluation results into formatted results for the user.  Result Formatters
// can also provide their own expansion view of objects and/or filter out members of
// objects.
namespace ComponentInterfaces
{
    // Formats values and type names of evaluation results into string appropriate for the
    // language being debugged.  Compiler vendors can implement this interface to customize
    // value formatting for their language.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // CompilerVendorId, LanguageId.
    //
    // This API was introduced in Visual Studio 14 RTM (DkmApiVersion.VS14RTM).
    #define IID_IDkmClrFormatter __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmClrFormatter)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("3ca4c224-a3dc-ccb6-e392-4ca87309d15f") IDkmClrFormatter : public IUnknown
    {
        /// <summary>
        /// Get the value string to display in the UI for the given DkmClrValue.
        /// </summary>
        /// <param name="pClrValue">
        /// [In] A value resulting from a CLR inspection query.  These values are used by a
        /// Result Formatter to generate DkmEvaluationResults.
        /// </param>
        /// <param name="pInspectionContext">
        /// [In] The inspection context for this evaluation.
        /// </param>
        /// <param name="pFormatSpecifiers">
        /// [In,Optional] The optional format specifier(s) to use when formatting this
        /// result.
        /// </param>
        /// <param name="ppValueString">
        /// [Out] The value string.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE GetValueString(
            _In_ Evaluation::ClrCompilation::DkmClrValue* pClrValue,
            _In_ Evaluation::DkmInspectionContext* pInspectionContext,
            _In_opt_ DkmReadOnlyCollection<DkmString*>* pFormatSpecifiers,
            _Deref_out_ DkmString** ppValueString
            ) = 0;

        /// <summary>
        /// Gets the type name string to display in the UI for the given DkmClrType.
        /// </summary>
        /// <param name="pInspectionContext">
        /// [In] Options and target context to use while performing the inspection operation.
        /// </param>
        /// <param name="pClrType">
        /// [In] The type to get the name for.
        /// </param>
        /// <param name="pCustomTypeInfo">
        /// [In,Optional] The optional information provided by the expression compiler for
        /// identifying compiler intrinsic type information.
        /// </param>
        /// <param name="pFormatSpecifiers">
        /// [In,Optional] The optional format specifier(s) to use when formatting this
        /// result.
        /// </param>
        /// <param name="ppTypeName">
        /// [Out] The type name string.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE GetTypeName(
            _In_ Evaluation::DkmInspectionContext* pInspectionContext,
            _In_ Clr::DkmClrType* pClrType,
            _In_opt_ Evaluation::ClrCompilation::DkmClrCustomTypeInfo* pCustomTypeInfo,
            _In_opt_ DkmReadOnlyCollection<DkmString*>* pFormatSpecifiers,
            _Deref_out_ DkmString** ppTypeName
            ) = 0;

        /// <summary>
        /// Determines if this value has an underlying string representation. If this method
        /// returns true, the user can use string visualizers to view this value in the
        /// debugger. GetUnderlyingString should return the underlying string representation.
        /// </summary>
        /// <param name="pClrValue">
        /// [In] A value resulting from a CLR inspection query.  These values are used by a
        /// Result Formatter to generate DkmEvaluationResults.
        /// </param>
        /// <param name="pInspectionContext">
        /// [In] The inspection context for this evaluation.
        /// </param>
        /// <param name="pResult">
        /// [Out] True if this value has and underlying string representation.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE HasUnderlyingString(
            _In_ Evaluation::ClrCompilation::DkmClrValue* pClrValue,
            _In_ Evaluation::DkmInspectionContext* pInspectionContext,
            _Out_ bool* pResult
            ) = 0;

        /// <summary>
        /// Get the underlying string representation of the value.
        /// </summary>
        /// <param name="pClrValue">
        /// [In] A value resulting from a CLR inspection query.  These values are used by a
        /// Result Formatter to generate DkmEvaluationResults.
        /// </param>
        /// <param name="pInspectionContext">
        /// [In] The inspection context for this evaluation.
        /// </param>
        /// <param name="ppResult">
        /// [Out] The underlying string representation.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE GetUnderlyingString(
            _In_ Evaluation::ClrCompilation::DkmClrValue* pClrValue,
            _In_ Evaluation::DkmInspectionContext* pInspectionContext,
            _Deref_out_ DkmString** ppResult
            ) = 0;
    };

    // Provides DkmEvaluationResults given DkmClrValues. Compiler vendors can implement this
    // interface to change the way values are expanded and presented to the user.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // CompilerVendorId, LanguageId.
    //
    // This API was introduced in Visual Studio 14 RTM (DkmApiVersion.VS14RTM).
    #define IID_IDkmClrResultProvider __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmClrResultProvider)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("a679c9a0-8c99-2ac7-ebf7-7bbecf9750e7") IDkmClrResultProvider : public IUnknown
    {
        /// <summary>
        /// Format a DkmClrValue and return a DkmEvaluationResult.
        /// </summary>
        /// <param name="pClrValue">
        /// [In] A value resulting from a CLR inspection query.  These values are used by a
        /// Result Formatter to generate DkmEvaluationResults.
        /// </param>
        /// <param name="pWorkList">
        /// WorkList which is currently being processed. This value can be used to check for
        /// cancelation or to append additional work. New work items will not begin executing
        /// until after this function returns.
        /// </param>
        /// <param name="pDeclaredType">
        /// [In,Optional] The declared type if it is different from the runtime type.
        /// </param>
        /// <param name="pCustomTypeInfo">
        /// [In,Optional] The optional information provided by the expression compiler for
        /// identifying compiler intrinsic type information.
        /// </param>
        /// <param name="pInspectionContext">
        /// [In] The inspection context for this evaluation.
        /// </param>
        /// <param name="pFormatSpecifiers">
        /// [In,Optional] The optional format specifier(s) to use when formatting this
        /// result.
        /// </param>
        /// <param name="pResultName">
        /// [In] The name of this result.  This value is typically the expression being
        /// evaluated.
        /// </param>
        /// <param name="pResultFullName">
        /// [In] The full name of this result.  This is the expression added to the Watch
        /// window if the user selects "Add to Watch".
        /// </param>
        /// <param name="pCompletionRoutine">
        /// Routine to fire when the request is complete. This will be implicitly fired if
        /// the implementation returns failure from this interface method. The implementation
        /// must fire this method in all other scenarios.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE GetResult(
            _In_ Evaluation::ClrCompilation::DkmClrValue* pClrValue,
            _In_ DkmWorkList* pWorkList,
            _In_opt_ Clr::DkmClrType* pDeclaredType,
            _In_opt_ Evaluation::ClrCompilation::DkmClrCustomTypeInfo* pCustomTypeInfo,
            _In_ Evaluation::DkmInspectionContext* pInspectionContext,
            _In_opt_ DkmReadOnlyCollection<DkmString*>* pFormatSpecifiers,
            _In_ DkmString* pResultName,
            _In_ DkmString* pResultFullName,
            _In_ IDkmCompletionRoutine<Evaluation::ClrCompilation::DkmEvaluationAsyncResult>* pCompletionRoutine
            ) = 0;

        /// <summary>
        /// Gets the underlying DkmClrValue from a DkmSuccessEvaluationResult, if it exists.
        /// </summary>
        /// <param name="pSuccessResult">
        /// [In] The formatted result of a successful evaluation, ready to be displayed in an
        /// expression evaluation window.
        /// </param>
        /// <param name="ppResult">
        /// [Out,Optional] The DkmClrValue, if it exists.
        /// </param>
        /// <returns>
        /// S_OK is returned if *ppResult is non-NULL, S_FALSE is returned when *ppResult is
        /// NULL, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE GetClrValue(
            _In_ Evaluation::DkmSuccessEvaluationResult* pSuccessResult,
            _Deref_out_opt_ Evaluation::ClrCompilation::DkmClrValue** ppResult
            ) = 0;

        /// <summary>
        /// Gets an enumeration context used to obtain the children of this evaluation
        /// result. This is used in all expression evaluation windows.
        /// </summary>
        /// <param name="pResult">
        /// [In] The formatted result of an evaluation, ready to be displayed in an
        /// expression evaluation window.
        /// </param>
        /// <param name="pWorkList">
        /// WorkList which is currently being processed. This value can be used to check for
        /// cancelation or to append additional work. New work items will not begin executing
        /// until after this function returns.
        /// </param>
        /// <param name="InitialRequestSize">
        /// [In] The initial number of children that the caller would like returned. This
        /// value can be zero if no children will be initially returned. This value may be
        /// larger than the number of children that this expression has, in which case all
        /// children should be returned. Very large or negative values should not be used as
        /// arrays can have extremely large sizes which would cause out-of-memory if all
        /// elements were requested.
        /// </param>
        /// <param name="pInspectionContext">
        /// [In] The inspection context to use for computing the children.  This may differ
        /// from the original inspection context with respect to settings, such as radix,
        /// evaluation flags, or timeout.
        /// </param>
        /// <param name="pCompletionRoutine">
        /// Routine to fire when the request is complete. This will be implicitly fired if
        /// the implementation returns failure from this interface method. The implementation
        /// must fire this method in all other scenarios.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE GetChildren(
            _In_ Evaluation::DkmEvaluationResult* pResult,
            _In_ DkmWorkList* pWorkList,
            _In_ UINT32 InitialRequestSize,
            _In_ Evaluation::DkmInspectionContext* pInspectionContext,
            _In_ IDkmCompletionRoutine<Evaluation::DkmGetChildrenAsyncResult>* pCompletionRoutine
            ) = 0;

        /// <summary>
        /// Obtain DkmEvaluationResult items from this enumeration context. This is used to
        /// obtain local variables of a stack frame or child members from an evaluation
        /// result.
        /// </summary>
        /// <param name="pEnumContext">
        /// [In] Context object used to enumerate child members of an evaluation result, or
        /// to enumerate local variables from a stack frame. This is logically similar to an
        /// enumerator, except that access to elements is index-based rather than sequential.
        /// </param>
        /// <param name="pWorkList">
        /// WorkList which is currently being processed. This value can be used to check for
        /// cancelation or to append additional work. New work items will not begin executing
        /// until after this function returns.
        /// </param>
        /// <param name="StartIndex">
        /// [In] The zero-based index of the first item to obtain.
        /// </param>
        /// <param name="Count">
        /// [In] The number of items to try and return. This value may be larger than the
        /// total number of remaining items, in which case all remaining items should be
        /// returned. Very large or negative values should not be used as arrays can have
        /// extremely large sizes which would cause out-of-memory if all elements were
        /// requested.
        /// </param>
        /// <param name="pCompletionRoutine">
        /// Routine to fire when the request is complete. This will be implicitly fired if
        /// the implementation returns failure from this interface method. The implementation
        /// must fire this method in all other scenarios.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE GetItems(
            _In_ Evaluation::DkmEvaluationResultEnumContext* pEnumContext,
            _In_ DkmWorkList* pWorkList,
            _In_ UINT32 StartIndex,
            _In_ UINT32 Count,
            _In_ IDkmCompletionRoutine<Evaluation::DkmEvaluationEnumAsyncResult>* pCompletionRoutine
            ) = 0;

        /// <summary>
        /// This method is used for evaluation results that include
        /// DkmEvaluationResultFlags.RawString to obtain the the underlying string, with no
        /// enclosing quotes or escape sequences. This is method is invoked to display one of
        /// the various string visualizers in an expression evaluation window (click the
        /// magnifying glass icon).
        /// </summary>
        /// <param name="pResult">
        /// [In] The formatted result of an evaluation, ready to be displayed in an
        /// expression evaluation window.
        /// </param>
        /// <param name="ppStringValue">
        /// [Out,Optional] The underlying string value.
        /// </param>
        /// <returns>
        /// S_OK is returned if *ppStringValue is non-NULL, S_FALSE is returned when
        /// *ppStringValue is NULL, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE GetUnderlyingString(
            _In_ Evaluation::DkmEvaluationResult* pResult,
            _Deref_out_opt_ DkmString** ppStringValue
            ) = 0;
    };

}; // end of CLR Result Formatters interfaces


// CLR Expression Compilers interfaces
// Expression compilers parse and compile expressions written in managed languages into
// MSIL to be executed by the debug engine.
//
// See also: IDkmModuleModifiedNotification
namespace ComponentInterfaces
{
    // Allows compilers for managed languages to compile expressions for use by the debugger
    // to support expression evaluation and conditional breakpoints.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // CompilerVendorId, LanguageId.
    //
    // This API was introduced in Visual Studio 14 RTM (DkmApiVersion.VS14RTM).
    #define IID_IDkmClrExpressionCompiler __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmClrExpressionCompiler)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("69e56b29-160e-16b6-50a4-9415f1f1ec7b") IDkmClrExpressionCompiler : public IUnknown
    {
        /// <summary>
        /// Compile the expression into MSIL code that can be executed by the CLR or debugger
        /// to evaluate the expression.
        /// </summary>
        /// <param name="pExpression">
        /// [In] DkmLanguageExpression represents an expression to be parsed and evaluated by
        /// an expression evaluator.
        /// </param>
        /// <param name="pInstructionAddress">
        /// [In] The code context to use for compiling the expression.
        /// </param>
        /// <param name="pInspectionContext">
        /// [In,Optional] The inspection context for this evaluation.  This value is null if
        /// there is no current evaluation context. An example of a time when there is no
        /// evaluation context is when compiling conditional breakpoints.
        /// </param>
        /// <param name="ppError">
        /// [Out,Optional] Indicates any error compiling the expression.  If the code
        /// compiles successfully, this value should be null. It should also be null for
        /// cases where the language or expression is not supported and the debug engine
        /// needs to fall back to the default implementation. In error cases, this value
        /// indicates the reason for the compile error and the caller should return S_OK.
        /// </param>
        /// <param name="ppResult">
        /// [Out,Optional] The compiled expression.  If Result is null, and Error is not
        /// null, there was a compile error.  If both are null, compilation of the expression
        /// is not supported and the debug engine needs to use the legacy expression
        /// evaluator.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE CompileExpression(
            _In_ Evaluation::DkmLanguageExpression* pExpression,
            _In_ Clr::DkmClrInstructionAddress* pInstructionAddress,
            _In_opt_ Evaluation::DkmInspectionContext* pInspectionContext,
            _Deref_out_opt_ DkmString** ppError,
            _Deref_out_opt_ Evaluation::ClrCompilation::DkmCompiledClrInspectionQuery** ppResult
            ) = 0;

        /// <summary>
        /// Compile the given expression and generate code to assign the value of the
        /// expression to an L-Value.
        /// </summary>
        /// <param name="pExpression">
        /// [In] DkmLanguageExpression represents an expression to be parsed and evaluated by
        /// an expression evaluator.
        /// </param>
        /// <param name="pInstructionAddress">
        /// [In] The code context to use for compiling the expression.
        /// </param>
        /// <param name="pLValue">
        /// [In] The L-value of the assignment.  This is the result of a previous evaluation.
        /// </param>
        /// <param name="ppError">
        /// [Out,Optional] Indicates any error compiling the expression or the reason the
        /// assignment is invalid. If the compiler can generate code for the assignment, this
        /// value should be null. In error cases, this value indicates the reason for the
        /// compile error and the caller should return S_OK.
        /// </param>
        /// <param name="ppResult">
        /// [Out,Optional] The compiled assignment operation.  If Result is null, and Error
        /// is not null, there was a compile error.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE CompileAssignment(
            _In_ Evaluation::DkmLanguageExpression* pExpression,
            _In_ Clr::DkmClrInstructionAddress* pInstructionAddress,
            _In_ Evaluation::DkmEvaluationResult* pLValue,
            _Deref_out_opt_ DkmString** ppError,
            _Deref_out_opt_ Evaluation::ClrCompilation::DkmCompiledClrInspectionQuery** ppResult
            ) = 0;

        /// <summary>
        /// Get a DkmCompiledClrLocalsQuery to allow viewing of local variables.
        /// </summary>
        /// <param name="pInspectionContext">
        /// [In] Options and target context to use while performing the inspection operation.
        /// </param>
        /// <param name="pInstructionAddress">
        /// [In] The code context to use for getting local variables.
        /// </param>
        /// <param name="ArgumentsOnly">
        /// [In] If set to true, get a query for arguments only.
        /// </param>
        /// <param name="ppResult">
        /// [Out] The local variables query.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE GetClrLocalVariableQuery(
            _In_ Evaluation::DkmInspectionContext* pInspectionContext,
            _In_ Clr::DkmClrInstructionAddress* pInstructionAddress,
            _In_ bool ArgumentsOnly,
            _Deref_out_ Evaluation::ClrCompilation::DkmCompiledClrLocalsQuery** ppResult
            ) = 0;
    };

    // Allows compilers for managed languages to compile expressions for use by the debugger
    // to support expression evaluation.  This interface contains methods that are called
    // from the monitor.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // CompilerVendorId, LanguageId.
    //
    // This API was introduced in Visual Studio 14 RTM (DkmApiVersion.VS14RTM).
    #define IID_IDkmClrExpressionCompilerCallback __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmClrExpressionCompilerCallback)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("5ede61c4-33cc-852f-2a94-a90108ab1525") IDkmClrExpressionCompilerCallback : public IUnknown
    {
        /// <summary>
        /// Compile the given DebuggerDisplayAttribute string.  The resulting IL should
        /// return a string. For debugger display, there is no code context.  Instead the
        /// compiler must do its binding based on a type token.
        /// </summary>
        /// <param name="pExpression">
        /// [In] DkmLanguageExpression represents an expression to be parsed and evaluated by
        /// an expression evaluator.
        /// </param>
        /// <param name="pModuleInstance">
        /// [In] The module instance containing the type the DebuggerDisplayAttribute applies
        /// to.
        /// </param>
        /// <param name="Token">
        /// [In] The metadata token of the type the DebuggerDisplayAttribute applies to.
        /// </param>
        /// <param name="ppError">
        /// [Out,Optional] Indicates any error compiling the expression.  If the code
        /// compiles successfully, this value should be null. In error cases, this value
        /// indicates the reason for the compile error and the caller should return S_OK.
        /// </param>
        /// <param name="ppResult">
        /// [Out,Optional] The compiled display attribute.  If Result is null, and Error is
        /// not null, there was a compile error.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE CompileDisplayAttribute(
            _In_ Evaluation::DkmLanguageExpression* pExpression,
            _In_ Clr::DkmClrModuleInstance* pModuleInstance,
            _In_ UINT32 Token,
            _Deref_out_opt_ DkmString** ppError,
            _Deref_out_opt_ Evaluation::ClrCompilation::DkmCompiledClrInspectionQuery** ppResult
            ) = 0;
    };

}; // end of CLR Expression Compilers interfaces


// Debug monitors (general) interfaces
// Debug monitors provide the basic inspection and execution control services that the
// rest of the debugger stack relies on. These run on the same computer as the target
// process. There are two types of debug monitors - 'Base debug monitors' and 'Runtime
// debug monitors'.
namespace ComponentInterfaces
{
    // This interface contains the API for performing an async-break on the debuggee process.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // BaseDebugMonitorId, EngineId, TransportKind.
    #define IID_IDkmAsyncBreak __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmAsyncBreak)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("d8c04b5c-9fe9-0cc7-1978-09a3b2a95d10") IDkmAsyncBreak : public IUnknown
    {
        /// <summary>
        /// This method will tell the debug monitors to asynchronously break execution of the
        /// debuggee process. An AsyncBreakComplete event is sent after the operation is
        /// complete.
        /// </summary>
        /// <param name="pProcess">
        /// [In] DkmProcess represents a target process which is being debugged. The debugger
        /// debugs processes, so this is the basic unit of debugging. A DkmProcess can
        /// represent a system process or a virtual process such as minidumps.
        /// </param>
        /// <param name="StopImmediately">
        /// [In] If this is set to true, implementers should immediately enter break rather
        /// than trying to find a thread inside the process that is executing code.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE AsyncBreak(
            _In_ DkmProcess* pProcess,
            _In_ bool StopImmediately
            ) = 0;
    };

    // This interface contains the API for writing out a dump file of the debuggee process.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // BaseDebugMonitorId, EngineId, TransportKind.
    #define IID_IDkmDumpWriter __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmDumpWriter)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("6d079f19-89d7-6468-ca62-de227a3cbc6f") IDkmDumpWriter : public IUnknown
    {
        /// <summary>
        /// This method will write out a memory dump of the process to the path specified.
        /// </summary>
        /// <param name="pProcess">
        /// [In] DkmProcess represents a target process which is being debugged. The debugger
        /// debugs processes, so this is the basic unit of debugging. A DkmProcess can
        /// represent a system process or a virtual process such as minidumps.
        /// </param>
        /// <param name="DumpType">
        /// [In] The type of dump to write. Either minidump or full-memory minidump.
        /// </param>
        /// <param name="pPath">
        /// [In] The full path to where the minidump should be saved. In remote scenarios,
        /// this path is relative to the remote machine.
        /// </param>
        /// <param name="pTargetThread">
        /// [In,Optional] The thread to use for the minidump if there is no current
        /// exception.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE WriteDump(
            _In_ DkmProcess* pProcess,
            _In_ DkmDumpType_t DumpType,
            _In_ DkmString* pPath,
            _In_opt_ DkmThread* pTargetThread
            ) = 0;
    };

    // IDkmExceptionController is implemented by runtime debug monitors which fire exception
    // events (DkmExceptionInformation.OnDebugMonitorException()).
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // BaseDebugMonitorId, EngineId, ExceptionCategory, RuntimeId.
    #define IID_IDkmExceptionController __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmExceptionController)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("d90b5b6e-0eb7-e6c3-517d-3c019667f21d") IDkmExceptionController : public IUnknown
    {
        /// <summary>
        /// Determines if processing for this exception may be modified by the debugger. For
        /// example, if this user has performed an action (such as set next statement) that
        /// required the exception to be implicitly squashed, this may return false. This
        /// method may also return false if the runtime does not permit the exception from
        /// being squashed.
        /// </summary>
        /// <param name="pException">
        /// [In] Provides information about an exception which was raised in the target
        /// process. This information includes details of what exception was raised and the
        /// current stage of exception processing.
        /// </param>
        /// <param name="pResult">
        /// [Out] True if the debug monitor is able to modify the processing of this
        /// exceptions.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE CanModifyProcessing(
            _In_ Exceptions::DkmExceptionInformation* pException,
            _Out_ bool* pResult
            ) = 0;

        /// <summary>
        /// Updates the state of the target process so that when execution is resumed, the
        /// target process will not continue standard exception processing (ex: handler
        /// search, stack unwinding). This method needs to be called before resuming
        /// execution.
        /// </summary>
        /// <param name="pException">
        /// [In] Provides information about an exception which was raised in the target
        /// process. This information includes details of what exception was raised and the
        /// current stage of exception processing.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE SquashProcessing(
            _In_ Exceptions::DkmExceptionInformation* pException
            ) = 0;
    };

    // IDkmExceptionFormatter is implemented by runtime debug monitors which fire exception
    // events. Unlike IDkmExceptionController, there is generally a single implementation of
    // IDkmExceptionFormatter for each exception category. For example, while multiple base
    // debug monitor implementations are able to detect Win32 exceptions, there only needs to
    // be one formatter implementation.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // BaseDebugMonitorId, EngineId, ExceptionCategory, RuntimeId.
    #define IID_IDkmExceptionFormatter __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmExceptionFormatter)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("b7863c9a-4fa5-5317-abd2-03fcbe66b47e") IDkmExceptionFormatter : public IUnknown
    {
        /// <summary>
        /// Provides a string description for an exception. This is used when tracing the
        /// exception to the output window.
        /// </summary>
        /// <param name="pException">
        /// [In] Provides information about an exception which was raised in the target
        /// process. This information includes details of what exception was raised and the
        /// current stage of exception processing.
        /// </param>
        /// <param name="ppValue">
        /// [Out] String description of the exception.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE GetDescription(
            _In_ Exceptions::DkmExceptionInformation* pException,
            _Deref_out_ DkmString** ppValue
            ) = 0;

        /// <summary>
        /// Provides additional information about an exception which will appear when Visual
        /// Studio stops on the exception. For CLR exceptions, this contains the 'Message'
        /// property from the System.Exception which was thrown.
        /// </summary>
        /// <param name="pException">
        /// [In] Provides information about an exception which was raised in the target
        /// process. This information includes details of what exception was raised and the
        /// current stage of exception processing.
        /// </param>
        /// <param name="ppValue">
        /// [Out,Optional] String description of the exception. If no other information is
        /// available, null is returned.
        /// </param>
        /// <returns>
        /// S_OK is returned if *ppValue is non-NULL, S_FALSE is returned when *ppValue is
        /// NULL, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE GetAdditionalInformation(
            _In_ Exceptions::DkmExceptionInformation* pException,
            _Deref_out_opt_ DkmString** ppValue
            ) = 0;
    };

    // IDkmExceptionWinRTErrorExtractor is called by the exception manager to extract WinRT
    // enhanced error info from a JavaScript/CLR/C++/etc exception.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // BaseDebugMonitorId, EngineId, ExceptionCategory, RuntimeId.
    #define IID_IDkmExceptionWinRTErrorExtractor __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmExceptionWinRTErrorExtractor)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("42247de7-53e4-d930-c996-5bf208e8148a") IDkmExceptionWinRTErrorExtractor : public IUnknown
    {
        /// <summary>
        /// Provides developer-oriented additional information about the exception.  This
        /// info should be displayed along with GetDescription and GetAdditionalInformation
        /// to clarify the cause of the error.
        /// </summary>
        /// <param name="pException">
        /// [In] Provides information about an exception which was raised in the target
        /// process. This information includes details of what exception was raised and the
        /// current stage of exception processing.
        /// </param>
        /// <param name="ppRestrictedDescription">
        /// [Out,Optional] RestrictedErrorInfo description of the exception. Due to security
        /// restrictions, this may not be available even if RestrictedErrorInfo is available
        /// for the exception.
        /// </param>
        /// <param name="ppRestrictedErrorReference">
        /// [Out,Optional] If present, used to retrieve IRestrictedErrorInfo via the
        /// RoResolvedRestrictedErrorInfoReference API.
        /// </param>
        /// <param name="ppRestrictedCapabilitySid">
        /// [Out,Optional] If present specifies the missing capability.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE GetWinRTErrorInfo(
            _In_ Exceptions::DkmExceptionInformation* pException,
            _Deref_out_opt_ DkmString** ppRestrictedDescription,
            _Deref_out_opt_ DkmString** ppRestrictedErrorReference,
            _Deref_out_opt_ DkmString** ppRestrictedCapabilitySid
            ) = 0;
    };

    // Interface to provide access to the runtime function table of a process. A default
    // implementation is provided by Microsoft's Native Debug Monitor which is able to find
    // function tables in loaded Win32 modules and dynamic PData in live processes. This
    // interface may be implemented by base debug monitors to provide runtime function table
    // access for non-live processes (ex: minidumps).
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // BaseDebugMonitorId, EngineId, TransportKind.
    #define IID_IDkmFunctionTableProvider __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmFunctionTableProvider)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("f9fcac25-fcbe-18d6-2700-22dddf8a67d3") IDkmFunctionTableProvider : public IUnknown
    {
        /// <summary>
        /// Obtain the function table entry for the passed address. The format of the engine
        /// is dependent on the debuggee architecture.
        /// </summary>
        /// <param name="pNativeModuleInstance">
        /// [In] 'DkmNativeModuleInstance' is used for modules which contain CPU code and/or
        /// are loaded by the Win32 loader.
        /// </param>
        /// <param name="Address">
        /// [In] The address to search the function table for. Normally, each entry contains
        /// a start and an end address. Implementations should return the entry whose address
        /// range contains the requested address.
        /// </param>
        /// <param name="ppEntry">
        /// [Out] The contents of the function table entry.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE GetFunctionTableEntry(
            _In_ Native::DkmNativeModuleInstance* pNativeModuleInstance,
            _In_ UINT64 Address,
            _Deref_out_ DkmReadOnlyCollection<BYTE>** ppEntry
            ) = 0;

        /// <summary>
        /// The method will return the contents of the IMAGE_RUNTIME_FUNCTION_ENTRY for an
        /// address if possible. For searching static entries, callers should call the
        /// equivalent method on DkmNativeModuleInstance.
        /// </summary>
        /// <param name="pProcess">
        /// [In] DkmProcess represents a target process which is being debugged. The debugger
        /// debugs processes, so this is the basic unit of debugging. A DkmProcess can
        /// represent a system process or a virtual process such as minidumps.
        /// </param>
        /// <param name="Address">
        /// [In] The virtual address for which to find a function table entry for.
        /// </param>
        /// <param name="pBaseAddress">
        /// [Out] The base address for the runtime function table entry.
        /// </param>
        /// <param name="ppFunctionTableEntry">
        /// [Out,Optional] The runtime function table entry for this address if found.
        /// </param>
        /// <returns>
        /// S_OK is returned if *ppFunctionTableEntry is non-NULL, S_FALSE is returned when
        /// *ppFunctionTableEntry is NULL, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE SearchRuntimeFunctionTable(
            _In_ DkmProcess* pProcess,
            _In_ UINT64 Address,
            _Out_ UINT64* pBaseAddress,
            _Deref_out_opt_ DkmReadOnlyCollection<BYTE>** ppFunctionTableEntry
            ) = 0;
    };

    // Interface implemented by debug monitors to perform any updates when the 'Disabled'
    // property of a module changed.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // BaseDebugMonitorId, EngineId, RuntimeId, SymbolProviderId, TransportKind.
    #define IID_IDkmModuleInstanceDisabledNotification __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmModuleInstanceDisabledNotification)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("62cde81a-01db-8f1e-f96f-fff01a95bbad") IDkmModuleInstanceDisabledNotification : public IUnknown
    {
        /// <summary>
        /// Performs any updates needed when the 'Disabled' state changes.
        /// </summary>
        /// <param name="pModuleInstance">
        /// [In] The Module Instance class represent a code bundle (ex: dll or exe) which is
        /// loaded into a particular process at a particular location. Module Instance
        /// objects are 1:1 with the execution environment's notion of a code bundle. For
        /// example, in native code, Module Instance objects are 1:1 with base address.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE OnDisabledChanged(
            _In_ DkmModuleInstance* pModuleInstance
            ) = 0;
    };

    // Interface implemented by debug monitors that support debugging dumps to allow the UI
    // to search for binaries that were not found when the dump originally loaded. The symbol
    // path is updated by the UI if the user chooses a path when searching for the binary.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // BaseDebugMonitorId, EngineId, RuntimeId, SymbolProviderId, TransportKind.
    #define IID_IDkmModuleLocator __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmModuleLocator)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("ab521d60-90eb-b345-211e-9dc45c22c601") IDkmModuleLocator : public IUnknown
    {
        /// <summary>
        /// Attempt to load a binary that previously failed to load using updated symbol
        /// paths.
        /// </summary>
        /// <param name="pModuleInstance">
        /// [In] The Module Instance class represent a code bundle (ex: dll or exe) which is
        /// loaded into a particular process at a particular location. Module Instance
        /// objects are 1:1 with the execution environment's notion of a code bundle. For
        /// example, in native code, Module Instance objects are 1:1 with base address.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE TryLoadBinary(
            _In_ DkmModuleInstance* pModuleInstance
            ) = 0;
    };

    // Provides services to set and remove breakpoints. This interface is implemented by the
    // Debug Monitor for most runtimes. The implementation must use a data item to track the
    // lifetime of each enabled DkmRuntimeBreakpoint so that it can implicitly disable the
    // breakpoint when the DkmRuntimeBreakpoint is closed.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // BaseDebugMonitorId, EngineId, RuntimeId, SourceId.
    #define IID_IDkmRuntimeMonitorBreakpointHandler __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmRuntimeMonitorBreakpointHandler)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("595931ad-c79f-4bd4-06a5-5ca93b3c16f2") IDkmRuntimeMonitorBreakpointHandler : public IUnknown
    {
        /// <summary>
        /// Enables a breakpoint. Breakpoints start off initially disabled, so this method
        /// must be called before the breakpoint can be set. Enabling a breakpoint is
        /// typically implemented in the debug monitor by modifying the state of the target
        /// process. For example inserting an 'int3' instruction into the code stream. If the
        /// breakpoint is already enabled, this operation has no effect.
        ///
        /// Once a breakpoint has been enabled, the debug monitor will raise a
        /// RuntimeBreakpoint event for this DkmRuntimeBreakpoint object whenever the trigger
        /// condition (ex: target instruction is executed) is met. Multiple
        /// DkmRuntimeBreakpoints may be set on the same instruction. In this case, the debug
        /// monitor will raise a different RuntimeBreakpoint event for each breakpoint
        /// object. Similarly, if a step complete and a breakpoint both complete on the same
        /// instruction, the debug monitor will raise both events.
        /// </summary>
        /// <param name="pRuntimeBreakpoint">
        /// [In] Low-level breakpoint object which is supported by debug monitors.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// E_BP_MODULE_UNLOADED indicates that the module instance specified by the
        /// breakpoint is no longer loaded. E_TEXT_SPAN_NOT_LOADED indicates that TextSpan is
        /// not currently loaded in the specified script document.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE EnableRuntimeBreakpoint(
            _In_ Breakpoints::DkmRuntimeBreakpoint* pRuntimeBreakpoint
            ) = 0;

        /// <summary>
        /// Determines if the given DkmRuntimeBreakpoint could be enabled. This is used from
        /// within the breakpoints dialog to validate breakpoints before the dialog is
        /// closed.
        /// </summary>
        /// <param name="pRuntimeBreakpoint">
        /// [In] Low-level breakpoint object which is supported by debug monitors.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// E_BP_MODULE_UNLOADED indicates that the module instance specified by the
        /// breakpoint is no longer loaded. E_TEXT_SPAN_NOT_LOADED indicates that TextSpan is
        /// not currently loaded in the specified script document.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE TestRuntimeBreakpoint(
            _In_ Breakpoints::DkmRuntimeBreakpoint* pRuntimeBreakpoint
            ) = 0;

        /// <summary>
        /// Disables a breakpoint. Disabling a breakpoint is typically implemented by
        /// modifying the state of the target process so the breakpoint will no longer fire.
        /// For example, removing a previously inserted 'int3' from the instruction stream.
        /// If the breakpoint is already disabled, this operation has no effect. In addition
        /// to this method, a breakpoint is implicitly disabled when it is closed.
        ///
        /// If multiple breakpoints are set on the same instruction, disabling one breakpoint
        /// does not affect the other breakpoints set on this instruction.
        /// </summary>
        /// <param name="pRuntimeBreakpoint">
        /// [In] Low-level breakpoint object which is supported by debug monitors.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE DisableRuntimeBreakpoint(
            _In_ Breakpoints::DkmRuntimeBreakpoint* pRuntimeBreakpoint
            ) = 0;
    };

}; // end of Debug monitors (general) interfaces


// Base debug monitors interfaces
// There is a single base debug monitor for every debugged process. The base debug
// monitor is responsible for providing the lowest-level inspection and execution control
// primitives such as native-instruction breakpoints, memory and register reads and
// writes, etc.
namespace ComponentInterfaces
{
    // Interface implemented by base debug monitors to allow resuming the process for a
    // function evaluation. This interface contains the basic services utilized by
    // 'ExecuteFuncEval'. Setup, cleanup, timeout handling, exception handling and completion
    // detection are all handled by the higher-level debug monitors.
    //
    // This interface is not provided for CLR v2 debugging.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // BaseDebugMonitorId, EngineId, TransportKind.
    #define IID_IDkmBaseFuncEvalService __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmBaseFuncEvalService)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("e7884271-5fb5-5eef-8dfc-948d12bd0c6f") IDkmBaseFuncEvalService : public IUnknown
    {
        /// <summary>
        /// This method is used to resume the target process so that a function evaluation
        /// may occur. This function is called by a runtime debug monitor after it has setup
        /// a function evaluation in order to make the target process run. The runtime
        /// monitor will first update the thread context, update any necessary memory in the
        /// target process, and setup any detection that the function evaluation is
        /// completed.
        ///
        /// Callers of this method MUST always call EndFuncEvalExecution before returning
        /// from the operation that triggered the function evaluation. The behavior is
        /// undefined if a caller fails to do so.
        ///
        /// This method is implemented in the base debug monitor by first updating the target
        /// process to be in function evaluation mode (DkmThread.OnBeginFuncEvalExecution),
        /// then suspending and/or resuming threads as specified by the function evaluation
        /// flags and finally continuing the target process.
        ///
        /// This method may be called from any thread, however OnBeginFuncEvalExecution must
        /// be called from the stopping event thread, so the base debug monitor may need to
        /// perform as thread switch as part of the implementation of this method. The base
        /// debug monitor should not return from BeginFuncEvalExecution until after the
        /// target has been resumed.
        /// </summary>
        /// <param name="pThread">
        /// [In] DkmThread represents a thread running in the target process.
        /// </param>
        /// <param name="Flags">
        /// [In] Flags impacting how function evaluation requests are performed.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE BeginFuncEvalExecution(
            _In_ DkmThread* pThread,
            _In_ Evaluation::DkmFuncEvalFlags_t Flags
            ) = 0;
    };

    // IDkmBaseNativeExecutionController is implemented by base debug monitors which support
    // setting native breakpoints or single stepping over native instructions. It provides
    // the advanced execution control primitives needed for CLR debugging.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // BaseDebugMonitorId, EngineId, TransportKind.
    #define IID_IDkmBaseNativeExecutionController __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmBaseNativeExecutionController)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("6eb3c780-c70d-1e67-98cf-9baf7b524b65") IDkmBaseNativeExecutionController : public IUnknown
    {
        /// <summary>
        /// API which may be called from a IDkmSingleStepCompleteReceived or
        /// IDkmRuntimeBreakpointReceived implementation to force the base DM to fire the
        /// EXCEPTION_BREAKPOINT or EXCEPTION_SINGLE_STEP exception in the target process
        /// when execution is resumed. Normally, the breakpoint or single step exception is
        /// implicitly suppressed. This allows the EXCEPTION_BREAKPOINT/EXCEPTION_SINGLE_STEP
        /// to be handled by exception handlers within the target process. This API will fail
        /// if the thread is not currently sitting at a step complete or breakpoint event.
        /// </summary>
        /// <param name="pThread">
        /// [In] DkmThread represents a thread running in the target process.
        /// </param>
        /// <param name="ExceptionCode">
        /// [In] Win32 exception code to raise. Currently, this must be EXCEPTION_BREAKPOINT
        /// or EXCEPTION_SINGLE_STEP.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE RaiseExecutionControlException(
            _In_ DkmThread* pThread,
            _In_ UINT32 ExceptionCode
            ) = 0;
    };

    // This interface contains the API for resuming execution after the engine has sent a
    // stopping event to the Visual Studio debugger package. This interface should only be
    // implemented by Base Debug Monitor components. Unlike nearly all other interfaces, one
    // implementation of this interface may not chain to another implementation.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // BaseDebugMonitorId, EngineId, TransportKind.
    #define IID_IDkmContinueExecution __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmContinueExecution)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("0f1ef515-340e-e38b-8db8-46ea677d90ec") IDkmContinueExecution : public IUnknown
    {
        /// <summary>
        /// This method is provided by base debug monitors to resume execution of the target
        /// process. This interface is always triggered by a request to resume the process by
        /// the Visual Studio Debugger UI/SDM. Concord components cannot resume the target
        /// process once a stopping event has been sent to the UI/SDM.
        ///
        /// Base debug monitors implement this by calling from the request thread onto the
        /// stopping event thread. On the stopping event thread, the base debug monitor calls
        /// DkmThread.OnContinueExecution and then modifies the target process so that it
        /// will resume. After the target is running, the base debug monitor signals the
        /// request thread so that ContinueExecution will return.
        /// </summary>
        /// <param name="pThread">
        /// [In] DkmThread represents a thread running in the target process.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE ContinueExecution(
            _In_ DkmThread* pThread
            ) = 0;
    };

    // Gets the extended registers from the thread context.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // BaseDebugMonitorId, EngineId, TransportKind.
    #define IID_IDkmExtendedRegisters __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmExtendedRegisters)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("ce482f7d-9401-eaa9-3ad8-f6fd122a04f1") IDkmExtendedRegisters : public IUnknown
    {
        /// <summary>
        /// Gets the extended registers from the thread context.
        /// </summary>
        /// <param name="pThread">
        /// [In] DkmThread represents a thread running in the target process.
        /// </param>
        /// <param name="pExtendedRegisters">
        /// [Out] An array of extended registers.
        ///
        /// The memory for the DkmArray members is allocated by the method implementation
        /// using DkmAllocBytes/DkmAllocArray. It is freed by the caller using the
        /// CAutoDkmArray template or with DkmFreeMemory and manual element release.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE GetExtendedRegisters(
            _In_ DkmThread* pThread,
            _Out_ DkmArray<CallStack::DkmUnwoundRegister*>* pExtendedRegisters
            ) = 0;

        /// <summary>
        /// Sets the value of the extended register in the thread's context.
        /// </summary>
        /// <param name="pThread">
        /// [In] DkmThread represents a thread running in the target process.
        /// </param>
        /// <param name="RegisterIndex">
        /// [In] The CV constant of the register to set. For AVX, this can be any of the YMM
        /// register enumeration codes. The caller is expected to set the full YMM register
        /// (including the portions which are aliased on XMM registers).
        /// </param>
        /// <param name="pValue">
        /// [In] The value to set the register to. The size of the byte array must match the
        /// width of the register being set.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE SetExtendedRegisterValue(
            _In_ DkmThread* pThread,
            _In_ CV_HREG_e RegisterIndex,
            _In_ DkmReadOnlyCollection<BYTE>* pValue
            ) = 0;
    };

    // Interface implemented by base debug monitors to provide instruction-level stepping
    // primitives. This interface is consumed by runtime debug monitors to implement
    // user-level execution control.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // BaseDebugMonitorId, EngineId, SourceId.
    #define IID_IDkmInstructionStepper __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmInstructionStepper)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("5c9a47d2-e4b8-b620-0fa0-d18f0b973e2b") IDkmInstructionStepper : public IUnknown
    {
        /// <summary>
        /// Enable single step on a thread. When then single step completes, the
        /// SingleStepComplete event should be sent. The single step should reset after
        /// completion.  Implementers should send one single step complete event per instance
        /// of DkmSingleStepRequest they receive. Callers must make a new request to
        /// single-step after this DkmSingleStepRequest is complete.
        /// </summary>
        /// <param name="pSingleStepRequest">
        /// [In] DkmSingleStepRequest represents a request to single step a thread.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE EnableSingleStep(
            _In_ Stepping::DkmSingleStepRequest* pSingleStepRequest
            ) = 0;

        /// <summary>
        /// Disable single step on a thread.
        /// </summary>
        /// <param name="pSingleStepRequest">
        /// [In] DkmSingleStepRequest represents a request to single step a thread.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE ClearSingleStep(
            _In_ Stepping::DkmSingleStepRequest* pSingleStepRequest
            ) = 0;
    };

    // Interface to support managed func-eval quick abort.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // BaseDebugMonitorId, EngineId, RuntimeId, TransportKind.
    #define IID_IDkmManagedFuncEvalQuickAbortServices __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmManagedFuncEvalQuickAbortServices)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("d83ff0da-6a34-8517-3a57-1bc6c0d38435") IDkmManagedFuncEvalQuickAbortServices : public IUnknown
    {
        /// <summary>
        /// Checks to see if we should load the FEQA DLL.
        /// </summary>
        /// <param name="pClrRuntimeInstance">
        /// [In] Represents a CLR instance running in a target process.
        /// </param>
        /// <param name="pThread">
        /// [In] DkmThread represents a thread running in the target process.
        /// </param>
        /// <param name="pSkipLoad">
        /// [Out] Specifies if the FEQA DLL should be loaded. The hosting process could have
        /// loaded it already.
        /// </param>
        /// <param name="pMemoryAddress">
        /// [Out] Specifies the address in debuggee process. Valid only if AlreadyLoaded is
        /// false.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE PrepareForFuncEvalQuickAbort(
            _In_ Clr::DkmClrRuntimeInstance* pClrRuntimeInstance,
            _In_ DkmThread* pThread,
            _Out_ bool* pSkipLoad,
            _Out_ UINT64* pMemoryAddress
            ) = 0;

        /// <summary>
        /// Notifies the result of the attempt to load the FEQA DLL.
        /// </summary>
        /// <param name="pClrRuntimeInstance">
        /// [In] Represents a CLR instance running in a target process.
        /// </param>
        /// <param name="pThread">
        /// [In] DkmThread represents a thread running in the target process.
        /// </param>
        /// <param name="Result">
        /// [In] Specifies if the FEQA DLL was successfully loaded.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE OnFuncEvalQuickAbortDllLoaded(
            _In_ Clr::DkmClrRuntimeInstance* pClrRuntimeInstance,
            _In_ DkmThread* pThread,
            _In_ bool Result
            ) = 0;
    };

    // Implemented by base debug monitors to provide access to the memory of the target
    // process. This interface is also implemented by higher level components to provide
    // memory caching. Base debug monitors are responsible for performing the memory I/O,
    // maintaining a table of invisible writes, and providing events when the invisible write
    // table is updated (via DkmProcess.OnInstructionPatchInserted/Removed).
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // BaseDebugMonitorId, EngineId, TransportKind.
    #define IID_IDkmMemoryOperation __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmMemoryOperation)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("7ad9578e-2685-b96c-8f49-0d6147e9a8f8") IDkmMemoryOperation : public IUnknown
    {
        /// <summary>
        /// Read the memory of the target process.
        /// </summary>
        /// <param name="pProcess">
        /// [In] DkmProcess represents a target process which is being debugged. The debugger
        /// debugs processes, so this is the basic unit of debugging. A DkmProcess can
        /// represent a system process or a virtual process such as minidumps.
        /// </param>
        /// <param name="Address">
        /// [In] The base address from which to read the target process's memory.
        /// </param>
        /// <param name="Flags">
        /// [In] Flags controlling the behavior of DkmProcess.ReadMemory and
        /// DkmProcess.ReadMemoryString.
        /// </param>
        /// <param name="pBuffer">
        /// [In,Out] A buffer that receives the contents from the address space of the target
        /// process. On failure, the content of this buffer is unspecified.
        /// </param>
        /// <param name="Size">
        /// [In] The number of bytes to be read from the process. In scenarios where the call
        /// is marshalled to the remote debugger from the IDE, this must be less than 25 MBs.
        /// </param>
        /// <param name="pBytesRead">
        /// [Out] Indicates the number of bytes read from the target process. If
        /// DkmReadMemoryFlags.AllowPartialRead is clear, on success this value will always
        /// be exactly equal to the input size. If DkmReadMemoryFlags.AllowPartialRead is
        /// specified, on success, this value will be greater than zero.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// E_INVALID_MEMORY_ADDRESS indicates that the address is not valid. See
        /// 'DkmReadMemoryFlags.AllowPartialRead' documentation for more information.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE ReadMemory(
            _In_ DkmProcess* pProcess,
            _In_ UINT64 Address,
            _In_ DkmReadMemoryFlags_t Flags,
            _Out_capcount_(Size) void* pBuffer,
            _In_ UINT32 Size,
            _Out_ UINT32* pBytesRead
            ) = 0;

        /// <summary>
        /// Reads a null-terminated string from the target process process's memory. This can
        /// be used to read an ANSI or Unicode (UTF-8, UTF-16 or UTF-32) strings.
        /// </summary>
        /// <param name="pProcess">
        /// [In] DkmProcess represents a target process which is being debugged. The debugger
        /// debugs processes, so this is the basic unit of debugging. A DkmProcess can
        /// represent a system process or a virtual process such as minidumps.
        /// </param>
        /// <param name="Address">
        /// [In] The base address from which to read the target process's memory.
        /// </param>
        /// <param name="Flags">
        /// [In] Flags controlling the behavior of DkmProcess.ReadMemory and
        /// DkmProcess.ReadMemoryString.
        /// </param>
        /// <param name="CharacterSize">
        /// [In] Number of bytes in each character. This should be set to 1 (ANSI/UTF-8), 2
        /// (UTF-16) or 4 (UTF-32).
        /// </param>
        /// <param name="MaxCharacters">
        /// [In] The maximum number of characters to read from the target process. When
        /// DkmReadMemoryFlags.AllowPartialRead is false, the request will fail if a null
        /// terminator isn't found within this range. This value should be reasonable. The
        /// Microsoft implementation will fail any request for more than 25 MBs of string
        /// memory.
        /// </param>
        /// <param name="pStringMemory">
        /// [Out] The value of the string which was read from the target process. If
        /// DkmReadMemoryFlags.AllowPartialRead is clear, this memory will always include the
        /// null termination character. If DkmReadMemoryFlags.AllowPartialRead is specified,
        /// this buffer will not contain the null termination character if the read was
        /// truncated.
        ///
        /// The memory for the DkmArray members is allocated by the method implementation
        /// using DkmAllocBytes/DkmAllocArray. It is freed by the caller using the
        /// CAutoDkmArray template or with DkmFreeMemory and manual element release.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// E_INVALID_MEMORY_ADDRESS indicates that the address is not valid. See
        /// 'DkmReadMemoryFlags.AllowPartialRead' documentation for more information.
        /// E_STRING_TOO_LONG indicates that the string could not be read within the
        /// specified maximum number of characters.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE ReadMemoryString(
            _In_ DkmProcess* pProcess,
            _In_ UINT64 Address,
            _In_ DkmReadMemoryFlags_t Flags,
            _In_ UINT16 CharacterSize,
            _In_ UINT32 MaxCharacters,
            _Out_ DkmArray<BYTE>* pStringMemory
            ) = 0;

        /// <summary>
        /// Writes memory to the target process. Before data transfer occurs, the system
        /// verifies that all data in the base address and memory of the specified size is
        /// accessible for write access, and if it is not accessible, the function raises an
        /// E_INVALID_MEMORY_ADDRESS error.
        /// </summary>
        /// <param name="pProcess">
        /// [In] DkmProcess represents a target process which is being debugged. The debugger
        /// debugs processes, so this is the basic unit of debugging. A DkmProcess can
        /// represent a system process or a virtual process such as minidumps.
        /// </param>
        /// <param name="Address">
        /// [In] The base address from which to write the target process's memory.
        /// </param>
        /// <param name="Data">
        /// [In] Data to be written in the address space of the specified process.
        ///
        /// The memory for the DkmArray members is allocated by the caller, and can be from
        /// any source (stack memory, static buffer, heap, etc). The implementation should
        /// not modify the members.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE WriteMemory(
            _In_ DkmProcess* pProcess,
            _In_ UINT64 Address,
            _In_ const DkmArray<BYTE>& Data
            ) = 0;

        /// <summary>
        /// Write memory to the target process, but hide the write from calls to ReadMemory.
        /// This API may be used to patch instructions or data within the target process to
        /// implement debugger features. Before data transfer occurs, the system verifies
        /// that all data in the base address and memory of the specified size is accessible
        /// for write access, and if it is not accessible, the function raises an
        /// E_INVALID_MEMORY_ADDRESS error.
        /// </summary>
        /// <param name="pProcess">
        /// [In] DkmProcess represents a target process which is being debugged. The debugger
        /// debugs processes, so this is the basic unit of debugging. A DkmProcess can
        /// represent a system process or a virtual process such as minidumps.
        /// </param>
        /// <param name="Address">
        /// [In] The base address from which to write the target process's memory.
        /// </param>
        /// <param name="Data">
        /// [In] Data to be written in the address space of the specified process.
        ///
        /// The memory for the DkmArray members is allocated by the caller, and can be from
        /// any source (stack memory, static buffer, heap, etc). The implementation should
        /// not modify the members.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE InvisibleWriteMemory(
            _In_ DkmProcess* pProcess,
            _In_ UINT64 Address,
            _In_ const DkmArray<BYTE>& Data
            ) = 0;
    };

    // Interface implemented by base debug monitors to fire a symbols loaded event.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // BaseDebugMonitorId, EngineId, RuntimeId, SymbolProviderId, TransportKind.
    #define IID_IDkmModuleSymbolsLoaded __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmModuleSymbolsLoaded)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("298f27bb-9a80-c3fe-1582-406a362ac38d") IDkmModuleSymbolsLoaded : public IUnknown
    {
        /// <summary>
        /// After a symbol provided has loaded symbols, this method will be invoked by the
        /// dispatcher to cause a ModuleSymbolsLoaded event to be raised. This method may be
        /// called on the event thread, in which case the base DM should simply call
        /// DkmModuleInstance.OnSymbolsLoaded. This method may also be called on the request
        /// thread, in which case the Base DM should transition to their event thread, call
        /// DkmModuleInstance.OnSymbolsLoaded and wait for that call to finish before
        /// returning.
        /// </summary>
        /// <param name="pModuleInstance">
        /// [In] The Module Instance class represent a code bundle (ex: dll or exe) which is
        /// loaded into a particular process at a particular location. Module Instance
        /// objects are 1:1 with the execution environment's notion of a code bundle. For
        /// example, in native code, Module Instance objects are 1:1 with base address.
        /// </param>
        /// <param name="pModule">
        /// [In] The DkmModule that is associated with the DkmModuleInstance.
        /// </param>
        /// <param name="IsReload">
        /// [In] True if symbols are being reloaded for an existing module, False if this is
        /// happening as part of module load processing.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE RaiseSymbolsLoadedEvent(
            _In_ DkmModuleInstance* pModuleInstance,
            _In_ Symbols::DkmModule* pModule,
            _In_ bool IsReload
            ) = 0;
    };

    // Optional interface implemented by base debug debug monitors which use the same event
    // thread for multiple processes.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // BaseDebugMonitorId, EngineId, TransportKind.
    //
    // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
    #define IID_IDkmProcessDebuggerInitializeWaiter __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmProcessDebuggerInitializeWaiter)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("5e2bc414-5920-aa35-8f3e-300d0395cddf") IDkmProcessDebuggerInitializeWaiter : public IUnknown
    {
        /// <summary>
        /// Wait until process debugger becomes initialized.
        /// </summary>
        /// <param name="pProcess">
        /// [In] DkmProcess represents a target process which is being debugged. The debugger
        /// debugs processes, so this is the basic unit of debugging. A DkmProcess can
        /// represent a system process or a virtual process such as minidumps.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE WaitForDebuggerInitialize(
            _In_ DkmProcess* pProcess
            ) = 0;

        /// <summary>
        /// Process debugging became initialized.
        /// </summary>
        /// <param name="pProcess">
        /// [In] DkmProcess represents a target process which is being debugged. The debugger
        /// debugs processes, so this is the basic unit of debugging. A DkmProcess can
        /// represent a system process or a virtual process such as minidumps.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE SetDebuggerInitialized(
            _In_ DkmProcess* pProcess
            ) = 0;
    };

    // Queries state about the debuggee process.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // BaseDebugMonitorId, EngineId, TransportKind.
    #define IID_IDkmProcessQueryOperation __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmProcessQueryOperation)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("495f1aa0-59b9-a149-e5ba-c12e29af53f6") IDkmProcessQueryOperation : public IUnknown
    {
        /// <summary>
        /// Obtains the number of active handles in the process.
        /// </summary>
        /// <param name="pProcess">
        /// [In] DkmProcess represents a target process which is being debugged. The debugger
        /// debugs processes, so this is the basic unit of debugging. A DkmProcess can
        /// represent a system process or a virtual process such as minidumps.
        /// </param>
        /// <param name="pHandleCount">
        /// [Out] The number of handles in the debuggee process.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE GetHandleCount(
            _In_ DkmProcess* pProcess,
            _Out_ UINT32* pHandleCount
            ) = 0;

        /// <summary>
        /// Obtains the number of clock cycles that the debuggee has been running since
        /// ResetRunningTime() was last called.
        /// </summary>
        /// <param name="pProcess">
        /// [In] DkmProcess represents a target process which is being debugged. The debugger
        /// debugs processes, so this is the basic unit of debugging. A DkmProcess can
        /// represent a system process or a virtual process such as minidumps.
        /// </param>
        /// <param name="pRunningTime">
        /// [Out] The time the debuggee has been running.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE GetRunningTime(
            _In_ DkmProcess* pProcess,
            _Out_ UINT64* pRunningTime
            ) = 0;

        /// <summary>
        /// Sets the running time counter to the specified value.
        /// </summary>
        /// <param name="pProcess">
        /// [In] DkmProcess represents a target process which is being debugged. The debugger
        /// debugs processes, so this is the basic unit of debugging. A DkmProcess can
        /// represent a system process or a virtual process such as minidumps.
        /// </param>
        /// <param name="RunningTime">
        /// [In] The value to set the clock to.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE SetRunningTime(
            _In_ DkmProcess* pProcess,
            _In_ UINT64 RunningTime
            ) = 0;
    };

    // This interface contains the API for launching a new process under the debugger or
    // attaching the debugger to an existing process.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // BaseDebugMonitorId, EngineId, TransportKind.
    #define IID_IDkmStartDebuggingOperations __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmStartDebuggingOperations)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("f0114593-949f-0b85-0693-33feed681031") IDkmStartDebuggingOperations : public IUnknown
    {
        /// <summary>
        /// Causes the debug monitor to attach to the process. Before this method returns,
        /// the debug monitor must start an event thread (or reuse an existing event thread)
        /// and create the DkmProcess object on the event thread. Creating the DkmProcess
        /// object will send a process create event.
        ///
        /// Note that this method may only be called in response to the Visual Studio
        /// debugger package requesting an attach. Components that wish to attach to another
        /// process should send a custom event to a visual studio package. From a package, an
        /// attach can be requested through the IVsDebugger.LaunchDebugTargets API.
        /// </summary>
        /// <param name="pRequest">
        /// [In] DkmProcessAttachRequest is used to describe the process that debugger should
        /// attach to.
        /// </param>
        /// <param name="ppProcess">
        /// [Out] DkmProcess represents a target process which is being debugged. The
        /// debugger debugs processes, so this is the basic unit of debugging. A DkmProcess
        /// can represent a system process or a virtual process such as minidumps.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// E_ATTACH_USER_CANCELED indicates that the attach to process operation was
        /// canceled. Returning this error will suppress most error messages. So it can be
        /// used in combination with DkmUserMessage.Post or DkmCustomMessage.SendToVsService
        /// as a way of providing custom failure messages to the user.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE AttachToProcess(
            _In_ Start::DkmProcessAttachRequest* pRequest,
            _Deref_out_ DkmProcess** ppProcess
            ) = 0;

        /// <summary>
        /// Causes the debug monitor to create a new process under the debugger. The process
        /// should be left suspended until ResumeDebuggedProcess is called. The debug monitor
        /// must wait for ResumeDebuggedProcess before creating the DkmProcess object since
        /// it needs the UniqueProcessId value from the AD7 Layer.
        ///
        /// Note that this method may only be called in response to the Visual Studio
        /// debugger package requesting a launch. Components that wish to launch another
        /// process under the debugger should send a custom event to a visual studio package.
        /// From a package, a launch can be requested through the
        /// IVsDebugger.LaunchDebugTargets API.
        /// </summary>
        /// <param name="pRequest">
        /// [In] DkmProcessLaunchRequest is used to describe the process that debugger should
        /// launch.
        /// </param>
        /// <param name="pLaunchedProcess">
        /// [Out] DkmLaunchedProcessInfo is returned from APIs that launch a process.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE LaunchDebuggedProcess(
            _In_ Start::DkmProcessLaunchRequest* pRequest,
            _Out_ Start::DkmLaunchedProcessInfo* pLaunchedProcess
            ) = 0;

        /// <summary>
        /// Causes the debug monitor to resume a launched process and create the DkmProcess
        /// object. The DkmProcess object will be created on the event thread and creating
        /// the object will send a process create event.
        ///
        /// Note that this method may only be called in response to the Visual Studio
        /// debugger package requesting a launch. Components that wish to launch another
        /// process under the debugger should send a custom event to a visual studio package.
        /// From a package, a launch can be requested through the
        /// IVsDebugger.LaunchDebugTargets API.
        /// </summary>
        /// <param name="pRequest">
        /// [In] DkmProcessLaunchRequest is used to describe the process that debugger should
        /// launch.
        /// </param>
        /// <param name="UniqueProcessId">
        /// [In] Value to assign to the 'DkmProcess.UniqueId' field. This Guid is generated
        /// by the port, and is used to uniquely identifies the process object.
        /// </param>
        /// <param name="ppProcess">
        /// [Out] DkmProcess represents a target process which is being debugged. The
        /// debugger debugs processes, so this is the basic unit of debugging. A DkmProcess
        /// can represent a system process or a virtual process such as minidumps.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE ResumeDebuggedProcess(
            _In_ Start::DkmProcessLaunchRequest* pRequest,
            _In_ const GUID& UniqueProcessId,
            _Deref_out_ DkmProcess** ppProcess
            ) = 0;
    };

    // This interface contains the API for stop debugging. These interface must be
    // implemented by base debug monitors. It is also possible to implement this interface in
    // order to customize the stop debugging experience for a particular application. For
    // example, a component could re-implement Terminate so that the debugger would
    // gracefully shutdown the application instead of using the TerminateProcess Win32 API.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // BaseDebugMonitorId, EngineId, TransportKind.
    #define IID_IDkmStopDebuggingOperations __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmStopDebuggingOperations)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("2e628601-1628-28fe-8b2e-524974efd213") IDkmStopDebuggingOperations : public IUnknown
    {
        /// <summary>
        /// This method is called to tell the monitor to detach from the target process. This
        /// will trigger a ProcessExit event to be sent on the event thread.
        /// </summary>
        /// <param name="pProcess">
        /// [In] DkmProcess represents a target process which is being debugged. The debugger
        /// debugs processes, so this is the basic unit of debugging. A DkmProcess can
        /// represent a system process or a virtual process such as minidumps.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE Detach(
            _In_ DkmProcess* pProcess
            ) = 0;

        /// <summary>
        /// This method is called to tell the monitor to terminate the target process. This
        /// will trigger a ProcessExit event to be sent on the event thread.
        /// </summary>
        /// <param name="pProcess">
        /// [In] DkmProcess represents a target process which is being debugged. The debugger
        /// debugs processes, so this is the basic unit of debugging. A DkmProcess can
        /// represent a system process or a virtual process such as minidumps.
        /// </param>
        /// <param name="ExitCode">
        /// [In] The exit code to be used by the process and threads terminated as a result
        /// of this call. Use the GetExitCodeProcess function to retrieve a process's exit
        /// value. Use the GetExitCodeThread function to retrieve a thread's exit value.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE Terminate(
            _In_ DkmProcess* pProcess,
            _In_ UINT32 ExitCode
            ) = 0;
    };

    // Operations provided by a base debug monitor to obtain and update a thread's context
    // (register values).
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // BaseDebugMonitorId, EngineId, TransportKind.
    #define IID_IDkmThreadContextOperation __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmThreadContextOperation)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("0b3dd722-7b1c-4a40-e96a-22dbdcd870e2") IDkmThreadContextOperation : public IUnknown
    {
        /// <summary>
        /// Update the context (register values) of a thread.
        /// </summary>
        /// <param name="pThread">
        /// [In] DkmThread represents a thread running in the target process.
        /// </param>
        /// <param name="Context">
        /// [In] A CONTEXT structure that contains the context to be set in the specified
        /// thread. The value of the ContextFlags member of this structure specifies which
        /// portions of a thread's context to set. Some values in the CONTEXT structure that
        /// cannot be specified are silently set to the correct value. This includes bits in
        /// the CPU status register that specify the privileged processor mode, global
        /// enabling bits in the debugging register, and other states that must be controlled
        /// by the operating system.
        ///
        /// The memory for the DkmArray members is allocated by the caller, and can be from
        /// any source (stack memory, static buffer, heap, etc). The implementation should
        /// not modify the members.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE SetContext(
            _In_ DkmThread* pThread,
            _In_ const DkmArray<BYTE>& Context
            ) = 0;

        /// <summary>
        /// Obtain the current context (register values) of a thread.
        /// </summary>
        /// <param name="pThread">
        /// [In] DkmThread represents a thread running in the target process.
        /// </param>
        /// <param name="ContextFlags">
        /// [In] Win32 flags indicating which portion of the CONTEXT object to obtain (ex:
        /// CONTEXT_FULL, CONTEXT_CONTROL, CONTEXT_INTEGER).
        /// </param>
        /// <param name="pContext">
        /// [In,Out] A Win32 CONTEXT structure that contains the context of the specified
        /// thread. The value of the ContextFlags member of this structure specifies which
        /// portions of a thread's context to obtained.
        /// </param>
        /// <param name="ContextSize">
        /// [In] Size of the context structure to read in bytes. This must exactly match the
        /// size required to read the context.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE GetContext(
            _In_ DkmThread* pThread,
            _In_ UINT32 ContextFlags,
            _Out_capcount_(ContextSize) void* pContext,
            _In_ UINT32 ContextSize
            ) = 0;
    };

    // Called to suspend or resume a thread and to obtain the current thread suspension
    // count.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // BaseDebugMonitorId, EngineId, TransportKind.
    #define IID_IDkmThreadSuspension __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmThreadSuspension)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("015aaf9b-9342-09b8-7873-980d89ff2ecc") IDkmThreadSuspension : public IUnknown
    {
        /// <summary>
        /// Suspend this thread.
        /// </summary>
        /// <param name="pThread">
        /// [In] DkmThread represents a thread running in the target process.
        /// </param>
        /// <param name="InternalSuspension">
        /// [In] Pass true if this suspension should be hidden in calls to
        /// GetSuspensionCount. This is useful for internal suspensions that should not be
        /// reported to the user such as thread slippage suspensions.
        /// </param>
        /// <param name="pExternalSuspensionCount">
        /// [Out,Optional] The previous number of suspensions for this thread minus the ones
        /// internal to the debugger.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE Suspend(
            _In_ DkmThread* pThread,
            _In_ bool InternalSuspension,
            _Out_ UINT32* pExternalSuspensionCount
            ) = 0;

        /// <summary>
        /// Resume this thread.
        /// </summary>
        /// <param name="pThread">
        /// [In] DkmThread represents a thread running in the target process.
        /// </param>
        /// <param name="InternalSuspension">
        /// [In] Pass true if this suspension should be hidden in calls to
        /// GetSuspensionCount. This is useful for internal suspensions that should not be
        /// reported to the user such as thread slippage suspensions.
        /// </param>
        /// <param name="pExternalSuspensionCount">
        /// [Out,Optional] The previous number of suspensions for this thread minus the ones
        /// internal to the debugger before this resume is applied.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE Resume(
            _In_ DkmThread* pThread,
            _In_ bool InternalSuspension,
            _Out_ UINT32* pExternalSuspensionCount
            ) = 0;

        /// <summary>
        /// Return the current suspension count of this thread.
        /// </summary>
        /// <param name="pThread">
        /// [In] DkmThread represents a thread running in the target process.
        /// </param>
        /// <param name="ShowInternal">
        /// [In] Pass true to return the true suspension count for the thread. Return false
        /// to only see the suspensions that occurred in the debuggee process or the one's
        /// that passed true for InternalSuspension to Suspend.
        /// </param>
        /// <param name="pSuspensionCount">
        /// [Out] The suspension count of thread. The internal thread suspension count is
        /// subtracted from this value if ShowInternal is false.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE GetSuspensionCount(
            _In_ DkmThread* pThread,
            _In_ bool ShowInternal,
            _Out_ UINT32* pSuspensionCount
            ) = 0;

        /// <summary>
        /// Return the total number of suspensions caused by the debugger (i.e. calls to
        /// DkmThread::Suspend without a call to DkmThread::Resume). This excludes any
        /// suspensions external to the debugger.
        /// </summary>
        /// <param name="pThread">
        /// [In] DkmThread represents a thread running in the target process.
        /// </param>
        /// <param name="pSuspensionCount">
        /// [Out] The total number of suspensions caused by the debugger (i.e. calls to
        /// DkmThread::Suspend without a call to DkmThread::Resume). This excludes any
        /// suspensions external to the debugger.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE GetDebuggerSuspensionCount(
            _In_ DkmThread* pThread,
            _Out_ UINT32* pSuspensionCount
            ) = 0;
    };

    // Implemented by base debug monitors to allow allocation/free of virtual memory in the
    // target process.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // BaseDebugMonitorId, EngineId, TransportKind.
    #define IID_IDkmVirtualMemoryAllocator __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmVirtualMemoryAllocator)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("5668629d-1253-d9a2-0cb1-7b77009092d8") IDkmVirtualMemoryAllocator : public IUnknown
    {
        /// <summary>
        /// Reserves and/or commits a region of memory within the virtual address space of
        /// the target process. The function initializes the memory it allocates to zero,
        /// unless MEM_RESET is used. For additional information, see the VirtualAlloc Win32
        /// API in MSDN.
        /// </summary>
        /// <param name="pProcess">
        /// [In] DkmProcess represents a target process which is being debugged. The debugger
        /// debugs processes, so this is the basic unit of debugging. A DkmProcess can
        /// represent a system process or a virtual process such as minidumps.
        /// </param>
        /// <param name="Address">
        /// [In] Address within the target process where the memory should be committed or
        /// reserved. This value is typically zero, in which case the system chooses an
        /// address.
        /// </param>
        /// <param name="Size">
        /// [In] The size of the region of memory to allocate, in bytes. The system will
        /// automatically round up to the next page boundary.
        /// </param>
        /// <param name="AllocationType">
        /// [In] Indicates the type of allocation to perform. This is typically MEM_COMMIT |
        /// MEM_RESERVE (0x3000) which reserves and commits an allocation in one step.
        /// </param>
        /// <param name="PageProtection">
        /// [In] The memory protection for the region of pages to be allocated. If the pages
        /// are being committed, you can specify any one of the memory protection constants
        /// (ex: PAGE_READWRITE, PAGE_EXECUTE).
        /// </param>
        /// <param name="pAllocatedAddress">
        /// [Out] Base address of the allocated region of pages.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE AllocateVirtualMemory(
            _In_ DkmProcess* pProcess,
            _In_ UINT64 Address,
            _In_ UINT32 Size,
            _In_ UINT32 AllocationType,
            _In_ UINT32 PageProtection,
            _Out_ UINT64* pAllocatedAddress
            ) = 0;

        /// <summary>
        /// Releases and/or decommits a region of memory within the virtual address space of
        /// the target process. For additional information, see the VirtualFree Win32 API in
        /// MSDN.
        /// </summary>
        /// <param name="pProcess">
        /// [In] DkmProcess represents a target process which is being debugged. The debugger
        /// debugs processes, so this is the basic unit of debugging. A DkmProcess can
        /// represent a system process or a virtual process such as minidumps.
        /// </param>
        /// <param name="Address">
        /// [In] Address within the target process where the memory should be freed.
        /// </param>
        /// <param name="Size">
        /// [In] Number of bytes to decommit. To release a region of memory, this value must
        /// be zero.
        /// </param>
        /// <param name="FreeType">
        /// [In] Indicates the type of free operation to perform. This is typically
        /// MEM_RELEASE (0x8000), which releases the specified region of pages. After the
        /// operation, the pages are in the free state. MEM_DECOMMIT (0x4000) can be used
        /// instead to decommit the pages without releasing them.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE FreeVirtualMemory(
            _In_ DkmProcess* pProcess,
            _In_ UINT64 Address,
            _In_ UINT32 Size,
            _In_ UINT32 FreeType
            ) = 0;
    };

    // Provides support for reading and writing memory. Unlike IDkmMemoryOperation, this
    // Interface can be used when the process is running, and it will never cache results, so
    // it should be used with care.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // BaseDebugMonitorId, EngineId, TransportKind.
    #define IID_IDkmVolatileMemoryOperation __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmVolatileMemoryOperation)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("d91f2e1d-6f19-6bf5-f7bd-dc29585d6601") IDkmVolatileMemoryOperation : public IUnknown
    {
        /// <summary>
        /// Read memory from the target process. This method differs from 'ReadMemory' in
        /// that this method can be called at any time (not just when the target is stopped)
        /// and the debugger will not try to cache the result of this operation.
        /// </summary>
        /// <param name="pProcess">
        /// [In] DkmProcess represents a target process which is being debugged. The debugger
        /// debugs processes, so this is the basic unit of debugging. A DkmProcess can
        /// represent a system process or a virtual process such as minidumps.
        /// </param>
        /// <param name="Address">
        /// [In] The base address from which to read the target process's memory.
        /// </param>
        /// <param name="pBuffer">
        /// [In,Out] A buffer that receives the contents from the address space of the target
        /// process. On failure, the content of this buffer is unspecified.
        /// </param>
        /// <param name="Size">
        /// [In] The number of bytes to be read from the process. In scenarios where the call
        /// is marshalled to the remote debugger from the IDE, this must be less than 25 MBs.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// E_INVALID_MEMORY_ADDRESS indicates that one or more bytes of the request could
        /// not be read.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE VolatileReadMemory(
            _In_ DkmProcess* pProcess,
            _In_ UINT64 Address,
            _Out_capcount_(Size) void* pBuffer,
            _In_ UINT32 Size
            ) = 0;

        /// <summary>
        /// Write to the memory of the target process. This method differs from 'WriteMemory'
        /// in that this method can be called at any time (not just when the target is
        /// stopped) and the debugger will not try to cache the result of this operation. If
        /// any memory cannot be written to, an E_INVALID_MEMORY_ADDRESS error will be
        /// raised. Because the memory write may occur from run mode, this failure may happen
        /// after the copy operation has already begun, and thus may lead to memory
        /// corruption in the target process. For this reason, this function must be used
        /// with care, and failures may be fatal.
        /// </summary>
        /// <param name="pProcess">
        /// [In] DkmProcess represents a target process which is being debugged. The debugger
        /// debugs processes, so this is the basic unit of debugging. A DkmProcess can
        /// represent a system process or a virtual process such as minidumps.
        /// </param>
        /// <param name="Address">
        /// [In] The base address from which to write the target process's memory.
        /// </param>
        /// <param name="Data">
        /// [In] Data to be written in the address space of the specified process.
        ///
        /// The memory for the DkmArray members is allocated by the caller, and can be from
        /// any source (stack memory, static buffer, heap, etc). The implementation should
        /// not modify the members.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE VolatileWriteMemory(
            _In_ DkmProcess* pProcess,
            _In_ UINT64 Address,
            _In_ const DkmArray<BYTE>& Data
            ) = 0;
    };

    // Exposes volatile properties of a thread such as priority and affinity mask. These
    // values are expected to change over time and should not be cached by callers.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // BaseDebugMonitorId, EngineId, TransportKind.
    #define IID_IDkmVolatileThreadProperties __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmVolatileThreadProperties)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("7af2ed97-ad57-169d-9694-9acf19c5018b") IDkmVolatileThreadProperties : public IUnknown
    {
        /// <summary>
        /// Get a thread's dynamic properties.
        /// </summary>
        /// <param name="pThread">
        /// [In] DkmThread represents a thread running in the target process.
        /// </param>
        /// <param name="pPriority">
        /// [Out] The priority of the thread. The values returned correspond directly to the
        /// values defined for kernel32!GetThreadPriority.
        /// </param>
        /// <param name="pAffinityMask">
        /// [Out] The affinity mask of the thread. The values returned correspond directly to
        /// the values defined for kernel32!SetThreadAffinityMask.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE GetVolatileProperties(
            _In_ DkmThread* pThread,
            _Out_ INT32* pPriority,
            _Out_ UINT64* pAffinityMask
            ) = 0;

        /// <summary>
        /// Get volatile flags about a thread. For instance, return if a thread is a
        /// user-mode scheduled thread.
        /// </summary>
        /// <param name="pThread">
        /// [In] DkmThread represents a thread running in the target process.
        /// </param>
        /// <param name="pFlags">
        /// [Out] Volatile flags that apply to a thread. These values are expected to change
        /// over time and should not be cached by callers.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE GetVolatileFlags(
            _In_ DkmThread* pThread,
            _Out_ ThreadProperties::DkmVolatileThreadFlags_t* pFlags
            ) = 0;
    };

}; // end of Base debug monitors interfaces


// Runtime debug monitors interfaces
// A runtime debug monitor is capable of inspecting and modifying a runtime environment
// in the target process in order to assist in execution control or data inspection. For
// example, Microsoft provides the Managed Debug Monitor component to interact with the
// .NET Framework Virtual Machine (VM), and it provides the Native Debug Monitor to
// interact with the Visual C++ Runtime (CRT) and to interact with code compiled with the
// Visual C++ compiler (or similar compilers and/or CRTs). There may be more than one
// Runtime debug monitor inspecting the target process.
//
// See also: IDkmRuntimeBreakpointNotification, IDkmRuntimeBreakpointReceived,
// IDkmThreadExitNotification
namespace ComponentInterfaces
{
    // Provides execution of compiled inspection queries.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // CompiledInspectionQueryKind, CompilerVendorId, EngineId, LanguageId, RuntimeId.
    #define IID_IDkmCompiledInspectionQueryProcessor __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmCompiledInspectionQueryProcessor)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("d8e2fa09-8d12-0e6a-c15e-4dc0968bcbf4") IDkmCompiledInspectionQueryProcessor : public IUnknown
    {
        /// <summary>
        /// Executes a compiled inspection query and returns any results.
        /// </summary>
        /// <param name="pQuery">
        /// [In] Represents a query which is produced by an expression evaluator or similar
        /// component and set to the target computer to obtain information about the dynamic
        /// state of the program (ex: the current value of a register).  Consumers of
        /// inspection queries should call Close() once it is known that the inspection query
        /// will no longer execute.
        /// </param>
        /// <param name="pParameters">
        /// [In,Optional] Optional array of parameter values to pass to the IL stream.
        /// </param>
        /// <param name="pILContext">
        /// [In] The stack frame context we are evaluating on.
        /// </param>
        /// <param name="Timeout">
        /// [In] This is the timeout to be used for potentially slow operations such as a
        /// function evaluation. This value is in milliseconds.
        /// </param>
        /// <param name="FuncEvalFlags">
        /// [In] Flags impacting how function evaluation requests are performed.
        /// </param>
        /// <param name="pResults">
        /// [Out] Results of the evaluations. Each ILEvaluationResult object contains an
        /// index that indicates which DkmILInstruction in the instructions parameter this
        /// result came from. NOTE: some instructions will not return a result.
        ///
        /// The memory for the DkmArray members is allocated by the method implementation
        /// using DkmAllocBytes/DkmAllocArray. It is freed by the caller using the
        /// CAutoDkmArray template or with DkmFreeMemory and manual element release.
        /// </param>
        /// <param name="pFailureReason">
        /// [Out] If an expected error occurs evaluating the DkmIL, indicates the reason for
        /// the failure.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE ExecuteQuery(
            _In_ Evaluation::DkmCompiledInspectionQuery* pQuery,
            _In_opt_ DkmReadOnlyCollection<Evaluation::IL::DkmILParameterValue*>* pParameters,
            _In_ Evaluation::DkmILContext* pILContext,
            _In_ UINT32 Timeout,
            _In_ Evaluation::DkmFuncEvalFlags_t FuncEvalFlags,
            _Out_ DkmArray<Evaluation::IL::DkmILEvaluationResult*>* pResults,
            _Out_ Evaluation::IL::DkmILFailureReason_t* pFailureReason
            ) = 0;
    };

    // IDkmDebugMonitorExceptionNotification is implemented by components that want to listen
    // for the DebugMonitorException event. When this notification fires, the target process
    // will be suspended and can be examined. The 'DebugMonitorException' event provides
    // notification from debug monitors about exceptions which occur within the target
    // process. This event notification is consumed by the exception manager, and by debug
    // monitors operating at component levels above the debug monitor which detected the
    // exception. Higher level components should use exception triggers instead. See
    // DkmExceptionTrigger for more information.
    //
    // If the exception is sent unhandled (DkmExceptionProcessingStage.Unhandled is set) then
    // the IDE will stop. Other exceptions may stop depending on any DkmExceptionTriggers set
    // by the AD7 AL or other components. The AD7 AL reads the default set of triggers from
    // %VSRegistryRoot%\AD7Metrics\Exception\%CategoryGuid%\*.
    //
    // DebugMonitorException events can be suppressed by calling
    // DkmEventDescriptorS.Suppress().
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // BaseDebugMonitorId, EngineId, ExceptionCategory, RuntimeId.
    #define IID_IDkmDebugMonitorExceptionNotification __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmDebugMonitorExceptionNotification)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("c919aea0-537d-2b9d-9369-e607b9632523") IDkmDebugMonitorExceptionNotification : public IUnknown
    {
        /// <summary>
        /// OnDebugMonitorException is invoked as part of event processing. See interface
        /// definition for more information.
        /// </summary>
        /// <param name="pException">
        /// [In] Provides information about an exception which was raised in the target
        /// process. This information includes details of what exception was raised and the
        /// current stage of exception processing.
        /// </param>
        /// <param name="pWorkList">
        /// WorkList to append additional event processing work to. This work list will begin
        /// execution after all listeners have been notifiied. The event will not finish
        /// until after the work list fully executes.
        /// </param>
        /// <param name="pEventDescriptor">
        /// [In] Describes the event being processed and provides the ability for a component
        /// to suppress this event.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE OnDebugMonitorException(
            _In_ Exceptions::DkmExceptionInformation* pException,
            _In_ DkmWorkList* pWorkList,
            _In_ DkmEventDescriptorS* pEventDescriptor
            ) = 0;
    };

    // IDkmExceptionContinuedNotification is implemented by components that want to listen
    // for the ExceptionContinued event. When this notification fires, the target process
    // will be suspended and can be examined. ExceptionContinued is sent by a debug monitor
    // when execution is resumed in the target process and the given exception has not been
    // squashed. In other words, the target process will continue with its standard exception
    // processing.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // BaseDebugMonitorId, EngineId, ExceptionCategory, RuntimeId.
    #define IID_IDkmExceptionContinuedNotification __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmExceptionContinuedNotification)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("0bd32e9f-3116-f724-fd7d-e197ffceac9d") IDkmExceptionContinuedNotification : public IUnknown
    {
        /// <summary>
        /// OnExceptionContinued is invoked as part of event processing. See interface
        /// definition for more information.
        /// </summary>
        /// <param name="pException">
        /// [In] Provides information about an exception which was raised in the target
        /// process. This information includes details of what exception was raised and the
        /// current stage of exception processing.
        /// </param>
        /// <param name="pWorkList">
        /// WorkList to append additional event processing work to. This work list will begin
        /// execution after all listeners have been notifiied. The event will not finish
        /// until after the work list fully executes.
        /// </param>
        /// <param name="pEventDescriptor">
        /// [In] Describes the event being processed.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE OnExceptionContinued(
            _In_ Exceptions::DkmExceptionInformation* pException,
            _In_ DkmWorkList* pWorkList,
            _In_ DkmEventDescriptor* pEventDescriptor
            ) = 0;
    };

    // This interface is implemented by debug monitors that provide support for unwinding
    // exceptions to a specific frame.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // BaseDebugMonitorId, EngineId, RuntimeId, SymbolProviderId, TransportKind.
    #define IID_IDkmFrameExceptionInterceptProvider __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmFrameExceptionInterceptProvider)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("1e02530a-7d51-4f8f-601a-63cc4d34748c") IDkmFrameExceptionInterceptProvider : public IUnknown
    {
        /// <summary>
        /// InterceptCurrentException is used to unwind to this frame as if there was an
        /// exception handler at that frame.
        /// </summary>
        /// <param name="pFrame">
        /// [In] DkmStackWalkFrame represents a frame on a call stack which has been walked,
        /// but may not have been formatted or filtered. Formatted frames are represented by
        /// DkmStackFrame instead.
        /// </param>
        /// <param name="InterceptAction">
        /// [In] Specifies exception interception actions.
        /// </param>
        /// <param name="pCookie">
        /// [Out] Cookie that represents this intercept request. The value is returned when
        /// an exception interception completed event is sent.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE InterceptCurrentException(
            _In_ CallStack::DkmStackWalkFrame* pFrame,
            _In_ Exceptions::DkmExceptionInterceptActionFlags_t InterceptAction,
            _Out_ UINT64* pCookie
            ) = 0;

        /// <summary>
        /// Returns the address that represents the location if an exception were to be
        /// intercepted to this frame.
        /// </summary>
        /// <param name="pFrame">
        /// [In] DkmStackWalkFrame represents a frame on a call stack which has been walked,
        /// but may not have been formatted or filtered. Formatted frames are represented by
        /// DkmStackFrame instead.
        /// </param>
        /// <param name="ppNewAddress">
        /// [Out] Possible new address if an exception was unwound to this frame.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE GetUnwindAddress(
            _In_ CallStack::DkmStackWalkFrame* pFrame,
            _Deref_out_ DkmInstructionAddress** ppNewAddress
            ) = 0;
    };

    // IDkmGPUSingleStepCompleteNotification is implemented by components that want to listen
    // for the GPUSingleStepComplete event. IDkmGPUSingleStepCompleteNotification is invoked
    // after all implementations of IDkmGPUSingleStepCompleteReceived. When this notification
    // is called, the target process is stopped and implementers are able to either inspect
    // the process or cause it to execute in a controlled manner (slip, func-eval).
    //
    // Sent when single stepping a GPU thread is complete. The event can be fired by a
    // different thread from the request thread in the same warp.
    //
    // GPUSingleStepComplete events can be suppressed by calling
    // DkmEventDescriptorS.Suppress().
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // BaseDebugMonitorId, EngineId, SourceId.
    #define IID_IDkmGPUSingleStepCompleteNotification __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmGPUSingleStepCompleteNotification)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("95954fd6-9dd4-f461-8907-6e34a1085cf4") IDkmGPUSingleStepCompleteNotification : public IUnknown
    {
        /// <summary>
        /// OnGPUSingleStepComplete is invoked as part of event processing. See interface
        /// definition for more information.
        /// </summary>
        /// <param name="pSingleStepRequest">
        /// [In] DkmSingleStepRequest represents a request to single step a thread.
        /// </param>
        /// <param name="pThread">
        /// [In] DkmThread represents a thread running in the target process.
        /// </param>
        /// <param name="pEventDescriptor">
        /// [In] Describes the event being processed and provides the ability for a component
        /// to suppress this event.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE OnGPUSingleStepComplete(
            _In_ Stepping::DkmSingleStepRequest* pSingleStepRequest,
            _In_ DkmThread* pThread,
            _In_ DkmEventDescriptorS* pEventDescriptor
            ) = 0;
    };

    // IDkmGPUSingleStepCompleteReceived is implemented by components that want to listen for
    // the GPUSingleStepComplete event. IDkmGPUSingleStepCompleteReceived is invoked before
    // IDkmGPUSingleStepCompleteNotification. From within this notification, it is not
    // possible to cause the target process to execute (no func-eval, no slipping).
    //
    // Sent when single stepping a GPU thread is complete. The event can be fired by a
    // different thread from the request thread in the same warp.
    //
    // GPUSingleStepComplete events can be suppressed by calling
    // DkmEventDescriptorS.Suppress().
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // BaseDebugMonitorId, EngineId, SourceId.
    #define IID_IDkmGPUSingleStepCompleteReceived __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmGPUSingleStepCompleteReceived)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("1b7fa450-5329-7b50-c04b-775791576b79") IDkmGPUSingleStepCompleteReceived : public IUnknown
    {
        /// <summary>
        /// OnGPUSingleStepCompleteReceived is invoked as part of event processing. See
        /// interface definition for more information.
        /// </summary>
        /// <param name="pSingleStepRequest">
        /// [In] DkmSingleStepRequest represents a request to single step a thread.
        /// </param>
        /// <param name="pThread">
        /// [In] DkmThread represents a thread running in the target process.
        /// </param>
        /// <param name="pEventDescriptor">
        /// [In] Describes the event being processed and provides the ability for a component
        /// to suppress this event.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE OnGPUSingleStepCompleteReceived(
            _In_ Stepping::DkmSingleStepRequest* pSingleStepRequest,
            _In_ DkmThread* pThread,
            _In_ DkmEventDescriptorS* pEventDescriptor
            ) = 0;
    };

    // Used to execute compiled group expression processing.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // CompiledInspectionQueryKind, CompilerVendorId, EngineId, LanguageId, RuntimeId.
    #define IID_IDkmGroupCompiledInspectionQueryProcessor __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmGroupCompiledInspectionQueryProcessor)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("946b64d3-390e-ce97-026e-1b6d86075bc9") IDkmGroupCompiledInspectionQueryProcessor : public IUnknown
    {
        /// <summary>
        /// Executes a compiled inspection query and returns any results.
        /// </summary>
        /// <param name="pDkmILQuery">
        /// [In] An inspection query compiled to one or more DkmIL instructions.
        /// </param>
        /// <param name="pILContext">
        /// [In] The stack frame context we are evaluating on.
        /// </param>
        /// <param name="pThreads">
        /// [In] The compute threads to use when executing the query.
        /// </param>
        /// <param name="pParameters">
        /// [In,Optional] Parameters to pass to each thread.  The collection should be empty
        /// if unused, or have exactly as many members as the Threads parameter.
        /// </param>
        /// <param name="ppResult">
        /// [Out] Results of the evaluations.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE ExecuteQueryOnThreads(
            _In_ Evaluation::IL::DkmCompiledILInspectionQuery* pDkmILQuery,
            _In_ Evaluation::DkmILContext* pILContext,
            _In_ DkmReadOnlyCollection<UINT64>* pThreads,
            _In_opt_ DkmReadOnlyCollection<Evaluation::Group::DkmILParameterValueCollection*>* pParameters,
            _Deref_out_ Evaluation::Group::DkmContextGroupEvaluationILResult** ppResult
            ) = 0;
    };

    // Interface to provide runtime-specific CPU address resolution. This could be
    // implemented either on server or client side (e.g. CLR native compilation).
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // BaseDebugMonitorId, EngineId, RuntimeId.
    #define IID_IDkmInstructionAddressResolver __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmInstructionAddressResolver)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("b071902e-dc75-5b4c-4db1-f0d4a7c5ac61") IDkmInstructionAddressResolver : public IUnknown
    {
        /// <summary>
        /// Resolves a CPU InstructionAddress to a runtime-specific DkmInstructionAddress
        /// object.
        ///
        /// This API is currently only supported by CLR DkmRuntimeInstance objects, and the
        /// CLR runtime instance can currently only find instruction addresses which are in a
        /// method that is currently on the call stack of one of the threads in the target
        /// process.
        /// </summary>
        /// <param name="pRuntimeInstance">
        /// [In] The DkmRuntimeInstance class represents an execution environment which is
        /// loaded into a DkmProcess and which contains code to be debugged.
        /// </param>
        /// <param name="InstructionPointer">
        /// [In] Memory address where the native instruction is located.
        /// </param>
        /// <param name="ppAddressObject">
        /// [Out] Abstract representation of an executable code location (ex: EIP value). If
        /// resolved, an Instruction Address will be within a particular module instance. An
        /// Instruction Address is always within a particular Runtime Instance.
        /// </param>
        /// <param name="pFirstAddress">
        /// [Out] True if this address is the first address in the line's range. False
        /// otherwise.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE ResolveCPUInstructionAddress(
            _In_ DkmRuntimeInstance* pRuntimeInstance,
            _In_ UINT64 InstructionPointer,
            _Deref_out_ DkmInstructionAddress** ppAddressObject,
            _Out_ bool* pFirstAddress
            ) = 0;

        /// <summary>
        /// Resolves a DkmInstructionAddress to a CPU InstructionAddress. This is the reverse
        /// mapping of ResolveCPUInstructionAddress. This API is currently only supported by
        /// CLR DkmRuntimeInstance objects.
        /// </summary>
        /// <param name="pInstructionAddress">
        /// [In] Abstract representation of an executable code location (ex: EIP value). If
        /// resolved, an Instruction Address will be within a particular module instance. An
        /// Instruction Address is always within a particular Runtime Instance.
        /// </param>
        /// <param name="pInstructionPointers">
        /// [Out] An array of the current CPU Instruction Addresses that map to this
        /// DkmInstructionAddress.
        ///
        /// The memory for the DkmArray members is allocated by the method implementation
        /// using DkmAllocBytes/DkmAllocArray. It is freed by the caller using the
        /// CAutoDkmArray template or with DkmFreeMemory and manual element release.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE GetCurrentCPUAddress(
            _In_ DkmInstructionAddress* pInstructionAddress,
            _Out_ DkmArray<UINT64>* pInstructionPointers
            ) = 0;
    };

    // Interface to determine if a particular location is user code.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // BaseDebugMonitorId, EngineId, RuntimeId, SymbolProviderId.
    //
    // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
    #define IID_IDkmJustMyCodeProvider __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmJustMyCodeProvider)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("f24e7455-e56c-dc04-c886-7bb8c741d16a") IDkmJustMyCodeProvider : public IUnknown
    {
        /// <summary>
        /// Determines if a given instruction address is user code or not.
        /// </summary>
        /// <param name="pInstructionAddress">
        /// [In] Abstract representation of an executable code location (ex: EIP value). If
        /// resolved, an Instruction Address will be within a particular module instance. An
        /// Instruction Address is always within a particular Runtime Instance.
        /// </param>
        /// <param name="pWorkList">
        /// WorkList which is currently being processed. This value can be used to check for
        /// cancelation or to append additional work. New work items will not begin executing
        /// until after this function returns.
        /// </param>
        /// <param name="pCompletionRoutine">
        /// Routine to fire when the request is complete. This will be implicitly fired if
        /// the implementation returns failure from this interface method. The implementation
        /// must fire this method in all other scenarios.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE IsUserCode(
            _In_ DkmInstructionAddress* pInstructionAddress,
            _In_ DkmWorkList* pWorkList,
            _In_ IDkmCompletionRoutine<Symbols::DkmIsUserCodeAsyncResult>* pCompletionRoutine
            ) = 0;
    };

    // Examines the portion of the stack which is from a particular DkmRuntimeInstance and
    // returns frames from this runtime. IDkmMonitorStackWalk is used to do this walking on
    // the target computer, and generally does this walk without symbols. It should be noted
    // that accurate monitor stack walk generally requires either: 1. The runtime monitor to
    // fully understand the calling convention of its underlying runtime AND the runtime
    // employs some mechanism so that it doesn't need code from other runtimes which are on
    // the stack to be walked. For example, the CLR maintains stack ranges so when managed
    // code calls off into native, the CLR can still find the managed code without needing to
    // walk through native. -or- 2. A uniform calling convention that all code needs to
    // follow. For example, all code must follow a uniform calling convention on x64 and
    // IA-64 versions of Windows. Microsoft will provide five implementations of
    // IDkmMonitorStackWalk: 1. An implementation for ICorDebug v2 2. An implementation for
    // ICorDebug v4 3. An implementation for x64/ia64 PDATA walking. 4. An implementation for
    // ActiveScript. 5. A default implementation that bundles together unknown regions to be
    // walked in the engine process.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // BaseDebugMonitorId, EngineId, RuntimeId.
    #define IID_IDkmMonitorStackWalk __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmMonitorStackWalk)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("3229efcc-f591-3f24-3639-70f0a90c9b00") IDkmMonitorStackWalk : public IUnknown
    {
        /// <summary>
        /// Initialize is invoked on each walker exactly once at the beginning of the walk
        /// process. This gives each walker a chance to initialize any state.
        /// </summary>
        /// <param name="pMonitorStackWalkContext">
        /// [In] DkmMonitorStackWalkContext allows the various components
        /// DkmSymbolStackWalkContext with this call stack.
        /// </param>
        /// <param name="pRegisters">
        /// [In] Registers to attempt to walk from.
        /// </param>
        /// <param name="StackRangeSize">
        /// [In] Size of the stack range that the debugger will attempt to walk through.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE Initialize(
            _In_ CallStack::DkmMonitorStackWalkContext* pMonitorStackWalkContext,
            _In_ CallStack::DkmFrameRegisters* pRegisters,
            _In_ UINT32 StackRangeSize
            ) = 0;

        /// <summary>
        /// UpdatePosition is invoked by the stack merger after another walker has walked one
        /// or more frames, and so this walker must be updated before invoking WalkNextFrame.
        /// Runtimes that maintain their own internal stack range state within in the target
        /// process will likely have nothing to do within this method.
        /// </summary>
        /// <param name="pMonitorStackWalkContext">
        /// [In] DkmMonitorStackWalkContext allows the various components
        /// DkmSymbolStackWalkContext with this call stack.
        /// </param>
        /// <param name="pRegisters">
        /// [In] Registers to attempt to walk from.
        /// </param>
        /// <param name="StackRangeSize">
        /// [In] Size of the stack range that the debugger will attempt to walk through.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE UpdatePosition(
            _In_ CallStack::DkmMonitorStackWalkContext* pMonitorStackWalkContext,
            _In_ CallStack::DkmFrameRegisters* pRegisters,
            _In_ UINT32 StackRangeSize
            ) = 0;

        /// <summary>
        /// Attempt to walk the next stack frame. The DkmMonitorStackWalkResult structure
        /// indicates if this monitor was able to walk the frame.
        /// </summary>
        /// <param name="pMonitorStackWalkContext">
        /// [In] DkmMonitorStackWalkContext allows the various components
        /// DkmSymbolStackWalkContext with this call stack.
        /// </param>
        /// <param name="pResult">
        /// [Out] Return result from IDkmMonitorStackWalk.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE WalkNextFrame(
            _In_ CallStack::DkmMonitorStackWalkContext* pMonitorStackWalkContext,
            _Out_ CallStack::DkmMonitorStackWalkResult* pResult
            ) = 0;
    };

    // Called by Native IDkmSteppingCodePathDecoder implementer to enumerate Native
    // CodePaths.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // BaseDebugMonitorId, EngineId, RuntimeId, SymbolProviderId.
    #define IID_IDkmNativeSteppingCallSiteProvider __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmNativeSteppingCallSiteProvider)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("42c82633-168e-4fa4-cb32-d81e42526c44") IDkmNativeSteppingCallSiteProvider : public IUnknown
    {
        /// <summary>
        /// GetSteppingCallSites is called to get call sites reachable from an instruction.
        /// </summary>
        /// <param name="pNativeAddress">
        /// [In] DkmNativeInstructionAddress is used for addresses that resolve to within a
        /// native module. This is used regardless as to if there are symbols for the module.
        /// </param>
        /// <param name="SteppingRanges">
        /// [In] The stepping ranges to evaluate for call sites.
        ///
        /// The memory for the DkmArray members is allocated by the caller, and can be from
        /// any source (stack memory, static buffer, heap, etc). The implementation should
        /// not modify the members.
        /// </param>
        /// <param name="pCallSites">
        /// [Out] DkmNativeSteppingCallSite[] specifies a call instruction and it's target..
        ///
        /// The memory for the DkmArray members is allocated by the method implementation
        /// using DkmAllocBytes/DkmAllocArray. It is freed by the caller using the
        /// CAutoDkmArray template or with DkmFreeMemory and manual element release.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE GetSteppingCallSites(
            _In_ Native::DkmNativeInstructionAddress* pNativeAddress,
            _In_ const DkmArray<Symbols::DkmSteppingRange>& SteppingRanges,
            _Out_ DkmArray<Stepping::DkmNativeSteppingCallSite*>* pCallSites
            ) = 0;
    };

    // IDkmOutOfBandExceptionNotification is implemented by components that want to listen
    // for the OutOfBandException event. When this notification fires, the target process
    // will be suspended and can be examined. The 'OutOfBandException' event provides
    // notification from debug monitors about out-of-band exceptions which occur within the
    // target process while managed/native interop debugging.  This event notification is
    // consumed by the exception manager. Out-of-band events can occur at any time (including
    // when stopped) and must be continued immediately.
    //
    // OutOfBandException events can be suppressed by calling DkmEventDescriptorS.Suppress().
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // BaseDebugMonitorId, EngineId, ExceptionCategory, RuntimeId.
    //
    // This API was introduced in Visual Studio 11 Update 1 (DkmApiVersion.VS11FeaturePack1).
    #define IID_IDkmOutOfBandExceptionNotification __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmOutOfBandExceptionNotification)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("90e4575e-1442-b444-115c-ba831c02395e") IDkmOutOfBandExceptionNotification : public IUnknown
    {
        /// <summary>
        /// OnOutOfBandException is invoked as part of event processing. See interface
        /// definition for more information.
        /// </summary>
        /// <param name="pException">
        /// [In] Provides information about an exception which was raised in the target
        /// process. This information includes details of what exception was raised and the
        /// current stage of exception processing.
        /// </param>
        /// <param name="pWorkList">
        /// WorkList to append additional event processing work to. This work list will begin
        /// execution after all listeners have been notifiied. The event will not finish
        /// until after the work list fully executes.
        /// </param>
        /// <param name="pEventDescriptor">
        /// [In] Describes the event being processed and provides the ability for a component
        /// to suppress this event.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE OnOutOfBandException(
            _In_ Exceptions::DkmExceptionInformation* pException,
            _In_ DkmWorkList* pWorkList,
            _In_ DkmEventDescriptorS* pEventDescriptor
            ) = 0;
    };

    // Optional interface which can be implemented to customize the environment of the target
    // process before it is started. It is possible to customize the environment from two
    // points. From the IDE side, the caller of LaunchDebugTargets may specify an environment
    // block. From the debug monitor side, this API can be implemented. This API is suggested
    // if either the IDE side doesn't have enough information to correctly specify the
    // environment, or if the extension doesn't control the call to LaunchDebugTargets.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // EngineId.
    #define IID_IDkmProcessLaunchEnvironmentFilter __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmProcessLaunchEnvironmentFilter)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("bdfa8fd2-093d-3d18-14a6-1fe13b432740") IDkmProcessLaunchEnvironmentFilter : public IUnknown
    {
        /// <summary>
        /// Obtains any environment variables which the extension would like to add.
        /// </summary>
        /// <param name="pDebugLaunchSettings">
        /// [In] Settings supplied during a start debugging operation from a project system
        /// or other caller of LaunchDebugTargets (or various other start debugging APIs).
        /// </param>
        /// <param name="Scenario">
        /// [In] Enumeration of the scenarios where IDkmProcessLaunchEnvironmentFilter
        /// implementations are invoked.
        /// </param>
        /// <param name="ppAdditionalEnvironmentBlock">
        /// [Out,Optional] One or more environment variables which should be passed to the
        /// target process. Multiple variables are separated with an embedded null ('\0').
        /// For example: "MyVariable1=1\0MyVariable2=12".
        ///
        /// Null or empty string are returned if the caller doesn't want to customize the
        /// environment block for this launch.
        /// </param>
        /// <returns>
        /// S_OK is returned if *ppAdditionalEnvironmentBlock is non-NULL, S_FALSE is
        /// returned when *ppAdditionalEnvironmentBlock is NULL, and failure codes are used
        /// for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE GetAdditionalEnvironmentVariables(
            _In_ Start::DkmDebugLaunchSettings* pDebugLaunchSettings,
            _In_ Start::DkmProcessLaunchEnvironmentFilterScenario_t Scenario,
            _Deref_out_opt_ DkmString** ppAdditionalEnvironmentBlock
            ) = 0;
    };

    // Optional interface which can be implemented to customize the environment of the target
    // process before it is started. This is an updated version of
    // IDkmProcessLaunchEnvironmentFilter which was added for Visual Studio 14.0 to provide
    // additional information to environment filters. Visual Studio 14+ will call both the
    // old and new API, so a component should generally not implement both interfaces.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // EngineId, TransportKind.
    //
    // This API was introduced in Visual Studio 14 RTM (DkmApiVersion.VS14RTM).
    #define IID_IDkmProcessLaunchEnvironmentFilter140 __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmProcessLaunchEnvironmentFilter140)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("0268241b-093a-08ee-9b10-4461d77adae0") IDkmProcessLaunchEnvironmentFilter140 : public IUnknown
    {
        /// <summary>
        /// Obtains any environment variables which the extension would like to add.
        /// </summary>
        /// <param name="pInputData">
        /// [In] DkmProcessLaunchEnvironmentFilterInputData is used to provide input to a
        /// IDkmProcessLaunchEnvironmentFilter140 implementation. It describes the process
        /// which is about to be started.
        /// </param>
        /// <param name="ppAdditionalEnvironmentBlock">
        /// [Out,Optional] One or more environment variables which should be passed to the
        /// target process. Multiple variables are separated with an embedded null ('\0').
        /// For example: "MyVariable1=1\0MyVariable2=12".
        ///
        /// Null or empty string are returned if the caller doesn't want to customize the
        /// environment block for this launch.
        /// </param>
        /// <returns>
        /// S_OK is returned if *ppAdditionalEnvironmentBlock is non-NULL, S_FALSE is
        /// returned when *ppAdditionalEnvironmentBlock is NULL, and failure codes are used
        /// for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE GetAdditionalEnvironmentVariables(
            _In_ Start::DkmProcessLaunchEnvironmentFilterInputData* pInputData,
            _Deref_out_opt_ DkmString** ppAdditionalEnvironmentBlock
            ) = 0;
    };

    // Provides the ability to read or write a register value by CV constant.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // BaseDebugMonitorId, EngineId, RuntimeId, TransportKind.
    #define IID_IDkmRegisterWrite __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmRegisterWrite)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("6c77ba81-0bd4-b09b-375d-ceffe69b48c0") IDkmRegisterWrite : public IUnknown
    {
        /// <summary>
        /// Sets the value of the register in the thread's context. Sub registers that are
        /// made up of larger registers are supported.
        /// </summary>
        /// <param name="pRuntimeInstance">
        /// [In] The DkmRuntimeInstance class represents an execution environment which is
        /// loaded into a DkmProcess and which contains code to be debugged.
        /// </param>
        /// <param name="pStackWalkFrame">
        /// [In] The stack frame the register is being set in. For most runtime instances,
        /// this is used to verify the stack frame is the top of the stack and stop the write
        /// if it isn't.
        /// </param>
        /// <param name="RegisterIndex">
        /// [In] The CV constant of the register to set.
        /// </param>
        /// <param name="pValue">
        /// [In] The value to set the register to. The size of the byte array must match the
        /// width of the register being set.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE SetRegisterValue(
            _In_ DkmRuntimeInstance* pRuntimeInstance,
            _In_ CallStack::DkmStackWalkFrame* pStackWalkFrame,
            _In_ CV_HREG_e RegisterIndex,
            _In_ DkmReadOnlyCollection<BYTE>* pValue
            ) = 0;
    };

    // IDkmRuntimeSetNextStatement is the interface runtime monitors implement to support set
    // next statement.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // BaseDebugMonitorId, EngineId, RuntimeId, SymbolProviderId, TransportKind.
    #define IID_IDkmRuntimeSetNextStatement __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmRuntimeSetNextStatement)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("19f373d3-f684-891d-0239-1ae39bca8bac") IDkmRuntimeSetNextStatement : public IUnknown
    {
        /// <summary>
        /// SetNextStatement moves the IP of a stack frame. The stack frame is always the
        /// leaf stack frame on a particular thread.
        /// </summary>
        /// <param name="pFrame">
        /// [In] DkmStackWalkFrame represents a frame on a call stack which has been walked,
        /// but may not have been formatted or filtered. Formatted frames are represented by
        /// DkmStackFrame instead.
        /// </param>
        /// <param name="pNewStatement">
        /// [In] Abstract representation of an executable code location (ex: EIP value). If
        /// resolved, an Instruction Address will be within a particular module instance. An
        /// Instruction Address is always within a particular Runtime Instance.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE SetNextStatement(
            _In_ CallStack::DkmStackWalkFrame* pFrame,
            _In_ DkmInstructionAddress* pNewStatement
            ) = 0;
    };

    // IDkmRuntimeStepper is the interface runtime monitors implement to support stepping.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // BaseDebugMonitorId, EngineId, RuntimeId, TransportKind.
    #define IID_IDkmRuntimeStepper __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmRuntimeStepper)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("9f1c95a5-868c-edaf-c078-17105c5a232a") IDkmRuntimeStepper : public IUnknown
    {
        /// <summary>
        /// BeforeEnableNewStepper is called by the stepping manager before a new stepper is
        /// enabled. This gives runtimes the ability to do any initialization that might be
        /// required such as performing pre-step function evaluations.
        /// </summary>
        /// <param name="pRuntimeInstance">
        /// [In] The DkmRuntimeInstance class represents an execution environment which is
        /// loaded into a DkmProcess and which contains code to be debugged.
        /// </param>
        /// <param name="pStepper">
        /// [In] DkmStepper represents a request to step a thread. It facilitates shared
        /// object lifetime between the various runtime debug monitors that participate in
        /// stepping.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE BeforeEnableNewStepper(
            _In_ DkmRuntimeInstance* pRuntimeInstance,
            _In_ Stepping::DkmStepper* pStepper
            ) = 0;

        /// <summary>
        /// OwnsCurrentExecutionLocation is called by the stepping manager while it is
        /// searching for monitors to perform a step. If the current location in the debuggee
        /// is understood by this monitor it can return true here to take control of the
        /// step.
        /// </summary>
        /// <param name="pRuntimeInstance">
        /// [In] The DkmRuntimeInstance class represents an execution environment which is
        /// loaded into a DkmProcess and which contains code to be debugged.
        /// </param>
        /// <param name="pStepper">
        /// [In] DkmStepper represents a request to step a thread. It facilitates shared
        /// object lifetime between the various runtime debug monitors that participate in
        /// stepping.
        /// </param>
        /// <param name="Reason">
        /// [In] DkmStepArbitrationReason the reason step arbitration is occurring.
        /// </param>
        /// <param name="pOwnsFrame">
        /// [Out] If the runtime instance wants control of the step, it should set this to
        /// true. It should be set to false to not take control.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE OwnsCurrentExecutionLocation(
            _In_ DkmRuntimeInstance* pRuntimeInstance,
            _In_ Stepping::DkmStepper* pStepper,
            _In_ Stepping::DkmStepArbitrationReason_t Reason,
            _Out_ bool* pOwnsFrame
            ) = 0;

        /// <summary>
        /// Step is called by the stepping manager after it determines this monitor is the
        /// correct monitor to perform the step.
        /// </summary>
        /// <param name="pRuntimeInstance">
        /// [In] The DkmRuntimeInstance class represents an execution environment which is
        /// loaded into a DkmProcess and which contains code to be debugged.
        /// </param>
        /// <param name="pStepper">
        /// [In] DkmStepper represents a request to step a thread. It facilitates shared
        /// object lifetime between the various runtime debug monitors that participate in
        /// stepping.
        /// </param>
        /// <param name="Reason">
        /// [In] DkmStepArbitrationReason the reason step arbitration is occurring.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE Step(
            _In_ DkmRuntimeInstance* pRuntimeInstance,
            _In_ Stepping::DkmStepper* pStepper,
            _In_ Stepping::DkmStepArbitrationReason_t Reason
            ) = 0;

        /// <summary>
        /// StopStep is called by the stepping manager when the process is being continued to
        /// clear out any remaining stepping state for a stepper.
        /// </summary>
        /// <param name="pRuntimeInstance">
        /// [In] The DkmRuntimeInstance class represents an execution environment which is
        /// loaded into a DkmProcess and which contains code to be debugged.
        /// </param>
        /// <param name="pStepper">
        /// [In] DkmStepper represents a request to step a thread. It facilitates shared
        /// object lifetime between the various runtime debug monitors that participate in
        /// stepping.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE StopStep(
            _In_ DkmRuntimeInstance* pRuntimeInstance,
            _In_ Stepping::DkmStepper* pStepper
            ) = 0;

        /// <summary>
        /// AfterSteppingArbitration is called by the stepping manager on the old controlling
        /// runtime instance after stepping arbitration is complete but before the next
        /// runtime instance starts stepping. This allows runtimes to clear any stepping
        /// state if another runtime took control. If no other runtime monitor claimed the
        /// current location, the original monitor should finish the step. This is indicated
        /// by NewControllingRuntimeInstance being null. For instance, a runtime instance may
        /// choose to step back out if a step-in landed in a location without symbols and no
        /// other runtime took control.
        /// </summary>
        /// <param name="pRuntimeInstance">
        /// [In] The DkmRuntimeInstance class represents an execution environment which is
        /// loaded into a DkmProcess and which contains code to be debugged.
        /// </param>
        /// <param name="pStepper">
        /// [In] DkmStepper represents a request to step a thread. It facilitates shared
        /// object lifetime between the various runtime debug monitors that participate in
        /// stepping.
        /// </param>
        /// <param name="Reason">
        /// [In] DkmStepArbitrationReason the reason step arbitration is occurring.
        /// </param>
        /// <param name="pNewControllingRuntimeInstance">
        /// [In,Optional] The DkmRuntimeInstance class represents an execution environment
        /// which is loaded into a DkmProcess and which contains code to be debugged.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE AfterSteppingArbitration(
            _In_ DkmRuntimeInstance* pRuntimeInstance,
            _In_ Stepping::DkmStepper* pStepper,
            _In_ Stepping::DkmStepArbitrationReason_t Reason,
            _In_opt_ DkmRuntimeInstance* pNewControllingRuntimeInstance
            ) = 0;

        /// <summary>
        /// OnNewControllingRuntimeInstance is called by the stepping manager on all
        /// non-controlling runtime instances after step arbitration has selected a new
        /// controlling runtime instance.
        /// </summary>
        /// <param name="pRuntimeInstance">
        /// [In] The DkmRuntimeInstance class represents an execution environment which is
        /// loaded into a DkmProcess and which contains code to be debugged.
        /// </param>
        /// <param name="pStepper">
        /// [In] DkmStepper represents a request to step a thread. It facilitates shared
        /// object lifetime between the various runtime debug monitors that participate in
        /// stepping.
        /// </param>
        /// <param name="Reason">
        /// [In] DkmStepArbitrationReason the reason step arbitration is occurring.
        /// </param>
        /// <param name="pControllingRuntimeInstance">
        /// [In] The DkmRuntimeInstance class represents an execution environment which is
        /// loaded into a DkmProcess and which contains code to be debugged.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE OnNewControllingRuntimeInstance(
            _In_ DkmRuntimeInstance* pRuntimeInstance,
            _In_ Stepping::DkmStepper* pStepper,
            _In_ Stepping::DkmStepArbitrationReason_t Reason,
            _In_ DkmRuntimeInstance* pControllingRuntimeInstance
            ) = 0;

        /// <summary>
        /// StepControlRequested is called by the stepping manager when a non-controlling
        /// runtime instance detects that the thread has hit a transition into its runtime.
        /// If the current controlling runtime instance can stop stepping, it should set
        /// Granted to true. Actual control is not given until the requesting runtime calls
        /// DkmStepper.TakeStepControl. This two part process allows callers to request
        /// control of multiple steppers at the same time.
        /// </summary>
        /// <param name="pRuntimeInstance">
        /// [In] The DkmRuntimeInstance class represents an execution environment which is
        /// loaded into a DkmProcess and which contains code to be debugged.
        /// </param>
        /// <param name="pStepper">
        /// [In] DkmStepper represents a request to step a thread. It facilitates shared
        /// object lifetime between the various runtime debug monitors that participate in
        /// stepping.
        /// </param>
        /// <param name="Reason">
        /// [In] DkmStepArbitrationReason the reason step arbitration is occurring.
        /// </param>
        /// <param name="pCallingRuntimeInstance">
        /// [In] The calling runtime instance that wishes to take control of the step.
        /// </param>
        /// <param name="pGranted">
        /// [Out] The controlling runtime can stop the step and give control to the caller,
        /// then it should set this to true.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE StepControlRequested(
            _In_ DkmRuntimeInstance* pRuntimeInstance,
            _In_ Stepping::DkmStepper* pStepper,
            _In_ Stepping::DkmStepArbitrationReason_t Reason,
            _In_ DkmRuntimeInstance* pCallingRuntimeInstance,
            _Out_ bool* pGranted
            ) = 0;

        /// <summary>
        /// TakeStepControl is called by the stepping manager when a non-controlling runtime
        /// instance detects that the thread has hit a transition into its runtime. The
        /// stepping manager will forward the call to the current controlling runtime
        /// instance. The runtime instance requesting control should first call
        /// StepControlRequested on all steppers it wants control of. If they all set Granted
        /// to true, the runtime instance should then call this method on each stepper it is
        /// taking control of.
        /// </summary>
        /// <param name="pRuntimeInstance">
        /// [In] The DkmRuntimeInstance class represents an execution environment which is
        /// loaded into a DkmProcess and which contains code to be debugged.
        /// </param>
        /// <param name="pStepper">
        /// [In] DkmStepper represents a request to step a thread. It facilitates shared
        /// object lifetime between the various runtime debug monitors that participate in
        /// stepping.
        /// </param>
        /// <param name="LeaveGuardsInPlace">
        /// [In] Set to true by the caller if it would like the current controlling runtime
        /// instance to leave guards in place to stop the step if necessary. For instance,
        /// this can be used to leave guard breakpoints after a call instruction so another
        /// runtime can step back out if the target of the call doesn't have source. However,
        /// any stepping state that affects the immediate step, such as trap flags, should be
        /// removed by the controlling runtime instance.
        /// </param>
        /// <param name="Reason">
        /// [In] DkmStepArbitrationReason the reason step arbitration is occurring.
        /// </param>
        /// <param name="pCallingRuntimeInstance">
        /// [In] The calling runtime instance that wishes to take control of the step.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE TakeStepControl(
            _In_ DkmRuntimeInstance* pRuntimeInstance,
            _In_ Stepping::DkmStepper* pStepper,
            _In_ bool LeaveGuardsInPlace,
            _In_ Stepping::DkmStepArbitrationReason_t Reason,
            _In_ DkmRuntimeInstance* pCallingRuntimeInstance
            ) = 0;

        /// <summary>
        /// NotifyStepComplete is called by the stepping manager on all non-controlling
        /// runtime instances when a step is complete.
        /// </summary>
        /// <param name="pRuntimeInstance">
        /// [In] The DkmRuntimeInstance class represents an execution environment which is
        /// loaded into a DkmProcess and which contains code to be debugged.
        /// </param>
        /// <param name="pStepper">
        /// [In] DkmStepper represents a request to step a thread. It facilitates shared
        /// object lifetime between the various runtime debug monitors that participate in
        /// stepping.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE NotifyStepComplete(
            _In_ DkmRuntimeInstance* pRuntimeInstance,
            _In_ Stepping::DkmStepper* pStepper
            ) = 0;
    };

    // IDkmSingleStepCompleteNotification is implemented by components that want to listen
    // for the SingleStepComplete event. IDkmSingleStepCompleteNotification is invoked after
    // all implementations of IDkmSingleStepCompleteReceived. When this notification is
    // called, the target process is stopped and implementers are able to either inspect the
    // process or cause it to execute in a controlled manner (slip, func-eval).
    //
    // Sent when single stepping a thread is complete.
    //
    // SingleStepComplete events can be suppressed by calling DkmEventDescriptorS.Suppress().
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // BaseDebugMonitorId, EngineId, SourceId.
    #define IID_IDkmSingleStepCompleteNotification __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmSingleStepCompleteNotification)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("a48fdaa3-b501-43cf-a213-81c0ecd593e0") IDkmSingleStepCompleteNotification : public IUnknown
    {
        /// <summary>
        /// OnSingleStepComplete is invoked as part of event processing. See interface
        /// definition for more information.
        /// </summary>
        /// <param name="pSingleStepRequest">
        /// [In] DkmSingleStepRequest represents a request to single step a thread.
        /// </param>
        /// <param name="pEventDescriptor">
        /// [In] Describes the event being processed and provides the ability for a component
        /// to suppress this event.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE OnSingleStepComplete(
            _In_ Stepping::DkmSingleStepRequest* pSingleStepRequest,
            _In_ DkmEventDescriptorS* pEventDescriptor
            ) = 0;
    };

    // IDkmSingleStepCompleteReceived is implemented by components that want to listen for
    // the SingleStepComplete event. IDkmSingleStepCompleteReceived is invoked before
    // IDkmSingleStepCompleteNotification. From within this notification, it is not possible
    // to cause the target process to execute (no func-eval, no slipping).
    //
    // Sent when single stepping a thread is complete.
    //
    // SingleStepComplete events can be suppressed by calling DkmEventDescriptorS.Suppress().
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // BaseDebugMonitorId, EngineId, SourceId.
    #define IID_IDkmSingleStepCompleteReceived __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmSingleStepCompleteReceived)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("a7aa8f4f-e5cb-45bf-2f66-b8384fd2d2f5") IDkmSingleStepCompleteReceived : public IUnknown
    {
        /// <summary>
        /// OnSingleStepCompleteReceived is invoked as part of event processing. See
        /// interface definition for more information.
        /// </summary>
        /// <param name="pSingleStepRequest">
        /// [In] DkmSingleStepRequest represents a request to single step a thread.
        /// </param>
        /// <param name="pEventDescriptor">
        /// [In] Describes the event being processed and provides the ability for a component
        /// to suppress this event.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE OnSingleStepCompleteReceived(
            _In_ Stepping::DkmSingleStepRequest* pSingleStepRequest,
            _In_ DkmEventDescriptorS* pEventDescriptor
            ) = 0;
    };

    // This interface is implemented by components that contribute stack frames, and wish to
    // provide an additional inspection interface for expression evaluators and other
    // components that need to inspect the stack frame.
    //
    // NOTE: The data container API should not be used from the implementation of the
    // returned custom interface.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // BaseDebugMonitorId, EngineId, RuntimeId, SymbolProviderId, TransportKind.
    #define IID_IDkmStackWalkFrameInterfaceProvider __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmStackWalkFrameInterfaceProvider)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("5aef1394-3062-c525-9ae6-f47531631aa3") IDkmStackWalkFrameInterfaceProvider : public IUnknown
    {
        /// <summary>
        /// GetFrameInspectionInterface is used to obtain a ICorDebugFrame or other
        /// implementation-specific interfaces which a component can use to deeply inspect
        /// the stack frame.
        ///
        /// The returned interface may ONLY be used to inspect the target process, and should
        /// NEVER be used to control execution (no stepping, no breakpoints, no continue,
        /// etc). Doing so is unsupported and will result in undefined behavior. NOTE: Using
        /// this method from managed code is not recommended for performance reasons.
        /// Marshalling of DkmStackWalkFrame between native and managed code is expensive.
        /// Use DkmRuntimeInstance.GetFrameInspectionInterface instead.
        /// </summary>
        /// <param name="pFrame">
        /// [In] DkmStackWalkFrame represents a frame on a call stack which has been walked,
        /// but may not have been formatted or filtered. Formatted frames are represented by
        /// DkmStackFrame instead.
        /// </param>
        /// <param name="pSession">
        /// [In] DkmInspectionSession allows the various components which inspect data to
        /// store private data which is associated with a group of evaluations.
        /// </param>
        /// <param name="InterfaceID">
        /// [In] The GUID of the desired interface. IID_ICorDebugFrame can be used to obtain
        /// the CorDebug frame interface for a managed frame. Other debug monitors or stack
        /// walkers may provide their own interface.
        /// </param>
        /// <param name="ppFrameInterface">
        /// [Out] Returned frame interface. This may be cast to the interface pointer
        /// corresponding to 'InterfaceID'.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE GetFrameInspectionInterface(
            _In_ CallStack::DkmStackWalkFrame* pFrame,
            _In_ Evaluation::DkmInspectionSession* pSession,
            _In_ const GUID& InterfaceID,
            _Deref_out_ IUnknown** ppFrameInterface
            ) = 0;
    };

    // This interface is implemented by the managed debug monitor and provides access to the
    // ICorDebugFrame.
    //
    // NOTE: The data container API should not be used from the implementation of the
    // returned custom interface.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // BaseDebugMonitorId, EngineId, RuntimeId, TransportKind.
    //
    // This API was introduced in Visual Studio 14 RTM (DkmApiVersion.VS14RTM).
    #define IID_IDkmStackWalkFrameInterfaceProvider2 __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmStackWalkFrameInterfaceProvider2)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("0426b33d-4f4c-b5cb-debf-409574d5cf39") IDkmStackWalkFrameInterfaceProvider2 : public IUnknown
    {
        /// <summary>
        /// GetCorFrame is used to obtain a ICorDebugFrame which a component can use to
        /// deeply inspect the stack frame.
        ///
        /// The returned interface may ONLY be used to inspect the target process, and should
        /// NEVER be used to control execution (no stepping, no breakpoints, no continue,
        /// etc). Doing so is unsupported and will result in undefined behavior.
        /// </summary>
        /// <param name="pClrRuntimeInstance">
        /// [In] Represents a CLR instance running in a target process.
        /// </param>
        /// <param name="pThread">
        /// [In] The thread the stack frame came from.
        /// </param>
        /// <param name="FrameBase">
        /// [In] The frame base of the stack frame to get the inspection interface for.
        /// </param>
        /// <param name="InterfaceID">
        /// [In] The GUID of the desired interface. IID_ICorDebugFrame can be used to obtain
        /// the CorDebug frame interface for a managed frame.
        /// </param>
        /// <param name="ppFrameInterface">
        /// [Out] Returned frame interface. This may be cast to the interface pointer
        /// corresponding to 'InterfaceID'.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE GetCorFrame(
            _In_ Clr::DkmClrRuntimeInstance* pClrRuntimeInstance,
            _In_ DkmThread* pThread,
            _In_ UINT64 FrameBase,
            _In_ const GUID& InterfaceID,
            _Deref_out_ IUnknown** ppFrameInterface
            ) = 0;
    };

    // This interface is implemented by runtime debug monitors to return the most recent
    // WinRT exception information on the given thread.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // BaseDebugMonitorId, EngineId, TransportKind.
    //
    // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
    #define IID_IDkmThreadCurrentWinRtExceptionQuery __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmThreadCurrentWinRtExceptionQuery)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("d6bd56eb-2905-91a2-3e1c-bcf785d58e2d") IDkmThreadCurrentWinRtExceptionQuery : public IUnknown
    {
        /// <summary>
        /// GetThreadCurrentWinRtErrorInfo is used to get the address of the current
        /// IErrorInfo object for this thread.
        /// </summary>
        /// <param name="pThread">
        /// [In] DkmThread represents a thread running in the target process.
        /// </param>
        /// <param name="pWinRTErrorInfo">
        /// [Out,Optional] Address of the current IErrorInfo object on this thread.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE GetThreadCurrentWinRtErrorInfo(
            _In_ DkmThread* pThread,
            _Out_ UINT64* pWinRTErrorInfo
            ) = 0;
    };

    // Used to determine a thread's category.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // BaseDebugMonitorId, EngineId, RuntimeId, TransportKind.
    #define IID_IDkmThreadDisplayPropertiesQuery __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmThreadDisplayPropertiesQuery)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("8cf2518b-16e7-d19a-9ed9-16e8eb3ff867") IDkmThreadDisplayPropertiesQuery : public IUnknown
    {
        /// <summary>
        /// Gets the Display Properties of the Thread including the Display Name and Thread
        /// Category.
        /// </summary>
        /// <param name="pRuntimeInstance">
        /// [In] The DkmRuntimeInstance class represents an execution environment which is
        /// loaded into a DkmProcess and which contains code to be debugged.
        /// </param>
        /// <param name="pWorkList">
        /// WorkList which is currently being processed. This value can be used to check for
        /// cancelation or to append additional work. New work items will not begin executing
        /// until after this function returns.
        /// </param>
        /// <param name="pThread">
        /// [In] The Thread.
        /// </param>
        /// <param name="pCompletionRoutine">
        /// Routine to fire when the request is complete. This will be implicitly fired if
        /// the implementation returns failure from this interface method. The implementation
        /// must fire this method in all other scenarios.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE GetThreadDisplayProperties(
            _In_ DkmRuntimeInstance* pRuntimeInstance,
            _In_ DkmWorkList* pWorkList,
            _In_ DkmThread* pThread,
            _In_ IDkmCompletionRoutine<ThreadProperties::DkmGetThreadDisplayPropertiesAsyncResult>* pCompletionRoutine
            ) = 0;
    };

    // Used to determine a thread's name. Does not return the thread's display name.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // BaseDebugMonitorId, EngineId, RuntimeId, TransportKind.
    #define IID_IDkmThreadNameQuery __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmThreadNameQuery)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("314a1608-cad1-1345-f02b-ca582df587e4") IDkmThreadNameQuery : public IUnknown
    {
        /// <summary>
        /// Compute the name of a thread.
        /// </summary>
        /// <param name="pRuntimeInstance">
        /// [In] The DkmRuntimeInstance class represents an execution environment which is
        /// loaded into a DkmProcess and which contains code to be debugged.
        /// </param>
        /// <param name="pThread">
        /// [In] The Thread.
        /// </param>
        /// <param name="ppName">
        /// [Out,Optional] The Thread Name.
        /// </param>
        /// <returns>
        /// S_OK is returned if *ppName is non-NULL, S_FALSE is returned when *ppName is
        /// NULL, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE GetThreadName(
            _In_ DkmRuntimeInstance* pRuntimeInstance,
            _In_ DkmThread* pThread,
            _Deref_out_opt_ DkmString** ppName
            ) = 0;
    };

}; // end of Runtime debug monitors interfaces


// Symbol handlers interfaces
// Provides the ability to search for symbol files (ex: PDBs) and retrieve information
// from them. Symbol handlers are typically implemented to support debugging native
// languages.
//
// See also: IDkmModuleInstanceLoadNotification
namespace ComponentInterfaces
{
    // This interface contains methods implemented by the symbol provider to allow debug
    // monitors to search for binaries on symbol servers and local disks. This is required
    // because the symbol server APIs are not thread safe and the symbol provider owns access
    // to them.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // BaseDebugMonitorId, EngineId, TransportKind.
    #define IID_IDkmBinaryLocator __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmBinaryLocator)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("181533cb-6f9a-9f65-6bb1-51631de38cb8") IDkmBinaryLocator : public IUnknown
    {
        /// <summary>
        /// This method will search the local disk and any configured symbol servers for a
        /// binary that matches the parameters. The path to this file on the local disk is
        /// returned. If the file was on a symbol server, it is downloaded to a cache and the
        /// local path is returned.
        /// </summary>
        /// <param name="pProcess">
        /// [In] DkmProcess represents a target process which is being debugged. The debugger
        /// debugs processes, so this is the basic unit of debugging. A DkmProcess can
        /// represent a system process or a virtual process such as minidumps.
        /// </param>
        /// <param name="pApplicationPath">
        /// [In] The original path to the exe stored in the minidump.
        /// </param>
        /// <param name="pDumpPath">
        /// [In] The path to the dump file.
        /// </param>
        /// <param name="pOriginalPath">
        /// [In] The original path to the binary stored in the minidump.
        /// </param>
        /// <param name="TimeDateStamp">
        /// [In] The time date stamp of the binary in the time_t format.
        /// </param>
        /// <param name="ImageSize">
        /// [In] The size of the image.
        /// </param>
        /// <param name="ppFoundPath">
        /// [Out,Optional] The path on the local disk of the local (or downloaded) binary.
        /// </param>
        /// <returns>
        /// S_OK is returned if *ppFoundPath is non-NULL, S_FALSE is returned when
        /// *ppFoundPath is NULL, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE LocateBinary(
            _In_ DkmProcess* pProcess,
            _In_ DkmString* pApplicationPath,
            _In_ DkmString* pDumpPath,
            _In_ DkmString* pOriginalPath,
            _In_ UINT32 TimeDateStamp,
            _In_ UINT32 ImageSize,
            _Deref_out_opt_ DkmString** ppFoundPath
            ) = 0;
    };

    // Extends binary locator functionality.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // BaseDebugMonitorId, EngineId, TransportKind.
    //
    // This API was introduced in Visual Studio 11 Update 1 (DkmApiVersion.VS11FeaturePack1).
    #define IID_IDkmBinaryLocator11a __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmBinaryLocator11a)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("0848f212-f24f-6c1b-2008-f4e6f81d4a19") IDkmBinaryLocator11a : public IUnknown
    {
        /// <summary>
        /// Called to initiate locating of binaries whose images might not have previously
        /// found or attempted to be loaded. This method will search the local disk and any
        /// configured symbol servers for a binary that matches the parameters. The path to
        /// this file on the local disk is returned. If the file was on a symbol server, it
        /// is downloaded to a cache and the local path is returned.
        /// </summary>
        /// <param name="pProcess">
        /// [In] DkmProcess represents a target process which is being debugged. The debugger
        /// debugs processes, so this is the basic unit of debugging. A DkmProcess can
        /// represent a system process or a virtual process such as minidumps.
        /// </param>
        /// <param name="pApplicationPath">
        /// [In] The original path to the exe stored in the minidump.
        /// </param>
        /// <param name="pDumpPath">
        /// [In] The path to the dump file.
        /// </param>
        /// <param name="pOriginalPath">
        /// [In] The original path to the binary stored in the minidump.
        /// </param>
        /// <param name="TimeDateStamp">
        /// [In] The time date stamp of the binary in the time_t format.
        /// </param>
        /// <param name="ImageSize">
        /// [In] The size of the image.
        /// </param>
        /// <param name="ppFoundPath">
        /// [Out,Optional] The path on the local disk of the local (or downloaded) binary.
        /// </param>
        /// <returns>
        /// S_OK is returned if *ppFoundPath is non-NULL, S_FALSE is returned when
        /// *ppFoundPath is NULL, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE TryLocateBinary(
            _In_ DkmProcess* pProcess,
            _In_ DkmString* pApplicationPath,
            _In_ DkmString* pDumpPath,
            _In_ DkmString* pOriginalPath,
            _In_ UINT32 TimeDateStamp,
            _In_ UINT32 ImageSize,
            _Deref_out_opt_ DkmString** ppFoundPath
            ) = 0;
    };

    // Interface to provide runtime-specific operations for instruction addresses. For native
    // and managed instructions, this service is provided by the symbol provider.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // BaseDebugMonitorId, EngineId, RuntimeId, SymbolProviderId.
    #define IID_IDkmInstructionAddressOperator __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmInstructionAddressOperator)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("ddb4c8fb-b4bd-82b3-c76f-6c9c7d01843c") IDkmInstructionAddressOperator : public IUnknown
    {
        /// <summary>
        /// Compares two instruction addresses and determines if they are within the same
        /// function.
        /// </summary>
        /// <param name="pInstructionAddress">
        /// [In] Abstract representation of an executable code location (ex: EIP value). If
        /// resolved, an Instruction Address will be within a particular module instance. An
        /// Instruction Address is always within a particular Runtime Instance.
        /// </param>
        /// <param name="pOther">
        /// [In] An address to compare with this address.
        /// </param>
        /// <param name="pResult">
        /// [Out] True if the two addresses are from the same function.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE IsInSameFunction(
            _In_ DkmInstructionAddress* pInstructionAddress,
            _In_ DkmInstructionAddress* pOther,
            _Out_ bool* pResult
            ) = 0;
    };

    // Interface implemented to provide Just-My-Code status for modules. To support the
    // modules window, this interface should be implemented in an IDE component, but it can
    // also be implemented on the monitor side if this is useful. Microsoft implements this
    // interface on the monitor side for managed code, but not native.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // BaseDebugMonitorId, EngineId, RuntimeId, SymbolProviderId, TransportKind.
    //
    // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
    #define IID_IDkmModuleUserCodeDeterminer __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmModuleUserCodeDeterminer)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("172f19fb-cb40-6c11-714a-a2d4f8b58460") IDkmModuleUserCodeDeterminer : public IUnknown
    {
        /// <summary>
        /// Determines if a module is considered user code.
        /// </summary>
        /// <param name="pModuleInstance">
        /// [In] The Module Instance class represent a code bundle (ex: dll or exe) which is
        /// loaded into a particular process at a particular location. Module Instance
        /// objects are 1:1 with the execution environment's notion of a code bundle. For
        /// example, in native code, Module Instance objects are 1:1 with base address.
        /// </param>
        /// <param name="pIsUserCode">
        /// [Out] True if some or all of the module is user code.  False if the entire module
        /// is nonuser code.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE IsUserCode(
            _In_ DkmModuleInstance* pModuleInstance,
            _Out_ bool* pIsUserCode
            ) = 0;
    };

    // This API is used to undecorate symbol names. Microsoft provides an implementation of
    // this to undecorate symbol names in PDBs.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // CompilerVendorId, LanguageId, SymbolProviderId, TransportKind.
    #define IID_IDkmNameUndecorator __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmNameUndecorator)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("25911e14-acc1-2fdc-d9ed-bf8abbe28779") IDkmNameUndecorator : public IUnknown
    {
        /// <summary>
        /// Undecorates a symbol name.
        /// </summary>
        /// <param name="pModule">
        /// [In] The DkmModule class represents a code bundle (ex: dll or exe) which is or
        /// once was loaded into one or more processes. The DkmModule class is the central
        /// object to the symbol APIs, and is 1:1 with the symbol handler's notation of what
        /// is loaded. If a code bundle loads into three different processes (or the same
        /// process but with three different base addresses or three different app domains)
        /// but the symbol handler thinks of all of these as being identical, there will be
        /// only one module object.
        /// </param>
        /// <param name="pDecoratedName">
        /// [In] The name to be undecorated.
        /// </param>
        /// <param name="Options">
        /// [In] Options to change the undecorated name. These are specific to the
        /// implementation being used. For Microsoft PDB, pass one or more of the values
        /// described in the documentation for DbgHelp.dll UnDecorateSymbolName or one of
        /// these three extended options: UNDNAME2_STRIP_ILT  0x10000  - to remove the
        /// leading ILT from Incremental Linking Thunks UNDNAME2_STRIP_CONST 0x20000 - to
        /// remove leading "const" from the front of the string UNDNAME2_STRINGS  0x30000 -
        /// to use pooled strings by name.
        /// </param>
        /// <param name="ppUndecoratedName">
        /// [Out] The undecorated name.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE UndecorateName(
            _In_ Symbols::DkmModule* pModule,
            _In_ DkmString* pDecoratedName,
            _In_ UINT32 Options,
            _Deref_out_ DkmString** ppUndecoratedName
            ) = 0;
    };

    // Callback interface which is implemented by the PDB symbol provider for returning
    // information about symbols to the base debug monitor. This interface should generally
    // be implemented on the Visual Studio computer. Debug monitor side implementations may
    // not be called.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // SymbolProviderId.
    #define IID_IDkmNativeSymbolProviderCallback __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmNativeSymbolProviderCallback)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("6d7f18b0-05fb-a8ba-a458-5951c03b5b6f") IDkmNativeSymbolProviderCallback : public IUnknown
    {
        /// <summary>
        /// Returns address information to the native debug monitor.
        /// </summary>
        /// <param name="pNativeInstruction">
        /// [In] DkmNativeInstructionSymbol represents a native instruction within a module
        /// of the target process. DkmNativeInstructionSymbol are 1:1 with the underlying
        /// native instructions. So if there are two template instantiations of a method (ex:
        /// MyMethod&lt;CString&gt; and MyMethod&lt;int&gt;) if the linker merges the two
        /// instantiations into a single function through COMDAT folding then the methods
        /// will be identical. If the linker isn't able to merge the two instantiations then
        /// both user-level functions will appear as one DkmNativeInstructionSymbol.
        /// </param>
        /// <param name="pInstructionAddress">
        /// [In,Optional] Abstract representation of an executable code location (ex: EIP
        /// value). If resolved, an Instruction Address will be within a particular module
        /// instance. An Instruction Address is always within a particular Runtime Instance.
        /// </param>
        /// <param name="ppMetadata">
        /// [Out,Optional] DkmNativeAddressMetadata represents symbol based metadata about
        /// addresses. This includes if the address is a thunk, a prolog, or a trampoline.
        /// </param>
        /// <returns>
        /// S_OK is returned if *ppMetadata is non-NULL, S_FALSE is returned when *ppMetadata
        /// is NULL, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE GetNativeInstructionMetadataCallback(
            _In_ Native::DkmNativeInstructionSymbol* pNativeInstruction,
            _In_opt_ DkmInstructionAddress* pInstructionAddress,
            _Deref_out_opt_ Native::DkmNativeAddressMetadata** ppMetadata
            ) = 0;

        /// <summary>
        /// Return the RVA for an S_PUBLIC32 for a particular name by string.
        /// </summary>
        /// <param name="pModule">
        /// [In] The DkmModule class represents a code bundle (ex: dll or exe) which is or
        /// once was loaded into one or more processes. The DkmModule class is the central
        /// object to the symbol APIs, and is 1:1 with the symbol handler's notation of what
        /// is loaded. If a code bundle loads into three different processes (or the same
        /// process but with three different base addresses or three different app domains)
        /// but the symbol handler thinks of all of these as being identical, there will be
        /// only one module object.
        /// </param>
        /// <param name="pPublicName">
        /// [In] The name of the public symbol to lookup.
        /// </param>
        /// <param name="ppAddress">
        /// [Out,Optional] The native instruction symbol for this public symbol.
        /// </param>
        /// <returns>
        /// S_OK is returned if *ppAddress is non-NULL, S_FALSE is returned when *ppAddress
        /// is NULL, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE GetPublicSymbolByNameCallback(
            _In_ Symbols::DkmModule* pModule,
            _In_ DkmString* pPublicName,
            _Deref_out_opt_ Native::DkmNativeInstructionSymbol** ppAddress
            ) = 0;
    };

    // Optional interface that may be implemented by native symbol providers and consumed by
    // the native DM to allow stepping. If not implemented, the native DM will fall back to
    // IDkmNativeSymbolProviderCallback.GetNativeInstructionMetadataCallback and
    // IDkmSymbolProviderCallback.GetSteppingRanges.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // RuntimeId, SymbolProviderId.
    //
    // This API was introduced in Visual Studio 14 RTM (DkmApiVersion.VS14RTM).
    #define IID_IDkmNativeSymbolProviderCallback120a __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmNativeSymbolProviderCallback120a)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("f457f98d-0317-f69f-6cbf-4502b5d42d98") IDkmNativeSymbolProviderCallback120a : public IUnknown
    {
        /// <summary>
        /// Queries the symbol provider to determine the ranges of instructions which the
        /// base debug monitor should step through to implement a step.
        /// </summary>
        /// <param name="pNativeInstruction">
        /// [In] DkmNativeInstructionSymbol represents a native instruction within a module
        /// of the target process. DkmNativeInstructionSymbol are 1:1 with the underlying
        /// native instructions. So if there are two template instantiations of a method (ex:
        /// MyMethod&lt;CString&gt; and MyMethod&lt;int&gt;) if the linker merges the two
        /// instantiations into a single function through COMDAT folding then the methods
        /// will be identical. If the linker isn't able to merge the two instantiations then
        /// both user-level functions will appear as one DkmNativeInstructionSymbol.
        /// </param>
        /// <param name="pModuleInstance">
        /// [In] Module instance which contains the current instruction symbol.
        /// </param>
        /// <param name="pStepStartingAddress">
        /// [In,Optional] Instruction where the step began. May be null in unusual
        /// situations, such as beginning the step with no frames on the stack. Note that
        /// this is not necessarily a native instruction.
        /// </param>
        /// <param name="RangeBoundary">
        /// [In] Indicates to the symbol provider the type of instructions to include in the
        /// 'no-step' regions.
        /// </param>
        /// <param name="IncludeInline">
        /// [In] True if the symbol provider should stop the stepping range when it
        /// encounters an inline functions. False otherwise. The Native DM will pass true for
        /// a step in so steps will stop in inline functions. It will pass false when doing a
        /// step-over so the stepper will not stop in inline functions.
        /// </param>
        /// <param name="pRanges">
        /// [Out] Array of ranges to step through. This array will be empty if there is no
        /// source information for the given instruction.
        ///
        /// The memory for the DkmArray members is allocated by the method implementation
        /// using DkmAllocBytes/DkmAllocArray. It is freed by the caller using the
        /// CAutoDkmArray template or with DkmFreeMemory and manual element release.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE GetSteppingRanges(
            _In_ Native::DkmNativeInstructionSymbol* pNativeInstruction,
            _In_ DkmModuleInstance* pModuleInstance,
            _In_opt_ DkmInstructionAddress* pStepStartingAddress,
            _In_ Symbols::DkmSteppingRangeBoundary_t RangeBoundary,
            _In_ bool IncludeInline,
            _Out_ DkmArray<Symbols::DkmSteppingRange>* pRanges
            ) = 0;

        /// <summary>
        /// Called by the native DM to fetch data about an instruction which is used to
        /// decide how this instruction should be stepped.
        /// </summary>
        /// <param name="pNativeInstruction">
        /// [In] DkmNativeInstructionSymbol represents a native instruction within a module
        /// of the target process. DkmNativeInstructionSymbol are 1:1 with the underlying
        /// native instructions. So if there are two template instantiations of a method (ex:
        /// MyMethod&lt;CString&gt; and MyMethod&lt;int&gt;) if the linker merges the two
        /// instantiations into a single function through COMDAT folding then the methods
        /// will be identical. If the linker isn't able to merge the two instantiations then
        /// both user-level functions will appear as one DkmNativeInstructionSymbol.
        /// </param>
        /// <param name="pModuleInstance">
        /// [In] Module instance which contains the current instruction symbol.
        /// </param>
        /// <param name="pStepStartingAddress">
        /// [In,Optional] Instruction where the step began. May be null in unusual
        /// situations, such as beginning the step with no frames on the stack.  Note that
        /// this is not necessarily a native instruction.
        /// </param>
        /// <param name="ppMetadata">
        /// [Out,Optional] DkmNativeAddressMetadata represents symbol based metadata about
        /// addresses. This includes if the address is a thunk, a prolog, or a trampoline.
        /// </param>
        /// <returns>
        /// S_OK is returned if *ppMetadata is non-NULL, S_FALSE is returned when *ppMetadata
        /// is NULL, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE GetSteppingNativeInstructionMetadata(
            _In_ Native::DkmNativeInstructionSymbol* pNativeInstruction,
            _In_ DkmModuleInstance* pModuleInstance,
            _In_opt_ DkmInstructionAddress* pStepStartingAddress,
            _Deref_out_opt_ Native::DkmNativeAddressMetadata** ppMetadata
            ) = 0;
    };

    // Callback interface implemented by script symbol providers in order to support stepping
    // customizations for languages that compile to JavaScript (or possibly other script
    // languages as well).
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // RuntimeId, SymbolProviderId.
    #define IID_IDkmScriptSymbolCallback __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmScriptSymbolCallback)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("b8dce0a2-be5e-215a-cfd7-ceed6a76870e") IDkmScriptSymbolCallback : public IUnknown
    {
        /// <summary>
        /// Call back implemented by the script symbol provider to tell the script debug
        /// monitor what to do next when stepping.
        /// </summary>
        /// <param name="pScriptInstruction">
        /// [In] DkmScriptInstructionSymbol is used to represent an executable statement in a
        /// script-based runtime environment such the Microsoft JavaScript engine.
        /// </param>
        /// <param name="pStartingInstruction">
        /// [In,Optional] The instruction symbol of the process at the time this step
        /// started. This will be NULL if the step originated on a thread with no frames.
        /// </param>
        /// <param name="IsSteppingByLine">
        /// [In] true if the step is by line (instead of by statement).
        /// </param>
        /// <param name="pResult">
        /// [Out] Enum value indicating the next action that the script dm should perform.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// NotImplementedException/E_NOTIMPL indicates that no symbol provider is available
        /// for the script symbol.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE GetNextSteppingAction(
            _In_ Script::DkmScriptInstructionSymbol* pScriptInstruction,
            _In_opt_ Script::DkmScriptInstructionSymbol* pStartingInstruction,
            _In_ bool IsSteppingByLine,
            _Out_ Script::DkmScriptSymbolNextSteppingAction_t* pResult
            ) = 0;
    };

    // Allows the UI to query if the current instruction can be set to an address. Must be
    // implemented on the Client side as it can be called in scenarios requiring a fast
    // result such as dragging the IP in the debugger editor.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // BaseDebugMonitorId, EngineId, RuntimeId, SymbolProviderId, TransportKind.
    #define IID_IDkmSetNextStatementQuery __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmSetNextStatementQuery)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("1c7c0349-1524-527e-af52-ec49fc35a418") IDkmSetNextStatementQuery : public IUnknown
    {
        /// <summary>
        /// CanSetNextStatement determines if it is possible to move the IP of a stack frame.
        /// The stack frame is always the leaf stack frame on a particular thread. This API
        /// may only be implemented within the engine process. The Result out parameter
        /// should be S_OK or the value of a failed HRESULT that the UI can map to an error
        /// message.
        /// </summary>
        /// <param name="pFrame">
        /// [In] DkmStackWalkFrame represents a frame on a call stack which has been walked,
        /// but may not have been formatted or filtered. Formatted frames are represented by
        /// DkmStackFrame instead.
        /// </param>
        /// <param name="pNewStatement">
        /// [In] Abstract representation of an executable code location (ex: EIP value). If
        /// resolved, an Instruction Address will be within a particular module instance. An
        /// Instruction Address is always within a particular Runtime Instance.
        /// </param>
        /// <param name="pResult">
        /// [Out] The error code to return to the UI. This should be S_OK or the value of a
        /// failed HRESULT that the UI can map to an error message.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE CanSetNextStatement(
            _In_ CallStack::DkmStackWalkFrame* pFrame,
            _In_ DkmInstructionAddress* pNewStatement,
            _Out_ UINT32* pResult
            ) = 0;
    };

    // This API is used to read information about source server data from a symbol provider.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // CompilerVendorId, LanguageId, SymbolProviderId, TransportKind.
    #define IID_IDkmSourceServerSymbolQuery __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmSourceServerSymbolQuery)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("938cb349-2835-d665-0c30-355e319be5e7") IDkmSourceServerSymbolQuery : public IUnknown
    {
        /// <summary>
        /// Returns the contents of the source server stream data for a module if the stream
        /// exists.
        /// </summary>
        /// <param name="pModule">
        /// [In] The DkmModule class represents a code bundle (ex: dll or exe) which is or
        /// once was loaded into one or more processes. The DkmModule class is the central
        /// object to the symbol APIs, and is 1:1 with the symbol handler's notation of what
        /// is loaded. If a code bundle loads into three different processes (or the same
        /// process but with three different base addresses or three different app domains)
        /// but the symbol handler thinks of all of these as being identical, there will be
        /// only one module object.
        /// </param>
        /// <param name="pModuleInstance">
        /// [In] The module instance for which symbol server data is being requested.
        /// </param>
        /// <param name="pStreamData">
        /// [Out] True if this address is the first address in the line's range. False
        /// otherwise.
        ///
        /// The memory for the DkmArray members is allocated by the method implementation
        /// using DkmAllocBytes/DkmAllocArray. It is freed by the caller using the
        /// CAutoDkmArray template or with DkmFreeMemory and manual element release.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE GetSourceServerData(
            _In_ Symbols::DkmModule* pModule,
            _In_ DkmModuleInstance* pModuleInstance,
            _Out_ DkmArray<BYTE>* pStreamData
            ) = 0;
    };

    // Used by AD7 to get step into specific options.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // CompilerVendorId, LanguageId, RuntimeId, SymbolProviderId.
    #define IID_IDkmSteppingCodePathProvider __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmSteppingCodePathProvider)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("c5ac6ff5-23cc-6c6a-d841-ed27b45289d6") IDkmSteppingCodePathProvider : public IUnknown
    {
        /// <summary>
        /// GetCodePaths is called to get step into specific targets.
        /// </summary>
        /// <param name="pSteppingCodePathSource">
        /// [In] Object used for filtering for step into specific.
        /// </param>
        /// <param name="pStackFrame">
        /// [In] Specifies the current frame.
        /// </param>
        /// <param name="StepUnit">
        /// [In] Specifies if code paths are for current statement or line.
        /// </param>
        /// <param name="pCodePaths">
        /// [Out] DkmSteppingCodePath[] represents a location that user can step to from
        /// current location.
        ///
        /// The memory for the DkmArray members is allocated by the method implementation
        /// using DkmAllocBytes/DkmAllocArray. It is freed by the caller using the
        /// CAutoDkmArray template or with DkmFreeMemory and manual element release.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE GetCodePaths(
            _In_ Stepping::DkmSteppingCodePathSource* pSteppingCodePathSource,
            _In_ CallStack::DkmStackWalkFrame* pStackFrame,
            _In_ Stepping::DkmStepUnit_t StepUnit,
            _Out_ DkmArray<Stepping::DkmSteppingCodePath*>* pCodePaths
            ) = 0;
    };

    // Optional interface implemented by symbol providers that wish to provide multiple
    // source mappings for the same instruction symbol - both a primary mapping, and a backup
    // mapping in the case the primary document cannot be found.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // RuntimeId, SymbolProviderId.
    //
    // This API was introduced in Visual Studio 12 Update 3 (DkmApiVersion.VS12Update3).
    #define IID_IDkmSymbolAlternateSourcePositionQuery __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmSymbolAlternateSourcePositionQuery)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("15db2fd2-a784-76bb-eaba-4b9f587cb415") IDkmSymbolAlternateSourcePositionQuery : public IUnknown
    {
        /// <summary>
        /// Returns an alternate source file position (ex: example.cs, line 12) for this
        /// instruction symbol. This is currently used in source map scenarios to return the
        /// original (unmapped) source location. This API will be called by the debugger UI
        /// in cases where the primary source location cannot be found.
        /// </summary>
        /// <param name="pInstruction">
        /// [In] DkmInstructionSymbol represents a method in the target process.
        /// </param>
        /// <param name="Flags">
        /// [In] Flags which affect the behavior of 'GetSourcePosition'.
        /// </param>
        /// <param name="ppSourcePosition">
        /// [Out] Associated source location for the instruction.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error. Symbol
        /// provider doesn't support mapping this specified instruction to an alternate
        /// location.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE GetAlternateSourcePosition(
            _In_ Symbols::DkmInstructionSymbol* pInstruction,
            _In_ Symbols::DkmSourcePositionFlags_t Flags,
            _Deref_out_ Symbols::DkmSourcePosition** ppSourcePosition
            ) = 0;
    };

    // This API is used to fetch the compiler id for a given symbol. It is implemented by
    // symbol providers that support symbol stores where the binary may contain multiple
    // languages. In other words, this interface only needs to be implemented when
    // DkmModule.CompilerId is Guid.Empty/Guid.Empty.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // RuntimeId, SymbolProviderId.
    #define IID_IDkmSymbolCompilerIdQuery __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmSymbolCompilerIdQuery)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("06890e81-01ed-2817-8044-5a60b4206a00") IDkmSymbolCompilerIdQuery : public IUnknown
    {
        /// <summary>
        /// Returns the compiler id (LanguageId/VendorId) of a given symbol. See
        /// DkmSymbol.GetCompilerId for a more detailed description.
        /// </summary>
        /// <param name="pInstruction">
        /// [In] DkmInstructionSymbol represents a method in the target process.
        /// </param>
        /// <param name="pInspectionSession">
        /// [In,Optional] A reference object describing the current inspection session.
        /// Common usage is for symbol providers to cache lookups using its data container.
        /// </param>
        /// <param name="pCompilerId">
        /// [Out] LanguageId/VendorId for the compiler which produced the code for this
        /// symbol. If this is unknown (ex: no symbols info for this block), both values will
        /// be Guid.Empty. Otherwise, both values should be non-zero.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE GetCompilerId(
            _In_ Symbols::DkmInstructionSymbol* pInstruction,
            _In_opt_ Evaluation::DkmInspectionSession* pInspectionSession,
            _Out_ Evaluation::DkmCompilerId* pCompilerId
            ) = 0;
    };

    // This API is used to fetch the compiler id for a given symbol. It is implemented by
    // symbol providers that support symbol stores where the binary may contain multiple
    // languages. In other words, this interface only needs to be implemented when
    // DkmModule.CompilerId is Guid.Empty/Guid.Empty.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // RuntimeId, SymbolProviderId.
    #define IID_IDkmSymbolCompilerIdQueryCallback __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmSymbolCompilerIdQueryCallback)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("1d8b5a15-af5d-3e93-0072-dab51a2d2b2a") IDkmSymbolCompilerIdQueryCallback : public IUnknown
    {
        /// <summary>
        /// Returns the compiler id (LanguageId/VendorId) of a given symbol. See
        /// DkmSymbol.GetCompilerId for a more detailed description.
        /// </summary>
        /// <param name="pInstruction">
        /// [In] DkmInstructionSymbol represents a method in the target process.
        /// </param>
        /// <param name="pInspectionSession">
        /// [In,Optional] A reference object describing the current inspection session.
        /// Common usage is for symbol providers to cache lookups using its data container.
        /// </param>
        /// <param name="pCompilerId">
        /// [Out] LanguageId/VendorId for the compiler which produced the code for this
        /// symbol. If this is unknown (ex: no symbols info for this block), both values will
        /// be Guid.Empty. Otherwise, both values should be non-zero.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE GetCompilerIdCallback(
            _In_ Symbols::DkmInstructionSymbol* pInstruction,
            _In_opt_ Evaluation::DkmInspectionSession* pInspectionSession,
            _Out_ Evaluation::DkmCompilerId* pCompilerId
            ) = 0;
    };

    // This API is used to resolve symbols in the disassembly window.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // RuntimeId, SymbolProviderId.
    #define IID_IDkmSymbolDisassemblyQuery __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmSymbolDisassemblyQuery)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("eab7b813-f0fc-2310-a110-1ea17600cae2") IDkmSymbolDisassemblyQuery : public IUnknown
    {
        /// <summary>
        /// Return the name of the symbol as it should appear in the disassembly window. For
        /// Microsoft C++ code, this is based on the public symbol name.
        /// </summary>
        /// <param name="pInstruction">
        /// [In] DkmInstructionSymbol represents a method in the target process.
        /// </param>
        /// <param name="pInspectionSession">
        /// [In,Optional] A reference object describing the current inspection session.
        /// Common usage is for symbol providers to cache lookups using its data container.
        /// </param>
        /// <param name="ppLabel">
        /// [Out,Optional] The label to use for this instruction.
        /// </param>
        /// <returns>
        /// S_OK is returned if *ppLabel is non-NULL, S_FALSE is returned when *ppLabel is
        /// NULL, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE GetDisassemblyLabel(
            _In_ Symbols::DkmInstructionSymbol* pInstruction,
            _In_opt_ Evaluation::DkmInspectionSession* pInspectionSession,
            _Deref_out_opt_ DkmString** ppLabel
            ) = 0;
    };

    // API implemented by symbol providers to allow the breakpoints manager and other
    // components to query the collection of documents inside of a symbol store.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // CompilerVendorId, LanguageId, SymbolProviderId, TransportKind.
    #define IID_IDkmSymbolDocumentCollectionQuery __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmSymbolDocumentCollectionQuery)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("80df6353-6253-e5ed-1dec-80505da7b92e") IDkmSymbolDocumentCollectionQuery : public IUnknown
    {
        /// <summary>
        /// Returns document objects from search parameters contained in the document query.
        /// If the symbol file does not contain a reference to this document the returned
        /// document object will be NULL (S_FALSE return code in native). The returned
        /// document objects must be explicitly closed by the caller when the caller is done
        /// with the document.
        /// </summary>
        /// <param name="pModule">
        /// [In] The DkmModule class represents a code bundle (ex: dll or exe) which is or
        /// once was loaded into one or more processes. The DkmModule class is the central
        /// object to the symbol APIs, and is 1:1 with the symbol handler's notation of what
        /// is loaded. If a code bundle loads into three different processes (or the same
        /// process but with three different base addresses or three different app domains)
        /// but the symbol handler thinks of all of these as being identical, there will be
        /// only one module object.
        /// </param>
        /// <param name="pSourceFileId">
        /// [In] Identifies a source file and provides the information which a symbol handler
        /// could use to search a symbol file (PDB) for information on this source file.
        /// </param>
        /// <param name="pDocuments">
        /// [Out] A collection of the documents that matched the query.
        ///
        /// The memory for the DkmArray members is allocated by the method implementation
        /// using DkmAllocBytes/DkmAllocArray. It is freed by the caller using the
        /// CAutoDkmArray template or with DkmFreeMemory and manual element release.
        /// </param>
        /// <returns>
        /// S_OK is returned if pDocuments contains any elements, S_FALSE is indicates the
        /// array is empty, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE FindDocuments(
            _In_ Symbols::DkmModule* pModule,
            _In_ Symbols::DkmSourceFileId* pSourceFileId,
            _Out_ DkmArray<Symbols::DkmResolvedDocument*>* pDocuments
            ) = 0;
    };

    // API implemented by symbol providers to allow the breakpoints manager and other
    // components to query the 'document text span->symbol' map which is inside a symbol
    // store.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // SymbolProviderId.
    #define IID_IDkmSymbolDocumentSpanQuery __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmSymbolDocumentSpanQuery)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("afcb73f7-9873-5130-b3dd-a9437699fc85") IDkmSymbolDocumentSpanQuery : public IUnknown
    {
        /// <summary>
        /// Finds the symbols within the document which best match the input text span.
        ///
        /// For IL-based languages, the symbol handler always return the DkmInstructionSymbol
        /// for sequence points. It will prefer sequence points which exactly match the text
        /// span followed by the sequence point or points which is left-most and which is
        /// inside the input span.
        /// </summary>
        /// <param name="pResolvedDocument">
        /// [In] Object which represents the result of a source file query against a symbol
        /// file (PDB). The resolved document object might encapsulate multiple document
        /// records with the symbol file. For example, in C++ compilation, each time that a
        /// header file is included there is another reference within the PDB. However, there
        /// is only one DkmResolvedDocument object for the header file.
        /// </param>
        /// <param name="TextSpan">
        /// [In] The text range (lines/column) to search for.
        /// </param>
        /// <param name="pText">
        /// [In,Optional] The text to search for. When available, this will be provided if
        /// ResolvedDocument.TextRequested is set.
        /// </param>
        /// <param name="pInstructionSymbols">
        /// [Out] The found instruction symbols which are within the specified text span.
        ///
        /// The memory for the DkmArray members is allocated by the method implementation
        /// using DkmAllocBytes/DkmAllocArray. It is freed by the caller using the
        /// CAutoDkmArray template or with DkmFreeMemory and manual element release.
        /// </param>
        /// <param name="pSymbolLocation">
        /// [Out] The source location of each returned instruction symbol. The length of this
        /// array should be the same of the returned instruction symbol array.
        ///
        /// The memory for the DkmArray members is allocated by the method implementation
        /// using DkmAllocBytes/DkmAllocArray. It is freed by the caller using the
        /// CAutoDkmArray template or with DkmFreeMemory and manual element release.
        /// </param>
        /// <returns>
        /// S_OK is returned if pInstructionSymbols contains any elements, S_FALSE is
        /// indicates the array is empty, and failure codes are used for any error.
        /// E_TEXT_SPAN_NOT_LOADED indicates that TextSpan is not currently loaded in the
        /// specified script document. E_SCRIPT_SPAN_MAPPING_FAILED indicates that TextSpan
        /// could not be mapped to a location in the specified script document.
        /// E_SCRIPT_FILE_DIFFERENT_CONTENT indicates that the content in the script file
        /// loaded by the target process doesn't match the provided Text.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE FindSymbols(
            _In_ Symbols::DkmResolvedDocument* pResolvedDocument,
            _In_ const Symbols::DkmTextSpan& TextSpan,
            _In_opt_ DkmString* pText,
            _Out_ DkmArray<Symbols::DkmInstructionSymbol*>* pInstructionSymbols,
            _Out_ DkmArray<Symbols::DkmSourcePosition*>* pSymbolLocation
            ) = 0;
    };

    // This API is used to read information about a symbol.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // RuntimeId, SymbolProviderId.
    #define IID_IDkmSymbolHiddenAttributeQuery __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmSymbolHiddenAttributeQuery)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("24d28567-6961-0144-9f37-1c617e915b57") IDkmSymbolHiddenAttributeQuery : public IUnknown
    {
        /// <summary>
        /// Returns if this instruction symbol is in hidden code. For instance, in managed
        /// code, the line number 0xfeefee marks a source line as hidden.
        /// </summary>
        /// <param name="pInstruction">
        /// [In] DkmInstructionSymbol represents a method in the target process.
        /// </param>
        /// <param name="pWorkList">
        /// WorkList which is currently being processed. This value can be used to check for
        /// cancelation or to append additional work. New work items will not begin executing
        /// until after this function returns.
        /// </param>
        /// <param name="pInspectionSession">
        /// [In] DkmInspectionSession allows the various components which inspect data to
        /// store private data which is associated with a group of evaluations.
        /// </param>
        /// <param name="pInstructionAddress">
        /// [In] Abstract representation of an executable code location (ex: EIP value). If
        /// resolved, an Instruction Address will be within a particular module instance. An
        /// Instruction Address is always within a particular Runtime Instance.
        /// </param>
        /// <param name="pCompletionRoutine">
        /// Routine to fire when the request is complete. This will be implicitly fired if
        /// the implementation returns failure from this interface method. The implementation
        /// must fire this method in all other scenarios.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE IsHiddenCode(
            _In_ Symbols::DkmInstructionSymbol* pInstruction,
            _In_ DkmWorkList* pWorkList,
            _In_ Evaluation::DkmInspectionSession* pInspectionSession,
            _In_ DkmInstructionAddress* pInstructionAddress,
            _In_ IDkmCompletionRoutine<Symbols::DkmIsHiddenCodeAsyncResult>* pCompletionRoutine
            ) = 0;
    };

    // Interface implemented by symbol providers which deal with symbol search. In other
    // words, this interface would not be implemented by symbol providers which deal only
    // with symbol formats which are inside the debugged binary.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // SymbolProviderId, TransportKind.
    #define IID_IDkmSymbolLocator __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmSymbolLocator)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("3dc0644b-3e46-080a-3fe8-2fdc8695d0c3") IDkmSymbolLocator : public IUnknown
    {
        /// <summary>
        /// Called to initiate loading of symbols for DkmModuleInstances whose symbols were
        /// not found when the module loaded.
        /// </summary>
        /// <param name="pModuleInstance">
        /// [In] The Module Instance class represent a code bundle (ex: dll or exe) which is
        /// loaded into a particular process at a particular location. Module Instance
        /// objects are 1:1 with the execution environment's notion of a code bundle. For
        /// example, in native code, Module Instance objects are 1:1 with base address.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE TryLoadSymbols(
            _In_ DkmModuleInstance* pModuleInstance
            ) = 0;

        /// <summary>
        /// Returns the path to the symbol file which backs a DkmModule object.
        /// </summary>
        /// <param name="pModule">
        /// [In] The DkmModule class represents a code bundle (ex: dll or exe) which is or
        /// once was loaded into one or more processes. The DkmModule class is the central
        /// object to the symbol APIs, and is 1:1 with the symbol handler's notation of what
        /// is loaded. If a code bundle loads into three different processes (or the same
        /// process but with three different base addresses or three different app domains)
        /// but the symbol handler thinks of all of these as being identical, there will be
        /// only one module object.
        /// </param>
        /// <param name="ppFilePath">
        /// [Out] Full path to the symbol file (ex: c:\myproj\bin\debug\myproj.pdb).
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE GetSymbolFilePath(
            _In_ Symbols::DkmModule* pModule,
            _Deref_out_ DkmString** ppFilePath
            ) = 0;

        /// <summary>
        /// Obtain a localized a string description of the current symbol status.
        /// </summary>
        /// <param name="pModuleInstance">
        /// [In] The Module Instance class represent a code bundle (ex: dll or exe) which is
        /// loaded into a particular process at a particular location. Module Instance
        /// objects are 1:1 with the execution environment's notion of a code bundle. For
        /// example, in native code, Module Instance objects are 1:1 with base address.
        /// </param>
        /// <param name="ExcludeCommonErrors">
        /// [In] This value will be true for creating the initial load output message, and
        /// false for obtaining the output window text.
        /// </param>
        /// <param name="ppStatus">
        /// [Out] Localized status string (ex: 'Symbols Loaded', 'No symbols loaded', etc.).
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE GetSymbolStatusMessage(
            _In_ DkmModuleInstance* pModuleInstance,
            _In_ bool ExcludeCommonErrors,
            _Deref_out_ DkmString** ppStatus
            ) = 0;

        /// <summary>
        /// Returns a string describing the various locations in which symbols were searched
        /// for, and the result of checking that location. This information is used to
        /// populate the 'Symbol Load Information' in the modules window.
        /// </summary>
        /// <param name="pModuleInstance">
        /// [In] The Module Instance class represent a code bundle (ex: dll or exe) which is
        /// loaded into a particular process at a particular location. Module Instance
        /// objects are 1:1 with the execution environment's notion of a code bundle. For
        /// example, in native code, Module Instance objects are 1:1 with base address.
        /// </param>
        /// <param name="ppDescription">
        /// [Out] String containing information about the symbol search. The typical format
        /// is 'location1:result1\r\nlocation2:result2...'.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE GetSymbolLoadInformation(
            _In_ DkmModuleInstance* pModuleInstance,
            _Deref_out_ DkmString** ppDescription
            ) = 0;
    };

    // Callback interface which is implemented by symbol providers to provide information
    // from the symbol store to debug monitors.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // SymbolProviderId.
    #define IID_IDkmSymbolProviderCallback __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmSymbolProviderCallback)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("ddc27912-0815-d9ed-dfe7-5888a86a4c92") IDkmSymbolProviderCallback : public IUnknown
    {
        /// <summary>
        /// Queries the symbol provider to determine the ranges of instructions which the
        /// base debug monitor should step through to implement a step.
        /// </summary>
        /// <param name="pInstruction">
        /// [In] DkmInstructionSymbol represents a method in the target process.
        /// </param>
        /// <param name="RangeBoundary">
        /// [In] Indicates to the symbol provider the type of instructions to include in the
        /// 'no-step' regions.
        /// </param>
        /// <param name="IncludeInline">
        /// [In] True if the symbol provider should stop the stepping range when it
        /// encounters an inline functions. False otherwise. The Native DM will pass true for
        /// a step in so steps will stop in inline functions. It will pass false when doing a
        /// step-over so the stepper will not stop in inline functions.
        /// </param>
        /// <param name="pRanges">
        /// [Out] Array of ranges to step through. This array will be empty if there is no
        /// source information for the given instruction.
        ///
        /// The memory for the DkmArray members is allocated by the method implementation
        /// using DkmAllocBytes/DkmAllocArray. It is freed by the caller using the
        /// CAutoDkmArray template or with DkmFreeMemory and manual element release.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE GetSteppingRanges(
            _In_ Symbols::DkmInstructionSymbol* pInstruction,
            _In_ Symbols::DkmSteppingRangeBoundary_t RangeBoundary,
            _In_ bool IncludeInline,
            _Out_ DkmArray<Symbols::DkmSteppingRange>* pRanges
            ) = 0;

        /// <summary>
        /// Queries the symbol provider to determine if we have line info. Used by debug
        /// monitor to decide if location can be considered user code.
        /// </summary>
        /// <param name="pInstruction">
        /// [In] DkmInstructionSymbol represents a method in the target process.
        /// </param>
        /// <param name="pResult">
        /// [Out] True if there is line info for this location.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE HasLineInfo(
            _In_ Symbols::DkmInstructionSymbol* pInstruction,
            _Out_ bool* pResult
            ) = 0;

        /// <summary>
        /// GetEntryPointSymbols is used by the breakpoint manager to find the entry point
        /// symbol(s) in the launching executable. For managed code, this symbol is defined
        /// using ISymUnmanagedWriter::SetUserEntryPoint. For native code, this symbol is
        /// found by looking for the various 'main' function (main, WinMain, etc). A third
        /// can override the entry point either by implementing their own symbol provider or
        /// by implementing IDkmEntryPointQuery.
        /// </summary>
        /// <param name="pModule">
        /// [In] The DkmModule class represents a code bundle (ex: dll or exe) which is or
        /// once was loaded into one or more processes. The DkmModule class is the central
        /// object to the symbol APIs, and is 1:1 with the symbol handler's notation of what
        /// is loaded. If a code bundle loads into three different processes (or the same
        /// process but with three different base addresses or three different app domains)
        /// but the symbol handler thinks of all of these as being identical, there will be
        /// only one module object.
        /// </param>
        /// <param name="pPossibleEntryPoints">
        /// [Out] DkmInstructionSymbol[] represents a method in the target process.
        ///
        /// The memory for the DkmArray members is allocated by the method implementation
        /// using DkmAllocBytes/DkmAllocArray. It is freed by the caller using the
        /// CAutoDkmArray template or with DkmFreeMemory and manual element release.
        /// </param>
        /// <returns>
        /// S_OK is returned if pPossibleEntryPoints contains any elements, S_FALSE is
        /// indicates the array is empty, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE GetEntryPointSymbols(
            _In_ Symbols::DkmModule* pModule,
            _Out_ DkmArray<Symbols::DkmInstructionSymbol*>* pPossibleEntryPoints
            ) = 0;

        /// <summary>
        /// This method returns the IL offset range that contains the current IL offset as
        /// specified in the instruction address.
        /// </summary>
        /// <param name="pInstruction">
        /// [In] DkmInstructionSymbol represents a method in the target process.
        /// </param>
        /// <param name="pResult">
        /// [Out] A offset/size pair which is returned from the symbol provider to a debug
        /// monitor to indicate a range of instructions which the debugger should not stop
        /// at.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE GetCurrentStatementRange(
            _In_ Symbols::DkmInstructionSymbol* pInstruction,
            _Out_ Symbols::DkmSteppingRange* pResult
            ) = 0;

        /// <summary>
        /// Search a module's symbols for a function with the specified name. Returns the RVA
        /// and size if it is found.
        /// </summary>
        /// <param name="pModule">
        /// [In] The DkmModule class represents a code bundle (ex: dll or exe) which is or
        /// once was loaded into one or more processes. The DkmModule class is the central
        /// object to the symbol APIs, and is 1:1 with the symbol handler's notation of what
        /// is loaded. If a code bundle loads into three different processes (or the same
        /// process but with three different base addresses or three different app domains)
        /// but the symbol handler thinks of all of these as being identical, there will be
        /// only one module object.
        /// </param>
        /// <param name="pFunctionName">
        /// [In] The name of the function to search for.
        /// </param>
        /// <param name="pResults">
        /// [Out] The RVA / size pairs from the query.
        ///
        /// The memory for the DkmArray members is allocated by the method implementation
        /// using DkmAllocBytes/DkmAllocArray. It is freed by the caller using the
        /// CAutoDkmArray template or with DkmFreeMemory and manual element release.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE GetFunctionInfo(
            _In_ Symbols::DkmModule* pModule,
            _In_ DkmString* pFunctionName,
            _Out_ DkmArray<Symbols::DkmRVASizePair>* pResults
            ) = 0;
    };

    // This API is used to read information about a symbol.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // SymbolProviderId.
    #define IID_IDkmSymbolQuery __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmSymbolQuery)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("50279314-b4bf-95de-7ef2-c83f7fe7953e") IDkmSymbolQuery : public IUnknown
    {
        /// <summary>
        /// GetSymbolInterface is used to obtain a raw COM interface to a symbol store. This
        /// is useful to either callers that find the symbol abstraction presented by the
        /// debugger to be either too restrictive for their needs, or simply undesirable due
        /// to how their component is implemented.
        /// </summary>
        /// <param name="pModule">
        /// [In] The DkmModule class represents a code bundle (ex: dll or exe) which is or
        /// once was loaded into one or more processes. The DkmModule class is the central
        /// object to the symbol APIs, and is 1:1 with the symbol handler's notation of what
        /// is loaded. If a code bundle loads into three different processes (or the same
        /// process but with three different base addresses or three different app domains)
        /// but the symbol handler thinks of all of these as being identical, there will be
        /// only one module object.
        /// </param>
        /// <param name="InterfaceID">
        /// [In] The GUID of the desired interface. Microsoft supports IID_IDiaSession for
        /// Native DkmModule's, and IID_ISymUnmanagedReader for Managed modules.
        /// </param>
        /// <param name="ppSymbolInterface">
        /// [Out] Returned symbol interface. This may be cast to the interface pointer
        /// corresponding to 'InterfaceID'.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE GetSymbolInterface(
            _In_ Symbols::DkmModule* pModule,
            _In_ const GUID& InterfaceID,
            _Deref_out_ IUnknown** ppSymbolInterface
            ) = 0;

        /// <summary>
        /// Returns the source file position (ex: example.cs, line 12) of this instruction
        /// symbol. If this instruction symbol is not associated with a source file then null
        /// is returned (S_FALSE return code in native).
        /// </summary>
        /// <param name="pInstruction">
        /// [In] DkmInstructionSymbol represents a method in the target process.
        /// </param>
        /// <param name="Flags">
        /// [In] Flags which affect the behavior of 'GetSourcePosition'.
        /// </param>
        /// <param name="pInspectionSession">
        /// [In,Optional] A reference object describing the current inspection session.
        /// Common usage is for symbol providers to cache lookups using its data container.
        /// </param>
        /// <param name="pStartOfLine">
        /// [Out] True if this address is the first address in the line's range. False
        /// otherwise.
        /// </param>
        /// <param name="ppSourcePosition">
        /// [Out,Optional] Source code position which corresponds to a code element. The
        /// could represent a location which has been extracted from a symbol (PDB) file, or
        /// it could be the location of a breakpoint in the IDE.
        /// </param>
        /// <returns>
        /// S_OK is returned if *ppSourcePosition is non-NULL, S_FALSE is returned when
        /// *ppSourcePosition is NULL, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE GetSourcePosition(
            _In_ Symbols::DkmInstructionSymbol* pInstruction,
            _In_ Symbols::DkmSourcePositionFlags_t Flags,
            _In_opt_ Evaluation::DkmInspectionSession* pInspectionSession,
            _Out_ bool* pStartOfLine,
            _Deref_out_opt_ Symbols::DkmSourcePosition** ppSourcePosition
            ) = 0;
    };

    // Allows remote components to obtain source position information when the symbol
    // provider is on the VS machine.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // RuntimeId, SymbolProviderId.
    #define IID_IDkmSymbolQueryCallback __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmSymbolQueryCallback)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("fba8efe6-fd22-340c-3188-6ae79d95c9d7") IDkmSymbolQueryCallback : public IUnknown
    {
        /// <summary>
        /// Returns the source file position (ex: example.cs, line 12) of this instruction
        /// symbol. If this instruction symbol is not associated with a source file then null
        /// is returned (S_FALSE return code in native).
        /// </summary>
        /// <param name="pInstruction">
        /// [In] DkmInstructionSymbol represents a method in the target process.
        /// </param>
        /// <param name="Flags">
        /// [In] Flags which affect the behavior of 'GetSourcePosition'.
        /// </param>
        /// <param name="pInspectionSession">
        /// [In,Optional] A reference object describing the current inspection session.
        /// Common usage is for symbol providers to cache lookups using its data container.
        /// </param>
        /// <param name="pStartOfLine">
        /// [Out] True if this address is the first address in the line's range. False
        /// otherwise.
        /// </param>
        /// <param name="ppSourcePosition">
        /// [Out,Optional] Source code position which corresponds to a code element. The
        /// could represent a location which has been extracted from a symbol (PDB) file, or
        /// it could be the location of a breakpoint in the IDE.
        /// </param>
        /// <returns>
        /// S_OK is returned if *ppSourcePosition is non-NULL, S_FALSE is returned when
        /// *ppSourcePosition is NULL, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE GetSourcePositionCallback(
            _In_ Symbols::DkmInstructionSymbol* pInstruction,
            _In_ Symbols::DkmSourcePositionFlags_t Flags,
            _In_opt_ Evaluation::DkmInspectionSession* pInspectionSession,
            _Out_ bool* pStartOfLine,
            _Deref_out_opt_ Symbols::DkmSourcePosition** ppSourcePosition
            ) = 0;
    };

    // Determines if a frame is user or nonuser when such determination was not made when the
    // frame was created.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // BaseDebugMonitorId, EngineId, RuntimeId, SymbolProviderId, TransportKind.
    //
    // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
    #define IID_IDkmUserCodeDeterminer __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmUserCodeDeterminer)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("73ba8775-e814-4f5b-8581-89f0a3fa7efb") IDkmUserCodeDeterminer : public IUnknown
    {
        /// <summary>
        /// Determines whether or not a frame is user code.
        /// </summary>
        /// <param name="pFrame">
        /// [In] DkmStackWalkFrame represents a frame on a call stack which has been walked,
        /// but may not have been formatted or filtered. Formatted frames are represented by
        /// DkmStackFrame instead.
        /// </param>
        /// <param name="pInspectionSession">
        /// [In,Optional] Optional inspection session which may be used for caching purposes.
        /// The same inspection session is reused when computing the user status of multiple
        /// frames in succession.
        /// </param>
        /// <param name="pUser">
        /// [Out] True if the frame is user code, false if the frame is nonuser code.
        /// </param>
        /// <param name="pExceptionImplementation">
        /// [Out] True if the frame is library code that implements the throwing of
        /// exceptions.  This will cause the frame to be collapsed if we are stopped here in
        /// response to an exception being thrown.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE ComputeUserStatus(
            _In_ CallStack::DkmStackWalkFrame* pFrame,
            _In_opt_ Evaluation::DkmInspectionSession* pInspectionSession,
            _Out_ bool* pUser,
            _Out_ bool* pExceptionImplementation
            ) = 0;
    };

}; // end of Symbol handlers interfaces


// Events interfaces
// These interfaces may be implemented by any component. They provide notification about
// events that occurred in the target process.
namespace ComponentInterfaces
{
    // IDkmAsyncBreakCompleteNotification is implemented by components that want to listen
    // for the AsyncBreakComplete event. IDkmAsyncBreakCompleteNotification is invoked after
    // all implementations of IDkmAsyncBreakCompleteReceived. When this notification is
    // called, the target process is stopped and implementers are able to either inspect the
    // process or cause it to execute in a controlled manner (slip, func-eval).
    //
    // Sent by a debug monitor after a request to async break the process has completed.
    //
    // AsyncBreakComplete events can be suppressed by calling DkmEventDescriptorS.Suppress().
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // BaseDebugMonitorId, EngineId, TransportKind.
    #define IID_IDkmAsyncBreakCompleteNotification __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmAsyncBreakCompleteNotification)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("badc52a7-5bc0-82dc-122d-ad6136dd381f") IDkmAsyncBreakCompleteNotification : public IUnknown
    {
        /// <summary>
        /// OnAsyncBreakComplete is invoked as part of event processing. See interface
        /// definition for more information.
        /// </summary>
        /// <param name="pProcess">
        /// [In] DkmProcess represents a target process which is being debugged. The debugger
        /// debugs processes, so this is the basic unit of debugging. A DkmProcess can
        /// represent a system process or a virtual process such as minidumps.
        /// </param>
        /// <param name="Status">
        /// [In] Indicates the type of async-break that occurred.
        /// </param>
        /// <param name="pThread">
        /// [In] DkmThread represents a thread running in the target process.
        /// </param>
        /// <param name="pEventDescriptor">
        /// [In] Describes the event being processed and provides the ability for a component
        /// to suppress this event.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE OnAsyncBreakComplete(
            _In_ DkmProcess* pProcess,
            _In_ DkmAsyncBreakStatus_t Status,
            _In_ DkmThread* pThread,
            _In_ DkmEventDescriptorS* pEventDescriptor
            ) = 0;
    };

    // IDkmAsyncBreakCompleteReceived is implemented by components that want to listen for
    // the AsyncBreakComplete event. IDkmAsyncBreakCompleteReceived is invoked before
    // IDkmAsyncBreakCompleteNotification. From within this notification, it is not possible
    // to cause the target process to execute (no func-eval, no slipping).
    //
    // Sent by a debug monitor after a request to async break the process has completed.
    //
    // AsyncBreakComplete events can be suppressed by calling DkmEventDescriptorS.Suppress().
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // BaseDebugMonitorId, EngineId, TransportKind.
    #define IID_IDkmAsyncBreakCompleteReceived __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmAsyncBreakCompleteReceived)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("f7956633-ffd0-dab1-5b16-ca5327112b93") IDkmAsyncBreakCompleteReceived : public IUnknown
    {
        /// <summary>
        /// OnAsyncBreakCompleteReceived is invoked as part of event processing. See
        /// interface definition for more information.
        /// </summary>
        /// <param name="pProcess">
        /// [In] DkmProcess represents a target process which is being debugged. The debugger
        /// debugs processes, so this is the basic unit of debugging. A DkmProcess can
        /// represent a system process or a virtual process such as minidumps.
        /// </param>
        /// <param name="Status">
        /// [In] Indicates the type of async-break that occurred.
        /// </param>
        /// <param name="pThread">
        /// [In] DkmThread represents a thread running in the target process.
        /// </param>
        /// <param name="pEventDescriptor">
        /// [In] Describes the event being processed and provides the ability for a component
        /// to suppress this event.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE OnAsyncBreakCompleteReceived(
            _In_ DkmProcess* pProcess,
            _In_ DkmAsyncBreakStatus_t Status,
            _In_ DkmThread* pThread,
            _In_ DkmEventDescriptorS* pEventDescriptor
            ) = 0;
    };

    // Provides notification that the process is about to continue execution. This function
    // is called before any relevant steppers are initialized, so func-evals can be executed.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // BaseDebugMonitorId, EngineId, TransportKind.
    //
    // This API was introduced in Visual Studio 14 RTM (DkmApiVersion.VS14RTM).
    #define IID_IDkmBeforeContinueExecutionNotification __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmBeforeContinueExecutionNotification)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("d91e112f-bcd1-4888-5ad1-2e7cdc8736b8") IDkmBeforeContinueExecutionNotification : public IUnknown
    {
        /// <summary>
        /// Handler which is notified before the target process is resumed.
        /// </summary>
        /// <param name="pThread">
        /// [In] DkmThread represents a thread running in the target process.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE BeforeContinueExecution(
            _In_ DkmThread* pThread
            ) = 0;
    };

    // Provides notification that the process is about to be detached or terminated.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // BaseDebugMonitorId, EngineId, TransportKind.
    //
    // This API was introduced in Visual Studio 14 RTM (DkmApiVersion.VS14RTM).
    #define IID_IDkmBeforeStopDebuggingNotification __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmBeforeStopDebuggingNotification)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("ee07228c-caad-1138-bb2d-8c3bfcdc245c") IDkmBeforeStopDebuggingNotification : public IUnknown
    {
        /// <summary>
        /// Handler which is notified before the target process is terminated or detached.
        /// </summary>
        /// <param name="pProcess">
        /// [In] DkmProcess represents a target process which is being debugged. The debugger
        /// debugs processes, so this is the basic unit of debugging. A DkmProcess can
        /// represent a system process or a virtual process such as minidumps.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE BeforeStopDebugging(
            _In_ DkmProcess* pProcess
            ) = 0;
    };

    // IDkmBinaryLoadedNotification is implemented by components that want to listen for the
    // BinaryLoaded event. When this notification fires, the target process will be suspended
    // and can be examined. Indicates that we have successfully loaded the binary of a module
    // in the minidump we are debugging.
    //
    // BinaryLoaded events can be suppressed by calling DkmEventDescriptorS.Suppress().
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // BaseDebugMonitorId, EngineId, RuntimeId, SymbolProviderId, TransportKind.
    //
    // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
    #define IID_IDkmBinaryLoadedNotification __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmBinaryLoadedNotification)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("ce3cbe07-9bc9-1a7a-7ee9-f2a975521222") IDkmBinaryLoadedNotification : public IUnknown
    {
        /// <summary>
        /// OnBinaryLoaded is invoked as part of event processing. See interface definition
        /// for more information.
        /// </summary>
        /// <param name="pModuleInstance">
        /// [In] The Module Instance class represent a code bundle (ex: dll or exe) which is
        /// loaded into a particular process at a particular location. Module Instance
        /// objects are 1:1 with the execution environment's notion of a code bundle. For
        /// example, in native code, Module Instance objects are 1:1 with base address.
        /// </param>
        /// <param name="pPath">
        /// [In] The full path, relative to the computer running Visual Studio to open the
        /// minidump, of the matching binary we were able to find.
        /// </param>
        /// <param name="pWorkList">
        /// WorkList to append additional event processing work to. This work list will begin
        /// execution after all listeners have been notifiied. The event will not finish
        /// until after the work list fully executes.
        /// </param>
        /// <param name="pEventDescriptor">
        /// [In] Describes the event being processed and provides the ability for a component
        /// to suppress this event.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE OnBinaryLoaded(
            _In_ DkmModuleInstance* pModuleInstance,
            _In_ DkmString* pPath,
            _In_ DkmWorkList* pWorkList,
            _In_ DkmEventDescriptorS* pEventDescriptor
            ) = 0;
    };

    // IDkmBinaryReloadOpportunityNotification is implemented by components that want to
    // listen for the BinaryReloadOpportunity event. When this notification fires, the target
    // process will be suspended and can be examined. While minidump debugging, raised by
    // MinidumpBDM to relocate binary when user tries to manually load binary.
    //
    // BinaryReloadOpportunity events can be suppressed by calling
    // DkmEventDescriptorS.Suppress().
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // BaseDebugMonitorId, EngineId, RuntimeId, SymbolProviderId, TransportKind.
    //
    // This API was introduced in Visual Studio 12 Update 2 (DkmApiVersion.VS12Update2).
    #define IID_IDkmBinaryReloadOpportunityNotification __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmBinaryReloadOpportunityNotification)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("f6619d5b-abe8-f419-74c7-79c6fed36da8") IDkmBinaryReloadOpportunityNotification : public IUnknown
    {
        /// <summary>
        /// OnBinaryReloadOpportunity is invoked as part of event processing. See interface
        /// definition for more information.
        /// </summary>
        /// <param name="pModuleInstance">
        /// [In] The Module Instance class represent a code bundle (ex: dll or exe) which is
        /// loaded into a particular process at a particular location. Module Instance
        /// objects are 1:1 with the execution environment's notion of a code bundle. For
        /// example, in native code, Module Instance objects are 1:1 with base address.
        /// </param>
        /// <param name="pWorkList">
        /// WorkList to append additional event processing work to. This work list will begin
        /// execution after all listeners have been notifiied. The event will not finish
        /// until after the work list fully executes.
        /// </param>
        /// <param name="pEventDescriptor">
        /// [In] Describes the event being processed and provides the ability for a component
        /// to suppress this event.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE OnBinaryReloadOpportunity(
            _In_ DkmModuleInstance* pModuleInstance,
            _In_ DkmWorkList* pWorkList,
            _In_ DkmEventDescriptorS* pEventDescriptor
            ) = 0;
    };

    // IDkmComputeKernelExitNotification is implemented by components that want to listen for
    // the ComputeKernelExit event. The target process may continue to run during this
    // notification. The event when a GPU compute kernel completes.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // BaseDebugMonitorId, EngineId, TransportKind.
    #define IID_IDkmComputeKernelExitNotification __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmComputeKernelExitNotification)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("03881c24-d3ab-0fab-93f6-f78ea8491a8e") IDkmComputeKernelExitNotification : public IUnknown
    {
        /// <summary>
        /// OnComputeKernelExit is invoked as part of event processing. See interface
        /// definition for more information.
        /// </summary>
        /// <param name="pComputeKernel">
        /// [In] DkmGPUComputeKernel represents a GPU compute kernel running in the target
        /// process.
        /// </param>
        /// <param name="ExitCode">
        /// [In] 32-bit value that the compute kernel returned on exit.
        /// </param>
        /// <param name="pEventDescriptor">
        /// [In] Describes the event being processed.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE OnComputeKernelExit(
            _In_ GPU::DkmGPUComputeKernel* pComputeKernel,
            _In_ UINT32 ExitCode,
            _In_ DkmEventDescriptor* pEventDescriptor
            ) = 0;
    };

    // IDkmCustomStopNotification is implemented by components that want to listen for the
    // CustomStop event. IDkmCustomStopNotification is invoked after all implementations of
    // IDkmCustomStopReceived. When this notification is called, the target process is
    // stopped and implementers are able to either inspect the process or cause it to execute
    // in a controlled manner (slip, func-eval).
    //
    // The CustomStop event allows a concord component to raise a stopping event to a custom
    // UI component or to a higher level Concord component.
    //
    // CustomStop events can be suppressed by calling DkmEventDescriptorS.Suppress().
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // BaseDebugMonitorId, EngineId, SourceId, TransportKind.
    #define IID_IDkmCustomStopNotification __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmCustomStopNotification)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("9ac75ab7-f351-4583-f4cc-cddbb17b38d0") IDkmCustomStopNotification : public IUnknown
    {
        /// <summary>
        /// OnCustomStop is invoked as part of event processing. See interface definition for
        /// more information.
        /// </summary>
        /// <param name="pCustomMessage">
        /// [In] Message structure used to pass information between custom debugger backend
        /// components and custom visual studio UI components (packages, add-ins, etc).
        /// </param>
        /// <param name="pThread">
        /// [In] DkmThread represents a thread running in the target process.
        /// </param>
        /// <param name="VsService">
        /// [In] Visual Studio service that this event should be sent to. A VS package must
        /// register this service id (ex:
        /// Software\Microsoft\VisualStudio\$(ver)\Services\{VsService}) and this package
        /// must implement the IVsCustomDebuggerStoppingEventHandler110 interface.
        /// </param>
        /// <param name="pEventDescriptor">
        /// [In] Describes the event being processed and provides the ability for a component
        /// to suppress this event.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE OnCustomStop(
            _In_ DkmCustomMessage* pCustomMessage,
            _In_ DkmThread* pThread,
            _In_ const GUID& VsService,
            _In_ DkmEventDescriptorS* pEventDescriptor
            ) = 0;
    };

    // IDkmCustomStopReceived is implemented by components that want to listen for the
    // CustomStop event. IDkmCustomStopReceived is invoked before IDkmCustomStopNotification.
    // From within this notification, it is not possible to cause the target process to
    // execute (no func-eval, no slipping).
    //
    // The CustomStop event allows a concord component to raise a stopping event to a custom
    // UI component or to a higher level Concord component.
    //
    // CustomStop events can be suppressed by calling DkmEventDescriptorS.Suppress().
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // BaseDebugMonitorId, EngineId, SourceId, TransportKind.
    #define IID_IDkmCustomStopReceived __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmCustomStopReceived)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("a22ab482-c40e-aae0-a1a0-d1e461a80551") IDkmCustomStopReceived : public IUnknown
    {
        /// <summary>
        /// OnCustomStopReceived is invoked as part of event processing. See interface
        /// definition for more information.
        /// </summary>
        /// <param name="pCustomMessage">
        /// [In] Message structure used to pass information between custom debugger backend
        /// components and custom visual studio UI components (packages, add-ins, etc).
        /// </param>
        /// <param name="pThread">
        /// [In] DkmThread represents a thread running in the target process.
        /// </param>
        /// <param name="VsService">
        /// [In] Visual Studio service that this event should be sent to. A VS package must
        /// register this service id (ex:
        /// Software\Microsoft\VisualStudio\$(ver)\Services\{VsService}) and this package
        /// must implement the IVsCustomDebuggerStoppingEventHandler110 interface.
        /// </param>
        /// <param name="pEventDescriptor">
        /// [In] Describes the event being processed and provides the ability for a component
        /// to suppress this event.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE OnCustomStopReceived(
            _In_ DkmCustomMessage* pCustomMessage,
            _In_ DkmThread* pThread,
            _In_ const GUID& VsService,
            _In_ DkmEventDescriptorS* pEventDescriptor
            ) = 0;
    };

    // IDkmEmbeddedBreakpointHitNotification is implemented by components that want to listen
    // for the EmbeddedBreakpointHit event. IDkmEmbeddedBreakpointHitNotification is invoked
    // after all implementations of IDkmEmbeddedBreakpointHitReceived. When this notification
    // is called, the target process is stopped and implementers are able to either inspect
    // the process or cause it to execute in a controlled manner (slip, func-eval).
    //
    // Sent by the exception manager when an embedded breakpoint exception is encountered.
    // Components beneath the exception manager must listen for the platform specific
    // exception event instead.
    //
    // EmbeddedBreakpointHit events can be suppressed. If this event reaches the AD7 layer,
    // the debugger will enter break mode.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // BaseDebugMonitorId, EngineId, TransportKind.
    #define IID_IDkmEmbeddedBreakpointHitNotification __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmEmbeddedBreakpointHitNotification)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("0649e942-bb3d-6cf0-44e9-0378b3b2a263") IDkmEmbeddedBreakpointHitNotification : public IUnknown
    {
        /// <summary>
        /// OnEmbeddedBreakpointHit is invoked as part of event processing. See interface
        /// definition for more information.
        /// </summary>
        /// <param name="pThread">
        /// [In] DkmThread represents a thread running in the target process.
        /// </param>
        /// <param name="pInstructionAddress">
        /// [In,Optional] The address where the embedded breakpoint was hit.
        /// </param>
        /// <param name="ShowAsException">
        /// [In] If true, the UI will display an exception hit dialog for a breakpoint
        /// exception. If false, UI will simply break and the DkmInstructionAddress is not
        /// used.
        /// </param>
        /// <param name="pEventDescriptor">
        /// [In] Describes the event being processed and provides the ability for a component
        /// to suppress this event.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE OnEmbeddedBreakpointHit(
            _In_ DkmThread* pThread,
            _In_opt_ DkmInstructionAddress* pInstructionAddress,
            _In_ bool ShowAsException,
            _In_ DkmEventDescriptorS* pEventDescriptor
            ) = 0;
    };

    // IDkmEmbeddedBreakpointHitReceived is implemented by components that want to listen for
    // the EmbeddedBreakpointHit event. IDkmEmbeddedBreakpointHitReceived is invoked before
    // IDkmEmbeddedBreakpointHitNotification. From within this notification, it is not
    // possible to cause the target process to execute (no func-eval, no slipping).
    //
    // Sent by the exception manager when an embedded breakpoint exception is encountered.
    // Components beneath the exception manager must listen for the platform specific
    // exception event instead.
    //
    // EmbeddedBreakpointHit events can be suppressed. If this event reaches the AD7 layer,
    // the debugger will enter break mode.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // BaseDebugMonitorId, EngineId, TransportKind.
    #define IID_IDkmEmbeddedBreakpointHitReceived __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmEmbeddedBreakpointHitReceived)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("498ca3ad-e538-b4b7-5323-657234721f9f") IDkmEmbeddedBreakpointHitReceived : public IUnknown
    {
        /// <summary>
        /// OnEmbeddedBreakpointHitReceived is invoked as part of event processing. See
        /// interface definition for more information.
        /// </summary>
        /// <param name="pThread">
        /// [In] DkmThread represents a thread running in the target process.
        /// </param>
        /// <param name="pInstructionAddress">
        /// [In,Optional] The address where the embedded breakpoint was hit.
        /// </param>
        /// <param name="ShowAsException">
        /// [In] If true, the UI will display an exception hit dialog for a breakpoint
        /// exception. If false, UI will simply break and the DkmInstructionAddress is not
        /// used.
        /// </param>
        /// <param name="pEventDescriptor">
        /// [In] Describes the event being processed and provides the ability for a component
        /// to suppress this event.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE OnEmbeddedBreakpointHitReceived(
            _In_ DkmThread* pThread,
            _In_opt_ DkmInstructionAddress* pInstructionAddress,
            _In_ bool ShowAsException,
            _In_ DkmEventDescriptorS* pEventDescriptor
            ) = 0;
    };

    // IDkmExceptionTriggerHitNotification is implemented by components that want to listen
    // for the ExceptionTriggerHit event. IDkmExceptionTriggerHitNotification is invoked
    // after all implementations of IDkmExceptionTriggerHitReceived. When this notification
    // is called, the target process is stopped and implementers are able to either inspect
    // the process or cause it to execute in a controlled manner (slip, func-eval).
    //
    // The 'ExceptionTriggerHit' event provides notification that a previously set
    // DkmExceptionTrigger has been met.
    //
    // ExceptionTriggerHit events can be suppressed by calling
    // DkmEventDescriptorS.Suppress().
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // BaseDebugMonitorId, EngineId, RuntimeId, SourceId.
    #define IID_IDkmExceptionTriggerHitNotification __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmExceptionTriggerHitNotification)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("ee701d2f-eabe-6525-51cf-60578d77548f") IDkmExceptionTriggerHitNotification : public IUnknown
    {
        /// <summary>
        /// OnExceptionTriggerHit is invoked as part of event processing. See interface
        /// definition for more information.
        /// </summary>
        /// <param name="pHit">
        /// [In] Provides information about an exception trigger which was satisfied (hit) by
        /// an exception coming from the target process.
        /// </param>
        /// <param name="pEventDescriptor">
        /// [In] Describes the event being processed and provides the ability for a component
        /// to suppress this event.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE OnExceptionTriggerHit(
            _In_ Exceptions::DkmExceptionTriggerHit* pHit,
            _In_ DkmEventDescriptorS* pEventDescriptor
            ) = 0;
    };

    // IDkmExceptionTriggerHitReceived is implemented by components that want to listen for
    // the ExceptionTriggerHit event. IDkmExceptionTriggerHitReceived is invoked before
    // IDkmExceptionTriggerHitNotification. From within this notification, it is not possible
    // to cause the target process to execute (no func-eval, no slipping).
    //
    // The 'ExceptionTriggerHit' event provides notification that a previously set
    // DkmExceptionTrigger has been met.
    //
    // ExceptionTriggerHit events can be suppressed by calling
    // DkmEventDescriptorS.Suppress().
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // BaseDebugMonitorId, EngineId, RuntimeId, SourceId.
    #define IID_IDkmExceptionTriggerHitReceived __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmExceptionTriggerHitReceived)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("b999d394-289b-6845-52ee-c742f756690e") IDkmExceptionTriggerHitReceived : public IUnknown
    {
        /// <summary>
        /// OnExceptionTriggerHitReceived is invoked as part of event processing. See
        /// interface definition for more information.
        /// </summary>
        /// <param name="pHit">
        /// [In] Provides information about an exception trigger which was satisfied (hit) by
        /// an exception coming from the target process.
        /// </param>
        /// <param name="pEventDescriptor">
        /// [In] Describes the event being processed and provides the ability for a component
        /// to suppress this event.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE OnExceptionTriggerHitReceived(
            _In_ Exceptions::DkmExceptionTriggerHit* pHit,
            _In_ DkmEventDescriptorS* pEventDescriptor
            ) = 0;
    };

    // IDkmFuncEvalCompletedNotification is implemented by components that want to listen for
    // the FuncEvalCompleted event. The target process may continue to run during this
    // notification. The FuncEvalCompleted event is sent after a function evaluation has
    // completed.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // BaseDebugMonitorId, EngineId, TransportKind.
    #define IID_IDkmFuncEvalCompletedNotification __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmFuncEvalCompletedNotification)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("fdda405d-d47d-5f7f-0dc0-e0de4550160d") IDkmFuncEvalCompletedNotification : public IUnknown
    {
        /// <summary>
        /// OnFuncEvalCompleted is invoked as part of event processing. See interface
        /// definition for more information.
        /// </summary>
        /// <param name="pThread">
        /// [In] DkmThread represents a thread running in the target process.
        /// </param>
        /// <param name="Flags">
        /// [In] Flags impacting how function evaluation requests are performed.
        /// </param>
        /// <param name="pEventDescriptor">
        /// [In] Describes the event being processed.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE OnFuncEvalCompleted(
            _In_ DkmThread* pThread,
            _In_ Evaluation::DkmFuncEvalFlags_t Flags,
            _In_ DkmEventDescriptor* pEventDescriptor
            ) = 0;
    };

    // IDkmFuncEvalStartingNotification is implemented by components that want to listen for
    // the FuncEvalStarting event. The target process may continue to run during this
    // notification. The FuncEvalStarting event is sent just before a function evaluation is
    // started. In the case of nested break state, each new function evaluation will trigger
    // another FuncEvalStarting event. In this scenario, the target stops, and a user
    // performs an evaluation from the immediate window which triggers a FuncEvalStarting
    // event. The user hits a breakpoint within their evaluated function, the user does a
    // second evaluation from there which triggers a second FuncEvalStarting event. The user
    // lets both evaluations complete and this triggers two FuncEvalCompleted events.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // BaseDebugMonitorId, EngineId, TransportKind.
    #define IID_IDkmFuncEvalStartingNotification __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmFuncEvalStartingNotification)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("bace2c45-da04-b755-9a20-56dbf143d5ca") IDkmFuncEvalStartingNotification : public IUnknown
    {
        /// <summary>
        /// OnFuncEvalStarting is invoked as part of event processing. See interface
        /// definition for more information.
        /// </summary>
        /// <param name="pThread">
        /// [In] DkmThread represents a thread running in the target process.
        /// </param>
        /// <param name="Flags">
        /// [In] Flags impacting how function evaluation requests are performed.
        /// </param>
        /// <param name="pEventDescriptor">
        /// [In] Describes the event being processed.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE OnFuncEvalStarting(
            _In_ DkmThread* pThread,
            _In_ Evaluation::DkmFuncEvalFlags_t Flags,
            _In_ DkmEventDescriptor* pEventDescriptor
            ) = 0;
    };

    // Interface implemented by components that want to find out when active (non-hidden)
    // debugging of a hosting process (ex: my_app.vshost.exe) begins.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // BaseDebugMonitorId, EngineId, TransportKind.
    //
    // This API was introduced in Visual Studio 14 RTM (DkmApiVersion.VS14RTM).
    #define IID_IDkmHostingProcessShowNotification __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmHostingProcessShowNotification)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("6ab5f1ac-55f8-ab09-f778-27684274788d") IDkmHostingProcessShowNotification : public IUnknown
    {
        /// <summary>
        /// This notification is called for hosting processes (processes that have
        /// DkmProcess.StartMethod == DkmStartMethod.AttachForHostingLaunch) when the user
        /// invokes an action that causes the debugger to begin active debugging of the
        /// process. The debugger will begin background debugging the hosting process soon
        /// after the solution opens. This notification gives components a chance to take
        /// some action just before active debugging begins.
        /// </summary>
        /// <param name="pProcess">
        /// [In] DkmProcess represents a target process which is being debugged. The debugger
        /// debugs processes, so this is the basic unit of debugging. A DkmProcess can
        /// represent a system process or a virtual process such as minidumps.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE OnHostingProcessShow(
            _In_ DkmProcess* pProcess
            ) = 0;
    };

    // IDkmInterceptExceptionCompletedNotification is implemented by components that want to
    // listen for the InterceptExceptionCompleted event.
    // IDkmInterceptExceptionCompletedNotification is invoked after all implementations of
    // IDkmInterceptExceptionCompletedReceived. When this notification is called, the target
    // process is stopped and implementers are able to either inspect the process or cause it
    // to execute in a controlled manner (slip, func-eval).
    //
    // Sent by a debug monitor after an exception has been unwound to a specified frame.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // BaseDebugMonitorId, EngineId, TransportKind.
    #define IID_IDkmInterceptExceptionCompletedNotification __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmInterceptExceptionCompletedNotification)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("563d7656-69cb-a569-1ffd-32c3c6947c7c") IDkmInterceptExceptionCompletedNotification : public IUnknown
    {
        /// <summary>
        /// OnInterceptExceptionCompleted is invoked as part of event processing. See
        /// interface definition for more information.
        /// </summary>
        /// <param name="pThread">
        /// [In] DkmThread represents a thread running in the target process.
        /// </param>
        /// <param name="Cookie">
        /// [In] Cookie that was handed out when intercept exception request came in.
        /// </param>
        /// <param name="pEventDescriptor">
        /// [In] Describes the event being processed.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE OnInterceptExceptionCompleted(
            _In_ DkmThread* pThread,
            _In_ UINT64 Cookie,
            _In_ DkmEventDescriptor* pEventDescriptor
            ) = 0;
    };

    // IDkmInterceptExceptionCompletedReceived is implemented by components that want to
    // listen for the InterceptExceptionCompleted event.
    // IDkmInterceptExceptionCompletedReceived is invoked before
    // IDkmInterceptExceptionCompletedNotification. From within this notification, it is not
    // possible to cause the target process to execute (no func-eval, no slipping).
    //
    // Sent by a debug monitor after an exception has been unwound to a specified frame.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // BaseDebugMonitorId, EngineId, TransportKind.
    #define IID_IDkmInterceptExceptionCompletedReceived __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmInterceptExceptionCompletedReceived)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("be0d2a66-c172-f03c-5ac5-019034714c90") IDkmInterceptExceptionCompletedReceived : public IUnknown
    {
        /// <summary>
        /// OnInterceptExceptionCompletedReceived is invoked as part of event processing. See
        /// interface definition for more information.
        /// </summary>
        /// <param name="pThread">
        /// [In] DkmThread represents a thread running in the target process.
        /// </param>
        /// <param name="Cookie">
        /// [In] Cookie that was handed out when intercept exception request came in.
        /// </param>
        /// <param name="pEventDescriptor">
        /// [In] Describes the event being processed.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE OnInterceptExceptionCompletedReceived(
            _In_ DkmThread* pThread,
            _In_ UINT64 Cookie,
            _In_ DkmEventDescriptor* pEventDescriptor
            ) = 0;
    };

    // IDkmLoadCompleteNotification is implemented by components that want to listen for the
    // LoadComplete event. When this notification fires, the target process will be suspended
    // and can be examined. LoadComplete is sent by the base debug monitor when launching or
    // attaching to the process has completed.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // BaseDebugMonitorId, EngineId, TransportKind.
    #define IID_IDkmLoadCompleteNotification __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmLoadCompleteNotification)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("cdc5ec64-65bf-7daa-c591-da0b1f4174d9") IDkmLoadCompleteNotification : public IUnknown
    {
        /// <summary>
        /// OnLoadComplete is invoked as part of event processing. See interface definition
        /// for more information.
        /// </summary>
        /// <param name="pProcess">
        /// [In] DkmProcess represents a target process which is being debugged. The debugger
        /// debugs processes, so this is the basic unit of debugging. A DkmProcess can
        /// represent a system process or a virtual process such as minidumps.
        /// </param>
        /// <param name="pWorkList">
        /// WorkList to append additional event processing work to. This work list will begin
        /// execution after all listeners have been notifiied. The event will not finish
        /// until after the work list fully executes.
        /// </param>
        /// <param name="pEventDescriptor">
        /// [In] Describes the event being processed.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE OnLoadComplete(
            _In_ DkmProcess* pProcess,
            _In_ DkmWorkList* pWorkList,
            _In_ DkmEventDescriptor* pEventDescriptor
            ) = 0;
    };

    // IDkmModuleCreateNotification is implemented by components that want to listen for the
    // ModuleCreate event. The target process may continue to run during this notification.
    // ModuleCreate is sent when a symbol provider loads a new symbols, and thus a new
    // DkmModule is created. A DkmModule will exist only for module instances that have
    // symbols.
    //
    // ModuleCreate events can be suppressed. In this case the module will be invisible to
    // components above the level where the module was suppressed.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // CompilerVendorId, LanguageId, SymbolProviderId, TransportKind.
    #define IID_IDkmModuleCreateNotification __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmModuleCreateNotification)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("81e5403b-0fb0-24fe-c2ed-0cafff8b2da2") IDkmModuleCreateNotification : public IUnknown
    {
        /// <summary>
        /// OnModuleCreate is invoked as part of event processing. See interface definition
        /// for more information.
        /// </summary>
        /// <param name="pModule">
        /// [In] The DkmModule class represents a code bundle (ex: dll or exe) which is or
        /// once was loaded into one or more processes. The DkmModule class is the central
        /// object to the symbol APIs, and is 1:1 with the symbol handler's notation of what
        /// is loaded. If a code bundle loads into three different processes (or the same
        /// process but with three different base addresses or three different app domains)
        /// but the symbol handler thinks of all of these as being identical, there will be
        /// only one module object.
        /// </param>
        /// <param name="pEventDescriptor">
        /// [In] Describes the event being processed and provides the ability for a component
        /// to suppress this event.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE OnModuleCreate(
            _In_ Symbols::DkmModule* pModule,
            _In_ DkmEventDescriptorS* pEventDescriptor
            ) = 0;
    };

    // IDkmModuleInstanceLoadNotification is implemented by components that want to listen
    // for the ModuleInstanceLoad event. When this notification fires, the target process
    // will be suspended and can be examined. ModuleInstanceLoad is fired when a module is
    // loaded by a target process. Among other things, this event is used for symbol
    // providers to load symbols, and for the breakpoint manager to set breakpoints.
    // ModuleInstanceLoad fires for all modules, even if there are no symbols loaded.
    //
    // ModuleInstanceLoad events can be suppressed. In this case the module will be invisible
    // to components above the level where the module was suppressed.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // BaseDebugMonitorId, EngineId, RuntimeId, SymbolProviderId, TransportKind.
    #define IID_IDkmModuleInstanceLoadNotification __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmModuleInstanceLoadNotification)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("dce74a01-7d98-358b-4a2a-71f0f2ab7af4") IDkmModuleInstanceLoadNotification : public IUnknown
    {
        /// <summary>
        /// OnModuleInstanceLoad is invoked as part of event processing. See interface
        /// definition for more information.
        /// </summary>
        /// <param name="pModuleInstance">
        /// [In] The Module Instance class represent a code bundle (ex: dll or exe) which is
        /// loaded into a particular process at a particular location. Module Instance
        /// objects are 1:1 with the execution environment's notion of a code bundle. For
        /// example, in native code, Module Instance objects are 1:1 with base address.
        /// </param>
        /// <param name="pWorkList">
        /// WorkList to append additional event processing work to. This work list will begin
        /// execution after all listeners have been notifiied. The event will not finish
        /// until after the work list fully executes.
        /// </param>
        /// <param name="pEventDescriptor">
        /// [In] Describes the event being processed and provides the ability for a component
        /// to suppress this event.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE OnModuleInstanceLoad(
            _In_ DkmModuleInstance* pModuleInstance,
            _In_ DkmWorkList* pWorkList,
            _In_ DkmEventDescriptorS* pEventDescriptor
            ) = 0;
    };

    // IDkmModuleInstanceUnloadNotification is implemented by components that want to listen
    // for the ModuleInstanceUnload event. When this notification fires, the target process
    // will be suspended and can be examined. ModuleInstanceUnload is sent when the monitor
    // detects that a module has unloaded from within the target process.
    //
    // ModuleInstanceUnload events cannot be suppressed. However, if the ModuleLoad event was
    // suppressed then ModuleUnload will stop processing at the level where ModuleLoad was
    // suppressed.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // BaseDebugMonitorId, EngineId, RuntimeId, SymbolProviderId, TransportKind.
    #define IID_IDkmModuleInstanceUnloadNotification __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmModuleInstanceUnloadNotification)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("a77edc8e-82c8-7718-a67b-3fa2b8a33d71") IDkmModuleInstanceUnloadNotification : public IUnknown
    {
        /// <summary>
        /// OnModuleInstanceUnload is invoked as part of event processing. See interface
        /// definition for more information.
        /// </summary>
        /// <param name="pModuleInstance">
        /// [In] The Module Instance class represent a code bundle (ex: dll or exe) which is
        /// loaded into a particular process at a particular location. Module Instance
        /// objects are 1:1 with the execution environment's notion of a code bundle. For
        /// example, in native code, Module Instance objects are 1:1 with base address.
        /// </param>
        /// <param name="pWorkList">
        /// WorkList to append additional event processing work to. This work list will begin
        /// execution after all listeners have been notifiied. The event will not finish
        /// until after the work list fully executes.
        /// </param>
        /// <param name="pEventDescriptor">
        /// [In] Describes the event being processed.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE OnModuleInstanceUnload(
            _In_ DkmModuleInstance* pModuleInstance,
            _In_ DkmWorkList* pWorkList,
            _In_ DkmEventDescriptor* pEventDescriptor
            ) = 0;
    };

    // Components should implement this interface to be informed of when a module changes due
    // to EnC or dynamically emitted code.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // BaseDebugMonitorId, EngineId, RuntimeId, SymbolProviderId, TransportKind.
    //
    // This API was introduced in Visual Studio 14 RTM (DkmApiVersion.VS14RTM).
    #define IID_IDkmModuleModifiedNotification __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmModuleModifiedNotification)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("1092fe5b-e9bd-127d-088b-d9ee7b649559") IDkmModuleModifiedNotification : public IUnknown
    {
        /// <summary>
        /// This method is called when a module changes due to EnC or dynamically emitted
        /// code.
        /// </summary>
        /// <param name="pModuleInstance">
        /// [In] The Module Instance class represent a code bundle (ex: dll or exe) which is
        /// loaded into a particular process at a particular location. Module Instance
        /// objects are 1:1 with the execution environment's notion of a code bundle. For
        /// example, in native code, Module Instance objects are 1:1 with base address.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE OnModuleModified(
            _In_ DkmModuleInstance* pModuleInstance
            ) = 0;
    };

    // IDkmModuleSymbolsLoadedNotification is implemented by components that want to listen
    // for the ModuleSymbolsLoaded event. When this notification fires, the target process
    // will be suspended and can be examined. ModuleSymbolsLoaded is sent after symbols have
    // been loaded for a particular module instance. This is sent either when symbols are
    // loaded as a dll/exe loads in the target process, or after the user asks to reload
    // symbols.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // BaseDebugMonitorId, EngineId, RuntimeId, SymbolProviderId, TransportKind.
    #define IID_IDkmModuleSymbolsLoadedNotification __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmModuleSymbolsLoadedNotification)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("942ad74e-dc07-38e9-b86e-1ba99fed3c41") IDkmModuleSymbolsLoadedNotification : public IUnknown
    {
        /// <summary>
        /// OnModuleSymbolsLoaded is invoked as part of event processing. See interface
        /// definition for more information.
        /// </summary>
        /// <param name="pModuleInstance">
        /// [In] The Module Instance class represent a code bundle (ex: dll or exe) which is
        /// loaded into a particular process at a particular location. Module Instance
        /// objects are 1:1 with the execution environment's notion of a code bundle. For
        /// example, in native code, Module Instance objects are 1:1 with base address.
        /// </param>
        /// <param name="pModule">
        /// [In] The DkmModule class represents a code bundle (ex: dll or exe) which is or
        /// once was loaded into one or more processes. The DkmModule class is the central
        /// object to the symbol APIs, and is 1:1 with the symbol handler's notation of what
        /// is loaded. If a code bundle loads into three different processes (or the same
        /// process but with three different base addresses or three different app domains)
        /// but the symbol handler thinks of all of these as being identical, there will be
        /// only one module object.
        /// </param>
        /// <param name="IsReload">
        /// [In] True if symbols are being reloaded for an existing module, False if this is
        /// happening as part of module load processing.
        /// </param>
        /// <param name="pWorkList">
        /// WorkList to append additional event processing work to. This work list will begin
        /// execution after all listeners have been notifiied. The event will not finish
        /// until after the work list fully executes.
        /// </param>
        /// <param name="pEventDescriptor">
        /// [In] Describes the event being processed.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE OnModuleSymbolsLoaded(
            _In_ DkmModuleInstance* pModuleInstance,
            _In_ Symbols::DkmModule* pModule,
            _In_ bool IsReload,
            _In_ DkmWorkList* pWorkList,
            _In_ DkmEventDescriptor* pEventDescriptor
            ) = 0;
    };

    // IDkmModuleSymbolsUpdatedNotification is implemented by components that want to listen
    // for the ModuleSymbolsUpdated event. When this notification fires, the target process
    // will be suspended and can be examined. ModuleSymbolsUpdated is sent by a debug monitor
    // when dynamic code in the target process updates the symbol state.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // BaseDebugMonitorId, EngineId, RuntimeId, SymbolProviderId, TransportKind.
    #define IID_IDkmModuleSymbolsUpdatedNotification __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmModuleSymbolsUpdatedNotification)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("9671534b-ebb8-64d9-c606-fdb7b3a04e79") IDkmModuleSymbolsUpdatedNotification : public IUnknown
    {
        /// <summary>
        /// OnModuleSymbolsUpdated is invoked as part of event processing. See interface
        /// definition for more information.
        /// </summary>
        /// <param name="pModuleInstance">
        /// [In] The Module Instance class represent a code bundle (ex: dll or exe) which is
        /// loaded into a particular process at a particular location. Module Instance
        /// objects are 1:1 with the execution environment's notion of a code bundle. For
        /// example, in native code, Module Instance objects are 1:1 with base address.
        /// </param>
        /// <param name="pModule">
        /// [In] The DkmModule class represents a code bundle (ex: dll or exe) which is or
        /// once was loaded into one or more processes. The DkmModule class is the central
        /// object to the symbol APIs, and is 1:1 with the symbol handler's notation of what
        /// is loaded. If a code bundle loads into three different processes (or the same
        /// process but with three different base addresses or three different app domains)
        /// but the symbol handler thinks of all of these as being identical, there will be
        /// only one module object.
        /// </param>
        /// <param name="pWorkList">
        /// WorkList to append additional event processing work to. This work list will begin
        /// execution after all listeners have been notifiied. The event will not finish
        /// until after the work list fully executes.
        /// </param>
        /// <param name="pEventDescriptor">
        /// [In] Describes the event being processed.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE OnModuleSymbolsUpdated(
            _In_ DkmModuleInstance* pModuleInstance,
            _In_ Symbols::DkmModule* pModule,
            _In_ DkmWorkList* pWorkList,
            _In_ DkmEventDescriptor* pEventDescriptor
            ) = 0;
    };

    // Interface implemented by components to listen to Native ENC notifications.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // BaseDebugMonitorId, EngineId, RuntimeId, SymbolProviderId, TransportKind.
    //
    // This API was introduced in Visual Studio 14 RTM (DkmApiVersion.VS14RTM).
    #define IID_IDkmNativeCppEditAndContinueNotification __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmNativeCppEditAndContinueNotification)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("3008c0cd-7b8d-eb7c-2bfc-81b241b04f89") IDkmNativeCppEditAndContinueNotification : public IUnknown
    {
        /// <summary>
        /// Fired from the Native ENC engine after an edit has been committed.
        /// </summary>
        /// <param name="pNativeModuleInstance">
        /// [In] 'DkmNativeModuleInstance' is used for modules which contain CPU code and/or
        /// are loaded by the Win32 loader.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE OnNativeCppEditAndContinueAfterCommitEdit(
            _In_ Native::DkmNativeModuleInstance* pNativeModuleInstance
            ) = 0;
    };

    // Provides notification when the target process is about to be resumed from an out of
    // band debug event while doing managed-native interop debugging on the in-process
    // pipeline.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // BaseDebugMonitorId, EngineId, TransportKind.
    //
    // This API was introduced in Visual Studio 11 Update 1 (DkmApiVersion.VS11FeaturePack1).
    #define IID_IDkmOutOfBandProcessContinueNotification __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmOutOfBandProcessContinueNotification)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("aec025cc-2c92-6d39-6383-a5c503642c82") IDkmOutOfBandProcessContinueNotification : public IUnknown
    {
        /// <summary>
        /// Handler which is notified before the target process is resumed.
        /// </summary>
        /// <param name="pProcess">
        /// [In] DkmProcess represents a target process which is being debugged. The debugger
        /// debugs processes, so this is the basic unit of debugging. A DkmProcess can
        /// represent a system process or a virtual process such as minidumps.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE OutOfBandProcessContinue(
            _In_ DkmProcess* pProcess
            ) = 0;
    };

    // Provides notification when the target process is about to be resumed. This will be
    // fired after the user hits F5, begins a func-eval, a pausing event is complete (ex:
    // module load) or a stopping event is complete. This primary purpose of this event is to
    // allow components to flush any caches that they have.
    //
    // This notification may be fired from any thread, but will not be fired reentrantly.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // BaseDebugMonitorId, EngineId, TransportKind.
    #define IID_IDkmProcessContinueNotification __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmProcessContinueNotification)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("4dd3cc9c-a9f7-31f7-375d-2f456ac4c58a") IDkmProcessContinueNotification : public IUnknown
    {
        /// <summary>
        /// Handler which is notified before the target process is resumed.
        /// </summary>
        /// <param name="pProcess">
        /// [In] DkmProcess represents a target process which is being debugged. The debugger
        /// debugs processes, so this is the basic unit of debugging. A DkmProcess can
        /// represent a system process or a virtual process such as minidumps.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE OnProcessContinue(
            _In_ DkmProcess* pProcess
            ) = 0;
    };

    // IDkmProcessCreateNotification is implemented by components that want to listen for the
    // ProcessCreate event. When this notification fires, the target process will be
    // suspended and can be examined. ProcessCreate is fired when a DkmProcess object is
    // created. This indicates that the debugger has started attaching to the specified
    // process. In launch scenarios, this event is fired before any code in the target
    // process is allowed to run.
    //
    // Implementations can only crudely filter based on the type of code in the target
    // process, and handlers also will run while the UI thread is blocked waiting for the
    // engine to return. For these reasons, is is often better to listen for the
    // RuntimeInstanceLoad event instead.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // BaseDebugMonitorId, EngineId, TransportKind.
    #define IID_IDkmProcessCreateNotification __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmProcessCreateNotification)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("d09408cf-0131-19ee-164d-b2662fe572f9") IDkmProcessCreateNotification : public IUnknown
    {
        /// <summary>
        /// OnProcessCreate is invoked as part of event processing. See interface definition
        /// for more information.
        /// </summary>
        /// <param name="pProcess">
        /// [In] DkmProcess represents a target process which is being debugged. The debugger
        /// debugs processes, so this is the basic unit of debugging. A DkmProcess can
        /// represent a system process or a virtual process such as minidumps.
        /// </param>
        /// <param name="pWorkList">
        /// WorkList to append additional event processing work to. This work list will begin
        /// execution after all listeners have been notifiied. The event will not finish
        /// until after the work list fully executes.
        /// </param>
        /// <param name="pEventDescriptor">
        /// [In] Describes the event being processed.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE OnProcessCreate(
            _In_ DkmProcess* pProcess,
            _In_ DkmWorkList* pWorkList,
            _In_ DkmEventDescriptor* pEventDescriptor
            ) = 0;
    };

    // Provides notification that the process is about to pause or resume execution.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // BaseDebugMonitorId, EngineId, TransportKind.
    //
    // This API was introduced in Visual Studio 14 RTM (DkmApiVersion.VS14RTM).
    #define IID_IDkmProcessExecutionNotification __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmProcessExecutionNotification)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("c919ce79-3851-3b87-9a2c-1495a918e97f") IDkmProcessExecutionNotification : public IUnknown
    {
        /// <summary>
        /// Handler which is notified before the target process is paused. A process becomes
        /// paused when it hits a stopping event (such as user-set or internal breakpoint),
        /// or raises a pausing event (e.g. module load). It is not considered paused when it
        /// raises output debug strings, or other non-pausing events.
        /// </summary>
        /// <param name="pProcess">
        /// [In] DkmProcess represents a target process which is being debugged. The debugger
        /// debugs processes, so this is the basic unit of debugging. A DkmProcess can
        /// represent a system process or a virtual process such as minidumps.
        /// </param>
        /// <param name="pProcessCounters">
        /// [In] Stores a QPC timestamp for a process stop/resume event.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE OnProcessPause(
            _In_ DkmProcess* pProcess,
            _In_ DkmProcessExecutionCounters* pProcessCounters
            ) = 0;

        /// <summary>
        /// Handler which is notified before the target process is resumed. A process is
        /// resumed when the pausing event finishes processing, when the internal breakpoint
        /// is continued, or if the UI entered break mode, when the user decides to continue.
        /// </summary>
        /// <param name="pProcess">
        /// [In] DkmProcess represents a target process which is being debugged. The debugger
        /// debugs processes, so this is the basic unit of debugging. A DkmProcess can
        /// represent a system process or a virtual process such as minidumps.
        /// </param>
        /// <param name="pProcessCounters">
        /// [In] Stores a QPC timestamp for a process stop/resume event.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE OnProcessResume(
            _In_ DkmProcess* pProcess,
            _In_ DkmProcessExecutionCounters* pProcessCounters
            ) = 0;
    };

    // IDkmProcessExitNotification is implemented by components that want to listen for the
    // ProcessExit event. The target process may continue to run during this notification.
    // ProcessExit is fired when the debugger is no longer debugging the specified process.
    // This can either be because the debugger has detached from the specified process or
    // because the process exited.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // BaseDebugMonitorId, EngineId, TransportKind.
    #define IID_IDkmProcessExitNotification __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmProcessExitNotification)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("6fc11c87-c334-9299-2d50-cc03af307830") IDkmProcessExitNotification : public IUnknown
    {
        /// <summary>
        /// OnProcessExit is invoked as part of event processing. See interface definition
        /// for more information.
        /// </summary>
        /// <param name="pProcess">
        /// [In] DkmProcess represents a target process which is being debugged. The debugger
        /// debugs processes, so this is the basic unit of debugging. A DkmProcess can
        /// represent a system process or a virtual process such as minidumps.
        /// </param>
        /// <param name="ExitCode">
        /// [In] 32-bit value which the processed returned on exit. This is the same value
        /// that would be reported from the kernel32!GetExitCodeProcess.
        /// </param>
        /// <param name="pEventDescriptor">
        /// [In] Describes the event being processed.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE OnProcessExit(
            _In_ DkmProcess* pProcess,
            _In_ UINT32 ExitCode,
            _In_ DkmEventDescriptor* pEventDescriptor
            ) = 0;
    };

    // IDkmRuntimeBreakpointNotification is implemented by components that want to listen for
    // the RuntimeBreakpoint event. IDkmRuntimeBreakpointNotification is invoked after all
    // implementations of IDkmRuntimeBreakpointReceived. When this notification is called,
    // the target process is stopped and implementers are able to either inspect the process
    // or cause it to execute in a controlled manner (slip, func-eval).
    //
    // Provides notification that a runtime breakpoint (DkmRuntimeBreakpoint) has been hit.
    // Runtime breakpoints are the low-level breakpoint objects. Notification for the higher
    // level breakpoints (DkmPendingBreakpoint/DkmBoundBreakpoint) is obtained through the
    // BoundBreakpointHit event.
    //
    // RuntimeBreakpoint events can be suppressed by calling DkmEventDescriptorS.Suppress().
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // BaseDebugMonitorId, EngineId, RuntimeId, SourceId.
    #define IID_IDkmRuntimeBreakpointNotification __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmRuntimeBreakpointNotification)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("73b53ed1-ebc4-01d4-ea32-367b3ec69995") IDkmRuntimeBreakpointNotification : public IUnknown
    {
        /// <summary>
        /// OnRuntimeBreakpoint is invoked as part of event processing. See interface
        /// definition for more information.
        /// </summary>
        /// <param name="pRuntimeBreakpoint">
        /// [In] Low-level breakpoint object which is supported by debug monitors.
        /// </param>
        /// <param name="pThread">
        /// [In] DkmThread represents a thread running in the target process.
        /// </param>
        /// <param name="HasException">
        /// [In] Contains true if the source runtime instance can determine that an exception
        /// is in flight on the thread which hit the breakpoint. Currently, only managed
        /// runtime instances ever set this. This is used to quickly determine if exception
        /// specific logic should apply without making another network round-trip.
        /// </param>
        /// <param name="pEventDescriptor">
        /// [In] Describes the event being processed and provides the ability for a component
        /// to suppress this event.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE OnRuntimeBreakpoint(
            _In_ Breakpoints::DkmRuntimeBreakpoint* pRuntimeBreakpoint,
            _In_ DkmThread* pThread,
            _In_ bool HasException,
            _In_ DkmEventDescriptorS* pEventDescriptor
            ) = 0;
    };

    // IDkmRuntimeBreakpointReceived is implemented by components that want to listen for the
    // RuntimeBreakpoint event. IDkmRuntimeBreakpointReceived is invoked before
    // IDkmRuntimeBreakpointNotification. From within this notification, it is not possible
    // to cause the target process to execute (no func-eval, no slipping).
    //
    // Provides notification that a runtime breakpoint (DkmRuntimeBreakpoint) has been hit.
    // Runtime breakpoints are the low-level breakpoint objects. Notification for the higher
    // level breakpoints (DkmPendingBreakpoint/DkmBoundBreakpoint) is obtained through the
    // BoundBreakpointHit event.
    //
    // RuntimeBreakpoint events can be suppressed by calling DkmEventDescriptorS.Suppress().
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // BaseDebugMonitorId, EngineId, RuntimeId, SourceId.
    #define IID_IDkmRuntimeBreakpointReceived __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmRuntimeBreakpointReceived)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("3dc65314-7cf0-f174-ad0d-616b0e0ee6bd") IDkmRuntimeBreakpointReceived : public IUnknown
    {
        /// <summary>
        /// OnRuntimeBreakpointReceived is invoked as part of event processing. See interface
        /// definition for more information.
        /// </summary>
        /// <param name="pRuntimeBreakpoint">
        /// [In] Low-level breakpoint object which is supported by debug monitors.
        /// </param>
        /// <param name="pThread">
        /// [In] DkmThread represents a thread running in the target process.
        /// </param>
        /// <param name="HasException">
        /// [In] Contains true if the source runtime instance can determine that an exception
        /// is in flight on the thread which hit the breakpoint. Currently, only managed
        /// runtime instances ever set this. This is used to quickly determine if exception
        /// specific logic should apply without making another network round-trip.
        /// </param>
        /// <param name="pEventDescriptor">
        /// [In] Describes the event being processed and provides the ability for a component
        /// to suppress this event.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE OnRuntimeBreakpointReceived(
            _In_ Breakpoints::DkmRuntimeBreakpoint* pRuntimeBreakpoint,
            _In_ DkmThread* pThread,
            _In_ bool HasException,
            _In_ DkmEventDescriptorS* pEventDescriptor
            ) = 0;
    };

    // IDkmRuntimeInstanceLoadCompleteNotification is implemented by components that want to
    // listen for the RuntimeInstanceLoadComplete event. When this notification fires, the
    // target process will be suspended and can be examined. RuntimeInstanceLoadComplete is
    // sent by the base debug monitor when launching or attaching to the process has
    // completed.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // BaseDebugMonitorId, EngineId, RuntimeId, TransportKind.
    //
    // This API was introduced in Visual Studio 12 Update 2 (DkmApiVersion.VS12Update2).
    #define IID_IDkmRuntimeInstanceLoadCompleteNotification __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmRuntimeInstanceLoadCompleteNotification)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("8bc06180-bd55-7bb3-21f4-155ec3bf12f6") IDkmRuntimeInstanceLoadCompleteNotification : public IUnknown
    {
        /// <summary>
        /// OnRuntimeInstanceLoadComplete is invoked as part of event processing. See
        /// interface definition for more information.
        /// </summary>
        /// <param name="pRuntimeInstance">
        /// [In] The DkmRuntimeInstance class represents an execution environment which is
        /// loaded into a DkmProcess and which contains code to be debugged.
        /// </param>
        /// <param name="pWorkList">
        /// WorkList to append additional event processing work to. This work list will begin
        /// execution after all listeners have been notifiied. The event will not finish
        /// until after the work list fully executes.
        /// </param>
        /// <param name="pEventDescriptor">
        /// [In] Describes the event being processed.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE OnRuntimeInstanceLoadComplete(
            _In_ DkmRuntimeInstance* pRuntimeInstance,
            _In_ DkmWorkList* pWorkList,
            _In_ DkmEventDescriptor* pEventDescriptor
            ) = 0;
    };

    // IDkmRuntimeInstanceLoadNotification is implemented by components that want to listen
    // for the RuntimeInstanceLoad event. The target process may continue to run during this
    // notification. RuntimeInstanceLoad is fired when a DkmRuntimeInstance object is
    // created. This event can be used to detect that a particular type of code (ex: native)
    // is now being debugged in this target process. In launch scenarios, the
    // RuntimeInstanceLoad event will be fired before any code of the specified type has a
    // chance to run in the target process. When debugging native code, this includes all
    // code in the target process.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // BaseDebugMonitorId, EngineId, RuntimeId, TransportKind.
    #define IID_IDkmRuntimeInstanceLoadNotification __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmRuntimeInstanceLoadNotification)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("c13a1419-139d-878d-8470-17da0674a194") IDkmRuntimeInstanceLoadNotification : public IUnknown
    {
        /// <summary>
        /// OnRuntimeInstanceLoad is invoked as part of event processing. See interface
        /// definition for more information.
        /// </summary>
        /// <param name="pRuntimeInstance">
        /// [In] The DkmRuntimeInstance class represents an execution environment which is
        /// loaded into a DkmProcess and which contains code to be debugged.
        /// </param>
        /// <param name="pEventDescriptor">
        /// [In] Describes the event being processed.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE OnRuntimeInstanceLoad(
            _In_ DkmRuntimeInstance* pRuntimeInstance,
            _In_ DkmEventDescriptor* pEventDescriptor
            ) = 0;
    };

    // IDkmRuntimeInstanceUnloadNotification is implemented by components that want to listen
    // for the RuntimeInstanceUnload event. The target process may continue to run during
    // this notification. RuntimeInstanceUnload is fired when an execution environment
    // unloads from the target process.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // BaseDebugMonitorId, EngineId, RuntimeId, TransportKind.
    #define IID_IDkmRuntimeInstanceUnloadNotification __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmRuntimeInstanceUnloadNotification)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("20c89371-8e8e-39cd-d66e-4c558b8d3f79") IDkmRuntimeInstanceUnloadNotification : public IUnknown
    {
        /// <summary>
        /// OnRuntimeInstanceUnload is invoked as part of event processing. See interface
        /// definition for more information.
        /// </summary>
        /// <param name="pRuntimeInstance">
        /// [In] The DkmRuntimeInstance class represents an execution environment which is
        /// loaded into a DkmProcess and which contains code to be debugged.
        /// </param>
        /// <param name="pEventDescriptor">
        /// [In] Describes the event being processed.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE OnRuntimeInstanceUnload(
            _In_ DkmRuntimeInstance* pRuntimeInstance,
            _In_ DkmEventDescriptor* pEventDescriptor
            ) = 0;
    };

    // IDkmScriptDocumentContentInsertNotification is implemented by components that want to
    // listen for the ScriptDocumentContentInsert event. The target process may continue to
    // run during this notification. Notification that new content has been added to the
    // target process. For aggregate documents (DkmScriptDocumentFlags.AggregateDocument is
    // set), this is a new document section.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // BaseDebugMonitorId, EngineId, RuntimeId, SymbolProviderId.
    #define IID_IDkmScriptDocumentContentInsertNotification __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmScriptDocumentContentInsertNotification)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("2d4bb681-882c-30fc-90a3-36249993d46e") IDkmScriptDocumentContentInsertNotification : public IUnknown
    {
        /// <summary>
        /// OnScriptDocumentContentInsert is invoked as part of event processing. See
        /// interface definition for more information.
        /// </summary>
        /// <param name="pScriptDocument">
        /// [In] Represents a document which is executing in a script runtime environment.
        /// For example, the Microsoft JavaScript engine.
        /// </param>
        /// <param name="Span">
        /// [In] The text span of the inserted text. For aggregate documents
        /// (DkmScriptDocumentFlags.AggregateDocument is set), this must start on a new line,
        /// and at at the end of a line immediately before a new section would begin.
        /// </param>
        /// <param name="pNewText">
        /// [In] The new text content which is inserted into the document.
        /// </param>
        /// <param name="pEventDescriptor">
        /// [In] Describes the event being processed.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE OnScriptDocumentContentInsert(
            _In_ Script::DkmScriptDocument* pScriptDocument,
            _In_ const Symbols::DkmTextSpan& Span,
            _In_ DkmString* pNewText,
            _In_ DkmEventDescriptor* pEventDescriptor
            ) = 0;
    };

    // IDkmScriptDocumentContentRemoveNotification is implemented by components that want to
    // listen for the ScriptDocumentContentRemove event. The target process may continue to
    // run during this notification. Notification that content has been removed from the
    // target process. For aggregate documents (DkmScriptDocumentFlags.AggregateDocument is
    // set), this will correspond to a deleted text section.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // BaseDebugMonitorId, EngineId, RuntimeId, SymbolProviderId.
    #define IID_IDkmScriptDocumentContentRemoveNotification __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmScriptDocumentContentRemoveNotification)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("f27427d4-2808-6d82-95cc-64d3e82dee9c") IDkmScriptDocumentContentRemoveNotification : public IUnknown
    {
        /// <summary>
        /// OnScriptDocumentContentRemove is invoked as part of event processing. See
        /// interface definition for more information.
        /// </summary>
        /// <param name="pScriptDocument">
        /// [In] Represents a document which is executing in a script runtime environment.
        /// For example, the Microsoft JavaScript engine.
        /// </param>
        /// <param name="Span">
        /// [In] The text span of the removed text. For aggregate documents
        /// (DkmScriptDocumentFlags.AggregateDocument is set), this must start at the begging
        /// of a line, and correspond to a previously added section.
        /// </param>
        /// <param name="CharsToRemove">
        /// [In] Number of characters within the section to remove.
        /// </param>
        /// <param name="pEventDescriptor">
        /// [In] Describes the event being processed.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE OnScriptDocumentContentRemove(
            _In_ Script::DkmScriptDocument* pScriptDocument,
            _In_ const Symbols::DkmTextSpan& Span,
            _In_ UINT32 CharsToRemove,
            _In_ DkmEventDescriptor* pEventDescriptor
            ) = 0;
    };

    // IDkmScriptDocumentTreeNodeCreateNotification is implemented by components that want to
    // listen for the ScriptDocumentTreeNodeCreate event. When this notification fires, the
    // target process will be suspended and can be examined. Notification when a new
    // DkmScriptDocumentTreeNode object is created.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // BaseDebugMonitorId, EngineId, RuntimeId.
    #define IID_IDkmScriptDocumentTreeNodeCreateNotification __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmScriptDocumentTreeNodeCreateNotification)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("740b8825-f45c-3cd0-333d-009ab90550b8") IDkmScriptDocumentTreeNodeCreateNotification : public IUnknown
    {
        /// <summary>
        /// OnScriptDocumentTreeNodeCreate is invoked as part of event processing. See
        /// interface definition for more information.
        /// </summary>
        /// <param name="pScriptDocumentTreeNode">
        /// [In] Represents a node in the 'Script Documents' virtual tree within solution
        /// explorer. Nodes may either be a virtual container, or they can be a document. In
        /// the latter case, they will be a DkmScriptDocument.
        /// </param>
        /// <param name="pWorkList">
        /// WorkList to append additional event processing work to. This work list will begin
        /// execution after all listeners have been notifiied. The event will not finish
        /// until after the work list fully executes.
        /// </param>
        /// <param name="pEventDescriptor">
        /// [In] Describes the event being processed.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE OnScriptDocumentTreeNodeCreate(
            _In_ Script::DkmScriptDocumentTreeNode* pScriptDocumentTreeNode,
            _In_ DkmWorkList* pWorkList,
            _In_ DkmEventDescriptor* pEventDescriptor
            ) = 0;
    };

    // IDkmScriptDocumentTreeNodeUnloadNotification is implemented by components that want to
    // listen for the ScriptDocumentTreeNodeUnload event. The target process may continue to
    // run during this notification. Notification that a DkmScriptDocumentTreeNode has been
    // unloaded from the target process.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // BaseDebugMonitorId, EngineId, RuntimeId.
    #define IID_IDkmScriptDocumentTreeNodeUnloadNotification __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmScriptDocumentTreeNodeUnloadNotification)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("ff22fc68-c65b-a726-a65f-b0c4cd8e4153") IDkmScriptDocumentTreeNodeUnloadNotification : public IUnknown
    {
        /// <summary>
        /// OnScriptDocumentTreeNodeUnload is invoked as part of event processing. See
        /// interface definition for more information.
        /// </summary>
        /// <param name="pScriptDocumentTreeNode">
        /// [In] Represents a node in the 'Script Documents' virtual tree within solution
        /// explorer. Nodes may either be a virtual container, or they can be a document. In
        /// the latter case, they will be a DkmScriptDocument.
        /// </param>
        /// <param name="pEventDescriptor">
        /// [In] Describes the event being processed.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE OnScriptDocumentTreeNodeUnload(
            _In_ Script::DkmScriptDocumentTreeNode* pScriptDocumentTreeNode,
            _In_ DkmEventDescriptor* pEventDescriptor
            ) = 0;
    };

    // IDkmScriptSymbolsUpdatedNotification is implemented by components that want to listen
    // for the ScriptSymbolsUpdated event. When this notification fires, the target process
    // will be suspended and can be examined. Notification that symbol state for one or more
    // script documents have been updated. This is used to rebind breakpoints in script-based
    // modules.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // BaseDebugMonitorId, EngineId, RuntimeId, TransportKind.
    #define IID_IDkmScriptSymbolsUpdatedNotification __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmScriptSymbolsUpdatedNotification)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("cd719ead-c44b-6f43-0466-943e5d6fdcfb") IDkmScriptSymbolsUpdatedNotification : public IUnknown
    {
        /// <summary>
        /// OnScriptSymbolsUpdated is invoked as part of event processing. See interface
        /// definition for more information.
        /// </summary>
        /// <param name="pScriptRuntimeInstance">
        /// [In] Represents a script-based execution environment executing in a target
        /// process.
        /// </param>
        /// <param name="Documents">
        /// [In] Set of documents which have been updated.
        ///
        /// The memory for the DkmArray members is allocated by the caller, and can be from
        /// any source (stack memory, static buffer, heap, etc). The implementation should
        /// not modify the members.
        /// </param>
        /// <param name="pWorkList">
        /// WorkList to append additional event processing work to. This work list will begin
        /// execution after all listeners have been notifiied. The event will not finish
        /// until after the work list fully executes.
        /// </param>
        /// <param name="pEventDescriptor">
        /// [In] Describes the event being processed.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE OnScriptSymbolsUpdated(
            _In_ Script::DkmScriptRuntimeInstance* pScriptRuntimeInstance,
            _In_ const DkmArray<Script::DkmScriptDocument*>& Documents,
            _In_ DkmWorkList* pWorkList,
            _In_ DkmEventDescriptor* pEventDescriptor
            ) = 0;
    };

    // IDkmTaskProviderCreateNotification is implemented by components that want to listen
    // for the TaskProviderCreate event. The target process may continue to run during this
    // notification. Indicates that a task provider object has been created.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // BaseDebugMonitorId, EngineId, RuntimeId, TaskProviderId.
    #define IID_IDkmTaskProviderCreateNotification __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmTaskProviderCreateNotification)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("b346af13-65e1-8e44-e9f1-2e5de6d1e08c") IDkmTaskProviderCreateNotification : public IUnknown
    {
        /// <summary>
        /// OnTaskProviderCreate is invoked as part of event processing. See interface
        /// definition for more information.
        /// </summary>
        /// <param name="pTaskProvider">
        /// [In] Represents a task provider which is loaded into the target process.
        /// </param>
        /// <param name="pEventDescriptor">
        /// [In] Describes the event being processed.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE OnTaskProviderCreate(
            _In_ ParallelTasks::DkmTaskProvider* pTaskProvider,
            _In_ DkmEventDescriptor* pEventDescriptor
            ) = 0;
    };

    // IDkmThreadCreateNotification is implemented by components that want to listen for the
    // ThreadCreate event. When this notification fires, the target process will be suspended
    // and can be examined. ThreadCreate is fired when a new thread starts in the target
    // process.
    //
    // ThreadCreate events can be suppressed. In this case the thread will be invisible to
    // components above the level where the thread was suppressed.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // BaseDebugMonitorId, EngineId, TransportKind.
    #define IID_IDkmThreadCreateNotification __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmThreadCreateNotification)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("e815c419-f857-75e2-0f79-8cd82018eaa1") IDkmThreadCreateNotification : public IUnknown
    {
        /// <summary>
        /// OnThreadCreate is invoked as part of event processing. See interface definition
        /// for more information.
        /// </summary>
        /// <param name="pThread">
        /// [In] DkmThread represents a thread running in the target process.
        /// </param>
        /// <param name="pWorkList">
        /// WorkList to append additional event processing work to. This work list will begin
        /// execution after all listeners have been notifiied. The event will not finish
        /// until after the work list fully executes.
        /// </param>
        /// <param name="pEventDescriptor">
        /// [In] Describes the event being processed and provides the ability for a component
        /// to suppress this event.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE OnThreadCreate(
            _In_ DkmThread* pThread,
            _In_ DkmWorkList* pWorkList,
            _In_ DkmEventDescriptorS* pEventDescriptor
            ) = 0;
    };

    // IDkmThreadExitNotification is implemented by components that want to listen for the
    // ThreadExit event. The target process may continue to run during this notification.
    // ThreadExit is fired when a thread in the target process exits. It will not be fired if
    // the target process exits while the thread is still running.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // BaseDebugMonitorId, EngineId, TransportKind.
    #define IID_IDkmThreadExitNotification __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmThreadExitNotification)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("6ec1c3fc-8fe9-6f86-6f9b-5b3473924209") IDkmThreadExitNotification : public IUnknown
    {
        /// <summary>
        /// OnThreadExit is invoked as part of event processing. See interface definition for
        /// more information.
        /// </summary>
        /// <param name="pThread">
        /// [In] DkmThread represents a thread running in the target process.
        /// </param>
        /// <param name="ExitCode">
        /// [In] 32-bit value that the process returned on exit. This is the same value that
        /// would be reported from the kernel32!GetExitCodeThread.
        /// </param>
        /// <param name="pEventDescriptor">
        /// [In] Describes the event being processed.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE OnThreadExit(
            _In_ DkmThread* pThread,
            _In_ UINT32 ExitCode,
            _In_ DkmEventDescriptor* pEventDescriptor
            ) = 0;
    };

    // IDkmThreadNameChangeNotification is implemented by components that want to listen for
    // the ThreadNameChange event. When this notification fires, the target process will be
    // suspended and can be examined. ThreadNameChange is fired when a thread name is changed
    // in the target process. Currently, this is only fired when Managed thread change their
    // name.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // BaseDebugMonitorId, EngineId, TransportKind.
    //
    // This API was introduced in Visual Studio 14 RTM (DkmApiVersion.VS14RTM).
    #define IID_IDkmThreadNameChangeNotification __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmThreadNameChangeNotification)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("9ea54567-dc87-90ff-e22d-73fe95ccd7c8") IDkmThreadNameChangeNotification : public IUnknown
    {
        /// <summary>
        /// OnThreadNameChange is invoked as part of event processing. See interface
        /// definition for more information.
        /// </summary>
        /// <param name="pThread">
        /// [In] DkmThread represents a thread running in the target process.
        /// </param>
        /// <param name="pWorkList">
        /// WorkList to append additional event processing work to. This work list will begin
        /// execution after all listeners have been notifiied. The event will not finish
        /// until after the work list fully executes.
        /// </param>
        /// <param name="pEventDescriptor">
        /// [In] Describes the event being processed.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE OnThreadNameChange(
            _In_ DkmThread* pThread,
            _In_ DkmWorkList* pWorkList,
            _In_ DkmEventDescriptor* pEventDescriptor
            ) = 0;
    };

}; // end of Events interfaces


// Settings update notifications interfaces
// These interfaces may be implemented by any component. They provide notifications when
// debugger settings are changed.
namespace ComponentInterfaces
{
    // IDkmAfterSetNextStatementNotification implemented by components that wish to receive
    // notification after a set next statement completed.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // BaseDebugMonitorId, EngineId, RuntimeId, SymbolProviderId, TransportKind.
    #define IID_IDkmAfterSetNextStatementNotification __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmAfterSetNextStatementNotification)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("8ef24f26-7e73-7719-706d-c0fabf136515") IDkmAfterSetNextStatementNotification : public IUnknown
    {
        /// <summary>
        /// OnSetNextStatementCompleted is a general purpose method to allow components to
        /// clear state after a set next statement completed. The DkmStackWalkFrame will be
        /// the frame prior to to the SetNextStatement call.
        /// </summary>
        /// <param name="pFrame">
        /// [In] DkmStackWalkFrame represents a frame on a call stack which has been walked,
        /// but may not have been formatted or filtered. Formatted frames are represented by
        /// DkmStackFrame instead.
        /// </param>
        /// <param name="pNewStatement">
        /// [In] Abstract representation of an executable code location (ex: EIP value). If
        /// resolved, an Instruction Address will be within a particular module instance. An
        /// Instruction Address is always within a particular Runtime Instance.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE OnSetNextStatementCompleted(
            _In_ CallStack::DkmStackWalkFrame* pFrame,
            _In_ DkmInstructionAddress* pNewStatement
            ) = 0;
    };

    // Interface to update components when 'IsGpuRaceHazardsAllowSameSettingEnabled' is
    // enabled or disabled.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // BaseDebugMonitorId, EngineId.
    #define IID_IDkmGpuRaceHazardsAllowSameNotification __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmGpuRaceHazardsAllowSameNotification)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("e3e083eb-ec58-1cfa-dd32-86ca6a87f395") IDkmGpuRaceHazardsAllowSameNotification : public IUnknown
    {
        /// <summary>
        /// Called when 'IsGpuRaceHazardsAllowSameSettingEnabled' is changed.
        /// </summary>
        /// <param name="pSettings">
        /// [In] Contains the session-wide debug settings. There is one instance of this
        /// object per engine Guid (ex: one instance for COMPlusOnlyEng2, one instance for
        /// COMPlusNativeEng).
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE OnGpuRaceHazardAllowSameSettingChanged(
            _In_ DkmEngineSettings* pSettings
            ) = 0;
    };

    // Interface to update components when JustMyCode is enabled or disabled.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // BaseDebugMonitorId, EngineId.
    #define IID_IDkmJustMyCodeEnableNotification __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmJustMyCodeEnableNotification)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("ede97f9f-a05a-2818-4f5d-7e9bd5aa688b") IDkmJustMyCodeEnableNotification : public IUnknown
    {
        /// <summary>
        /// Called when 'IsJustMyCodeEnabled' is changed.
        /// </summary>
        /// <param name="pSettings">
        /// [In] Contains the session-wide debug settings. There is one instance of this
        /// object per engine Guid (ex: one instance for COMPlusOnlyEng2, one instance for
        /// COMPlusNativeEng).
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE OnJustMyCodeChanged(
            _In_ DkmEngineSettings* pSettings
            ) = 0;
    };

    // Interface to update components when native debugging is enabled or disabled for a
    // particular process. Note that for Visual Studio 11, native debugging cannot be
    // enabled/disabled on the fly, but future versions may support this functionality.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // BaseDebugMonitorId, EngineId, TransportKind.
    #define IID_IDkmNativeDebuggingEnableNotification __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmNativeDebuggingEnableNotification)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("e126c5d6-bb96-562e-ebae-5dae8d2e5df1") IDkmNativeDebuggingEnableNotification : public IUnknown
    {
        /// <summary>
        /// Called when 'IsNativeDebuggingEnabled' is changed.
        /// </summary>
        /// <param name="pProcess">
        /// [In] DkmProcess represents a target process which is being debugged. The debugger
        /// debugs processes, so this is the basic unit of debugging. A DkmProcess can
        /// represent a system process or a virtual process such as minidumps.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE OnNativeDebuggingEnabledChanged(
            _In_ DkmProcess* pProcess
            ) = 0;
    };

    // Interface to update components when 'IsNativeExportsEnabled' is enabled or disabled.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // BaseDebugMonitorId, EngineId.
    #define IID_IDkmNativeExportsEnableNotification __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmNativeExportsEnableNotification)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("ac1d537a-6899-f914-86ee-8c728c01d312") IDkmNativeExportsEnableNotification : public IUnknown
    {
        /// <summary>
        /// Called when 'IsNativeExportsEnabled' is changed.
        /// </summary>
        /// <param name="pSettings">
        /// [In] Contains the session-wide debug settings. There is one instance of this
        /// object per engine Guid (ex: one instance for COMPlusOnlyEng2, one instance for
        /// COMPlusNativeEng).
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE OnNativeExportsChanged(
            _In_ DkmEngineSettings* pSettings
            ) = 0;
    };

    // Interface to update components when RequireFullTrustForSourceServer is enabled or
    // disabled.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // BaseDebugMonitorId, EngineId.
    #define IID_IDkmRequireFullTrustForSourceServerNotification __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmRequireFullTrustForSourceServerNotification)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("0649fcb4-60d9-599d-6f60-f72d0f986b8f") IDkmRequireFullTrustForSourceServerNotification : public IUnknown
    {
        /// <summary>
        /// Called when 'RequireFullTrustForSourceServer' is changed.
        /// </summary>
        /// <param name="pSettings">
        /// [In] Contains the session-wide debug settings. There is one instance of this
        /// object per engine Guid (ex: one instance for COMPlusOnlyEng2, one instance for
        /// COMPlusNativeEng).
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE OnRequireFullTrustForSourceServerChanged(
            _In_ DkmEngineSettings* pSettings
            ) = 0;
    };

    // Interface to update components when 'IsStepOverPropertiesAndOperatorsEnabled' is
    // enabled or  disabled.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // BaseDebugMonitorId, EngineId.
    #define IID_IDkmStepOverPropertiesAndOperatorsEnableNotification __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmStepOverPropertiesAndOperatorsEnableNotification)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("5a8587ed-a475-7af6-a3ce-0246c3d86c60") IDkmStepOverPropertiesAndOperatorsEnableNotification : public IUnknown
    {
        /// <summary>
        /// Called when 'IsStepOverPropertiesAndOperatorsEnabled' is changed.
        /// </summary>
        /// <param name="pSettings">
        /// [In] Contains the session-wide debug settings. There is one instance of this
        /// object per engine Guid (ex: one instance for COMPlusOnlyEng2, one instance for
        /// COMPlusNativeEng).
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE OnStepOverPropertiesAndOperatorsChanged(
            _In_ DkmEngineSettings* pSettings
            ) = 0;
    };

    // Interface to update components when 'IsSuppressOptimizationsEnabled' is enabled or
    // disabled.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // BaseDebugMonitorId, EngineId.
    #define IID_IDkmSuppressOptimizationsEnableNotification __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmSuppressOptimizationsEnableNotification)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("bb69f4b9-fd42-ad8a-f0f6-6bd1c48b8e7a") IDkmSuppressOptimizationsEnableNotification : public IUnknown
    {
        /// <summary>
        /// Called when 'IsSuppressOptimizationsEnabled' is changed.
        /// </summary>
        /// <param name="pSettings">
        /// [In] Contains the session-wide debug settings. There is one instance of this
        /// object per engine Guid (ex: one instance for COMPlusOnlyEng2, one instance for
        /// COMPlusNativeEng).
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE OnSuppressOptimizationsChanged(
            _In_ DkmEngineSettings* pSettings
            ) = 0;
    };

    // Interface to update components when symbol settings change.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // BaseDebugMonitorId, EngineId.
    #define IID_IDkmSymbolPathChangeNotification __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmSymbolPathChangeNotification)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("6e177901-05d1-ed76-1ce4-cbfeca02295d") IDkmSymbolPathChangeNotification : public IUnknown
    {
        /// <summary>
        /// Called when the symbol path is changed.
        /// </summary>
        /// <param name="pSettings">
        /// [In] Contains the session-wide debug settings. There is one instance of this
        /// object per engine Guid (ex: one instance for COMPlusOnlyEng2, one instance for
        /// COMPlusNativeEng).
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE OnSymbolPathChanged(
            _In_ DkmEngineSettings* pSettings
            ) = 0;
    };

    // Interface to update components when trace settings are changed.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // BaseDebugMonitorId, EngineId.
    //
    // This API was introduced in Visual Studio 14 RTM (DkmApiVersion.VS14RTM).
    #define IID_IDkmTraceSettingsNotification __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmTraceSettingsNotification)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("df81e659-0f83-2375-33ad-1a7dbe46ff9b") IDkmTraceSettingsNotification : public IUnknown
    {
        /// <summary>
        /// Called when 'TraceSettings' is changed.
        /// </summary>
        /// <param name="pSettings">
        /// [In] Contains the session-wide debug settings. There is one instance of this
        /// object per engine Guid (ex: one instance for COMPlusOnlyEng2, one instance for
        /// COMPlusNativeEng).
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE OnTraceSettingsChanged(
            _In_ DkmEngineSettings* pSettings
            ) = 0;
    };

}; // end of Settings update notifications interfaces


// Call stack walkers (native code generators) interfaces
// These interfaces are implemented by partners who have a native code generator (ex:
// compiler) where the generated code produces call stacks that cannot be walked without
// access to symbols (ex: non-EBP framed x86 code).
//
// See also: IDkmStackWalkFrameInterfaceProvider
namespace ComponentInterfaces
{
    // Provides a mechanism for the Base Debug Monitor and Native Debug Monitor to obtain
    // information about the stack frames that may require symbol support.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // BaseDebugMonitorId, EngineId, TransportKind.
    #define IID_IDkmNativeStackCallback __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmNativeStackCallback)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("f5e432fb-b862-5df5-91b8-e0380145480d") IDkmNativeStackCallback : public IUnknown
    {
        /// <summary>
        /// GetCurrentFrameInfo is used to obtain the frame base and return address for the
        /// current context of the thread. This takes into account Frame Pointer Omission and
        /// if the current instruction pointer is in a prolog, epilog etc... NOTE: In some
        /// cases this will get it wrong if the frame has Frame Pointer Omission and there
        /// are no symbols loaded.
        /// </summary>
        /// <param name="pThread">
        /// [In] DkmThread represents a thread running in the target process.
        /// </param>
        /// <param name="pReturnAddress">
        /// [Out] The return address of the frame.
        /// </param>
        /// <param name="pFrameBase">
        /// [Out] The frame base of the frame.
        /// </param>
        /// <param name="pVFrame">
        /// [Out] The vframe of the current frame. Only valid on x86.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE GetCurrentFrameInfo(
            _In_ DkmThread* pThread,
            _Out_ UINT64* pReturnAddress,
            _Out_ UINT64* pFrameBase,
            _Out_ UINT64* pVFrame
            ) = 0;
    };

    // Provides a mechanism for walking native stack frames using information from symbol
    // files. This mechanism is used to walk any stack frames which could not be resolved on
    // the target computer.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // BaseDebugMonitorId, EngineId, SymbolProviderId.
    #define IID_IDkmSymbolStackWalk __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmSymbolStackWalk)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("cc886169-aa9c-d9c9-0ee1-42c9d6f280d0") IDkmSymbolStackWalk : public IUnknown
    {
        /// <summary>
        /// Initialize is invoked on each walker exactly once at the beginning of the walk
        /// process. This gives each walker a chance to initialize any state.
        /// </summary>
        /// <param name="pSymbolStackWalkContext">
        /// [In] DkmSymbolStackWalkContext allows the various symbol providers which walk the
        /// call stack to store private data which is associated with this call stack.
        /// </param>
        /// <param name="pRegisters">
        /// [In] Registers to attempt to walk from.
        /// </param>
        /// <param name="StackRangeSize">
        /// [In] Size of the stack range that the debugger will attempt to walk through.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE Initialize(
            _In_ CallStack::DkmSymbolStackWalkContext* pSymbolStackWalkContext,
            _In_ CallStack::DkmFrameRegisters* pRegisters,
            _In_ UINT32 StackRangeSize
            ) = 0;

        /// <summary>
        /// UpdatePosition is invoked by the stack provider after another walker has walked
        /// one or more frames, and so this walker must be updated before invoking
        /// WalkNextFrame.
        /// </summary>
        /// <param name="pSymbolStackWalkContext">
        /// [In] DkmSymbolStackWalkContext allows the various symbol providers which walk the
        /// call stack to store private data which is associated with this call stack.
        /// </param>
        /// <param name="pRegisters">
        /// [In] Registers to attempt to walk from.
        /// </param>
        /// <param name="StackRangeSize">
        /// [In] Size of the stack range that the debugger will attempt to walk through.
        /// </param>
        /// <param name="pInstructionAddress">
        /// [In] Address from the instruction pointer in the registers. This will be either a
        /// 'Native' or 'Unresolved' address.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE UpdatePosition(
            _In_ CallStack::DkmSymbolStackWalkContext* pSymbolStackWalkContext,
            _In_ CallStack::DkmFrameRegisters* pRegisters,
            _In_ UINT32 StackRangeSize,
            _In_ DkmInstructionAddress* pInstructionAddress
            ) = 0;

        /// <summary>
        /// Walk the next stack frame from the call stack.
        /// </summary>
        /// <param name="pSymbolStackWalkContext">
        /// [In] DkmSymbolStackWalkContext allows the various symbol providers which walk the
        /// call stack to store private data which is associated with this call stack.
        /// </param>
        /// <param name="ppNextRegisters">
        /// [Out,Optional] NextRegisters indicates the registers of the next frame (the
        /// caller of 'FrameObject'). It is used to invoke UpdatePosition if the next frame
        /// is owned by a different symbol provider. A null NextRegisters value indicates
        /// that the returned frame is the last frame of the call stack, so the stack walk
        /// will end here.
        /// </param>
        /// <param name="ppFrameObject">
        /// [Out,Optional] Created frame object for the current registers.
        /// </param>
        /// <returns>
        /// S_OK is returned if *ppFrameObject is non-NULL, S_FALSE is returned when
        /// *ppFrameObject is NULL, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE WalkNextFrame(
            _In_ CallStack::DkmSymbolStackWalkContext* pSymbolStackWalkContext,
            _Deref_out_opt_ CallStack::DkmFrameRegisters** ppNextRegisters,
            _Deref_out_opt_ CallStack::DkmStackWalkFrame** ppFrameObject
            ) = 0;
    };

}; // end of Call stack walkers (native code generators) interfaces


// Customize the debugging experience for a library interfaces
// The following interfaces are primarily intended to be implemented by a library
// developer who wants to improve the debugging experience of clients consuming their
// library. For example, this category includes the breakpoint manager interfaces. A
// library which did text processing could use the breakpoint manager interfaces to
// interpret input file breakpoints as a request to stop in the library just before this
// part of the text document was processed.
//
// See also: IDkmModuleInstanceLoadNotification, IDkmProcessLaunchEnvironmentFilter,
// IDkmProcessLaunchEnvironmentFilter140, IDkmRuntimeBreakpointNotification,
// IDkmRuntimeBreakpointReceived, IDkmStopDebuggingOperations,
// IDkmThreadDisplayPropertiesQuery, IDkmThreadNameQuery
namespace ComponentInterfaces
{
    // Implemented by callers of DkmRuntimeBreakpoint.SetCompiledConditionPending to provide
    // compiled conditions when a breakpoint is hit.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // BaseDebugMonitorId, EngineId, RuntimeId, SourceId.
    #define IID_IDkmBreakpointConditionProcessorClient __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmBreakpointConditionProcessorClient)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("fe8268ed-63b3-beed-8458-5e74841a650b") IDkmBreakpointConditionProcessorClient : public IUnknown
    {
        /// <summary>
        /// Call back invoked from the breakpoint condition processor to the breakpoint
        /// manager (or other component which calls SetCompiledConditionPending) when the
        /// breakpoint condition needs to be re-compiled for a new instruction address.
        /// </summary>
        /// <param name="pRuntimeBreakpoint">
        /// [In] Low-level breakpoint object which is supported by debug monitors.
        /// </param>
        /// <param name="pInstructionAddress">
        /// [In] The instruction address to compile the condition against.
        /// </param>
        /// <param name="pConditionOperator">
        /// [Out] Operator to use when evaluating the condition.
        /// </param>
        /// <param name="ppCompiledCondition">
        /// [Out,Optional] The compiled condition to be used for the specified instruction
        /// address. This value is null in the case that the condition failed to compile. In
        /// this case, the condition processor should stop on the breakpoint.
        /// </param>
        /// <returns>
        /// S_OK is returned if *ppCompiledCondition is non-NULL, S_FALSE is returned when
        /// *ppCompiledCondition is NULL, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE GetCompiledCondition(
            _In_ Breakpoints::DkmRuntimeBreakpoint* pRuntimeBreakpoint,
            _In_ DkmInstructionAddress* pInstructionAddress,
            _Out_ Breakpoints::DkmBreakpointConditionOperator_t* pConditionOperator,
            _Deref_out_opt_ Evaluation::DkmCompiledInspectionQuery** ppCompiledCondition
            ) = 0;

        /// <summary>
        /// Call back invoked from the breakpoint condition processor to the breakpoint
        /// manager when a breakpoint condition encounters a runtime error.
        /// </summary>
        /// <param name="pRuntimeBreakpoint">
        /// [In] Low-level breakpoint object which is supported by debug monitors.
        /// </param>
        /// <param name="pErrorMessage">
        /// [In] The message to display to the user.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE OnBreakpointConditionFailed(
            _In_ Breakpoints::DkmRuntimeBreakpoint* pRuntimeBreakpoint,
            _In_ DkmString* pErrorMessage
            ) = 0;
    };

    // Implemented by callers of DkmRuntimeBreakpoint.SetCompiledConditionPending to provide
    // compiled conditions when a breakpoint is hit.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // BaseDebugMonitorId, EngineId, RuntimeId, SourceId.
    //
    // This API was introduced in Visual Studio 14 RTM (DkmApiVersion.VS14RTM).
    #define IID_IDkmBreakpointConditionProcessorClient140 __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmBreakpointConditionProcessorClient140)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("9a14241b-1b37-7795-08af-c5e75662f92e") IDkmBreakpointConditionProcessorClient140 : public IUnknown
    {
        /// <summary>
        /// Call back invoked from the breakpoint condition processor to the breakpoint
        /// manager when a breakpoint condition encounters a runtime error.
        /// </summary>
        /// <param name="pRuntimeBreakpoint">
        /// [In] Low-level breakpoint object which is supported by debug monitors.
        /// </param>
        /// <param name="ErrorCode">
        /// [In] Failure code explaining why the IL-based breakpoint query failed to execute.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE OnBreakpointConditionFailed(
            _In_ Breakpoints::DkmRuntimeBreakpoint* pRuntimeBreakpoint,
            _In_ Evaluation::IL::DkmILFailureReason_t ErrorCode
            ) = 0;
    };

    // This interface is implemented by the Breakpoint Manager component to provide the
    // default handling for breakpoints. Other components in the system may also implement
    // this interface to remap the meaning of breakpoints for certain languages.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // BaseDebugMonitorId, CompilerVendorId, EngineId, LanguageId, SourceId.
    #define IID_IDkmBreakpointManager __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmBreakpointManager)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("21ad9ecf-0707-b85a-8b40-32cf146308e7") IDkmBreakpointManager : public IUnknown
    {
        /// <summary>
        /// Sets the state of the pending breakpoint so that instances of the breakpoint that
        /// bind in the future will get hit. If the pending breakpoint is not yet enrolled,
        /// then this method will also enroll the breakpoint. Enrolling a pending breakpoint
        /// consists of attempting to resolve the breakpoint against any modules which are
        /// currently loaded and adding the breakpoint to the list of breakpoints which the
        /// breakpoint manager will bind on any module load. If the pending breakpoint is
        /// already enrolled, existing bound breakpoints will not automatically get enabled.
        /// Bound breakpoints must get enabled separately.
        /// </summary>
        /// <param name="pPendingBreakpoint">
        /// [In] High level breakpoint object which is tied to a user-level construct (ex:
        /// source file, function name) which may map to zero or more code-level constructs
        /// (DkmBoundBreakpoint) and which may be tracked over time.
        /// </param>
        /// <param name="pWorkList">
        /// WorkList which is currently being processed. This value can be used to check for
        /// cancelation or to append additional work. New work items will not begin executing
        /// until after this function returns.
        /// </param>
        /// <param name="pCompletionRoutine">
        /// Routine to fire when the request is complete. This will be implicitly fired if
        /// the implementation returns failure from this interface method. The implementation
        /// must fire this method in all other scenarios.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE EnablePendingBreakpoint(
            _In_ Breakpoints::DkmPendingBreakpoint* pPendingBreakpoint,
            _In_ DkmWorkList* pWorkList,
            _In_ IDkmCompletionRoutine<Breakpoints::DkmEnablePendingBreakpointAsyncResult>* pCompletionRoutine
            ) = 0;

        /// <summary>
        /// Disable the pending breakpoint object so that it will no longer fire. If the
        /// pending breakpoint is already bound, any bound breakpoints will be implicitly
        /// disabled.
        /// </summary>
        /// <param name="pPendingBreakpoint">
        /// [In] High level breakpoint object which is tied to a user-level construct (ex:
        /// source file, function name) which may map to zero or more code-level constructs
        /// (DkmBoundBreakpoint) and which may be tracked over time.
        /// </param>
        /// <param name="pWorkList">
        /// WorkList which is currently being processed. This value can be used to check for
        /// cancelation or to append additional work. New work items will not begin executing
        /// until after this function returns.
        /// </param>
        /// <param name="pCompletionRoutine">
        /// Routine to fire when the request is complete. This will be implicitly fired if
        /// the implementation returns failure from this interface method. The implementation
        /// must fire this method in all other scenarios.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE DisablePendingBreakpoint(
            _In_ Breakpoints::DkmPendingBreakpoint* pPendingBreakpoint,
            _In_ DkmWorkList* pWorkList,
            _In_ IDkmCompletionRoutine<Breakpoints::DkmDisablePendingBreakpointAsyncResult>* pCompletionRoutine
            ) = 0;

        /// <summary>
        /// This method will enroll the pending breakpoint without enabling it. The result is
        /// a breakpoint which the breakpoint manager will attempt to resolve, but which will
        /// not fire. Enrolling a pending breakpoint consists of attempting to resolve the
        /// breakpoint against any modules which are currently loaded and adding the
        /// breakpoint to the list of breakpoints which the breakpoint manager will bind on
        /// any module load.
        /// </summary>
        /// <param name="pPendingBreakpoint">
        /// [In] High level breakpoint object which is tied to a user-level construct (ex:
        /// source file, function name) which may map to zero or more code-level constructs
        /// (DkmBoundBreakpoint) and which may be tracked over time.
        /// </param>
        /// <param name="pWorkList">
        /// WorkList which is currently being processed. This value can be used to check for
        /// cancelation or to append additional work. New work items will not begin executing
        /// until after this function returns.
        /// </param>
        /// <param name="pCompletionRoutine">
        /// Routine to fire when the request is complete. This will be implicitly fired if
        /// the implementation returns failure from this interface method. The implementation
        /// must fire this method in all other scenarios.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE EnrollPendingBreakpoint(
            _In_ Breakpoints::DkmPendingBreakpoint* pPendingBreakpoint,
            _In_ DkmWorkList* pWorkList,
            _In_ IDkmCompletionRoutine<Breakpoints::DkmEnrollPendingBreakpointAsyncResult>* pCompletionRoutine
            ) = 0;

        /// <summary>
        /// Initialize, update or clear the language-level condition on all bound breakpoints
        /// of this condition breakpoint.  If the same breakpoint has both a language-level
        /// condition, and a hit count condition, the language-level condition is applied
        /// first.
        /// </summary>
        /// <param name="pPendingBreakpoint">
        /// [In] High level breakpoint object which is tied to a user-level construct (ex:
        /// source file, function name) which may map to zero or more code-level constructs
        /// (DkmBoundBreakpoint) and which may be tracked over time.
        /// </param>
        /// <param name="pWorkList">
        /// WorkList which is currently being processed. This value can be used to check for
        /// cancelation or to append additional work. New work items will not begin executing
        /// until after this function returns.
        /// </param>
        /// <param name="pCondition">
        /// [In,Optional] Condition to apply to this breakpoint. This value may be 'null' if
        /// the caller wishes to remove the condition.
        /// </param>
        /// <param name="pCompletionRoutine">
        /// Routine to fire when the request is complete. This will be implicitly fired if
        /// the implementation returns failure from this interface method. The implementation
        /// must fire this method in all other scenarios.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE SetPendingBreakpointCondition(
            _In_ Breakpoints::DkmPendingBreakpoint* pPendingBreakpoint,
            _In_ DkmWorkList* pWorkList,
            _In_opt_ Breakpoints::DkmBreakpointCondition* pCondition,
            _In_ IDkmCompletionRoutine<Breakpoints::DkmSetPendingBreakpointConditionAsyncResult>* pCompletionRoutine
            ) = 0;

        /// <summary>
        /// Initialize, update or clear the hit count condition on all bound breakpoints of
        /// this pending breakpoint. If the same breakpoint has both a language-level
        /// condition, and a hit count condition, the language-level condition is applied
        /// first.
        ///
        /// Note that the hit count condition acts independently on each bound breakpoint,
        /// rather than being aggregated together on the pending breakpoint. For example, if
        /// the hit count is configured to stop at hit #2, and the breakpoint to two separate
        /// locations, each of which hit the breakpoint once, the UI will still not have gone
        /// into break mode because neither individual bound breakpoint has hit twice.
        /// </summary>
        /// <param name="pPendingBreakpoint">
        /// [In] High level breakpoint object which is tied to a user-level construct (ex:
        /// source file, function name) which may map to zero or more code-level constructs
        /// (DkmBoundBreakpoint) and which may be tracked over time.
        /// </param>
        /// <param name="pWorkList">
        /// WorkList which is currently being processed. This value can be used to check for
        /// cancelation or to append additional work. New work items will not begin executing
        /// until after this function returns.
        /// </param>
        /// <param name="pCondition">
        /// [In,Optional] Condition to apply to this breakpoint. This value may be 'null' if
        /// the caller wishes to remove the condition.
        /// </param>
        /// <param name="pCompletionRoutine">
        /// Routine to fire when the request is complete. This will be implicitly fired if
        /// the implementation returns failure from this interface method. The implementation
        /// must fire this method in all other scenarios.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE SetPendingBreakpointHitCountCondition(
            _In_ Breakpoints::DkmPendingBreakpoint* pPendingBreakpoint,
            _In_ DkmWorkList* pWorkList,
            _In_opt_ Breakpoints::DkmBreakpointHitCountCondition* pCondition,
            _In_ IDkmCompletionRoutine<Breakpoints::DkmSetPendingBreakpointHitCountConditionAsyncResult>* pCompletionRoutine
            ) = 0;

        /// <summary>
        /// Enables the bound breakpoint so that it can be hit. If the bound breakpoint is
        /// already enabled, this operation has no effect.
        /// </summary>
        /// <param name="pBoundBreakpoint">
        /// [In] Represents a breakpoint which has been bound (resolved) to a particular code
        /// instruction address or a particular data element. For example, in C++ templates
        /// one could create a DkmPendingBreakpoint for a source line. The breakpoint manager
        /// would resolve it to zero (ex: module not loaded), one (ex: template is only used
        /// on 'int') or many (ex: template is used with many template arguments) location.
        /// Each location would have a DkmBoundBreakpoint object.
        /// </param>
        /// <param name="pWorkList">
        /// WorkList which is currently being processed. This value can be used to check for
        /// cancelation or to append additional work. New work items will not begin executing
        /// until after this function returns.
        /// </param>
        /// <param name="pCompletionRoutine">
        /// Routine to fire when the request is complete. This will be implicitly fired if
        /// the implementation returns failure from this interface method. The implementation
        /// must fire this method in all other scenarios.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE EnableBoundBreakpoint(
            _In_ Breakpoints::DkmBoundBreakpoint* pBoundBreakpoint,
            _In_ DkmWorkList* pWorkList,
            _In_ IDkmCompletionRoutine<Breakpoints::DkmEnableBoundBreakpointAsyncResult>* pCompletionRoutine
            ) = 0;

        /// <summary>
        /// Disable the bound breakpoint so that it will no longer hit. If the bound
        /// breakpoint is already disabled, this operation has no effect.
        /// </summary>
        /// <param name="pBoundBreakpoint">
        /// [In] Represents a breakpoint which has been bound (resolved) to a particular code
        /// instruction address or a particular data element. For example, in C++ templates
        /// one could create a DkmPendingBreakpoint for a source line. The breakpoint manager
        /// would resolve it to zero (ex: module not loaded), one (ex: template is only used
        /// on 'int') or many (ex: template is used with many template arguments) location.
        /// Each location would have a DkmBoundBreakpoint object.
        /// </param>
        /// <param name="pWorkList">
        /// WorkList which is currently being processed. This value can be used to check for
        /// cancelation or to append additional work. New work items will not begin executing
        /// until after this function returns.
        /// </param>
        /// <param name="pCompletionRoutine">
        /// Routine to fire when the request is complete. This will be implicitly fired if
        /// the implementation returns failure from this interface method. The implementation
        /// must fire this method in all other scenarios.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE DisableBoundBreakpoint(
            _In_ Breakpoints::DkmBoundBreakpoint* pBoundBreakpoint,
            _In_ DkmWorkList* pWorkList,
            _In_ IDkmCompletionRoutine<Breakpoints::DkmDisableBoundBreakpointAsyncResult>* pCompletionRoutine
            ) = 0;

        /// <summary>
        /// Query to determine if the bound breakpoint is enabled.
        /// </summary>
        /// <param name="pBoundBreakpoint">
        /// [In] Represents a breakpoint which has been bound (resolved) to a particular code
        /// instruction address or a particular data element. For example, in C++ templates
        /// one could create a DkmPendingBreakpoint for a source line. The breakpoint manager
        /// would resolve it to zero (ex: module not loaded), one (ex: template is only used
        /// on 'int') or many (ex: template is used with many template arguments) location.
        /// Each location would have a DkmBoundBreakpoint object.
        /// </param>
        /// <param name="pResult">
        /// [Out] 'true' if the breakpoint is enabled.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE IsBoundBreakpointEnabled(
            _In_ Breakpoints::DkmBoundBreakpoint* pBoundBreakpoint,
            _Out_ bool* pResult
            ) = 0;

        /// <summary>
        /// Initialize or update or clear the condition on a breakpoint.  If the same
        /// breakpoint has both a language-level condition, and a hit count condition, the
        /// language-level condition is applied first.
        /// </summary>
        /// <param name="pBoundBreakpoint">
        /// [In] Represents a breakpoint which has been bound (resolved) to a particular code
        /// instruction address or a particular data element. For example, in C++ templates
        /// one could create a DkmPendingBreakpoint for a source line. The breakpoint manager
        /// would resolve it to zero (ex: module not loaded), one (ex: template is only used
        /// on 'int') or many (ex: template is used with many template arguments) location.
        /// Each location would have a DkmBoundBreakpoint object.
        /// </param>
        /// <param name="pCondition">
        /// [In,Optional] Condition to apply to this breakpoint. This value may be 'null' if
        /// the caller wishes to remove the condition.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE SetBoundBreakpointCondition(
            _In_ Breakpoints::DkmBoundBreakpoint* pBoundBreakpoint,
            _In_opt_ Breakpoints::DkmBreakpointCondition* pCondition
            ) = 0;

        /// <summary>
        /// Initialize, update or clear the hit count condition on a breakpoint. If the same
        /// breakpoint has both a language-level condition, and a hit count condition, the
        /// language-level condition is applied first.
        /// </summary>
        /// <param name="pBoundBreakpoint">
        /// [In] Represents a breakpoint which has been bound (resolved) to a particular code
        /// instruction address or a particular data element. For example, in C++ templates
        /// one could create a DkmPendingBreakpoint for a source line. The breakpoint manager
        /// would resolve it to zero (ex: module not loaded), one (ex: template is only used
        /// on 'int') or many (ex: template is used with many template arguments) location.
        /// Each location would have a DkmBoundBreakpoint object.
        /// </param>
        /// <param name="pCondition">
        /// [In,Optional] Condition to apply to this breakpoint. This value may be 'null' if
        /// the caller wishes to remove the condition.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE SetBoundBreakpointHitCountCondition(
            _In_ Breakpoints::DkmBoundBreakpoint* pBoundBreakpoint,
            _In_opt_ Breakpoints::DkmBreakpointHitCountCondition* pCondition
            ) = 0;

        /// <summary>
        /// Modifies the value for a breakpoint hit count.
        /// </summary>
        /// <param name="pBoundBreakpoint">
        /// [In] Represents a breakpoint which has been bound (resolved) to a particular code
        /// instruction address or a particular data element. For example, in C++ templates
        /// one could create a DkmPendingBreakpoint for a source line. The breakpoint manager
        /// would resolve it to zero (ex: module not loaded), one (ex: template is only used
        /// on 'int') or many (ex: template is used with many template arguments) location.
        /// Each location would have a DkmBoundBreakpoint object.
        /// </param>
        /// <param name="NewValue">
        /// [In] New value for the hit count.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE SetBoundBreakpointHitCountValue(
            _In_ Breakpoints::DkmBoundBreakpoint* pBoundBreakpoint,
            _In_ UINT32 NewValue
            ) = 0;

        /// <summary>
        /// Returns the number of times that a bound breakpoint has been hit. This value
        /// should not include any times when the breakpoint's instruction was executed, but
        /// the breakpoint's condition indicated that the debugger should not stop.
        /// </summary>
        /// <param name="pBoundBreakpoint">
        /// [In] Represents a breakpoint which has been bound (resolved) to a particular code
        /// instruction address or a particular data element. For example, in C++ templates
        /// one could create a DkmPendingBreakpoint for a source line. The breakpoint manager
        /// would resolve it to zero (ex: module not loaded), one (ex: template is only used
        /// on 'int') or many (ex: template is used with many template arguments) location.
        /// Each location would have a DkmBoundBreakpoint object.
        /// </param>
        /// <param name="pWorkList">
        /// WorkList which is currently being processed. This value can be used to check for
        /// cancelation or to append additional work. New work items will not begin executing
        /// until after this function returns.
        /// </param>
        /// <param name="pCompletionRoutine">
        /// Routine to fire when the request is complete. This will be implicitly fired if
        /// the implementation returns failure from this interface method. The implementation
        /// must fire this method in all other scenarios.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE GetBoundBreakpointHitCountValue(
            _In_ Breakpoints::DkmBoundBreakpoint* pBoundBreakpoint,
            _In_ DkmWorkList* pWorkList,
            _In_ IDkmCompletionRoutine<Breakpoints::DkmGetBoundBreakpointHitCountValueAsyncResult>* pCompletionRoutine
            ) = 0;
    };

    // Interface implemented by breakpoint managers which wish to receive notification when
    // files are updated in the IDE.
    //
    // Implementations of this interface are always called (no filtering is supported). To
    // reduce memory impact, it is suggested that this interface be implemented in a small
    // dll, or that the implementation is configured with 'CallOnlyWhenLoaded="true"'.
    #define IID_IDkmBreakpointManagerFileUpdate __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmBreakpointManagerFileUpdate)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("90fe337d-d8a4-ee91-fe3f-53efde6520d4") IDkmBreakpointManagerFileUpdate : public IUnknown
    {
        /// <summary>
        /// Provides notification that one or more files containing breakpoints have been
        /// updated.
        /// </summary>
        /// <param name="pFileUpdateNotification">
        /// [In] Object used to send file update notifications to breakpoint managers.
        /// </param>
        /// <param name="pWorkList">
        /// WorkList which is currently being processed. This value can be used to check for
        /// cancelation or to append additional work. New work items will not begin executing
        /// until after this function returns.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE OnBreakpointFilesUpdated(
            _In_ Breakpoints::DkmBreakpointFileUpdateNotification* pFileUpdateNotification,
            _In_ DkmWorkList* pWorkList
            ) = 0;
    };

    // Allows a component to add additional annotation to the call stack or remove physical
    // frames from the call stack. For performance reasons, stack frame filters are invoked
    // prior to evaluation by expression evaluators. One example stack frame filter is to
    // hide external code in the call stack.  Frame filters that add async stack walk
    // contexts must have a priority of Normal or above.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // BaseDebugMonitorId, EngineId.
    #define IID_IDkmCallStackFilter __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmCallStackFilter)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("56f90ba7-54a6-001e-c419-0c8b60821376") IDkmCallStackFilter : public IUnknown
    {
        /// <summary>
        /// Provides a filter with the next stack frame. A filter can simply pass this frame
        /// on through, it can suppress the frame by returning nothing, or it can provide its
        /// own set of annotated frames. The stack provider will ignore
        /// NotImplementedException (E_NOTIMPL). All other errors will truncate stack walk.
        /// </summary>
        /// <param name="pStackContext">
        /// [In] DkmStackContext objects are created by components that wish to request the
        /// stack from the stack provider. A component needs to close the context after they
        /// have completed the stack walk. To obtain the stack a component should create this
        /// object and then call GetNextFrames.
        /// </param>
        /// <param name="pInput">
        /// [In,Optional] Input is the next frame to examine. After all frame have been
        /// filtered, this function will be called one last time with a null input frame.
        /// This lets the filter know that the call stack is fully processed.
        /// </param>
        /// <param name="pResult">
        /// [Out] DkmStackWalkFrame[] represents a frame on a call stack which has been
        /// walked, but may not have been formatted or filtered. Formatted frames are
        /// represented by DkmStackFrame instead.
        ///
        /// The memory for the DkmArray members is allocated by the method implementation
        /// using DkmAllocBytes/DkmAllocArray. It is freed by the caller using the
        /// CAutoDkmArray template or with DkmFreeMemory and manual element release.
        /// </param>
        /// <returns>
        /// S_OK is returned if pResult contains any elements, S_FALSE is indicates the array
        /// is empty, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE FilterNextFrame(
            _In_ CallStack::DkmStackContext* pStackContext,
            _In_opt_ CallStack::DkmStackWalkFrame* pInput,
            _Out_ DkmArray<CallStack::DkmStackWalkFrame*>* pResult
            ) = 0;
    };

    // Implemented by components that wish to receive custom messages from another Concord
    // component. This is interface is similar to IDkmCustomMessageForwardReceiver, except
    // that this method requires that the caller be at a lower level in the component
    // hierarchy than the component that receives the notification (ex: Base Debug Monitor ->
    // AD7 AL). Implementers of this interface typically use a SourceId filter.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // BaseDebugMonitorId, EngineId, SourceId, TransportKind.
    #define IID_IDkmCustomMessageCallbackReceiver __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmCustomMessageCallbackReceiver)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("dd14a9f2-498e-eb3f-3e3a-21218e758d6e") IDkmCustomMessageCallbackReceiver : public IUnknown
    {
        /// <summary>
        /// Sends a message to a listening component which is higher in the hierarchy.
        /// </summary>
        /// <param name="pCustomMessage">
        /// [In] Message structure used to pass information between custom debugger backend
        /// components and custom visual studio UI components (packages, add-ins, etc).
        /// </param>
        /// <param name="ppReplyMessage">
        /// [Out,Optional] Message sent back from the implementation.
        /// </param>
        /// <returns>
        /// S_OK is returned if *ppReplyMessage is non-NULL, S_FALSE is returned when
        /// *ppReplyMessage is NULL, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE SendHigher(
            _In_ DkmCustomMessage* pCustomMessage,
            _Deref_out_opt_ DkmCustomMessage** ppReplyMessage
            ) = 0;
    };

    // Implemented by components that wish to receive custom messages from the IDE or from
    // another Concord component. This is interface is similar to
    // IDkmCustomMessageCallbackReceiver, except that this method requires that the caller be
    // at a higher level in the component hierarchy than the component that receives the (ex:
    // AD7 AL -> Base Debug Monitor). Implementers of this interface typically use a SourceId
    // filter.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // BaseDebugMonitorId, EngineId, SourceId, TransportKind.
    #define IID_IDkmCustomMessageForwardReceiver __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmCustomMessageForwardReceiver)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("043c14a8-13aa-fece-cdc5-ad57bfc8d1a7") IDkmCustomMessageForwardReceiver : public IUnknown
    {
        /// <summary>
        /// Sends a message to a listening component which is lower in the hierarchy.
        /// </summary>
        /// <param name="pCustomMessage">
        /// [In] Message structure used to pass information between custom debugger backend
        /// components and custom visual studio UI components (packages, add-ins, etc).
        /// </param>
        /// <param name="ppReplyMessage">
        /// [Out,Optional] Message sent back from the implementation.
        /// </param>
        /// <returns>
        /// S_OK is returned if *ppReplyMessage is non-NULL, S_FALSE is returned when
        /// *ppReplyMessage is NULL, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE SendLower(
            _In_ DkmCustomMessage* pCustomMessage,
            _Deref_out_opt_ DkmCustomMessage** ppReplyMessage
            ) = 0;
    };

    // Allows a library that implements exception objects that maintain a captured stack
    // trace to expose this stack trace to the debugger.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // BaseDebugMonitorId, EngineId, ExceptionCategory, RuntimeId.
    //
    // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
    #define IID_IDkmExceptionStackTraceProvider __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmExceptionStackTraceProvider)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("e62065ff-66b2-f2c6-8fe7-1ce92fabd74b") IDkmExceptionStackTraceProvider : public IUnknown
    {
        /// <summary>
        /// Obtains the captured stack trace associated with the exception, if one is
        /// available.
        /// </summary>
        /// <param name="pException">
        /// [In] Provides information about an exception which was raised in the target
        /// process. This information includes details of what exception was raised and the
        /// current stage of exception processing.
        /// </param>
        /// <param name="ppStackTrace">
        /// [Out,Optional] An array of frames that were running at the time the exception got
        /// thrown.
        /// </param>
        /// <returns>
        /// S_OK is returned if *ppStackTrace is non-NULL, S_FALSE is returned when
        /// *ppStackTrace is NULL, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE GetExceptionStackTrace(
            _In_ Exceptions::DkmExceptionInformation* pException,
            _Deref_out_opt_ DkmReadOnlyCollection<DkmInstructionAddress*>** ppStackTrace
            ) = 0;
    };

    // IDkmLaunchResumeProcess is used to launch and resume a process. It is called from the
    // debug monitor in F5, and from the transport in Ctrl-F5.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // BaseDebugMonitorId, EngineId, TransportKind.
    #define IID_IDkmLaunchResumeProcess __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmLaunchResumeProcess)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("38ee0541-48c8-7a9a-9dfe-1fd4cbe3c111") IDkmLaunchResumeProcess : public IUnknown
    {
        /// <summary>
        /// This API is remote-able version of the Win32 CreateProcess API. The
        /// implementation will merge the environment block, process command line redirection
        /// and launch the process. Unless the NoDebug flag is used, CreateProcess will use
        /// the DEBUG_PROCESS flag when creating the Win32 process.
        /// </summary>
        /// <param name="pRequest">
        /// [In] DkmProcessLaunchRequest is used to describe the process that debugger should
        /// launch.
        /// </param>
        /// <param name="AdditionalWin32Flags">
        /// [In] Win32 process creation flags in addition to those found in the
        /// DkmProcessLaunchRequest.Win32Flags. This is often used to pass DEBUG_PROCESS
        /// (0x1), DEBUG_ONLY_THIS_PROCESS (0x2), or CREATE_SUSPENDED (0x4).
        /// </param>
        /// <param name="pLaunchedProcess">
        /// [Out] DkmLaunchedProcessInfo is returned from APIs that launch a process.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE LaunchProcess(
            _In_ Start::DkmProcessLaunchRequest* pRequest,
            _In_ UINT32 AdditionalWin32Flags,
            _Out_ Start::DkmLaunchedProcessInfo* pLaunchedProcess
            ) = 0;

        /// <summary>
        /// This API is used to resume a process which was launched from CreateProcess with
        /// the LaunchSuspended flag set to true.
        /// </summary>
        /// <param name="pRequest">
        /// [In] DkmProcessLaunchRequest is used to describe the process that debugger should
        /// launch.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE ResumeProcess(
            _In_ Start::DkmProcessLaunchRequest* pRequest
            ) = 0;
    };

}; // end of Customize the debugging experience for a library interfaces


// Breakpoint creator interfaces
// Breakpoints are typically by the AD7 adaptation layer in response to a new breakpoint
// request from the UI or from a debugger automation-layer client. Low-level breakpoints
// are also typically created. These can be set through the DkmRuntimeBreakpoint class.
// In addition to these two methods, it is also possible for high-level breakpoints to be
// added to the breakpoint manager through the DkmPendingBreakpoint class. When a
// component chooses to add breakpoints through DkmPendingBreakpoint it should implement
// these interfaces to obtain status.
namespace ComponentInterfaces
{
    // IDkmBoundBreakpointHitNotification is implemented by components that want to listen
    // for the BoundBreakpointHit event. IDkmBoundBreakpointHitNotification is invoked after
    // all implementations of IDkmBoundBreakpointHitReceived. When this notification is
    // called, the target process is stopped and implementers are able to either inspect the
    // process or cause it to execute in a controlled manner (slip, func-eval).
    //
    // Provides notification that a bound breakpoint (DkmBoundBreakpoint) has been hit. Bound
    // breakpoints are the high-level breakpoint objects. Notification for the low level
    // breakpoints (DkmRuntimeBreakpoint) is obtained through the RuntimeBreakpoint event.
    //
    // BoundBreakpointHit events can be suppressed by calling DkmEventDescriptorS.Suppress().
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // BaseDebugMonitorId, CompilerVendorId, EngineId, LanguageId, SourceId.
    #define IID_IDkmBoundBreakpointHitNotification __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmBoundBreakpointHitNotification)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("4a9d4453-aeae-b181-1694-f66637cb196d") IDkmBoundBreakpointHitNotification : public IUnknown
    {
        /// <summary>
        /// OnBoundBreakpointHit is invoked as part of event processing. See interface
        /// definition for more information.
        /// </summary>
        /// <param name="pBoundBreakpoint">
        /// [In] Represents a breakpoint which has been bound (resolved) to a particular code
        /// instruction address or a particular data element. For example, in C++ templates
        /// one could create a DkmPendingBreakpoint for a source line. The breakpoint manager
        /// would resolve it to zero (ex: module not loaded), one (ex: template is only used
        /// on 'int') or many (ex: template is used with many template arguments) location.
        /// Each location would have a DkmBoundBreakpoint object.
        /// </param>
        /// <param name="pThread">
        /// [In] DkmThread represents a thread running in the target process.
        /// </param>
        /// <param name="HasException">
        /// [In] Contains true if the source runtime instance can determine that an exception
        /// is in flight on the thread which hit the breakpoint. Currently, only managed
        /// runtime instances ever set this. This is used to quickly determine if exception
        /// specific logic should apply without making another network round-trip.
        /// </param>
        /// <param name="pEventDescriptor">
        /// [In] Describes the event being processed and provides the ability for a component
        /// to suppress this event.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE OnBoundBreakpointHit(
            _In_ Breakpoints::DkmBoundBreakpoint* pBoundBreakpoint,
            _In_ DkmThread* pThread,
            _In_ bool HasException,
            _In_ DkmEventDescriptorS* pEventDescriptor
            ) = 0;
    };

    // IDkmBoundBreakpointHitReceived is implemented by components that want to listen for
    // the BoundBreakpointHit event. IDkmBoundBreakpointHitReceived is invoked before
    // IDkmBoundBreakpointHitNotification. From within this notification, it is not possible
    // to cause the target process to execute (no func-eval, no slipping).
    //
    // Provides notification that a bound breakpoint (DkmBoundBreakpoint) has been hit. Bound
    // breakpoints are the high-level breakpoint objects. Notification for the low level
    // breakpoints (DkmRuntimeBreakpoint) is obtained through the RuntimeBreakpoint event.
    //
    // BoundBreakpointHit events can be suppressed by calling DkmEventDescriptorS.Suppress().
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // BaseDebugMonitorId, CompilerVendorId, EngineId, LanguageId, SourceId.
    #define IID_IDkmBoundBreakpointHitReceived __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmBoundBreakpointHitReceived)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("11907038-fbf4-ac6f-9b86-00612f438738") IDkmBoundBreakpointHitReceived : public IUnknown
    {
        /// <summary>
        /// OnBoundBreakpointHitReceived is invoked as part of event processing. See
        /// interface definition for more information.
        /// </summary>
        /// <param name="pBoundBreakpoint">
        /// [In] Represents a breakpoint which has been bound (resolved) to a particular code
        /// instruction address or a particular data element. For example, in C++ templates
        /// one could create a DkmPendingBreakpoint for a source line. The breakpoint manager
        /// would resolve it to zero (ex: module not loaded), one (ex: template is only used
        /// on 'int') or many (ex: template is used with many template arguments) location.
        /// Each location would have a DkmBoundBreakpoint object.
        /// </param>
        /// <param name="pThread">
        /// [In] DkmThread represents a thread running in the target process.
        /// </param>
        /// <param name="HasException">
        /// [In] Contains true if the source runtime instance can determine that an exception
        /// is in flight on the thread which hit the breakpoint. Currently, only managed
        /// runtime instances ever set this. This is used to quickly determine if exception
        /// specific logic should apply without making another network round-trip.
        /// </param>
        /// <param name="pEventDescriptor">
        /// [In] Describes the event being processed and provides the ability for a component
        /// to suppress this event.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE OnBoundBreakpointHitReceived(
            _In_ Breakpoints::DkmBoundBreakpoint* pBoundBreakpoint,
            _In_ DkmThread* pThread,
            _In_ bool HasException,
            _In_ DkmEventDescriptorS* pEventDescriptor
            ) = 0;
    };

    // This interface is implemented by components that add breakpoints to the breakpoint
    // manager (such as the AD7 AL). This allows a component to be notified when the
    // breakpoint manager binds a breakpoint or detects a breakpoint error or warning.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // BaseDebugMonitorId, CompilerVendorId, EngineId, LanguageId, SourceId.
    #define IID_IDkmBreakpointManagerNotification __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmBreakpointManagerNotification)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("ce868706-c4b9-08e9-b2a3-a8d64ce034a2") IDkmBreakpointManagerNotification : public IUnknown
    {
        /// <summary>
        /// Notification from the breakpoint manager when a breakpoint has been bound. In the
        /// case of user-set breakpoints, this notification will be sent to the AD7 AL, and
        /// the AD7 AL will fire a IDebugBreakpointBoundEvent2 to the Visual Studio Debugger
        /// UI.
        /// </summary>
        /// <param name="pPendingBreakpoint">
        /// [In] High level breakpoint object which is tied to a user-level construct (ex:
        /// source file, function name) which may map to zero or more code-level constructs
        /// (DkmBoundBreakpoint) and which may be tracked over time.
        /// </param>
        /// <param name="BoundBreakpoints">
        /// [In] Represents a breakpoint which has been bound (resolved) to a particular code
        /// instruction address or a particular data element. For example, in C++ templates
        /// one could create a DkmPendingBreakpoint for a source line. The breakpoint manager
        /// would resolve it to zero (ex: module not loaded), one (ex: template is only used
        /// on 'int') or many (ex: template is used with many template arguments) location.
        /// Each location would have a DkmBoundBreakpoint object.
        ///
        /// The memory for the DkmArray members is allocated by the caller, and can be from
        /// any source (stack memory, static buffer, heap, etc). The implementation should
        /// not modify the members.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE OnBreakpointBound(
            _In_ Breakpoints::DkmPendingBreakpoint* pPendingBreakpoint,
            _In_ const DkmArray<Breakpoints::DkmBoundBreakpoint*>& BoundBreakpoints
            ) = 0;

        /// <summary>
        /// Notification from the breakpoint manager which indicates that the given
        /// breakpoint is being unbound.
        /// </summary>
        /// <param name="pPendingBreakpoint">
        /// [In] High level breakpoint object which is tied to a user-level construct (ex:
        /// source file, function name) which may map to zero or more code-level constructs
        /// (DkmBoundBreakpoint) and which may be tracked over time.
        /// </param>
        /// <param name="BoundBreakpoints">
        /// [In] Represents a breakpoint which has been bound (resolved) to a particular code
        /// instruction address or a particular data element. For example, in C++ templates
        /// one could create a DkmPendingBreakpoint for a source line. The breakpoint manager
        /// would resolve it to zero (ex: module not loaded), one (ex: template is only used
        /// on 'int') or many (ex: template is used with many template arguments) location.
        /// Each location would have a DkmBoundBreakpoint object.
        ///
        /// The memory for the DkmArray members is allocated by the caller, and can be from
        /// any source (stack memory, static buffer, heap, etc). The implementation should
        /// not modify the members.
        /// </param>
        /// <param name="Reason">
        /// [In] Describes the reason for a breakpoint to be unbound.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE OnBreakpointUnbound(
            _In_ Breakpoints::DkmPendingBreakpoint* pPendingBreakpoint,
            _In_ const DkmArray<Breakpoints::DkmBoundBreakpoint*>& BoundBreakpoints,
            _In_ Breakpoints::DkmBreakpointUnboundReason_t Reason
            ) = 0;

        /// <summary>
        /// Notification from the breakpoint manager concerning the status of binding the
        /// breakpoint.
        /// </summary>
        /// <param name="pPendingBreakpoint">
        /// [In] High level breakpoint object which is tied to a user-level construct (ex:
        /// source file, function name) which may map to zero or more code-level constructs
        /// (DkmBoundBreakpoint) and which may be tracked over time.
        /// </param>
        /// <param name="Level">
        /// [In] Describes the severity of a message sent from a breakpoint manager back to
        /// the source component. This list is sorted in order of priority, as the UI will
        /// only display the most important warning. All warnings are ignored if the
        /// breakpoint is bound.
        /// </param>
        /// <param name="pMessage">
        /// [In] Message string to display to the user.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE OnBreakpointMessage(
            _In_ Breakpoints::DkmPendingBreakpoint* pPendingBreakpoint,
            _In_ Breakpoints::DkmBreakpointMessageLevel_t Level,
            _In_ DkmString* pMessage
            ) = 0;
    };

    // This interface is implemented by components that wish to add
    // DkmPendingFileLineBreakpoint objects to the breakpoint manager. The breakpoint manager
    // will query for the current location on the first bind and during an Edit-and-Continue
    // apply.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // BaseDebugMonitorId, CompilerVendorId, EngineId, LanguageId, SourceId.
    #define IID_IDkmPendingFileLineBreakpointCallback __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmPendingFileLineBreakpointCallback)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("bc7a2f08-8934-01ad-1e67-ff937eab25fc") IDkmPendingFileLineBreakpointCallback : public IUnknown
    {
        /// <summary>
        /// Returns the current location of a file/line breakpoint. In edit and continue
        /// scenarios, the location of the text marker may change within a debug session.
        /// </summary>
        /// <param name="pFileLineBreakpoint">
        /// [In] Pending breakpoint which is requested to bind against code elements that
        /// point back to a text span within a source file.
        /// </param>
        /// <param name="ppCurrentPosition">
        /// [Out] Source code position which corresponds to a code element. The could
        /// represent a location which has been extracted from a symbol (PDB) file, or it
        /// could be the location of a breakpoint in the IDE.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE GetCurrentSourcePosition(
            _In_ Breakpoints::DkmPendingFileLineBreakpoint* pFileLineBreakpoint,
            _Deref_out_ Symbols::DkmSourcePosition** ppCurrentPosition
            ) = 0;

        /// <summary>
        /// Returns the current text at the location of a file/line breakpoint.
        /// </summary>
        /// <param name="pFileLineBreakpoint">
        /// [In] Pending breakpoint which is requested to bind against code elements that
        /// point back to a text span within a source file.
        /// </param>
        /// <param name="ppCurrentText">
        /// [Out,Optional] The current source text.
        /// </param>
        /// <returns>
        /// S_OK is returned if *ppCurrentText is non-NULL, S_FALSE is returned when
        /// *ppCurrentText is NULL, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE GetCurrentSourceText(
            _In_ Breakpoints::DkmPendingFileLineBreakpoint* pFileLineBreakpoint,
            _Deref_out_opt_ DkmString** ppCurrentText
            ) = 0;
    };

}; // end of Breakpoint creator interfaces


// Microsoft implemented interfaces
// For the following interfaces, it is expected that they will only be implemented by a
// Microsoft-provided component.
//
// See also: IDkmDebugMonitorExceptionNotification, IDkmOutOfBandExceptionNotification
namespace ComponentInterfaces
{
    // Interface implemented by the Script DM to provide direct access to the target script
    // runtime.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // BaseDebugMonitorId, EngineId, RuntimeId, TransportKind.
    #define IID_IDkmActiveScriptDebugMonitor __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmActiveScriptDebugMonitor)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("1290ef94-6ae5-c0f5-b6bf-929c2f63a447") IDkmActiveScriptDebugMonitor : public IUnknown
    {
        /// <summary>
        /// Allows a caller to obtain a direct access to the IRemoteDebugApplication
        /// interface from the target process. This can be used to load dlls into the target
        /// application, or inspect the target application. Note that this should never be
        /// used for execution control, breakpoints, or evaluation.
        /// </summary>
        /// <param name="pScriptRuntimeInstance">
        /// [In] Represents a script-based execution environment executing in a target
        /// process.
        /// </param>
        /// <param name="ppApplication">
        /// [Out] Debug application interface from the debugged process.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE GetRemoteDebugApplication(
            _In_ Script::DkmScriptRuntimeInstance* pScriptRuntimeInstance,
            _Deref_out_ IRemoteDebugApplication** ppApplication
            ) = 0;

        /// <summary>
        /// API which is called from break mode which tells the script runtime that execution
        /// should be aborted when resuming (BREAKRESUMEACTION_ABORT). This API requires an
        /// MSHTML v10+ target execution environment.
        /// </summary>
        /// <param name="pScriptRuntimeInstance">
        /// [In] Represents a script-based execution environment executing in a target
        /// process.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE AbortExecutionOnResume(
            _In_ Script::DkmScriptRuntimeInstance* pScriptRuntimeInstance
            ) = 0;
    };

    // Interface to enumerate App Package information on the local or remote system.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // TransportKind.
    #define IID_IDkmAppPackageInfo __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmAppPackageInfo)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("be5a0e92-d115-3691-7e4f-c621900ec0cd") IDkmAppPackageInfo : public IUnknown
    {
        /// <summary>
        /// Enumerates installed and launchable (App Packages with applications) App
        /// Packages.
        /// </summary>
        /// <param name="pConnection">
        /// [In] This represents a connection between the monitor and the IDE. It can either
        /// be a local connection if the monitor is running in the same process as the IDE,
        /// or it can be a remote connection. In the monitor process, there is only one
        /// connection.
        /// </param>
        /// <param name="pPackages">
        /// [Out] Array of App Packages found.
        ///
        /// The memory for the DkmArray members is allocated by the method implementation
        /// using DkmAllocBytes/DkmAllocArray. It is freed by the caller using the
        /// CAutoDkmArray template or with DkmFreeMemory and manual element release.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE EnumPackages(
            _In_ DefaultPort::DkmTransportConnection* pConnection,
            _Out_ DkmArray<DefaultPort::DkmInstalledAppPackageInfo*>* pPackages
            ) = 0;
    };

    // Interface implemented on the target computer to handle evaluating breakpoint
    // conditions and hit counts.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // BaseDebugMonitorId, EngineId, RuntimeId, SourceId.
    #define IID_IDkmBreakpointConditionProcessor __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmBreakpointConditionProcessor)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("f7dcc8b5-fee9-38be-0d1b-9e4ed8dc0f7c") IDkmBreakpointConditionProcessor : public IUnknown
    {
        /// <summary>
        /// This sets an associated compiled condition on the specified runtime instruction
        /// breakpoint. The breakpoint condition processor will then test the condition
        /// whenever it is hit. This is used for languages which are evaluated in the IDE
        /// process (ex: C++).
        /// </summary>
        /// <param name="pInstructionBreakpoint">
        /// [In] Low-level breakpoint which is set on an instruction address.
        /// </param>
        /// <param name="pCompiledCondition">
        /// [In] Compiled query used to evaluate the condition.
        /// </param>
        /// <param name="ConditionOperator">
        /// [In] Operator to use when evaluating the condition.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE SetCompiledCondition(
            _In_ Breakpoints::DkmRuntimeInstructionBreakpoint* pInstructionBreakpoint,
            _In_ Evaluation::DkmCompiledInspectionQuery* pCompiledCondition,
            _In_ Breakpoints::DkmBreakpointConditionOperator_t ConditionOperator
            ) = 0;

        /// <summary>
        /// This method is similar to SetCompiledCondition, but is used in cases where the
        /// instruction address is not known up front, such as data breakpoints. In these
        /// cases, when the breakpoint is first hit at a particular address, a call will be
        /// made to the breakpoint client to obtain a new compiled condition for this address
        /// (IDkmBreakpointConditionProcessorClient.GetCompiledCondition).  This is used for
        /// languages which are evaluated in the IDE process (ex: C++).
        /// </summary>
        /// <param name="pRuntimeBreakpoint">
        /// [In] Low-level breakpoint object which is supported by debug monitors.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE SetCompiledConditionPending(
            _In_ Breakpoints::DkmRuntimeBreakpoint* pRuntimeBreakpoint
            ) = 0;

        /// <summary>
        /// Sets a breakpoint condition which is evaluated on the target computer. This is
        /// used for .NET languages.
        /// </summary>
        /// <param name="pRuntimeBreakpoint">
        /// [In] Low-level breakpoint object which is supported by debug monitors.
        /// </param>
        /// <param name="pCondition">
        /// [In] Conditions under which a breakpoint should fire.
        /// </param>
        /// <param name="ppErrorText">
        /// [Out,Optional] If the condition could not be parsed, this indicates the reason
        /// why. This value should be null if the compile succeeded.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE SetEvaluationCondition(
            _In_ Breakpoints::DkmRuntimeBreakpoint* pRuntimeBreakpoint,
            _In_ Breakpoints::DkmBreakpointCondition* pCondition,
            _Deref_out_opt_ DkmString** ppErrorText
            ) = 0;

        /// <summary>
        /// Clear any compiled/evaluation condition associated with the specified
        /// DkmRuntimeBreakpoint. This method is implicitly called when the
        /// DkmRuntimeBreakpoint is closed.
        /// </summary>
        /// <param name="pRuntimeBreakpoint">
        /// [In] Low-level breakpoint object which is supported by debug monitors.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE ClearConditions(
            _In_ Breakpoints::DkmRuntimeBreakpoint* pRuntimeBreakpoint
            ) = 0;

        /// <summary>
        /// Initialize or update the hit count condition/value on a breakpoint. If the same
        /// breakpoint has both a language-level condition, and a hit count condition, the
        /// language-level condition is applied first. The condition is implicitly removed if
        /// the DkmRuntimeBreakpoint is closed.
        /// </summary>
        /// <param name="pRuntimeBreakpoint">
        /// [In] Low-level breakpoint object which is supported by debug monitors.
        /// </param>
        /// <param name="pCondition">
        /// [In] Condition to apply to this breakpoint.
        /// </param>
        /// <param name="HitCountValue">
        /// [In] The initial value of the breakpoint's hit count. A value of -1/MAXDWORD
        /// indicates that the current hit count value should be preserved.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE SetHitCountCondition(
            _In_ Breakpoints::DkmRuntimeBreakpoint* pRuntimeBreakpoint,
            _In_ Breakpoints::DkmBreakpointHitCountCondition* pCondition,
            _In_ UINT32 HitCountValue
            ) = 0;

        /// <summary>
        /// Clears the hit count condition on a breakpoint.
        /// </summary>
        /// <param name="pRuntimeBreakpoint">
        /// [In] Low-level breakpoint object which is supported by debug monitors.
        /// </param>
        /// <param name="pCondition">
        /// [In] Condition to apply to this breakpoint.
        /// </param>
        /// <param name="pCurrentHitCount">
        /// [Out] Number of times that the breakpoint has been hit as of the time that the
        /// condition was removed.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE ClearHitCountCondition(
            _In_ Breakpoints::DkmRuntimeBreakpoint* pRuntimeBreakpoint,
            _In_ Breakpoints::DkmBreakpointHitCountCondition* pCondition,
            _Out_ UINT32* pCurrentHitCount
            ) = 0;

        /// <summary>
        /// Obtains the current hit count value for a DkmRuntimeBreakpoint which has a hit
        /// count condition. This function will fail if the DkmRuntimeBreakpoint does not
        /// currently have a hit count condition.
        /// </summary>
        /// <param name="pRuntimeBreakpoint">
        /// [In] Low-level breakpoint object which is supported by debug monitors.
        /// </param>
        /// <param name="pCurrentHitCount">
        /// [Out] Number of times that the breakpoint has been hit.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE GetHitCountConditionStatus(
            _In_ Breakpoints::DkmRuntimeBreakpoint* pRuntimeBreakpoint,
            _Out_ UINT32* pCurrentHitCount
            ) = 0;
    };

    // Extension interface for GPU debugging, implemented on the target computer to handle
    // evaluating breakpoint conditions.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // BaseDebugMonitorId, EngineId, RuntimeId, SourceId.
    #define IID_IDkmBreakpointConditionProcessorGpuExtension __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmBreakpointConditionProcessorGpuExtension)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("092f0ce3-bfa7-56bd-53d3-9cab54b0acb8") IDkmBreakpointConditionProcessorGpuExtension : public IUnknown
    {
        /// <summary>
        /// This tries to push the associated condition on the specified runtime instruction
        /// breakpoint to the target. This is useful for GPU debugging since testing the
        /// condition on the target (GPU hardware or VSD3D ref) is much more efficient than
        /// doing it in the debugger. Once this method succeeds, breakpoint event will only
        /// be received by the debugger when the condition tests to be true on the debuggee;
        /// if it fails, the debugger can still test the condition.
        /// </summary>
        /// <param name="pInstructionBreakpoint">
        /// [In] Low-level breakpoint which is set on an instruction address.
        /// </param>
        /// <param name="pCompiledCondition">
        /// [In] Compiled query used to evaluate the condition.
        /// </param>
        /// <param name="ConditionOperator">
        /// [In] Operator to use when evaluating the condition.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE TryPushConditionToTargetDevice(
            _In_ Breakpoints::DkmRuntimeInstructionBreakpoint* pInstructionBreakpoint,
            _In_ Evaluation::DkmCompiledInspectionQuery* pCompiledCondition,
            _In_ Breakpoints::DkmBreakpointConditionOperator_t ConditionOperator
            ) = 0;

        /// <summary>
        /// Clear any condition associated with the specified
        /// DkmRuntimeInstructionBreakpoint.
        /// </summary>
        /// <param name="pInstructionBreakpoint">
        /// [In] Low-level breakpoint which is set on an instruction address.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE TryClearConditionOnTargetDevice(
            _In_ Breakpoints::DkmRuntimeInstructionBreakpoint* pInstructionBreakpoint
            ) = 0;

        /// <summary>
        /// The breakpoint condition processor decides not to break on the given thread but
        /// another thread of the same warp, so the breakpoint condition processor instructs
        /// the base debug monitor to re-send the breakpoint event on the other thread.
        /// </summary>
        /// <param name="pRuntimeBreakpoint">
        /// [In] Low-level breakpoint object which is supported by debug monitors.
        /// </param>
        /// <param name="pModifiedBreakThread">
        /// [In] The base debug monitor should re-send breakpoint event on this thread.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE RequestBreakpointEventOnModifiedThread(
            _In_ Breakpoints::DkmRuntimeBreakpoint* pRuntimeBreakpoint,
            _In_ DkmThread* pModifiedBreakThread
            ) = 0;
    };

    // Interface implemented on the target computer to handle evaluating breakpoint
    // conditions on all stopped threads and select the thread whose condition is true for
    // GPU.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // BaseDebugMonitorId, EngineId, RuntimeId, SourceId.
    //
    // This API was introduced in Visual Studio 11 Update 1 (DkmApiVersion.VS11FeaturePack1).
    #define IID_IDkmBreakpointConditionThreadSelectorForGpu __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmBreakpointConditionThreadSelectorForGpu)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("f8eddcb0-ef7e-13da-2362-f7ac536bcd1b") IDkmBreakpointConditionThreadSelectorForGpu : public IUnknown
    {
        /// <summary>
        /// The base debug monitor asks the breakpoint condition processor to evaluate on all
        /// stopped threads, and selects the thread whose condition is true.
        /// </summary>
        /// <param name="pRuntimeBreakpoint">
        /// [In] Low-level breakpoint object which is supported by debug monitors.
        /// </param>
        /// <param name="pFirstStoppedThread">
        /// [In] The first stopped thread.
        /// </param>
        /// <param name="ppConditionMetThread">
        /// [Out,Optional] The thread whose condition is true. The value is null in the case
        /// that no thread is found to have a true condition.
        /// </param>
        /// <returns>
        /// S_OK is returned if *ppConditionMetThread is non-NULL, S_FALSE is returned when
        /// *ppConditionMetThread is NULL, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE EvaluateConditionAndSelectThread(
            _In_ Breakpoints::DkmRuntimeBreakpoint* pRuntimeBreakpoint,
            _In_ DkmThread* pFirstStoppedThread,
            _Deref_out_opt_ DkmThread** ppConditionMetThread
            ) = 0;
    };

    // Interface to update name of the AppDomain.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // BaseDebugMonitorId, EngineId, RuntimeId.
    #define IID_IDkmClrAppDomainNameChanged __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmClrAppDomainNameChanged)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("6b35c9be-346f-108b-02c4-99532b0869cb") IDkmClrAppDomainNameChanged : public IUnknown
    {
        /// <summary>
        /// Called when 'Name' is changed.
        /// </summary>
        /// <param name="pAppDomain">
        /// [In] DkmClrAppDomain represents a CLR app domain inside a process which is being
        /// debugged.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE OnAppDomainNameChanged(
            _In_ Clr::DkmClrAppDomain* pAppDomain
            ) = 0;
    };

    // IDkmClrDebugMonitorExceptionCaughtNotification is implemented by components that want
    // to listen for the ClrDebugMonitorExceptionCaught event. When this notification fires,
    // the target process will be suspended and can be examined. The
    // 'ClrDebugMonitorExceptionCaught' event provides notification from the Managed Debug
    // Monitor about a caught exception which occurred within the target process.  This event
    // is consumed by Diagnostic tools like IntelliTrace to be logged in their
    // TraceDebugger.\n.
    //
    // ClrDebugMonitorExceptionCaught events can be suppressed by calling
    // DkmEventDescriptorS.Suppress().
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // BaseDebugMonitorId, EngineId, RuntimeId.
    //
    // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
    #define IID_IDkmClrDebugMonitorExceptionCaughtNotification __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmClrDebugMonitorExceptionCaughtNotification)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("6623b5f1-9b1b-1c2f-3c01-7b760550d12b") IDkmClrDebugMonitorExceptionCaughtNotification : public IUnknown
    {
        /// <summary>
        /// OnClrDebugMonitorExceptionCaught is invoked as part of event processing. See
        /// interface definition for more information.
        /// </summary>
        /// <param name="pClrCaughtException">
        /// [In] Provides information about an exception which was caught in the target
        /// process. This information includes details of the exception that was caught.
        /// </param>
        /// <param name="pWorkList">
        /// WorkList to append additional event processing work to. This work list will begin
        /// execution after all listeners have been notifiied. The event will not finish
        /// until after the work list fully executes.
        /// </param>
        /// <param name="pEventDescriptor">
        /// [In] Describes the event being processed and provides the ability for a component
        /// to suppress this event.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE OnClrDebugMonitorExceptionCaught(
            _In_ Clr::DkmClrCaughtExceptionInformation* pClrCaughtException,
            _In_ DkmWorkList* pWorkList,
            _In_ DkmEventDescriptorS* pEventDescriptor
            ) = 0;
    };

    // Internal methods used by the CLR Expression Evaluator to communicate between the
    // monitor/IDE.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // CompilerVendorId, LanguageId.
    //
    // This API was introduced in Visual Studio 14 RTM (DkmApiVersion.VS14RTM).
    #define IID_IDkmClrExpressionEvaluatorCallbackInternal __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmClrExpressionEvaluatorCallbackInternal)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("f9daa722-6670-b93e-09a1-ff54c8e2d0ee") IDkmClrExpressionEvaluatorCallbackInternal : public IUnknown
    {
        /// <summary>
        /// This method is used internally by the CLR Expression Evaluator.
        /// </summary>
        /// <param name="pExpression">
        /// [In] DkmLanguageExpression represents an expression to be parsed and evaluated by
        /// an expression evaluator.
        /// </param>
        /// <param name="pModuleInstance">
        /// [In] The module instance containing the type the DebuggerDisplayAttribute applies
        /// to.
        /// </param>
        /// <param name="Token">
        /// [In] The metadata token of the type the DebuggerDisplayAttribute applies to.
        /// </param>
        /// <param name="ppError">
        /// [Out,Optional] Indicates any error compiling the expression.  If the code
        /// compiles successfully, this value should be null. In error cases, this value
        /// indicates the reason for the compile error and the caller should return S_OK.
        /// </param>
        /// <param name="ppResult">
        /// [Out,Optional] The compiled display attribute.  If Result is null, and Error is
        /// not null, there was a compile error.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE CompileDisplayAttributeInternal(
            _In_ Evaluation::DkmLanguageExpression* pExpression,
            _In_ Clr::DkmClrModuleInstance* pModuleInstance,
            _In_ UINT32 Token,
            _Deref_out_opt_ DkmString** ppError,
            _Deref_out_opt_ Evaluation::ClrCompilation::DkmCompiledClrInspectionQuery** ppResult
            ) = 0;
    };

    // Provides the ability to get the generic parameters for a stack frame.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // BaseDebugMonitorId, EngineId, RuntimeId, SymbolProviderId, TransportKind.
    //
    // This API was introduced in Visual Studio 14 RTM (DkmApiVersion.VS14RTM).
    #define IID_IDkmClrFrameGenericParameterProvider __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmClrFrameGenericParameterProvider)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("09d9b0d1-e60d-8f67-7a02-f393d02e7c82") IDkmClrFrameGenericParameterProvider : public IUnknown
    {
        /// <summary>
        /// Gets the generic parameters for the current stack frame as a list of assembly
        /// qualified names.
        /// </summary>
        /// <param name="pFrame">
        /// [In] DkmStackWalkFrame represents a frame on a call stack which has been walked,
        /// but may not have been formatted or filtered. Formatted frames are represented by
        /// DkmStackFrame instead.
        /// </param>
        /// <param name="pParameterTypeNames">
        /// [Out] The list of assembly qualified names for the type parameters, if any,
        /// followed by the method parameters, if any.
        ///
        /// The memory for the DkmArray members is allocated by the method implementation
        /// using DkmAllocBytes/DkmAllocArray. It is freed by the caller using the
        /// CAutoDkmArray template or with DkmFreeMemory and manual element release.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE GetClrGenericParameters(
            _In_ CallStack::DkmStackWalkFrame* pFrame,
            _Out_ DkmArray<DkmString*>* pParameterTypeNames
            ) = 0;
    };

    // Allows execution of queries that have been compiled to Managed IL.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // EngineId, RuntimeId.
    //
    // This API was introduced in Visual Studio 14 RTM (DkmApiVersion.VS14RTM).
    #define IID_IDkmClrInspectionQueryProcessor __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmClrInspectionQueryProcessor)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("7ddc2808-ae6a-25b4-79df-38a8955fb0ab") IDkmClrInspectionQueryProcessor : public IUnknown
    {
        /// <summary>
        /// Execute a compiled inspection query and returns the result as a list of formatted
        /// DkmEvaluationResults.
        /// </summary>
        /// <param name="pCompiledClrInspectionQuery">
        /// [In] Represents an evaluation query that has been compiled to managed IL code.
        /// </param>
        /// <param name="pWorkList">
        /// WorkList which is currently being processed. This value can be used to check for
        /// cancelation or to append additional work. New work items will not begin executing
        /// until after this function returns.
        /// </param>
        /// <param name="pInspectionContext">
        /// [In] The inspection context for this query.
        /// </param>
        /// <param name="pILContext">
        /// [In] The stack context to execute the query against.
        /// </param>
        /// <param name="pExpressionName">
        /// [In] The name of the expression used to create this inspection query.
        /// </param>
        /// <param name="pCompletionRoutine">
        /// Routine to fire when the request is complete. This will be implicitly fired if
        /// the implementation returns failure from this interface method. The implementation
        /// must fire this method in all other scenarios.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE Execute(
            _In_ Evaluation::ClrCompilation::DkmCompiledClrInspectionQuery* pCompiledClrInspectionQuery,
            _In_ DkmWorkList* pWorkList,
            _In_ Evaluation::DkmInspectionContext* pInspectionContext,
            _In_ Evaluation::DkmILContext* pILContext,
            _In_ DkmString* pExpressionName,
            _In_ IDkmCompletionRoutine<Evaluation::ClrCompilation::DkmExecuteClrInspectionQueryAsyncResult>* pCompletionRoutine
            ) = 0;

        /// <summary>
        /// Execute a compiled inspection query to get a set of local variable values as a
        /// list of formatted DkmEvaluationResults.
        /// </summary>
        /// <param name="pCompiledClrLocalsQuery">
        /// [In] Represents a query to populate local variable information using managed IL
        /// code.
        /// </param>
        /// <param name="pWorkList">
        /// WorkList which is currently being processed. This value can be used to check for
        /// cancelation or to append additional work. New work items will not begin executing
        /// until after this function returns.
        /// </param>
        /// <param name="pInspectionContext">
        /// [In] The inspection context for this query.
        /// </param>
        /// <param name="pILContext">
        /// [In] The stack context to execute the query against.
        /// </param>
        /// <param name="FirstLocalIndex">
        /// [In] The index of the first local variable to get the value for.
        /// </param>
        /// <param name="Count">
        /// [In] The number of local variables to get the value for.
        /// </param>
        /// <param name="pCompletionRoutine">
        /// Routine to fire when the request is complete. This will be implicitly fired if
        /// the implementation returns failure from this interface method. The implementation
        /// must fire this method in all other scenarios.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE GetLocalValues(
            _In_ Evaluation::ClrCompilation::DkmCompiledClrLocalsQuery* pCompiledClrLocalsQuery,
            _In_ DkmWorkList* pWorkList,
            _In_ Evaluation::DkmInspectionContext* pInspectionContext,
            _In_ Evaluation::DkmILContext* pILContext,
            _In_ UINT32 FirstLocalIndex,
            _In_ UINT32 Count,
            _In_ IDkmCompletionRoutine<Evaluation::ClrCompilation::DkmGetLocalValuesAsyncResult>* pCompletionRoutine
            ) = 0;

        /// <summary>
        /// Gets the list of aliases that can currently be used in expressions.
        /// </summary>
        /// <param name="pClrRuntimeInstance">
        /// [In] Represents a CLR instance running in a target process.
        /// </param>
        /// <param name="pInspectionContext">
        /// [In,Optional] The current InspectionContext.  If null, aliases that depend on the
        /// current thread or app domain will not be returned by this method.
        /// </param>
        /// <param name="ppResult">
        /// [Out] The list of alias that can currently be used in expressions.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE GetAliases(
            _In_ Clr::DkmClrRuntimeInstance* pClrRuntimeInstance,
            _In_opt_ Evaluation::DkmInspectionContext* pInspectionContext,
            _Deref_out_ DkmReadOnlyCollection<Clr::DkmClrAlias*>** ppResult
            ) = 0;
    };

    // Contains method to load the intrinsic methods assembly.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // BaseDebugMonitorId, EngineId, RuntimeId, TransportKind.
    //
    // This API was introduced in Visual Studio 14 RTM (DkmApiVersion.VS14RTM).
    #define IID_IDkmClrIntrinsicAssemblyProvider __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmClrIntrinsicAssemblyProvider)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("038fd9ce-613c-bb28-bb22-23c45a5604f8") IDkmClrIntrinsicAssemblyProvider : public IUnknown
    {
        /// <summary>
        /// Get metadata for the "Intrinsic Methods Assembly". Intrinsic methods are special
        /// methods the debug engine understands when executing a CLR inspection query.
        /// Example: When evaluating "$exception" in the C# expression evaluator, the C#
        /// expression compiler will emit a call to GetException in the intrinsic methods
        /// assembly.  Instead of executing the call normally, the debugger will instead
        /// simulate the method call and return the exception on the current thread.
        /// </summary>
        /// <param name="pClrRuntimeInstance">
        /// [In] Represents a CLR instance running in a target process.
        /// </param>
        /// <param name="pSize">
        /// [Out] The size of the metadata buffer.
        /// </param>
        /// <param name="pMetaDataPtr">
        /// [Out] A pointer to the metadata buffer.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE GetIntrinsicAssemblyMetaDataBytesPtr(
            _In_ Clr::DkmClrRuntimeInstance* pClrRuntimeInstance,
            _Out_ UINT32* pSize,
            _Out_ LPCVOID* pMetaDataPtr
            ) = 0;
    };

    // Methods to load metadata for modules that are not loaded in the debuggee process.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // BaseDebugMonitorId, EngineId, RuntimeId.
    //
    // This API was introduced in Visual Studio 14 RTM (DkmApiVersion.VS14RTM).
    #define IID_IDkmClrMetaDataLoader __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmClrMetaDataLoader)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("373e1f82-5322-e10c-d6e5-c2082a09257a") IDkmClrMetaDataLoader : public IUnknown
    {
        /// <summary>
        /// Get a pointer to the raw metadata bytes of the manifest module of the requested
        /// assembly that has not been loaded in the debuggee process. NOTE:  This pointer
        /// value will become invalid if/when the actual module loads in the debuggee process
        /// or if the app domain is unloaded.
        /// </summary>
        /// <param name="pAppDomain">
        /// [In] DkmClrAppDomain represents a CLR app domain inside a process which is being
        /// debugged.
        /// </param>
        /// <param name="pAssemblyName">
        /// [In] The fully qualified name of the assembly to load.
        /// </param>
        /// <param name="pSize">
        /// [Out] The size of the metadata buffer.
        /// </param>
        /// <param name="pMetaDataPtr">
        /// [Out] A pointer to the metadata buffer.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// CORDB_E_MISSING_METADATA indicates that the assembly was not found or could not
        /// be loaded.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE GetMetaDataBytesPtr(
            _In_ Clr::DkmClrAppDomain* pAppDomain,
            _In_ DkmString* pAssemblyName,
            _Out_ UINT32* pSize,
            _Out_ LPCVOID* pMetaDataPtr
            ) = 0;

        /// <summary>
        /// Used internally to support DkmClrAppDomain.GetMetaDataBytesPtr.  For performance
        /// reasons, use GetMetaDataBytesPtr instead of this method.
        /// </summary>
        /// <param name="pAppDomain">
        /// [In] DkmClrAppDomain represents a CLR app domain inside a process which is being
        /// debugged.
        /// </param>
        /// <param name="pAssemblyName">
        /// [In] The fully qualified name of the assembly to load.
        /// </param>
        /// <param name="pMvid">
        /// [Out] The MVID of the module that was loaded.
        /// </param>
        /// <param name="pMetaData">
        /// [Out] The metadata blob.
        ///
        /// The memory for the DkmArray members is allocated by the method implementation
        /// using DkmAllocBytes/DkmAllocArray. It is freed by the caller using the
        /// CAutoDkmArray template or with DkmFreeMemory and manual element release.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// CORDB_E_MISSING_METADATA indicates that the assembly was not found or could not
        /// be loaded.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE GetMetaDataBytes(
            _In_ Clr::DkmClrAppDomain* pAppDomain,
            _In_ DkmString* pAssemblyName,
            _Out_ GUID* pMvid,
            _Out_ DkmArray<BYTE>* pMetaData
            ) = 0;

        /// <summary>
        /// Resolve an assembly by name and return the MVID of its manifest module.
        /// </summary>
        /// <param name="pAppDomain">
        /// [In] DkmClrAppDomain represents a CLR app domain inside a process which is being
        /// debugged.
        /// </param>
        /// <param name="pAssemblyName">
        /// [In] The fully qualified name of the assembly to resolve.
        /// </param>
        /// <param name="pMvid">
        /// [Out] The MVID of the resolved assembly's manifest module.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// COR_E_FILENOTFOUND/System.FileNotFoundException indicates that the assembly was
        /// not found or could not be loaded.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE ResolveMvidByAssemblyName(
            _In_ Clr::DkmClrAppDomain* pAppDomain,
            _In_ DkmString* pAssemblyName,
            _Out_ GUID* pMvid
            ) = 0;
    };

    // Interface implemented by the managed DM to obtain the metadata from a given module.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // BaseDebugMonitorId, EngineId, RuntimeId, SymbolProviderId, TransportKind.
    #define IID_IDkmClrMetaDataProvider __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmClrMetaDataProvider)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("eb718ded-9ed6-3c7d-fbcf-8bb4b4c1c332") IDkmClrMetaDataProvider : public IUnknown
    {
        /// <summary>
        /// Obtains the CLR metadata from a given module. See IMetaDataImport documentation
        /// in MSDN for more information on metadata.
        ///
        /// NOTE: Callers must take great care when consuming this API from managed code. The
        /// IMetaDataImport implementation may hold a file handle to a debuggee file, and the
        /// file handle will only be closed when the COM reference count hits zero. So it
        /// must be manually released (Marshal.IsComObject + Marshal.ReleaseComObject) rather
        /// than waiting for the GC to detect that the object can be released. When testing,
        /// be sure that the debuggee file has at least 64KB of metadata, as the metadata
        /// reader will not keep the file locked for reading when dealing with small files.
        /// </summary>
        /// <param name="pClrModuleInstance">
        /// [In] 'DkmClrModuleInstance' is used for modules which are loaded into the Common
        /// Language Runtime.
        /// </param>
        /// <param name="ppMetaData">
        /// [Out] The IMetaDataImport interface for this managed module instance. When
        /// consuming this API from managed code, the RCW which wraps the native
        /// implementation will have its reference count increased by 1 by this API. The
        /// caller should use Marshal.IsComObject + Marshal.ReleaseComObject to release this
        /// reference.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE GetMetaDataImport(
            _In_ Clr::DkmClrModuleInstance* pClrModuleInstance,
            _Deref_out_ IUnknown** ppMetaData
            ) = 0;
    };

    // Added methods for accessing metadata that were added in VS14RTM.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // BaseDebugMonitorId, EngineId, RuntimeId, SymbolProviderId, TransportKind.
    //
    // This API was introduced in Visual Studio 14 RTM (DkmApiVersion.VS14RTM).
    #define IID_IDkmClrMetaDataProvider140 __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmClrMetaDataProvider140)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("bfe68323-b779-230b-dca8-e4b526cfd905") IDkmClrMetaDataProvider140 : public IUnknown
    {
        /// <summary>
        /// Get a pointer to the raw metadata bytes for the given module.
        ///
        /// NOTE:  This pointer value will become invalid if/when the module is unloaded or
        /// modified. To detect this, implement IDkmModuleInstanceUnloadNotification and
        /// IDkmClrModuleModifiedNotification, respectively.
        /// </summary>
        /// <param name="pClrModuleInstance">
        /// [In] 'DkmClrModuleInstance' is used for modules which are loaded into the Common
        /// Language Runtime.
        /// </param>
        /// <param name="pSize">
        /// [Out] The size of the metadata buffer.
        /// </param>
        /// <param name="pMetaDataPtr">
        /// [Out] A pointer to the metadata buffer.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE GetMetaDataBytesPtr(
            _In_ Clr::DkmClrModuleInstance* pClrModuleInstance,
            _Out_ UINT32* pSize,
            _Out_ LPCVOID* pMetaDataPtr
            ) = 0;
    };

    // Provides a method to get the signature token for a local variable signature given a
    // method token. If the method has been modified via EnC, this method returns the latest
    // blob token.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // BaseDebugMonitorId, EngineId, RuntimeId, SymbolProviderId, TransportKind.
    //
    // This API was introduced in Visual Studio 14 RTM (DkmApiVersion.VS14RTM).
    #define IID_IDkmClrMethodSignatureHelper __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmClrMethodSignatureHelper)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("a0bc8485-44c5-1aae-e57f-a84841f256ba") IDkmClrMethodSignatureHelper : public IUnknown
    {
        /// <summary>
        /// Gets the signature token for a local variable signature given a method token.
        /// </summary>
        /// <param name="pClrModuleInstance">
        /// [In] 'DkmClrModuleInstance' is used for modules which are loaded into the Common
        /// Language Runtime.
        /// </param>
        /// <param name="MethodToken">
        /// [In] Token of the method to get the local variable signature for.
        /// </param>
        /// <param name="pLocalSignatureToken">
        /// [Out] The local variable signature blob token.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE GetLocalSignatureToken(
            _In_ Clr::DkmClrModuleInstance* pClrModuleInstance,
            _In_ UINT32 MethodToken,
            _Out_ UINT32* pLocalSignatureToken
            ) = 0;
    };

    // Obtains the DkmClrModuleInstance from an ICorDebugModule.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // BaseDebugMonitorId, EngineId, RuntimeId, TransportKind.
    #define IID_IDkmClrModuleLookup __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmClrModuleLookup)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("627f8870-1e8e-b0f7-52de-cac9608e9d35") IDkmClrModuleLookup : public IUnknown
    {
        /// <summary>
        /// Obtains the DkmClrModuleInstance from an ICorDebugModule.
        /// </summary>
        /// <param name="pClrRuntimeInstance">
        /// [In] Represents a CLR instance running in a target process.
        /// </param>
        /// <param name="pCorModule">
        /// [In] The CLR module to get the module instance for.
        /// </param>
        /// <param name="ppResult">
        /// [Out] The DkmClrModuleInstance that matches the provided ICorDebugModule.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE FindClrModuleInstance(
            _In_ Clr::DkmClrRuntimeInstance* pClrRuntimeInstance,
            _In_ ICorDebugModule* pCorModule,
            _Deref_out_ Clr::DkmClrModuleInstance** ppResult
            ) = 0;
    };

    // Interface implemented by the managed DM to obtain information about the current
    // runtime state of the process.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // BaseDebugMonitorId, EngineId, RuntimeId, SymbolProviderId.
    #define IID_IDkmClrRuntimeDebugMonitor __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmClrRuntimeDebugMonitor)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("a5f24014-9404-5db0-72cd-d4566d8dfcfa") IDkmClrRuntimeDebugMonitor : public IUnknown
    {
        /// <summary>
        /// Obtains non user code status for this instruction address.
        /// </summary>
        /// <param name="pClrAddress">
        /// [In] DkmClrInstructionAddress is used for addresses in managed code.
        /// </param>
        /// <param name="pNonUserCodeFlags">
        /// [Out] The non user code status for this instruction address.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE GetNonUserCodeMetadataFlags(
            _In_ Clr::DkmClrInstructionAddress* pClrAddress,
            _Out_ Clr::DkmNonUserCodeFlags_t* pNonUserCodeFlags
            ) = 0;

        /// <summary>
        /// Provides the map of how this method was compiled to native code.
        /// </summary>
        /// <param name="pClrAddress">
        /// [In] DkmClrInstructionAddress is used for addresses in managed code.
        /// </param>
        /// <param name="pStackFrame">
        /// [In,Optional] Stack frame where this address is from. This is necessary for CLR
        /// v2 support. This argument will be ignored for CLR v4.
        /// </param>
        /// <param name="pMap">
        /// [Out] Structure to define the IL instruction mapping for one or more native
        /// instructions.
        ///
        /// The memory for the DkmArray members is allocated by the method implementation
        /// using DkmAllocBytes/DkmAllocArray. It is freed by the caller using the
        /// CAutoDkmArray template or with DkmFreeMemory and manual element release.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE GetNativeCodeMap(
            _In_ Clr::DkmClrInstructionAddress* pClrAddress,
            _In_opt_ CallStack::DkmStackWalkFrame* pStackFrame,
            _Out_ DkmArray<Clr::DkmClrNativeCodeMapEntry>* pMap
            ) = 0;

        /// <summary>
        /// Obtains the bytes of the CLR metadata from a given module. These bytes can then
        /// be passed to IMetaDataDispenser::OpenScope to decode the metadata.
        /// </summary>
        /// <param name="pClrModuleInstance">
        /// [In] 'DkmClrModuleInstance' is used for modules which are loaded into the Common
        /// Language Runtime.
        /// </param>
        /// <param name="pMetaData">
        /// [Out] The raw metadata for this module.
        ///
        /// The memory for the DkmArray members is allocated by the method implementation
        /// using DkmAllocBytes/DkmAllocArray. It is freed by the caller using the
        /// CAutoDkmArray template or with DkmFreeMemory and manual element release.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE GetMetaDataBytes(
            _In_ Clr::DkmClrModuleInstance* pClrModuleInstance,
            _Out_ DkmArray<BYTE>* pMetaData
            ) = 0;
    };

    // Interface implemented by the managed DM to provide expression evaluators and other
    // components direct access to ICorDebug interfaces.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // BaseDebugMonitorId, EngineId, RuntimeId.
    #define IID_IDkmClrRuntimeDebugMonitorDirect __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmClrRuntimeDebugMonitorDirect)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("9a0b913c-81d3-13c9-b127-5d088cf85f8b") IDkmClrRuntimeDebugMonitorDirect : public IUnknown
    {
        /// <summary>
        /// Provides direct access to the ICorDebugAppDomain object, which expression
        /// evaluators or other components can use to inspect the app domain.
        ///
        /// The returned interface may ONLY be used to inspect the target process, and should
        /// NEVER be used to control execution (no stepping, no breakpoints, no continue,
        /// etc). Doing so is unsupported and will result in undefined behavior.
        /// </summary>
        /// <param name="pAppDomain">
        /// [In] DkmClrAppDomain represents a CLR app domain inside a process which is being
        /// debugged.
        /// </param>
        /// <param name="ppCorAppDomain">
        /// [Out] ICorDebug interface representing an app domain inspection.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE GetCorAppDomain(
            _In_ Clr::DkmClrAppDomain* pAppDomain,
            _Deref_out_ ICorDebugAppDomain** ppCorAppDomain
            ) = 0;

        /// <summary>
        /// Provides direct access to the ICorDebugThread object, which expression evaluators
        /// or other components can use to inspect the app domain.
        ///
        /// The returned interface may ONLY be used to inspect the target process, and should
        /// NEVER be used to control execution (no stepping, no breakpoints, no continue,
        /// etc). Doing so is unsupported and will result in undefined behavior.
        /// </summary>
        /// <param name="pClrRuntimeInstance">
        /// [In] Represents a CLR instance running in a target process.
        /// </param>
        /// <param name="pThread">
        /// [In] DkmThread object that should be mapped to the CorDebug thread.
        /// </param>
        /// <param name="ppCorThread">
        /// [Out] ICorDebug interface representing an app domain inspection.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE GetCorThread(
            _In_ Clr::DkmClrRuntimeInstance* pClrRuntimeInstance,
            _In_ DkmThread* pThread,
            _Deref_out_ ICorDebugThread** ppCorThread
            ) = 0;

        /// <summary>
        /// Provides direct access to the ICorDebugProcess object, which expression
        /// evaluators or other components can use for inspection.
        ///
        /// The returned interface may ONLY be used to inspect the target process, and should
        /// NEVER be used to control execution (no stepping, no breakpoints, no continue,
        /// etc). Doing so is unsupported and will result in undefined behavior.
        /// </summary>
        /// <param name="pClrRuntimeInstance">
        /// [In] Represents a CLR instance running in a target process.
        /// </param>
        /// <param name="ppCorProcess">
        /// [Out] ICorDebug interface representing a process.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE GetCorProcess(
            _In_ Clr::DkmClrRuntimeInstance* pClrRuntimeInstance,
            _Deref_out_ ICorDebugProcess** ppCorProcess
            ) = 0;

        /// <summary>
        /// Provides direct access to the ICorDebugModule object, which expression evaluators
        /// or other components can use to inspect the app domain.
        ///
        /// The returned interface may ONLY be used to inspect the target process, and should
        /// NEVER be used to control execution (no stepping, no breakpoints, no continue,
        /// etc). Doing so is unsupported and will result in undefined behavior.
        /// </summary>
        /// <param name="pClrModuleInstance">
        /// [In] 'DkmClrModuleInstance' is used for modules which are loaded into the Common
        /// Language Runtime.
        /// </param>
        /// <param name="ppCorModule">
        /// [Out] ICorDebug interface representing an app domain inspection.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE GetCorModule(
            _In_ Clr::DkmClrModuleInstance* pClrModuleInstance,
            _Deref_out_ ICorDebugModule** ppCorModule
            ) = 0;

        /// <summary>
        /// Provides direct access to the ICorDebugFunction object, which expression
        /// evaluators or other components can use to inspect the app domain.
        ///
        /// The returned interface may ONLY be used to inspect the target process, and should
        /// NEVER be used to control execution (no stepping, no breakpoints, no continue,
        /// etc). Doing so is unsupported and will result in undefined behavior.
        /// </summary>
        /// <param name="pClrAddress">
        /// [In] DkmClrInstructionAddress is used for addresses in managed code.
        /// </param>
        /// <param name="ppCorFunction">
        /// [Out] ICorDebug interface representing an app domain inspection.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE GetCorFunction(
            _In_ Clr::DkmClrInstructionAddress* pClrAddress,
            _Deref_out_ ICorDebugFunction** ppCorFunction
            ) = 0;
    };

    // This API allows an Expression Evaluator to obtain information contained within a CLR
    // PDB File or CLR dynamic module symbol store.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // SymbolProviderId.
    #define IID_IDkmClrSymbolCallback __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmClrSymbolCallback)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("c4644cb3-10fc-16cd-bd1b-e25a03dbde4f") IDkmClrSymbolCallback : public IUnknown
    {
        /// <summary>
        /// Returns the scopes within a method. There will always be at least one scope.
        /// </summary>
        /// <param name="pModule">
        /// [In] The DkmModule class represents a code bundle (ex: dll or exe) which is or
        /// once was loaded into one or more processes. The DkmModule class is the central
        /// object to the symbol APIs, and is 1:1 with the symbol handler's notation of what
        /// is loaded. If a code bundle loads into three different processes (or the same
        /// process but with three different base addresses or three different app domains)
        /// but the symbol handler thinks of all of these as being identical, there will be
        /// only one module object.
        /// </param>
        /// <param name="MethodId">
        /// [In] DkmClrMethodId is a token/version pair which is used to uniquely identify
        /// the symbol store's understanding of a particular CLR method within a module.
        /// </param>
        /// <param name="pScopes">
        /// [Out] DkmClrMethodScopeData[] describes a scope within a method. These are
        /// defined using ISymUnmanagedWriter::OpenScope/CloseScope.
        ///
        /// The memory for the DkmArray members is allocated by the method implementation
        /// using DkmAllocBytes/DkmAllocArray. It is freed by the caller using the
        /// CAutoDkmArray template or with DkmFreeMemory and manual element release.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE GetMethodSymbolStoreData(
            _In_ Symbols::DkmModule* pModule,
            _In_ const Clr::DkmClrMethodId& MethodId,
            _Out_ DkmArray<Clr::DkmClrMethodScopeData>* pScopes
            ) = 0;

        /// <summary>
        /// Returns the first method in the first document.
        /// </summary>
        /// <param name="pModule">
        /// [In] The DkmModule class represents a code bundle (ex: dll or exe) which is or
        /// once was loaded into one or more processes. The DkmModule class is the central
        /// object to the symbol APIs, and is 1:1 with the symbol handler's notation of what
        /// is loaded. If a code bundle loads into three different processes (or the same
        /// process but with three different base addresses or three different app domains)
        /// but the symbol handler thinks of all of these as being identical, there will be
        /// only one module object.
        /// </param>
        /// <param name="pMethod">
        /// [Out] DkmClrMethodId is a token/version pair which is used to uniquely identify
        /// the symbol store's understanding of a particular CLR method within a module.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE GetFirstMethodInFirstDocument(
            _In_ Symbols::DkmModule* pModule,
            _Out_ Clr::DkmClrMethodId* pMethod
            ) = 0;

        /// <summary>
        /// Returns the scopes within a method. There will always be at least one scope.
        /// </summary>
        /// <param name="pModule">
        /// [In] The DkmModule class represents a code bundle (ex: dll or exe) which is or
        /// once was loaded into one or more processes. The DkmModule class is the central
        /// object to the symbol APIs, and is 1:1 with the symbol handler's notation of what
        /// is loaded. If a code bundle loads into three different processes (or the same
        /// process but with three different base addresses or three different app domains)
        /// but the symbol handler thinks of all of these as being identical, there will be
        /// only one module object.
        /// </param>
        /// <param name="MethodId">
        /// [In] Method Id PreRemap.
        /// </param>
        /// <param name="pRemapToken">
        /// [Out] Method token after the Remap.
        /// </param>
        /// <param name="pScopes">
        /// [Out] DkmClrMethodScopeData[] describes a scope within a method. These are
        /// defined using ISymUnmanagedWriter::OpenScope/CloseScope.
        ///
        /// The memory for the DkmArray members is allocated by the method implementation
        /// using DkmAllocBytes/DkmAllocArray. It is freed by the caller using the
        /// CAutoDkmArray template or with DkmFreeMemory and manual element release.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE GetMethodSymbolStoreDataPreRemap(
            _In_ Symbols::DkmModule* pModule,
            _In_ const Clr::DkmClrMethodId& MethodId,
            _Out_ UINT32* pRemapToken,
            _Out_ DkmArray<Clr::DkmClrMethodScopeData>* pScopes
            ) = 0;

        /// <summary>
        /// Gets a custom attribute based upon its name. Not to be confused with Metadata
        /// custom attributes, these attributes are held in the symbol store.
        /// </summary>
        /// <param name="pModule">
        /// [In] The DkmModule class represents a code bundle (ex: dll or exe) which is or
        /// once was loaded into one or more processes. The DkmModule class is the central
        /// object to the symbol APIs, and is 1:1 with the symbol handler's notation of what
        /// is loaded. If a code bundle loads into three different processes (or the same
        /// process but with three different base addresses or three different app domains)
        /// but the symbol handler thinks of all of these as being identical, there will be
        /// only one module object.
        /// </param>
        /// <param name="ParentToken">
        /// [In] The token of the method where the symbol store attribute is stored.
        /// </param>
        /// <param name="IsPreRemap">
        /// [In] True if the specified token value is not a real method token but rather was
        /// internally computed by the compiler before the method was emitted using the CLR
        /// image creation APIs.
        /// </param>
        /// <param name="pAttributeName">
        /// [In] The name of the attribute to find.
        /// </param>
        /// <param name="pData">
        /// [Out] The value of the requested symbol store attribute. This will be an empty
        /// array if the specified attribute name cannot be found.
        ///
        /// The memory for the DkmArray members is allocated by the method implementation
        /// using DkmAllocBytes/DkmAllocArray. It is freed by the caller using the
        /// CAutoDkmArray template or with DkmFreeMemory and manual element release.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE GetTokenSymbolStoreAttribute(
            _In_ Symbols::DkmModule* pModule,
            _In_ UINT32 ParentToken,
            _In_ bool IsPreRemap,
            _In_ DkmString* pAttributeName,
            _Out_ DkmArray<BYTE>* pData
            ) = 0;

        /// <summary>
        /// Gets the location of the instruction symbol in it's method.
        /// </summary>
        /// <param name="pClrInstruction">
        /// [In] DkmClrInstructionSymbol represents an IL instruction that runs under the
        /// Common Language Runtime (CLR) in the target process. This object contains the
        /// method version number. So in Edit-and-Continue scenarios, the instruction symbol
        /// would be different for different versions of the method. This object does not
        /// contain information about generic binding parameters. So different generic
        /// instantiations of a method (ex: MyMethod&lt;string&gt; and MyMethod&lt;int&gt;)
        /// are represented by the same instruction symbol since the CLR represents them with
        /// a single method token.
        /// </param>
        /// <param name="pAsyncLocation">
        /// [Out] The location of the given instruction.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE GetAsyncMethodLocation(
            _In_ Clr::DkmClrInstructionSymbol* pClrInstruction,
            _Out_ Clr::DkmClrAsyncMethodLocation_t* pAsyncLocation
            ) = 0;

        /// <summary>
        /// Gets the yield and resume points contained within the statement surrounding the
        /// given instruction symbol.
        /// </summary>
        /// <param name="pClrInstruction">
        /// [In] DkmClrInstructionSymbol represents an IL instruction that runs under the
        /// Common Language Runtime (CLR) in the target process. This object contains the
        /// method version number. So in Edit-and-Continue scenarios, the instruction symbol
        /// would be different for different versions of the method. This object does not
        /// contain information about generic binding parameters. So different generic
        /// instantiations of a method (ex: MyMethod&lt;string&gt; and MyMethod&lt;int&gt;)
        /// are represented by the same instruction symbol since the CLR represents them with
        /// a single method token.
        /// </param>
        /// <param name="pAsyncExpressionInfo">
        /// [Out] An array of the yield and resume points for the statement.
        ///
        /// The memory for the DkmArray members is allocated by the method implementation
        /// using DkmAllocBytes/DkmAllocArray. It is freed by the caller using the
        /// CAutoDkmArray template or with DkmFreeMemory and manual element release.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE GetAllAwaitExpressionInfoForStatement(
            _In_ Clr::DkmClrInstructionSymbol* pClrInstruction,
            _Out_ DkmArray<Clr::DkmClrAwaitExpressionInfo>* pAsyncExpressionInfo
            ) = 0;

        /// <summary>
        /// Gets the optional starting IL offset of an async method's generated catch
        /// handler.
        /// </summary>
        /// <param name="pClrInstruction">
        /// [In] DkmClrInstructionSymbol represents an IL instruction that runs under the
        /// Common Language Runtime (CLR) in the target process. This object contains the
        /// method version number. So in Edit-and-Continue scenarios, the instruction symbol
        /// would be different for different versions of the method. This object does not
        /// contain information about generic binding parameters. So different generic
        /// instantiations of a method (ex: MyMethod&lt;string&gt; and MyMethod&lt;int&gt;)
        /// are represented by the same instruction symbol since the CLR represents them with
        /// a single method token.
        /// </param>
        /// <param name="pHasCatchHandlerILOffset">
        /// [Out] True if async method has a catch handler IL offset in the PDB.
        /// </param>
        /// <param name="pCatchHandlerILOffset">
        /// [Out] The catch handler's starting IL offset.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE GetAsyncMethodCatchHandlerILOffset(
            _In_ Clr::DkmClrInstructionSymbol* pClrInstruction,
            _Out_ bool* pHasCatchHandlerILOffset,
            _Out_ UINT32* pCatchHandlerILOffset
            ) = 0;

        /// <summary>
        /// Get the yield and resume information of the next await expression.
        /// </summary>
        /// <param name="pClrInstruction">
        /// [In] DkmClrInstructionSymbol represents an IL instruction that runs under the
        /// Common Language Runtime (CLR) in the target process. This object contains the
        /// method version number. So in Edit-and-Continue scenarios, the instruction symbol
        /// would be different for different versions of the method. This object does not
        /// contain information about generic binding parameters. So different generic
        /// instantiations of a method (ex: MyMethod&lt;string&gt; and MyMethod&lt;int&gt;)
        /// are represented by the same instruction symbol since the CLR represents them with
        /// a single method token.
        /// </param>
        /// <param name="pAwaitExpressionInfo">
        /// [Out] Next await expression info.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE GetNextAwaitExpressionInfo(
            _In_ Clr::DkmClrInstructionSymbol* pClrInstruction,
            _Out_ Clr::DkmClrAwaitExpressionInfo* pAwaitExpressionInfo
            ) = 0;

        /// <summary>
        /// If the current method is an async method then return the kickoff method for this
        /// async method.
        /// </summary>
        /// <param name="pClrInstruction">
        /// [In] DkmClrInstructionSymbol represents an IL instruction that runs under the
        /// Common Language Runtime (CLR) in the target process. This object contains the
        /// method version number. So in Edit-and-Continue scenarios, the instruction symbol
        /// would be different for different versions of the method. This object does not
        /// contain information about generic binding parameters. So different generic
        /// instantiations of a method (ex: MyMethod&lt;string&gt; and MyMethod&lt;int&gt;)
        /// are represented by the same instruction symbol since the CLR represents them with
        /// a single method token.
        /// </param>
        /// <param name="pKickoffMethodToken">
        /// [Out] Kickoff method token.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE GetAsyncKickoffMethod(
            _In_ Clr::DkmClrInstructionSymbol* pClrInstruction,
            _Out_ UINT32* pKickoffMethodToken
            ) = 0;
    };

    // Enhancement to IDkmClrSymbolCallback to allow it to support ClrNc scenarios.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // RuntimeId, SymbolProviderId.
    //
    // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
    #define IID_IDkmClrSymbolCallback120 __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmClrSymbolCallback120)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("f84bbb43-2253-59c4-5cdb-70ad53358374") IDkmClrSymbolCallback120 : public IUnknown
    {
        /// <summary>
        /// Returns the scopes within a method. There will always be at least one scope.
        /// </summary>
        /// <param name="pClrInstruction">
        /// [In] DkmClrInstructionSymbol represents an IL instruction that runs under the
        /// Common Language Runtime (CLR) in the target process. This object contains the
        /// method version number. So in Edit-and-Continue scenarios, the instruction symbol
        /// would be different for different versions of the method. This object does not
        /// contain information about generic binding parameters. So different generic
        /// instantiations of a method (ex: MyMethod&lt;string&gt; and MyMethod&lt;int&gt;)
        /// are represented by the same instruction symbol since the CLR represents them with
        /// a single method token.
        /// </param>
        /// <param name="pScopes">
        /// [Out] DkmClrMethodScopeData[] describes a scope within a method. These are
        /// defined using ISymUnmanagedWriter::OpenScope/CloseScope.
        ///
        /// The memory for the DkmArray members is allocated by the method implementation
        /// using DkmAllocBytes/DkmAllocArray. It is freed by the caller using the
        /// CAutoDkmArray template or with DkmFreeMemory and manual element release.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE GetMethodLocalSymbols(
            _In_ Clr::DkmClrInstructionSymbol* pClrInstruction,
            _Out_ DkmArray<Clr::DkmClrMethodScopeData>* pScopes
            ) = 0;

        /// <summary>
        /// Gets a custom attribute based upon its name. Not to be confused with Metadata
        /// custom attributes, these attributes are held in the symbol store.
        /// </summary>
        /// <param name="pClrInstruction">
        /// [In] DkmClrInstructionSymbol represents an IL instruction that runs under the
        /// Common Language Runtime (CLR) in the target process. This object contains the
        /// method version number. So in Edit-and-Continue scenarios, the instruction symbol
        /// would be different for different versions of the method. This object does not
        /// contain information about generic binding parameters. So different generic
        /// instantiations of a method (ex: MyMethod&lt;string&gt; and MyMethod&lt;int&gt;)
        /// are represented by the same instruction symbol since the CLR represents them with
        /// a single method token.
        /// </param>
        /// <param name="pAttributeName">
        /// [In] The name of the attribute to find.
        /// </param>
        /// <param name="pData">
        /// [Out] The value of the requested symbol store attribute. This will be an empty
        /// array if the specified attribute name cannot be found.
        ///
        /// The memory for the DkmArray members is allocated by the method implementation
        /// using DkmAllocBytes/DkmAllocArray. It is freed by the caller using the
        /// CAutoDkmArray template or with DkmFreeMemory and manual element release.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE GetMethodSymbolStoreAttribute(
            _In_ Clr::DkmClrInstructionSymbol* pClrInstruction,
            _In_ DkmString* pAttributeName,
            _Out_ DkmArray<BYTE>* pData
            ) = 0;
    };

    // Provides APIs to expression evaluators to obtain the signature of local variables and
    // constants.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // SymbolProviderId.
    #define IID_IDkmClrSymbolSignatureCallback __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmClrSymbolSignatureCallback)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("2503e78b-ebb8-ef6b-1a41-c1fc743e6d5e") IDkmClrSymbolSignatureCallback : public IUnknown
    {
        /// <summary>
        /// Provides the COR_SIGNATURE for a local constant.
        /// </summary>
        /// <param name="pClrLocalConstant">
        /// [In] Represents a local constant defined within a method scope. These are defined
        /// with ISymUnmanagedWriter::DefineConstant or
        /// ISymUnmanagedWriter2::DefineConstant2.
        /// </param>
        /// <param name="pSignature">
        /// [Out] The COR_SIGNATURE for the constant, which defines the type of this
        /// constant.
        ///
        /// The memory for the DkmArray members is allocated by the method implementation
        /// using DkmAllocBytes/DkmAllocArray. It is freed by the caller using the
        /// CAutoDkmArray template or with DkmFreeMemory and manual element release.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE GetSignatureForConstant(
            _In_ Clr::DkmClrLocalConstant* pClrLocalConstant,
            _Out_ DkmArray<BYTE>* pSignature
            ) = 0;

        /// <summary>
        /// Provides the COR_SIGNATURE for a local Variable.
        /// </summary>
        /// <param name="pClrLocalVariable">
        /// [In] Represents a local variable defined within a method scope. These are defined
        /// with ISymUnmanagedWriter::DefineLocalVariable or
        /// ISymUnmanagedWriter2::DefineLocalVariable2.
        /// </param>
        /// <param name="pSignature">
        /// [Out] The COR_SIGNATURE for the Variable, which defines the type of this
        /// Variable.
        ///
        /// The memory for the DkmArray members is allocated by the method implementation
        /// using DkmAllocBytes/DkmAllocArray. It is freed by the caller using the
        /// CAutoDkmArray template or with DkmFreeMemory and manual element release.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE GetSignatureForVariable(
            _In_ Clr::DkmClrLocalVariable* pClrLocalVariable,
            _Out_ DkmArray<BYTE>* pSignature
            ) = 0;
    };

    // Interface for resolving types from strings into method id's or type id's.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // BaseDebugMonitorId, EngineId, RuntimeId, SymbolProviderId.
    //
    // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
    #define IID_IDkmClrTypeResolver __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmClrTypeResolver)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("369aef0a-8d41-9914-4d66-bb9444ba059d") IDkmClrTypeResolver : public IUnknown
    {
        /// <summary>
        /// Resolves a method name belonging to a given class into a DkmClrMethodId.
        /// </summary>
        /// <param name="pClrType">
        /// [In] Represents a managed type.
        /// </param>
        /// <param name="pMethodName">
        /// [In] The name of the method.
        /// </param>
        /// <param name="pParameterTypes">
        /// [In,Optional] Optional array of parameter types.
        /// </param>
        /// <param name="pResult">
        /// [Out] A DkmClrMethodId describing the method.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE ResolveMethodName(
            _In_ Clr::DkmClrType* pClrType,
            _In_ DkmString* pMethodName,
            _In_opt_ DkmReadOnlyCollection<Clr::DkmClrType*>* pParameterTypes,
            _Out_ Clr::DkmClrMethodId* pResult
            ) = 0;

        /// <summary>
        /// Resolves a type name into a type.  If the type is generic, the generic parameters
        /// will not be instantiated.
        /// </summary>
        /// <param name="pClrModuleInstance">
        /// [In] 'DkmClrModuleInstance' is used for modules which are loaded into the Common
        /// Language Runtime.
        /// </param>
        /// <param name="pTypeName">
        /// [In] The name of the type.
        /// </param>
        /// <param name="pGenericParameters">
        /// [In,Optional] If the type is generic, specifies the generic parameters for the
        /// type.
        /// </param>
        /// <param name="ppResult">
        /// [Out] A DkmClrType describing the type.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE ResolveTypeName(
            _In_ Clr::DkmClrModuleInstance* pClrModuleInstance,
            _In_ DkmString* pTypeName,
            _In_opt_ DkmReadOnlyCollection<Clr::DkmClrType*>* pGenericParameters,
            _Deref_out_ Clr::DkmClrType** ppResult
            ) = 0;
    };

    // Implemented by expression evaluators which support the C# EE's method of custom
    // viewers (i.e. IPropertyProxyEESide). This interface is subject to change in future
    // releases.
    //
    // Implementations of this interface are always called (no filtering is supported). To
    // reduce memory impact, it is suggested that this interface be implemented in a small
    // dll, or that the implementation is configured with 'CallOnlyWhenLoaded="true"'.
    #define IID_IDkmClrUIVisualizerService __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmClrUIVisualizerService)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("1c940299-48aa-be63-2520-d83d3427b07c") IDkmClrUIVisualizerService : public IUnknown
    {
        /// <summary>
        /// Not described (internal API).
        /// </summary>
        /// <param name="pPropertyProxy">
        /// [In] Concord wrapper around IPropertyProxyEESide.
        /// </param>
        /// <param name="ppDataOut">
        /// [Out,Optional] the result bytes.
        /// </param>
        /// <returns>
        /// S_OK is returned if *ppDataOut is non-NULL, S_FALSE is returned when *ppDataOut
        /// is NULL, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE InitSourceDataProvider(
            _In_ Internal::DkmPropertyProxy* pPropertyProxy,
            _Deref_out_opt_ DkmReadOnlyCollection<BYTE>** ppDataOut
            ) = 0;

        /// <summary>
        /// Not described (internal API).
        /// </summary>
        /// <param name="pPropertyProxy">
        /// [In] Concord wrapper around IPropertyProxyEESide.
        /// </param>
        /// <param name="ppAssemblyName">
        /// [Out,Optional] Not described (internal API).
        /// </param>
        /// <param name="ppAssemblyBytes">
        /// [Out,Optional] Not described (internal API).
        /// </param>
        /// <param name="ppAssemblyPdb">
        /// [Out,Optional] Not described (internal API).
        /// </param>
        /// <param name="ppClassName">
        /// [Out,Optional] class name.
        /// </param>
        /// <param name="pAssemblyResolution">
        /// [Out] enum_ASSEMBLYLOCRESOLUTION enumeration.
        /// </param>
        /// <param name="pReplacementOk">
        /// [Out] replacement ok.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE GetManagedViewerCreationData(
            _In_ Internal::DkmPropertyProxy* pPropertyProxy,
            _Deref_out_opt_ DkmString** ppAssemblyName,
            _Deref_out_opt_ DkmReadOnlyCollection<BYTE>** ppAssemblyBytes,
            _Deref_out_opt_ DkmReadOnlyCollection<BYTE>** ppAssemblyPdb,
            _Deref_out_opt_ DkmString** ppClassName,
            _Out_ UINT32* pAssemblyResolution,
            _Out_ bool* pReplacementOk
            ) = 0;

        /// <summary>
        /// Not described (internal API).
        /// </summary>
        /// <param name="pPropertyProxy">
        /// [In] Concord wrapper around IPropertyProxyEESide.
        /// </param>
        /// <param name="DataIn">
        /// [In] Not described (internal API).
        ///
        /// The memory for the DkmArray members is allocated by the caller, and can be from
        /// any source (stack memory, static buffer, heap, etc). The implementation should
        /// not modify the members.
        /// </param>
        /// <param name="ppDataOut">
        /// [Out,Optional] Not described (internal API).
        /// </param>
        /// <returns>
        /// S_OK is returned if *ppDataOut is non-NULL, S_FALSE is returned when *ppDataOut
        /// is NULL, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE InPlaceUpdateObject(
            _In_ Internal::DkmPropertyProxy* pPropertyProxy,
            _In_ const DkmArray<BYTE>& DataIn,
            _Deref_out_opt_ DkmReadOnlyCollection<BYTE>** ppDataOut
            ) = 0;

        /// <summary>
        /// Implements IPropertyProxyEESide::ResolveAssemblyReference().
        /// </summary>
        /// <param name="pPropertyProxy">
        /// [In] Concord wrapper around IPropertyProxyEESide.
        /// </param>
        /// <param name="pAssemblyName">
        /// [In] Not described (internal API).
        /// </param>
        /// <param name="Flags">
        /// [In] GETASSEMBLY flags.
        /// </param>
        /// <param name="ppAssemblyBytes">
        /// [Out,Optional] Not described (internal API).
        /// </param>
        /// <param name="ppAssemblyPdb">
        /// [Out,Optional] Not described (internal API).
        /// </param>
        /// <param name="ppAssemblyLocation">
        /// [Out,Optional] Not described (internal API).
        /// </param>
        /// <param name="pAssemblyResolution">
        /// [Out] ASSEMBLYLOCRESOLUTION enum.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE ResolveAssemblyReference(
            _In_ Internal::DkmPropertyProxy* pPropertyProxy,
            _In_ DkmString* pAssemblyName,
            _In_ UINT32 Flags,
            _Deref_out_opt_ DkmReadOnlyCollection<BYTE>** ppAssemblyBytes,
            _Deref_out_opt_ DkmReadOnlyCollection<BYTE>** ppAssemblyPdb,
            _Deref_out_opt_ DkmString** ppAssemblyLocation,
            _Out_ UINT32* pAssemblyResolution
            ) = 0;
    };

    // Implemented by expression evaluators which support the C# EE's method of custom
    // viewers (i.e. IPropertyProxyEESide). This interface is subject to change in future
    // releases.
    //
    // Implementations of this interface are always called (no filtering is supported). To
    // reduce memory impact, it is suggested that this interface be implemented in a small
    // dll, or that the implementation is configured with 'CallOnlyWhenLoaded="true"'.
    //
    // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
    #define IID_IDkmClrUIVisualizerService120 __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmClrUIVisualizerService120)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("249ac8c4-54ed-188e-69ad-c8e688482851") IDkmClrUIVisualizerService120 : public IUnknown
    {
        /// <summary>
        /// Not described (internal API).
        /// </summary>
        /// <param name="pPropertyProxy">
        /// [In] Concord wrapper around IPropertyProxyEESide.
        /// </param>
        /// <param name="ppDataOut">
        /// [Out,Optional] Not described (internal API).
        /// </param>
        /// <returns>
        /// S_OK is returned if *ppDataOut is non-NULL, S_FALSE is returned when *ppDataOut
        /// is NULL, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE GetInitialData(
            _In_ Internal::DkmPropertyProxy* pPropertyProxy,
            _Deref_out_opt_ DkmReadOnlyCollection<BYTE>** ppDataOut
            ) = 0;

        /// <summary>
        /// Not described (internal API).
        /// </summary>
        /// <param name="pPropertyProxy">
        /// [In] Concord wrapper around IPropertyProxyEESide.
        /// </param>
        /// <param name="DataIn">
        /// [In] Not described (internal API).
        ///
        /// The memory for the DkmArray members is allocated by the caller, and can be from
        /// any source (stack memory, static buffer, heap, etc). The implementation should
        /// not modify the members.
        /// </param>
        /// <param name="ppDataOut">
        /// [Out,Optional] Not described (internal API).
        /// </param>
        /// <returns>
        /// S_OK is returned if *ppDataOut is non-NULL, S_FALSE is returned when *ppDataOut
        /// is NULL, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE CreateReplacementObject(
            _In_ Internal::DkmPropertyProxy* pPropertyProxy,
            _In_ const DkmArray<BYTE>& DataIn,
            _Deref_out_opt_ DkmReadOnlyCollection<BYTE>** ppDataOut
            ) = 0;
    };

    // Interface implemented to allow inspection of CLR values represented by DkmClrValues.
    //
    // Implementations of this interface are always called (no filtering is supported). To
    // reduce memory impact, it is suggested that this interface be implemented in a small
    // dll, or that the implementation is configured with 'CallOnlyWhenLoaded="true"'.
    //
    // This API was introduced in Visual Studio 14 RTM (DkmApiVersion.VS14RTM).
    #define IID_IDkmClrValueInspectionCallback __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmClrValueInspectionCallback)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("0b9cd6a8-24a6-71f2-d952-3b886bdc5c5e") IDkmClrValueInspectionCallback : public IUnknown
    {
        /// <summary>
        /// Gets attributes on the type that affect the way variables are displayed in the
        /// debugger windows.
        /// </summary>
        /// <param name="pClrType">
        /// [In] Represents a managed type.
        /// </param>
        /// <param name="ppAttributes">
        /// [Out] A list of attributes that apply to this type or its members.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE GetEvalAttributes(
            _In_ Clr::DkmClrType* pClrType,
            _Deref_out_ DkmReadOnlyCollection<Evaluation::ClrCompilation::DkmClrEvalAttribute*>** ppAttributes
            ) = 0;

        /// <summary>
        /// Execute the ToString override on an object represented by the given DkmClrValue.
        /// If the value is of type object or does not override ToString, this method will
        /// return null.  This method requires function evaluation to be enabled.  If
        /// function evaluation is disabled by the user or for any other reason, this method
        /// will return null.  This method will also return null if the function evaluation
        /// fails for any reason.
        /// </summary>
        /// <param name="pClrValue">
        /// [In] A value resulting from a CLR inspection query.  These values are used by a
        /// Result Formatter to generate DkmEvaluationResults.
        /// </param>
        /// <param name="pInspectionContext">
        /// [In] The inspection context for this evaluation.
        /// </param>
        /// <param name="ppResult">
        /// [Out,Optional] The result of calling ToString on the object represented by this
        /// DkmClrValue.
        /// </param>
        /// <returns>
        /// S_OK is returned if *ppResult is non-NULL, S_FALSE is returned when *ppResult is
        /// NULL, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE EvaluateToString(
            _In_ Evaluation::ClrCompilation::DkmClrValue* pClrValue,
            _In_ Evaluation::DkmInspectionContext* pInspectionContext,
            _Deref_out_opt_ DkmString** ppResult
            ) = 0;

        /// <summary>
        /// Gets the string to display in the debugger UI for a CLR value given a
        /// DebuggerDisplay attribute string.
        /// </summary>
        /// <param name="pClrValue">
        /// [In] A value resulting from a CLR inspection query.  These values are used by a
        /// Result Formatter to generate DkmEvaluationResults.
        /// </param>
        /// <param name="pWorkList">
        /// WorkList which is currently being processed. This value can be used to check for
        /// cancelation or to append additional work. New work items will not begin executing
        /// until after this function returns.
        /// </param>
        /// <param name="pInspectionContext">
        /// [In] The inspection context for this evaluation.
        /// </param>
        /// <param name="pTargetType">
        /// [In] The type to use when evaluating debugger display attributes.
        /// </param>
        /// <param name="pFormatString">
        /// [In] The format string to be evaluated by the debugger.  For example "Count =
        /// {Count}".
        /// </param>
        /// <param name="pCompletionRoutine">
        /// Routine to fire when the request is complete. This will be implicitly fired if
        /// the implementation returns failure from this interface method. The implementation
        /// must fire this method in all other scenarios.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE EvaluateDebuggerDisplayString(
            _In_ Evaluation::ClrCompilation::DkmClrValue* pClrValue,
            _In_ DkmWorkList* pWorkList,
            _In_ Evaluation::DkmInspectionContext* pInspectionContext,
            _In_ Clr::DkmClrType* pTargetType,
            _In_ DkmString* pFormatString,
            _In_ IDkmCompletionRoutine<Evaluation::ClrCompilation::DkmEvaluateDebuggerDisplayStringAsyncResult>* pCompletionRoutine
            ) = 0;

        /// <summary>
        /// Instantiate a proxy class for a DkmClrValue with an associated DebuggerTypeProxy
        /// attribute.
        /// </summary>
        /// <param name="pClrValue">
        /// [In] A value resulting from a CLR inspection query.  These values are used by a
        /// Result Formatter to generate DkmEvaluationResults.
        /// </param>
        /// <param name="pInspectionContext">
        /// [In] The inspection context for this evaluation.
        /// </param>
        /// <param name="pType">
        /// [In] The type of the proxy to instantiate.  The proxy type should have a
        /// constructor taking a single parameter. The debugger will pass the instance of the
        /// type being inspected to this constructor.
        /// </param>
        /// <param name="ppResult">
        /// [Out] A value representing the instantiated type proxy.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// E_INVALIDARG indicates that Type is an unconstructed generic type.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE InstantiateProxyType(
            _In_ Evaluation::ClrCompilation::DkmClrValue* pClrValue,
            _In_ Evaluation::DkmInspectionContext* pInspectionContext,
            _In_ Clr::DkmClrType* pType,
            _Deref_out_ Evaluation::ClrCompilation::DkmClrValue** ppResult
            ) = 0;

        /// <summary>
        /// Instantiate the proxy class to use for iterating an IEnumerable value.
        /// </summary>
        /// <param name="pClrValue">
        /// [In] A value resulting from a CLR inspection query.  These values are used by a
        /// Result Formatter to generate DkmEvaluationResults.
        /// </param>
        /// <param name="pInspectionContext">
        /// [In] The inspection context for this evaluation.
        /// </param>
        /// <param name="pEnumerableType">
        /// [In] The interface type (IEnumerable or IEnumerable&lt;T&gt;) to construct the
        /// the results view proxy for. This is needed because a class may implement several
        /// different IEnumerable interfaces.
        /// </param>
        /// <param name="ppResult">
        /// [Out,Optional] A value representing the instantiated results view proxy. This
        /// method returns null in case of failure instantiating the results view proxy.
        /// </param>
        /// <returns>
        /// S_OK is returned if *ppResult is non-NULL, S_FALSE is returned when *ppResult is
        /// NULL, and failure codes are used for any error. COR_E_INVALIDOPERATION indicates
        /// that this method was called on a DkmClrValue that does not implement the
        /// requested interface or represents a null value. E_INVALIDARG indicates that
        /// EnumerableType is not an interface type.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE InstantiateResultsViewProxy(
            _In_ Evaluation::ClrCompilation::DkmClrValue* pClrValue,
            _In_ Evaluation::DkmInspectionContext* pInspectionContext,
            _In_ Clr::DkmClrType* pEnumerableType,
            _Deref_out_opt_ Evaluation::ClrCompilation::DkmClrValue** ppResult
            ) = 0;

        /// <summary>
        /// Instantiate the proxy class to use for iterating the dynamic members of an
        /// IDynamicMetaObjectProvider value.
        /// </summary>
        /// <param name="pClrValue">
        /// [In] A value resulting from a CLR inspection query.  These values are used by a
        /// Result Formatter to generate DkmEvaluationResults.
        /// </param>
        /// <param name="pInspectionContext">
        /// [In] The inspection context for this evaluation.
        /// </param>
        /// <param name="ppResult">
        /// [Out,Optional] A value representing the instantiated results view proxy. This
        /// method returns null in case of failure instantiating the dynamic view proxy.
        /// </param>
        /// <returns>
        /// S_OK is returned if *ppResult is non-NULL, S_FALSE is returned when *ppResult is
        /// NULL, and failure codes are used for any error. COR_E_INVALIDOPERATION indicates
        /// that this method was called on a DkmClrValue that does not implement the
        /// IDynamicMetaObjectProvider interface or represents a null value.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE InstantiateDynamicViewProxy(
            _In_ Evaluation::ClrCompilation::DkmClrValue* pClrValue,
            _In_ Evaluation::DkmInspectionContext* pInspectionContext,
            _Deref_out_opt_ Evaluation::ClrCompilation::DkmClrValue** ppResult
            ) = 0;

        /// <summary>
        /// Gets the value of a field or property as a DkmClrValue.
        /// </summary>
        /// <param name="pClrValue">
        /// [In] A value resulting from a CLR inspection query.  These values are used by a
        /// Result Formatter to generate DkmEvaluationResults.
        /// </param>
        /// <param name="pMemberName">
        /// [In] The name of the member to get the value for.
        /// </param>
        /// <param name="MemberType">
        /// [In] The type of member to get the value for. The value should match a value of
        /// System.Reflection.MemberTypes. This method currently only supports getting the
        /// value for Fields (4) or Properties (16).
        /// </param>
        /// <param name="pParentTypeName">
        /// [In,Optional] The full name of the type containing the member to get the value
        /// for. If ParentTypeName value is null, this method will look for the member in the
        /// runtime type.
        /// </param>
        /// <param name="pInspectionContext">
        /// [In] The inspection context for this evaluation.
        /// </param>
        /// <param name="ppResult">
        /// [Out] The DkmClrValue for the given member.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE GetMemberValue(
            _In_ Evaluation::ClrCompilation::DkmClrValue* pClrValue,
            _In_ DkmString* pMemberName,
            _In_ UINT32 MemberType,
            _In_opt_ DkmString* pParentTypeName,
            _In_ Evaluation::DkmInspectionContext* pInspectionContext,
            _Deref_out_ Evaluation::ClrCompilation::DkmClrValue** ppResult
            ) = 0;

        /// <summary>
        /// Get an array element.  This method may only be used if the DkmClrValue represents
        /// an array value.
        /// </summary>
        /// <param name="pClrValue">
        /// [In] A value resulting from a CLR inspection query.  These values are used by a
        /// Result Formatter to generate DkmEvaluationResults.
        /// </param>
        /// <param name="Index">
        /// [In] The index or indices of the array element to get.
        ///
        /// The memory for the DkmArray members is allocated by the caller, and can be from
        /// any source (stack memory, static buffer, heap, etc). The implementation should
        /// not modify the members.
        /// </param>
        /// <param name="pInspectionContext">
        /// [In] The inspection context for this evaluation.
        /// </param>
        /// <param name="ppResult">
        /// [Out] The element value.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE GetArrayElement(
            _In_ Evaluation::ClrCompilation::DkmClrValue* pClrValue,
            _In_ const DkmArray<UINT32>& Index,
            _In_ Evaluation::DkmInspectionContext* pInspectionContext,
            _Deref_out_ Evaluation::ClrCompilation::DkmClrValue** ppResult
            ) = 0;

        /// <summary>
        /// Dereference this pointer value to get the underlying value.  This method may only
        /// be used if the DkmClrValue represents a Pointer value.
        /// </summary>
        /// <param name="pClrValue">
        /// [In] A value resulting from a CLR inspection query.  These values are used by a
        /// Result Formatter to generate DkmEvaluationResults.
        /// </param>
        /// <param name="pInspectionContext">
        /// [In] The inspection context for this evaluation.
        /// </param>
        /// <param name="ppResult">
        /// [Out] The dereferenced value.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE Dereference(
            _In_ Evaluation::ClrCompilation::DkmClrValue* pClrValue,
            _In_ Evaluation::DkmInspectionContext* pInspectionContext,
            _Deref_out_ Evaluation::ClrCompilation::DkmClrValue** ppResult
            ) = 0;
    };

    // Callback interface implemented by callers of DkmDeploymentCommand.Start to receive
    // notification of events in the deployment command.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // SourceId, TransportKind.
    #define IID_IDkmDeploymentCommandCallback __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmDeploymentCommandCallback)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("bd5a772b-2b1b-636c-aafd-839a7b5c0a0a") IDkmDeploymentCommandCallback : public IUnknown
    {
        /// <summary>
        /// Indication that the launched command has completed. After this is received, no
        /// further notifications will be sent.
        /// </summary>
        /// <param name="pDeploymentCommand">
        /// [In] Object representing an arbitrary executable which is executed on the target
        /// computer.
        /// </param>
        /// <param name="ExitCode">
        /// [In] 32-bit value which the processed returned on exit. This is the same value
        /// that would be reported from the kernel32!GetExitCodeProcess.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE OnProcessExit(
            _In_ DefaultPort::DkmDeploymentCommand* pDeploymentCommand,
            _In_ UINT32 ExitCode
            ) = 0;

        /// <summary>
        /// Indication that the target wrote to stdout. This is also used for StdErr if the
        /// DkmDeploymentCommandFlags.CombineStdErr flag is used.
        /// </summary>
        /// <param name="pDeploymentCommand">
        /// [In] Object representing an arbitrary executable which is executed on the target
        /// computer.
        /// </param>
        /// <param name="pText">
        /// [In] Text written to stdout.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE OnStdOut(
            _In_ DefaultPort::DkmDeploymentCommand* pDeploymentCommand,
            _In_ DkmString* pText
            ) = 0;

        /// <summary>
        /// Indication that the target wrote to stderr. This will not be used if the
        /// DkmDeploymentCommandFlags.CombineStdErr flag is used. Note that the output from
        /// stderr and stdout is not synchronized, so if a program writes to stdout before
        /// stderr, a listener may still get the stderr output first (or vice versa).
        /// </summary>
        /// <param name="pDeploymentCommand">
        /// [In] Object representing an arbitrary executable which is executed on the target
        /// computer.
        /// </param>
        /// <param name="pText">
        /// [In] Text written to stderr.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE OnStdErr(
            _In_ DefaultPort::DkmDeploymentCommand* pDeploymentCommand,
            _In_ DkmString* pText
            ) = 0;
    };

    // IDkmEntryPointNotification is implemented by components that want to listen for the
    // EntryPoint event. IDkmEntryPointNotification is invoked after all implementations of
    // IDkmEntryPointReceived. When this notification is called, the target process is
    // stopped and implementers are able to either inspect the process or cause it to execute
    // in a controlled manner (slip, func-eval).
    //
    // Fired from the breakpoint manager when the entry point breakpoint has been hit.
    //
    // EntryPoint events cannot be suppressed. To override the entry point, implement
    // IDkmEntryPointQuery.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // BaseDebugMonitorId, EngineId, TransportKind.
    #define IID_IDkmEntryPointNotification __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmEntryPointNotification)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("537825af-498e-b770-9103-b6b5fbf5e58d") IDkmEntryPointNotification : public IUnknown
    {
        /// <summary>
        /// OnEntryPoint is invoked as part of event processing. See interface definition for
        /// more information.
        /// </summary>
        /// <param name="pProcess">
        /// [In] DkmProcess represents a target process which is being debugged. The debugger
        /// debugs processes, so this is the basic unit of debugging. A DkmProcess can
        /// represent a system process or a virtual process such as minidumps.
        /// </param>
        /// <param name="pThread">
        /// [In] DkmThread represents a thread running in the target process.
        /// </param>
        /// <param name="pEventDescriptor">
        /// [In] Describes the event being processed.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE OnEntryPoint(
            _In_ DkmProcess* pProcess,
            _In_ DkmThread* pThread,
            _In_ DkmEventDescriptor* pEventDescriptor
            ) = 0;
    };

    // IDkmEntryPointReceived is implemented by components that want to listen for the
    // EntryPoint event. IDkmEntryPointReceived is invoked before IDkmEntryPointNotification.
    // From within this notification, it is not possible to cause the target process to
    // execute (no func-eval, no slipping).
    //
    // Fired from the breakpoint manager when the entry point breakpoint has been hit.
    //
    // EntryPoint events cannot be suppressed. To override the entry point, implement
    // IDkmEntryPointQuery.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // BaseDebugMonitorId, EngineId, TransportKind.
    #define IID_IDkmEntryPointReceived __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmEntryPointReceived)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("818a549c-975d-0253-de0d-0ed090868103") IDkmEntryPointReceived : public IUnknown
    {
        /// <summary>
        /// OnEntryPointReceived is invoked as part of event processing. See interface
        /// definition for more information.
        /// </summary>
        /// <param name="pProcess">
        /// [In] DkmProcess represents a target process which is being debugged. The debugger
        /// debugs processes, so this is the basic unit of debugging. A DkmProcess can
        /// represent a system process or a virtual process such as minidumps.
        /// </param>
        /// <param name="pThread">
        /// [In] DkmThread represents a thread running in the target process.
        /// </param>
        /// <param name="pEventDescriptor">
        /// [In] Describes the event being processed.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE OnEntryPointReceived(
            _In_ DkmProcess* pProcess,
            _In_ DkmThread* pThread,
            _In_ DkmEventDescriptor* pEventDescriptor
            ) = 0;
    };

    // Interface implemented by the exception manager component to allow exception triggers
    // to be enabled or disabled.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // BaseDebugMonitorId, EngineId, TransportKind.
    #define IID_IDkmExceptionManager __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmExceptionManager)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("2b0c253b-41ae-8816-3290-e47bfe3e29f1") IDkmExceptionManager : public IUnknown
    {
        /// <summary>
        /// Adds an exception trigger so that ExceptionTriggerHit events will be sent when
        /// the exception trigger has been met.
        ///
        /// If there is already an exception triggered defined for this {SourceId,
        /// DkmExceptionTrigger} tuple then the existing trigger will be modified with the
        /// new settings. For example, if a component defines a trigger to stop when an
        /// access violation exception is thrown and later sets a trigger to fire when any
        /// Win32 exception goes unhandled, then the access violation trigger will be
        /// removed.
        /// </summary>
        /// <param name="pProcess">
        /// [In] DkmProcess represents a target process which is being debugged. The debugger
        /// debugs processes, so this is the basic unit of debugging. A DkmProcess can
        /// represent a system process or a virtual process such as minidumps.
        /// </param>
        /// <param name="SourceId">
        /// [In] Identifies the source of an object. SourceIds are used to enable filtering
        /// in scenarios when multiple components may be creating instances of a class. For
        /// example, source ids can be used to determine if a breakpoint comes from the AD7
        /// AL (ex: user breakpoint, or other breakpoint visible at the SDM level) instead of
        /// a breakpoint which may be created by another component (for example an internal
        /// breakpoint used for stepping).
        /// </param>
        /// <param name="pTrigger">
        /// [In] Describes an exception or collection of exceptions which a component wants
        /// to break on. When a higher level components wants to be notified about certain
        /// exceptions, it should create one or more exception triggers, and then enable
        /// these triggers (DkmProcess.EnableExceptionTriggers). After this, when the
        /// exception occurs, a ExceptionTriggerHit exception will be fired whenever this
        /// trigger is met.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE AddExceptionTrigger(
            _In_ DkmProcess* pProcess,
            _In_ const GUID& SourceId,
            _In_ Exceptions::DkmExceptionTrigger* pTrigger
            ) = 0;

        /// <summary>
        /// Removes all the exception triggers which have been set with a particular
        /// SourceId. After this method returns, the exception triggers will no longer raise
        /// ExceptionTriggerHit events. Exception triggers are automatically cleared when the
        /// DkmProcess object is closed.
        /// </summary>
        /// <param name="pProcess">
        /// [In] DkmProcess represents a target process which is being debugged. The debugger
        /// debugs processes, so this is the basic unit of debugging. A DkmProcess can
        /// represent a system process or a virtual process such as minidumps.
        /// </param>
        /// <param name="SourceId">
        /// [In] Identifies the source of an object. SourceIds are used to enable filtering
        /// in scenarios when multiple components may be creating instances of a class. For
        /// example, source ids can be used to determine if a breakpoint comes from the AD7
        /// AL (ex: user breakpoint, or other breakpoint visible at the SDM level) instead of
        /// a breakpoint which may be created by another component (for example an internal
        /// breakpoint used for stepping).
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE ClearExceptionTriggers(
            _In_ DkmProcess* pProcess,
            _In_ const GUID& SourceId
            ) = 0;
    };

    // This is an updated version of IDkmExceptionManager, which was added for Visual Studio
    // 14.0 to provide a means of removing exception triggers from the exception manager.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // BaseDebugMonitorId, EngineId, TransportKind.
    //
    // This API was introduced in Visual Studio 14 RTM (DkmApiVersion.VS14RTM).
    #define IID_IDkmExceptionManager140 __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmExceptionManager140)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("f6538195-af92-d939-2d99-45b152bf0e7a") IDkmExceptionManager140 : public IUnknown
    {
        /// <summary>
        /// Removes an exception trigger previously set. Note that the processing stage is
        /// ignored and does not need to match the value originally provided.
        /// </summary>
        /// <param name="pProcess">
        /// [In] DkmProcess represents a target process which is being debugged. The debugger
        /// debugs processes, so this is the basic unit of debugging. A DkmProcess can
        /// represent a system process or a virtual process such as minidumps.
        /// </param>
        /// <param name="SourceId">
        /// [In] Identifies the source of an object. SourceIds are used to enable filtering
        /// in scenarios when multiple components may be creating instances of a class. For
        /// example, source ids can be used to determine if a breakpoint comes from the AD7
        /// AL (ex: user breakpoint, or other breakpoint visible at the SDM level) instead of
        /// a breakpoint which may be created by another component (for example an internal
        /// breakpoint used for stepping).
        /// </param>
        /// <param name="pTrigger">
        /// [In] Describes an exception or collection of exceptions which a component wants
        /// to break on. When a higher level components wants to be notified about certain
        /// exceptions, it should create one or more exception triggers, and then enable
        /// these triggers (DkmProcess.EnableExceptionTriggers). After this, when the
        /// exception occurs, a ExceptionTriggerHit exception will be fired whenever this
        /// trigger is met.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE RemoveExceptionTrigger(
            _In_ DkmProcess* pProcess,
            _In_ const GUID& SourceId,
            _In_ Exceptions::DkmExceptionTrigger* pTrigger
            ) = 0;
    };

    // Optional internal interface which can be implemented to customize the environment of
    // the GPU target process before it is started. From the debug monitor side, this API, or
    // IDkmGPUEnvironmentFilter, can be implemented.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // EngineId.
    #define IID_IDkmGPUEnvironmentFilter __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmGPUEnvironmentFilter)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("badaf0d3-5c93-a55a-c3f1-1daa99e2b1aa") IDkmGPUEnvironmentFilter : public IUnknown
    {
        /// <summary>
        /// Obtains any environment variables which the extension would like to add.
        /// </summary>
        /// <param name="pDebugLaunchSettings">
        /// [In] Settings supplied during a start debugging operation from a project system
        /// or other caller of LaunchDebugTargets (or various other start debugging APIs).
        /// </param>
        /// <param name="Scenario">
        /// [In] Enumeration of the scenarios where IDkmProcessLaunchEnvironmentFilter
        /// implementations are invoked.
        /// </param>
        /// <param name="ppAdditionalEnvironmentBlock">
        /// [Out,Optional] One or more environment variables which should be passed to the
        /// target process. Multiple variables are separated with an embedded null ('\0').
        /// For example: "MyVariable1=1\0MyVariable2=12".
        ///
        /// Null or empty string are returned if the caller doesn't want to customize the
        /// environment block for this launch.
        /// </param>
        /// <returns>
        /// S_OK is returned if *ppAdditionalEnvironmentBlock is non-NULL, S_FALSE is
        /// returned when *ppAdditionalEnvironmentBlock is NULL, and failure codes are used
        /// for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE GetGPUAdditionalEnvironmentVariables(
            _In_ Start::DkmDebugLaunchSettings* pDebugLaunchSettings,
            _In_ Start::DkmProcessLaunchEnvironmentFilterScenario_t Scenario,
            _Deref_out_opt_ DkmString** ppAdditionalEnvironmentBlock
            ) = 0;
    };

    // IDkmHeuristicStackWalker is invoked by the stack provider. It is invoked when
    // attempting to walk through frames without symbols.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // BaseDebugMonitorId, EngineId.
    #define IID_IDkmHeuristicStackWalker __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmHeuristicStackWalker)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("313dd6f8-9b34-364a-1434-e0ddc85ce48e") IDkmHeuristicStackWalker : public IUnknown
    {
        /// <summary>
        /// Attempt to walk through a region of the stack using a heuristic stack walk
        /// algorithm. This is used in x86 when no symbols are available. It is not
        /// implemented on other platforms as PDATA allows walking of all frames.
        /// </summary>
        /// <param name="pStackWalkContext">
        /// [In] DkmStackWalkContext allows the various components which walk, filter, or
        /// examine call stacks to store private data which is associated with this call
        /// stack.
        /// </param>
        /// <param name="pRegisters">
        /// [In] Registers to attempt to walk from.
        /// </param>
        /// <param name="RequestSize">
        /// [In] RequestSize is the number of frames that the caller would like returned. The
        /// implementation of HeuristicWalkFrames may return fewer frames in the case that
        /// stack does not contain that many frames.
        /// </param>
        /// <param name="EndStackPointer">
        /// [In] Stack address to stop the unwinding at. This value is UInt64.MaxValue if the
        /// no end stack pointer is present.
        /// </param>
        /// <param name="pFrames">
        /// [Out] DkmStackWalkFrame[] represents a frame on a call stack which has been
        /// walked, but may not have been formatted or filtered. Formatted frames are
        /// represented by DkmStackFrame instead.
        ///
        /// The memory for the DkmArray members is allocated by the method implementation
        /// using DkmAllocBytes/DkmAllocArray. It is freed by the caller using the
        /// CAutoDkmArray template or with DkmFreeMemory and manual element release.
        /// </param>
        /// <param name="ppNextRegisters">
        /// [Out,Optional] NextRegisters indicates the registers of the next frame (the
        /// caller of 'FrameObject'). This will be null if the stack is complete, or if the
        /// EndStackPointer was reached.
        /// </param>
        /// <param name="pEndOfStack">
        /// [Out] Returns true if the monitor reached the end of the stack.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE HeuristicWalkFrames(
            _In_ CallStack::DkmStackWalkContext* pStackWalkContext,
            _In_ CallStack::DkmFrameRegisters* pRegisters,
            _In_ UINT32 RequestSize,
            _In_ UINT64 EndStackPointer,
            _Out_ DkmArray<CallStack::DkmStackWalkFrame*>* pFrames,
            _Deref_out_opt_ CallStack::DkmFrameRegisters** ppNextRegisters,
            _Out_ bool* pEndOfStack
            ) = 0;
    };

    // IDkmHiddenEntryPointNotification is implemented by components that want to listen for
    // the HiddenEntryPoint event. IDkmHiddenEntryPointNotification is invoked after all
    // implementations of IDkmHiddenEntryPointReceived. When this notification is called, the
    // target process is stopped and implementers are able to either inspect the process or
    // cause it to execute in a controlled manner (slip, func-eval).
    //
    // Fired from the breakpoint manager when the entry point breakpoint has been hit in
    // hidden code. The actual EntryPoint is delayed until we leave hidden code, and might
    // not even be fired if we're unable to find an appropriate opening.  The
    // HiddenEntryPoint will be fired in addition for any behind-the-scenes work necessary.
    //
    // HiddenEntryPoint events cannot be suppressed. To override the entry point, implement
    // IDkmHiddenEntryPointQuery.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // BaseDebugMonitorId, EngineId, TransportKind.
    //
    // This API was introduced in Visual Studio 14 RTM (DkmApiVersion.VS14RTM).
    #define IID_IDkmHiddenEntryPointNotification __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmHiddenEntryPointNotification)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("f1dc4f16-eb64-15b5-70b4-12235dd7a502") IDkmHiddenEntryPointNotification : public IUnknown
    {
        /// <summary>
        /// OnHiddenEntryPoint is invoked as part of event processing. See interface
        /// definition for more information.
        /// </summary>
        /// <param name="pProcess">
        /// [In] DkmProcess represents a target process which is being debugged. The debugger
        /// debugs processes, so this is the basic unit of debugging. A DkmProcess can
        /// represent a system process or a virtual process such as minidumps.
        /// </param>
        /// <param name="pThread">
        /// [In] DkmThread represents a thread running in the target process.
        /// </param>
        /// <param name="pEventDescriptor">
        /// [In] Describes the event being processed.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE OnHiddenEntryPoint(
            _In_ DkmProcess* pProcess,
            _In_ DkmThread* pThread,
            _In_ DkmEventDescriptor* pEventDescriptor
            ) = 0;
    };

    // IDkmHiddenEntryPointReceived is implemented by components that want to listen for the
    // HiddenEntryPoint event. IDkmHiddenEntryPointReceived is invoked before
    // IDkmHiddenEntryPointNotification. From within this notification, it is not possible to
    // cause the target process to execute (no func-eval, no slipping).
    //
    // Fired from the breakpoint manager when the entry point breakpoint has been hit in
    // hidden code. The actual EntryPoint is delayed until we leave hidden code, and might
    // not even be fired if we're unable to find an appropriate opening.  The
    // HiddenEntryPoint will be fired in addition for any behind-the-scenes work necessary.
    //
    // HiddenEntryPoint events cannot be suppressed. To override the entry point, implement
    // IDkmHiddenEntryPointQuery.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // BaseDebugMonitorId, EngineId, TransportKind.
    //
    // This API was introduced in Visual Studio 14 RTM (DkmApiVersion.VS14RTM).
    #define IID_IDkmHiddenEntryPointReceived __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmHiddenEntryPointReceived)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("c54ae880-ec4d-ce0b-79a2-a5a174a6eaad") IDkmHiddenEntryPointReceived : public IUnknown
    {
        /// <summary>
        /// OnHiddenEntryPointReceived is invoked as part of event processing. See interface
        /// definition for more information.
        /// </summary>
        /// <param name="pProcess">
        /// [In] DkmProcess represents a target process which is being debugged. The debugger
        /// debugs processes, so this is the basic unit of debugging. A DkmProcess can
        /// represent a system process or a virtual process such as minidumps.
        /// </param>
        /// <param name="pThread">
        /// [In] DkmThread represents a thread running in the target process.
        /// </param>
        /// <param name="pEventDescriptor">
        /// [In] Describes the event being processed.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE OnHiddenEntryPointReceived(
            _In_ DkmProcess* pProcess,
            _In_ DkmThread* pThread,
            _In_ DkmEventDescriptor* pEventDescriptor
            ) = 0;
    };

    // Interface to provide IIS debugging facilities to the SDM.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // TransportKind.
    #define IID_IDkmIISDebuggingServices __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmIISDebuggingServices)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("251e4dab-7136-dce5-a863-d287c5e5bdba") IDkmIISDebuggingServices : public IUnknown
    {
        /// <summary>
        /// Internal API to diagnose IIS start debugging failures.
        /// </summary>
        /// <param name="pConnection">
        /// [In] This represents a connection between the monitor and the IDE. It can either
        /// be a local connection if the monitor is running in the same process as the IDE,
        /// or it can be a remote connection. In the monitor process, there is only one
        /// connection.
        /// </param>
        /// <param name="pUrl">
        /// [In] URL that the debug verb was sent to.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE DiagnoseRemoteWebDebuggingError(
            _In_ DefaultPort::DkmTransportConnection* pConnection,
            _In_ DkmString* pUrl
            ) = 0;
    };

    // Interface to provide URL->Work process resolution on the Visual Studio computer.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // TransportKind.
    #define IID_IDkmIISResolver __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmIISResolver)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("92a528b4-98bd-8f15-52c4-74a15a6da8c5") IDkmIISResolver : public IUnknown
    {
        /// <summary>
        /// Internal API to determine the IIS processes which the debugger should
        /// automatically attach to.
        /// </summary>
        /// <param name="pConnection">
        /// [In] This represents a connection between the monitor and the IDE. It can either
        /// be a local connection if the monitor is running in the same process as the IDE,
        /// or it can be a remote connection. In the monitor process, there is only one
        /// connection.
        /// </param>
        /// <param name="pUrl">
        /// [In] URL that the debug verb was sent to.
        /// </param>
        /// <param name="pDnsNames">
        /// [In] Semi-colon delimitated string of addresses that URL's host name resolves to.
        /// These are only IPv4 addresses because IIS only supports filtering on IPv4
        /// addresses. This resolution is always done on the VS computer to match the request
        /// from IE.
        /// </param>
        /// <param name="pProcesses">
        /// [Out] IIS worker processes to attach to.
        ///
        /// The memory for the DkmArray members is allocated by the method implementation
        /// using DkmAllocBytes/DkmAllocArray. It is freed by the caller using the
        /// CAutoDkmArray template or with DkmFreeMemory and manual element release.
        /// </param>
        /// <param name="ppExceptionText">
        /// [Out,Optional] Exception text for any caught exception. This may be present in
        /// the S_FALSE case.
        /// </param>
        /// <returns>
        /// S_OK is returned if pProcesses contains any elements, S_FALSE is indicates the
        /// array is empty, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE ResolveUrlToProcessIds(
            _In_ DefaultPort::DkmTransportConnection* pConnection,
            _In_ DkmString* pUrl,
            _In_ DkmString* pDnsNames,
            _Out_ DkmArray<UINT32>* pProcesses,
            _Deref_out_opt_ DkmString** ppExceptionText
            ) = 0;
    };

    // Interface for interpreting IL.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // BaseDebugMonitorId, EngineId, RuntimeId, SymbolProviderId, TransportKind.
    //
    // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
    #define IID_IDkmILInterpreter __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmILInterpreter)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("be7346a5-7bff-ab79-dd9e-ebfac2644677") IDkmILInterpreter : public IUnknown
    {
        /// <summary>
        /// Simulates the execution of a method on an object by interpreting the method's
        /// MSIL code. The result of the method will be returned back to the caller.
        /// However, unlike a function evaluation, in which the method is actually running in
        /// the target, interpreting a method does not actually execute the method, but
        /// instead, merely simulates the behavior of the method.  Because the method never
        /// actually executes, any side effects resulting from the method's execution are
        /// discarded after the interpretation of the method is complete, leaving the target
        /// process in an identical state to that from before the call.
        /// </summary>
        /// <param name="pClrModuleInstance">
        /// [In] 'DkmClrModuleInstance' is used for modules which are loaded into the Common
        /// Language Runtime.
        /// </param>
        /// <param name="Method">
        /// [In] The method to be interpreted.  This function does not support interpreting
        /// certain types of methods, including, but not limited to: - Methods that consume
        /// ref or out parameters - Methods whose implementation calls into native code via
        /// P/Invoke, COM interop, or some other means.
        /// </param>
        /// <param name="pGenericTypeParameters">
        /// [In,Optional] If the method belongs to a generic class, specifies the
        /// instantiations of the type's generic parameters.
        /// </param>
        /// <param name="pGenericMethodParameters">
        /// [In,Optional] If the method is generic, specifies the instantiations of the
        /// method's generic parameters.
        /// </param>
        /// <param name="pThisParameter">
        /// [In,Optional] If the method to be interpreted is non-static, specifies the
        /// non-null object instance that the method should be called on. If the method to be
        /// interpreted is a class constructor, this can be either null or non-null.  A null
        /// this parameter on a class constructor will cause us to virtually create a new
        /// object and interpret the constructor. A non-null this parameter to a constructor
        /// will cause us to interpret the call to the constructor on the existing object.
        /// </param>
        /// <param name="pParameters">
        /// [In,Optional] Parameters to be passed into the function, excluding the 'this'
        /// parameter.  This may be null if the function to be interpreted takes no
        /// parameters. If the function takes parameters, the length of this array must be
        /// equal to the number of parameters specified in the method signature.
        /// </param>
        /// <param name="MaxInstructionCount">
        /// [In] The maximum number of total IL instructions that we are allowed to
        /// interpret.  The IL interpretation will be aborted with an error code of E_ABORT
        /// if the actual number of instructions exceeds this limit.  This limit prevents
        /// Visual Studio from hanging if the code being interpreted enters an infinite loop.
        /// </param>
        /// <param name="Options">
        /// [In] Additional options for the IL interpreter.
        /// </param>
        /// <param name="ppReturnValue">
        /// [Out,Optional] The return value of the method.  This will be null if the method
        /// returns void or throws an exception.
        /// </param>
        /// <param name="ppExceptionType">
        /// [Out,Optional] If the method throws an unhandled exception, the type of the
        /// exception that got thrown.
        /// </param>
        /// <returns>
        /// S_OK is returned if *ppReturnValue is non-NULL, S_FALSE is returned when
        /// *ppReturnValue is NULL, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE InterpretManagedMethod(
            _In_ Clr::DkmClrModuleInstance* pClrModuleInstance,
            _In_ const Clr::DkmClrMethodId& Method,
            _In_opt_ DkmReadOnlyCollection<Clr::DkmClrType*>* pGenericTypeParameters,
            _In_opt_ DkmReadOnlyCollection<Clr::DkmClrType*>* pGenericMethodParameters,
            _In_opt_ Clr::DkmILInterpreterValue* pThisParameter,
            _In_opt_ DkmReadOnlyCollection<Clr::DkmILInterpreterValue*>* pParameters,
            _In_ UINT32 MaxInstructionCount,
            _In_ Clr::DkmILInterpreterOptions_t Options,
            _Deref_out_opt_ Clr::DkmILInterpreterValue** ppReturnValue,
            _Deref_out_opt_ DkmString** ppExceptionType
            ) = 0;
    };

    // Interface to provide process specific instruction addresses.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // BaseDebugMonitorId, EngineId, TransportKind.
    #define IID_IDkmInstructionAddressProvider __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmInstructionAddressProvider)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("c26a0dec-b1da-600d-f8c0-51c334bdbb13") IDkmInstructionAddressProvider : public IUnknown
    {
        /// <summary>
        /// Resolves a CPU InstructionAddress to a DkmInstructionAddress.
        /// </summary>
        /// <param name="pProcess">
        /// [In] DkmProcess represents a target process which is being debugged. The debugger
        /// debugs processes, so this is the basic unit of debugging. A DkmProcess can
        /// represent a system process or a virtual process such as minidumps.
        /// </param>
        /// <param name="pWorkList">
        /// WorkList which is currently being processed. This value can be used to check for
        /// cancelation or to append additional work. New work items will not begin executing
        /// until after this function returns.
        /// </param>
        /// <param name="InstructionPointer">
        /// [In] Memory address where the native instruction is located.
        /// </param>
        /// <param name="pCompletionRoutine">
        /// Routine to fire when the request is complete. This will be implicitly fired if
        /// the implementation returns failure from this interface method. The implementation
        /// must fire this method in all other scenarios.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE GetInstructionAddress(
            _In_ DkmProcess* pProcess,
            _In_ DkmWorkList* pWorkList,
            _In_ UINT64 InstructionPointer,
            _In_ IDkmCompletionRoutine<DkmGetInstructionAddressAsyncResult>* pCompletionRoutine
            ) = 0;
    };

    // Interface implemented by components that wish to receive notification when the base
    // debug monitor performs a memory write to the instruction stream. This interface may
    // only be implemented in the monitor process.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // BaseDebugMonitorId, EngineId, TransportKind.
    #define IID_IDkmInstructionPatchNotification __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmInstructionPatchNotification)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("5068f663-791d-e66a-bf5e-459a63325fc6") IDkmInstructionPatchNotification : public IUnknown
    {
        /// <summary>
        /// Method called by the base debug monitor to inform other components that the
        /// instruction memory of the target process was modified. Currently, this is only
        /// used for breakpoint insertion.
        /// </summary>
        /// <param name="pProcess">
        /// [In] DkmProcess represents a target process which is being debugged. The debugger
        /// debugs processes, so this is the basic unit of debugging. A DkmProcess can
        /// represent a system process or a virtual process such as minidumps.
        /// </param>
        /// <param name="Address">
        /// [In] The base address from which to write the target process's memory.
        /// </param>
        /// <param name="OriginalMemory">
        /// [In] The original code bytes which were replaced in the target process.
        ///
        /// The memory for the DkmArray members is allocated by the caller, and can be from
        /// any source (stack memory, static buffer, heap, etc). The implementation should
        /// not modify the members.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE OnInstructionPatchInserted(
            _In_ DkmProcess* pProcess,
            _In_ UINT64 Address,
            _In_ const DkmArray<BYTE>& OriginalMemory
            ) = 0;

        /// <summary>
        /// Method called by the base debug monitor to inform other components that the
        /// instruction memory of the target process was restored to its original state.
        /// Currently, this is only used for breakpoint removal.
        /// </summary>
        /// <param name="pProcess">
        /// [In] DkmProcess represents a target process which is being debugged. The debugger
        /// debugs processes, so this is the basic unit of debugging. A DkmProcess can
        /// represent a system process or a virtual process such as minidumps.
        /// </param>
        /// <param name="Address">
        /// [In] The base address from which to write the target process's memory.
        /// </param>
        /// <param name="OriginalMemory">
        /// [In] The original code bytes which were restored in the target process.
        ///
        /// The memory for the DkmArray members is allocated by the caller, and can be from
        /// any source (stack memory, static buffer, heap, etc). The implementation should
        /// not modify the members.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE OnInstructionPatchRemoved(
            _In_ DkmProcess* pProcess,
            _In_ UINT64 Address,
            _In_ const DkmArray<BYTE>& OriginalMemory
            ) = 0;
    };

    // Obtains information to construct continuation frames of a managed task.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // EngineId.
    //
    // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
    #define IID_IDkmManagedAsyncTaskDecoder __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmManagedAsyncTaskDecoder)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("c6201787-bdb7-f70d-9bc1-2cc581ca1c7d") IDkmManagedAsyncTaskDecoder : public IUnknown
    {
        /// <summary>
        /// Returns a list of frames that will execute when this task completes.  The order
        /// that the frames will execute in is arbitrary and might not be the order returned
        /// here.  Only frames that will execute as a direct result of this task are
        /// included, not frames that will execute as a result of another task that will
        /// execute after this task completes.
        /// </summary>
        /// <param name="pAsyncStackWalkContext">
        /// [In] Provides a context for walking async return stacks and task creation stacks.
        /// </param>
        /// <param name="pWorkList">
        /// WorkList which is currently being processed. This value can be used to check for
        /// cancelation or to append additional work. New work items will not begin executing
        /// until after this function returns.
        /// </param>
        /// <param name="pThread">
        /// [In] The thread that the resultant frames should belong to.
        /// </param>
        /// <param name="pCompletionRoutine">
        /// Routine to fire when the request is complete. This will be implicitly fired if
        /// the implementation returns failure from this interface method. The implementation
        /// must fire this method in all other scenarios.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE GetManagedTaskContinuationFrames(
            _In_ CallStack::DkmAsyncStackWalkContext* pAsyncStackWalkContext,
            _In_ DkmWorkList* pWorkList,
            _In_ DkmThread* pThread,
            _In_ IDkmCompletionRoutine<CallStack::DkmGetManagedTaskContinuationFramesAsyncResult>* pCompletionRoutine
            ) = 0;

        /// <summary>
        /// Returns a list of frames that will execute when this task completes.  The order
        /// that the frames will execute in is arbitrary and might not be the order returned
        /// here.  Only frames that will execute as a direct result of this task are
        /// included, not frames that will execute as a result of another task that will
        /// execute after this task completes.
        /// </summary>
        /// <param name="pAsyncStackWalkContext">
        /// [In] Provides a context for walking async return stacks and task creation stacks.
        /// </param>
        /// <param name="pWorkList">
        /// WorkList which is currently being processed. This value can be used to check for
        /// cancelation or to append additional work. New work items will not begin executing
        /// until after this function returns.
        /// </param>
        /// <param name="pThread">
        /// [In] The thread that the resultant frames should belong to.
        /// </param>
        /// <param name="pTaskObject">
        /// [In] The task object that we are retrieving continuation frames from.
        /// </param>
        /// <param name="pTaskAppDomain">
        /// [In] The AppDomain of the Task object.
        /// </param>
        /// <param name="pCompletionRoutine">
        /// Routine to fire when the request is complete. This will be implicitly fired if
        /// the implementation returns failure from this interface method. The implementation
        /// must fire this method in all other scenarios.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE GetContinuationFramesFromTaskObject(
            _In_ CallStack::DkmAsyncStackWalkContext* pAsyncStackWalkContext,
            _In_ DkmWorkList* pWorkList,
            _In_ DkmThread* pThread,
            _In_ ICorDebugHandleValue* pTaskObject,
            _In_ Clr::DkmClrAppDomain* pTaskAppDomain,
            _In_ IDkmCompletionRoutine<CallStack::DkmGetContinuationFramesFromTaskObjectAsyncResult>* pCompletionRoutine
            ) = 0;

        /// <summary>
        /// Returns the task handle that was used to create this frame.
        /// </summary>
        /// <param name="pManagedReturnStackFrame">
        /// [In] Contains information needed to construct a managed DkmStackWalkFrame.
        /// </param>
        /// <param name="ppTaskHandle">
        /// [Out] The task handle that matches this frame.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE GetTaskHandleFromManagedReturnFrame(
            _In_ Clr::DkmManagedReturnStackFrame* pManagedReturnStackFrame,
            _Deref_out_ ICorDebugHandleValue** ppTaskHandle
            ) = 0;
    };

    // Interface provided by the managed debug monitor to continue the process for a managed
    // function evaluation.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // BaseDebugMonitorId, EngineId, RuntimeId, TransportKind.
    #define IID_IDkmManagedFuncEvalServices __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmManagedFuncEvalServices)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("a22ace5c-f5d0-89dd-97d7-e9b93c5fed9e") IDkmManagedFuncEvalServices : public IUnknown
    {
        /// <summary>
        /// Continue the process and wait for a func-eval to complete.
        /// </summary>
        /// <param name="pClrRuntimeInstance">
        /// [In] Represents a CLR instance running in a target process.
        /// </param>
        /// <param name="pThread">
        /// [In] The thread for which to do the func-eval.
        /// </param>
        /// <param name="pCorEval">
        /// [In] The object.
        /// </param>
        /// <param name="FuncEvalFlags">
        /// [In] Function evaluation flags.
        /// </param>
        /// <param name="Timeout">
        /// [In] The timeout.
        /// </param>
        /// <param name="pEvaluationString">
        /// [In] The text being evaluated. Displayed in the call stack window if the function
        /// evaluation re-enters break mode.
        /// </param>
        /// <param name="pResult">
        /// [Out] The result of doing the function evaluation. S_OK if all went well. Other
        /// possible values include S_EVAL_TIMEDOUT, S_EVAL_ABORTED, or E_PROCESS_DESTROYED.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE ContinueForFuncEval(
            _In_ Clr::DkmClrRuntimeInstance* pClrRuntimeInstance,
            _In_ DkmThread* pThread,
            _In_ ICorDebugEval* pCorEval,
            _In_ Evaluation::DkmFuncEvalFlags_t FuncEvalFlags,
            _In_ UINT32 Timeout,
            _In_ DkmString* pEvaluationString,
            _Out_ HRESULT* pResult
            ) = 0;

        /// <summary>
        /// Checks if the given thread is in a state in which the CLR supports managed
        /// func-evals.
        /// </summary>
        /// <param name="pClrRuntimeInstance">
        /// [In] Represents a CLR instance running in a target process.
        /// </param>
        /// <param name="pThread">
        /// [In] DkmThread represents a thread running in the target process.
        /// </param>
        /// <param name="pResult">
        /// [Out] The result of doing the function evaluation. S_OK if all went well. Other
        /// possible values include E_EVAL_FUNCEVAL_IN_MINIDUMP or S_EVAL_BAD_THREAD_STATE.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE CanDoFuncEval(
            _In_ Clr::DkmClrRuntimeInstance* pClrRuntimeInstance,
            _In_ DkmThread* pThread,
            _Out_ HRESULT* pResult
            ) = 0;
    };

    // Interface implemented by sampler to obtain sampled managed heap.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // EngineId, RuntimeId.
    //
    // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
    #define IID_IDkmManagedHeapSampler __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmManagedHeapSampler)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("6ebb0305-8e03-b0f8-8733-9325a2219e26") IDkmManagedHeapSampler : public IUnknown
    {
        /// <summary>
        /// Initializes heap sampler.
        /// </summary>
        /// <param name="pManagedHeapSampler">
        /// [In] DkmManagedHeapSampler represents a sampler for objects in the managed heap.
        /// </param>
        /// <param name="TargetObjectCount">
        /// [In] The number of sampled objects to return.
        /// </param>
        /// <param name="LiveObjectStatsOnly">
        /// [In] Whether the sampler should calculate stats for only the live objects on the
        /// heap.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// E_MANAGED_HEAP_NOT_ENUMERABLE indicates that the managed heap is not a state that
        /// can be enumerated.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE InitializeHeapObjectWalk(
            _In_ Clr::DkmManagedHeapSampler* pManagedHeapSampler,
            _In_ UINT32 TargetObjectCount,
            _In_ bool LiveObjectStatsOnly
            ) = 0;

        /// <summary>
        /// Walks the given number of objects on the heap.
        /// </summary>
        /// <param name="pManagedHeapSampler">
        /// [In] DkmManagedHeapSampler represents a sampler for objects in the managed heap.
        /// </param>
        /// <param name="RequestCount">
        /// [In] Count of items requested.
        /// </param>
        /// <param name="pFetchedCount">
        /// [Out] Count of items fetched.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE NextObjects(
            _In_ Clr::DkmManagedHeapSampler* pManagedHeapSampler,
            _In_ UINT32 RequestCount,
            _Out_ UINT32* pFetchedCount
            ) = 0;

        /// <summary>
        /// Walks the given number of references on the heap.
        /// </summary>
        /// <param name="pManagedHeapSampler">
        /// [In] DkmManagedHeapSampler represents a sampler for objects in the managed heap.
        /// </param>
        /// <param name="RequestCount">
        /// [In] Count of items requested.
        /// </param>
        /// <param name="pFetchedCount">
        /// [Out] Count of items fetched.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE NextReferences(
            _In_ Clr::DkmManagedHeapSampler* pManagedHeapSampler,
            _In_ UINT32 RequestCount,
            _Out_ UINT32* pFetchedCount
            ) = 0;

        /// <summary>
        /// Walks the given number of GC roots on the heap.
        /// </summary>
        /// <param name="pManagedHeapSampler">
        /// [In] DkmManagedHeapSampler represents a sampler for objects in the managed heap.
        /// </param>
        /// <param name="RequestCount">
        /// [In] Count of items requested.
        /// </param>
        /// <param name="pFetchedCount">
        /// [Out] Count of items fetched.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE NextRoots(
            _In_ Clr::DkmManagedHeapSampler* pManagedHeapSampler,
            _In_ UINT32 RequestCount,
            _Out_ UINT32* pFetchedCount
            ) = 0;

        /// <summary>
        /// Returns the next requested portion of serialized object graph data.
        /// </summary>
        /// <param name="pManagedHeapSampler">
        /// [In] DkmManagedHeapSampler represents a sampler for objects in the managed heap.
        /// </param>
        /// <param name="RequestCount">
        /// [In] Count of items requested.
        /// </param>
        /// <param name="pItems">
        /// [Out] Sampled heap data.
        ///
        /// The memory for the DkmArray members is allocated by the method implementation
        /// using DkmAllocBytes/DkmAllocArray. It is freed by the caller using the
        /// CAutoDkmArray template or with DkmFreeMemory and manual element release.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE GetSampledHeapData(
            _In_ Clr::DkmManagedHeapSampler* pManagedHeapSampler,
            _In_ UINT32 RequestCount,
            _Out_ DkmArray<BYTE>* pItems
            ) = 0;

        /// <summary>
        /// Returns the heap type stats.
        /// </summary>
        /// <param name="pManagedHeapSampler">
        /// [In] DkmManagedHeapSampler represents a sampler for objects in the managed heap.
        /// </param>
        /// <param name="pItems">
        /// [Out] Sampled heap type stats.
        ///
        /// The memory for the DkmArray members is allocated by the method implementation
        /// using DkmAllocBytes/DkmAllocArray. It is freed by the caller using the
        /// CAutoDkmArray template or with DkmFreeMemory and manual element release.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE GetSampledHeapTypeStats(
            _In_ Clr::DkmManagedHeapSampler* pManagedHeapSampler,
            _Out_ DkmArray<Clr::DkmManagedHeapTypeInfo>* pItems
            ) = 0;

        /// <summary>
        /// Returns roots from the sampled heap.
        /// </summary>
        /// <param name="pManagedHeapSampler">
        /// [In] DkmManagedHeapSampler represents a sampler for objects in the managed heap.
        /// </param>
        /// <param name="pItems">
        /// [Out] Sampled heap roots.
        ///
        /// The memory for the DkmArray members is allocated by the method implementation
        /// using DkmAllocBytes/DkmAllocArray. It is freed by the caller using the
        /// CAutoDkmArray template or with DkmFreeMemory and manual element release.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE GetRoots(
            _In_ Clr::DkmManagedHeapSampler* pManagedHeapSampler,
            _Out_ DkmArray<Clr::DkmManagedHeapRootInfo>* pItems
            ) = 0;
    };

    // Interface implemented by managed dm to allow walking the managed heap.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // EngineId, RuntimeId.
    //
    // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
    #define IID_IDkmManagedHeapWalker __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmManagedHeapWalker)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("d19e8743-c1aa-7d86-7d40-55862926d93c") IDkmManagedHeapWalker : public IUnknown
    {
        /// <summary>
        /// Prepares enumerator for walking the objects in the heap, returns error if heap
        /// cannot be enumerated.
        /// </summary>
        /// <param name="pManagedHeapWalker">
        /// [In] DkmManagedHeapWalker represents an enumerator for managed heap.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// E_MANAGED_HEAP_NOT_ENUMERABLE indicates that the managed heap is not a state that
        /// can be enumerated.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE InitializeHeapObjectWalk(
            _In_ Clr::DkmManagedHeapWalker* pManagedHeapWalker
            ) = 0;

        /// <summary>
        /// Prepares enumeration for reporting references between objects in the heap,
        /// returns error if heap cannot be enumerated.
        /// </summary>
        /// <param name="pManagedHeapWalker">
        /// [In] DkmManagedHeapWalker represents an enumerator for managed heap.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// E_MANAGED_HEAP_NOT_ENUMERABLE indicates that the managed heap is not a state that
        /// can be enumerated.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE InitializeHeapReferenceWalk(
            _In_ Clr::DkmManagedHeapWalker* pManagedHeapWalker
            ) = 0;

        /// <summary>
        /// Prepares enumeration for reporting roots in the heap, returns error if heap
        /// cannot be enumerated.
        /// </summary>
        /// <param name="pManagedHeapWalker">
        /// [In] DkmManagedHeapWalker represents an enumerator for managed heap.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// E_MANAGED_HEAP_NOT_ENUMERABLE indicates that the managed heap is not a state that
        /// can be enumerated.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE InitializeHeapRootsWalk(
            _In_ Clr::DkmManagedHeapWalker* pManagedHeapWalker
            ) = 0;

        /// <summary>
        /// Returns the next set of objects from the enumeration.
        /// </summary>
        /// <param name="pManagedHeapWalker">
        /// [In] DkmManagedHeapWalker represents an enumerator for managed heap.
        /// </param>
        /// <param name="RequestCount">
        /// [In] Count of items requested.
        /// </param>
        /// <param name="pItems">
        /// [Out] Array containing the managed heap object infos.
        ///
        /// The memory for the DkmArray members is allocated by the method implementation
        /// using DkmAllocBytes/DkmAllocArray. It is freed by the caller using the
        /// CAutoDkmArray template or with DkmFreeMemory and manual element release.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE NextObjects(
            _In_ Clr::DkmManagedHeapWalker* pManagedHeapWalker,
            _In_ UINT32 RequestCount,
            _Out_ DkmArray<Clr::DkmManagedHeapObjectInfo>* pItems
            ) = 0;

        /// <summary>
        /// Returns the next set of elements from the enumeration.
        /// </summary>
        /// <param name="pManagedHeapWalker">
        /// [In] DkmManagedHeapWalker represents an enumerator for managed heap.
        /// </param>
        /// <param name="RequestCount">
        /// [In] Count of items requested.
        /// </param>
        /// <param name="pItems">
        /// [Out] Array containing the managed heap reference infos.
        ///
        /// The memory for the DkmArray members is allocated by the method implementation
        /// using DkmAllocBytes/DkmAllocArray. It is freed by the caller using the
        /// CAutoDkmArray template or with DkmFreeMemory and manual element release.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE NextReferences(
            _In_ Clr::DkmManagedHeapWalker* pManagedHeapWalker,
            _In_ UINT32 RequestCount,
            _Out_ DkmArray<Clr::DkmManagedObjectReferenceInfo>* pItems
            ) = 0;

        /// <summary>
        /// Returns the next set of roots from the enumeration.
        /// </summary>
        /// <param name="pManagedHeapWalker">
        /// [In] DkmManagedHeapWalker represents an enumerator for managed heap.
        /// </param>
        /// <param name="RequestCount">
        /// [In] Count of items requested.
        /// </param>
        /// <param name="pItems">
        /// [Out] Array containing the managed heap root infos.
        ///
        /// The memory for the DkmArray members is allocated by the method implementation
        /// using DkmAllocBytes/DkmAllocArray. It is freed by the caller using the
        /// CAutoDkmArray template or with DkmFreeMemory and manual element release.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE NextRoots(
            _In_ Clr::DkmManagedHeapWalker* pManagedHeapWalker,
            _In_ UINT32 RequestCount,
            _Out_ DkmArray<Clr::DkmManagedHeapRootInfo>* pItems
            ) = 0;

        /// <summary>
        /// Gets the type names for the given type ids.
        /// </summary>
        /// <param name="pManagedHeapWalker">
        /// [In] DkmManagedHeapWalker represents an enumerator for managed heap.
        /// </param>
        /// <param name="TypeIds">
        /// [In] The list of managed type ids.
        ///
        /// The memory for the DkmArray members is allocated by the caller, and can be from
        /// any source (stack memory, static buffer, heap, etc). The implementation should
        /// not modify the members.
        /// </param>
        /// <param name="pTypeNames">
        /// [Out] The list of type names.
        ///
        /// The memory for the DkmArray members is allocated by the method implementation
        /// using DkmAllocBytes/DkmAllocArray. It is freed by the caller using the
        /// CAutoDkmArray template or with DkmFreeMemory and manual element release.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE GetTypeNames(
            _In_ Clr::DkmManagedHeapWalker* pManagedHeapWalker,
            _In_ const DkmArray<Clr::DkmManagedTypeId>& TypeIds,
            _Out_ DkmArray<DkmString*>* pTypeNames
            ) = 0;

        /// <summary>
        /// Gets the list of segments in the heap.
        /// </summary>
        /// <param name="pManagedHeapWalker">
        /// [In] DkmManagedHeapWalker represents an enumerator for managed heap.
        /// </param>
        /// <param name="pSegments">
        /// [Out] The list of heap segments.
        ///
        /// The memory for the DkmArray members is allocated by the method implementation
        /// using DkmAllocBytes/DkmAllocArray. It is freed by the caller using the
        /// CAutoDkmArray template or with DkmFreeMemory and manual element release.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE GetSegments(
            _In_ Clr::DkmManagedHeapWalker* pManagedHeapWalker,
            _Out_ DkmArray<Clr::DkmManagedHeapSegmentInfo>* pSegments
            ) = 0;
    };

    // Obtains managed return value information from ManagedDM for evaluation.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // BaseDebugMonitorId, EngineId, RuntimeId.
    //
    // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
    #define IID_IDkmManagedReturnValueFetcher __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmManagedReturnValueFetcher)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("6ab682bc-c602-8c59-6bb7-4efe9bbb0737") IDkmManagedReturnValueFetcher : public IUnknown
    {
        /// <summary>
        /// Evaluates and formats a given DkmRawReturnValue using solely the provided data.
        /// </summary>
        /// <param name="pManagedReturnValueContext">
        /// [In] Provides a context for managed return value.
        /// </param>
        /// <param name="ppValueInfo">
        /// [Out] Return value from CLR.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE GetReturnValueInfo(
            _In_ Clr::DkmManagedReturnValueContext* pManagedReturnValueContext,
            _Deref_out_ Clr::DkmManagedReturnValueInfo** ppValueInfo
            ) = 0;
    };

    // Used by ManagedDM to query code path info.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // BaseDebugMonitorId, EngineId, RuntimeId, TransportKind.
    //
    // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
    #define IID_IDkmManagedSteppingCodePathProvider __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmManagedSteppingCodePathProvider)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("132fa9df-a8eb-caf0-0d83-856e70510813") IDkmManagedSteppingCodePathProvider : public IUnknown
    {
        /// <summary>
        /// GetCodePathsInRange is called to get code paths in specific IL range.
        /// </summary>
        /// <param name="pRuntimeInstance">
        /// [In] The DkmRuntimeInstance class represents an execution environment which is
        /// loaded into a DkmProcess and which contains code to be debugged.
        /// </param>
        /// <param name="pCorFrame">
        /// [In] The ICorDebugFrame to query for code paths.
        /// </param>
        /// <param name="StartILOffset">
        /// [In] Specifies the query start IL offset, inclusively.
        /// </param>
        /// <param name="EndILOffset">
        /// [In] Specifies the query end IL offset, inclusively.
        /// </param>
        /// <param name="pCodePaths">
        /// [Out] DkmSteppingCodePath[] represents a location that user can step to from
        /// current location.
        ///
        /// The memory for the DkmArray members is allocated by the method implementation
        /// using DkmAllocBytes/DkmAllocArray. It is freed by the caller using the
        /// CAutoDkmArray template or with DkmFreeMemory and manual element release.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE GetCodePathsInRange(
            _In_ DkmRuntimeInstance* pRuntimeInstance,
            _In_ ICorDebugFrame* pCorFrame,
            _In_ UINT32 StartILOffset,
            _In_ UINT32 EndILOffset,
            _Out_ DkmArray<Stepping::DkmSteppingCodePath*>* pCodePaths
            ) = 0;
    };

    // Provides services to task providers and to Debug Monitors for getting managed task
    // information.  This is implemented by the Shim Managed EE.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // BaseDebugMonitorId, EngineId, RuntimeId, TransportKind.
    //
    // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
    #define IID_IDkmManagedTaskServices __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmManagedTaskServices)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("71275006-d86e-b4a7-7126-0eaed1503f3b") IDkmManagedTaskServices : public IUnknown
    {
        /// <summary>
        /// Gets the metadata token for a CLR method.
        /// </summary>
        /// <param name="pClrRuntimeInstance">
        /// [In] Represents a CLR instance running in a target process.
        /// </param>
        /// <param name="pClassName">
        /// [In] The fully qualified class name.
        /// </param>
        /// <param name="pMethodName">
        /// [In] The method name.
        /// </param>
        /// <param name="MethodArguments">
        /// [In] The list of fully qualified arguments for the method.
        ///
        /// The memory for the DkmArray members is allocated by the caller, and can be from
        /// any source (stack memory, static buffer, heap, etc). The implementation should
        /// not modify the members.
        /// </param>
        /// <param name="pMetadataToken">
        /// [Out] The metadata token or 0 if not found.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE GetMethodMetadataToken(
            _In_ Clr::DkmClrRuntimeInstance* pClrRuntimeInstance,
            _In_ DkmString* pClassName,
            _In_ DkmString* pMethodName,
            _In_ const DkmArray<DkmString*>& MethodArguments,
            _Out_ UINT32* pMetadataToken
            ) = 0;

        /// <summary>
        /// Get a DkmManagedTaskInfo from a stack frame parameter.
        /// </summary>
        /// <param name="pClrRuntimeInstance">
        /// [In] Represents a CLR instance running in a target process.
        /// </param>
        /// <param name="pStackFrame">
        /// [In] The stack frame to get the task info from.
        /// </param>
        /// <param name="ArgumentIndex">
        /// [In] The index of the task argument.
        /// </param>
        /// <param name="pTaskInfo">
        /// [Out] The DkmManagedTaskInfo for the task.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE GetTaskInfoFromFrame(
            _In_ Clr::DkmClrRuntimeInstance* pClrRuntimeInstance,
            _In_ CallStack::DkmStackWalkFrame* pStackFrame,
            _In_ UINT32 ArgumentIndex,
            _Out_ ParallelTasks::DkmManagedTaskInfo* pTaskInfo
            ) = 0;

        /// <summary>
        /// Get a DkmManagedTaskInfo array from a stack frame parameter.
        /// </summary>
        /// <param name="pClrRuntimeInstance">
        /// [In] Represents a CLR instance running in a target process.
        /// </param>
        /// <param name="pStackFrame">
        /// [In] The stack frame to get the task info from.
        /// </param>
        /// <param name="ArgumentIndex">
        /// [In] The index of the task argument.
        /// </param>
        /// <param name="pTaskInfoArray">
        /// [Out] The DkmManagedTaskInfo array for the tasks.
        ///
        /// The memory for the DkmArray members is allocated by the method implementation
        /// using DkmAllocBytes/DkmAllocArray. It is freed by the caller using the
        /// CAutoDkmArray template or with DkmFreeMemory and manual element release.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE GetTaskInfoArrayFromFrame(
            _In_ Clr::DkmClrRuntimeInstance* pClrRuntimeInstance,
            _In_ CallStack::DkmStackWalkFrame* pStackFrame,
            _In_ UINT32 ArgumentIndex,
            _Out_ DkmArray<ParallelTasks::DkmManagedTaskInfo>* pTaskInfoArray
            ) = 0;

        /// <summary>
        /// Get a DkmManagedTaskInfo from an ICorDebugHandleValue.
        /// </summary>
        /// <param name="pClrRuntimeInstance">
        /// [In] Represents a CLR instance running in a target process.
        /// </param>
        /// <param name="pTaskHandle">
        /// [In] The ICorDebugHandleValue for the task.
        /// </param>
        /// <param name="pAppDomain">
        /// [In] The AppDomain of the task.
        /// </param>
        /// <param name="pTaskInfo">
        /// [Out] The DkmManagedTaskInfo for the task.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE GetTaskInfoFromHandle(
            _In_ Clr::DkmClrRuntimeInstance* pClrRuntimeInstance,
            _In_ ICorDebugHandleValue* pTaskHandle,
            _In_ Clr::DkmClrAppDomain* pAppDomain,
            _Out_ ParallelTasks::DkmManagedTaskInfo* pTaskInfo
            ) = 0;
    };

    // Exposes properties of a managed thread such as Managed Thread ID.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // BaseDebugMonitorId, EngineId, TransportKind.
    #define IID_IDkmManagedThreadProperties __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmManagedThreadProperties)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("6facf9de-f299-7f13-184c-6356ed266681") IDkmManagedThreadProperties : public IUnknown
    {
        /// <summary>
        /// Get a managed thread's properties.
        /// </summary>
        /// <param name="pThread">
        /// [In] DkmThread represents a thread running in the target process.
        /// </param>
        /// <param name="pManagedThreadId">
        /// [Out] The managed thread id of the thread.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE GetManagedThreadProperties(
            _In_ DkmThread* pThread,
            _Out_ INT32* pManagedThreadId
            ) = 0;
    };

    // IDkmMergedMonitorStackWalk is invoked by the stack provider. It will arbitrate between
    // the various implementations of IDkmMonitorStackWalk to walk portions of the stack
    // which should be walked inside the monitor (instead of walked inside the engine).
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // BaseDebugMonitorId, EngineId.
    #define IID_IDkmMergedMonitorStackWalk __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmMergedMonitorStackWalk)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("1f06bb96-5e18-46d8-648d-3eb252339537") IDkmMergedMonitorStackWalk : public IUnknown
    {
        /// <summary>
        /// Version of RuntimeWalkNextFrames() that also checks if a cached copy of the call
        /// stack is still valid.
        /// </summary>
        /// <param name="pStackWalkContext">
        /// [In] DkmStackWalkContext allows the various components which walk, filter, or
        /// examine call stacks to store private data which is associated with this call
        /// stack.
        /// </param>
        /// <param name="RequestSizeHintIfCacheIsValid">
        /// [In] RequestSizeHintIfCacheIsValid is a hint as to the number of frame that the
        /// caller needs. This value is treated as a hint because this API can return frames
        /// which are not yet walked, so this API may return more or less than the hint
        /// value.  A request size hint of 0 means not to do any stack walking at all if the
        /// cache is valid.
        /// </param>
        /// <param name="RequestSizeHintIfCacheIsInvalid">
        /// [In] RequestSizeHintIfCacheIsInvalid is a hint as to the number of frame that the
        /// caller needs. This value is treated as a hint because this API can return frames
        /// which are not yet walked, so this API may return more or less than the hint
        /// value.
        /// </param>
        /// <param name="pCachedHash">
        /// [In,Optional] Cached call stack hash, will not walk the stack if cache is still
        /// valid.  This parameter is optional.  If null, we will still compute the actual
        /// hash and do the stack walk, but will skip the comparing of the actual hash
        /// against the cached hash to suppress the stack walk.
        /// </param>
        /// <param name="pFrames">
        /// [Out] Array of walked frames. For, unresolved frames, both InstructionAddress and
        /// Description will be null.
        ///
        /// The memory for the DkmArray members is allocated by the method implementation
        /// using DkmAllocBytes/DkmAllocArray. It is freed by the caller using the
        /// CAutoDkmArray template or with DkmFreeMemory and manual element release.
        /// </param>
        /// <param name="pEndOfStack">
        /// [Out] Returns true if the monitor reached the end of the stack.
        /// </param>
        /// <param name="ppActualStackHash">
        /// [Out,Optional] The actual hash of the call stack.  This may be NULL for runtimes
        /// that don't support call stack hashing.
        /// </param>
        /// <param name="ppActualStackWalkContext">
        /// [Out] The DkmStackWalkContext object that can used later to continue the walk. If
        /// the cache is valid, this is the original context.  If the cache is invalid, this
        /// will be a new DkmStackWalkContext object.
        /// </param>
        /// <param name="pIsCacheValid">
        /// [Out] True if the cache was valid, false if not.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE RuntimeWalkNextFramesAndCheckCache(
            _In_ CallStack::DkmStackWalkContext* pStackWalkContext,
            _In_ UINT32 RequestSizeHintIfCacheIsValid,
            _In_ UINT32 RequestSizeHintIfCacheIsInvalid,
            _In_opt_ CallStack::DkmStackHash* pCachedHash,
            _Out_ DkmArray<CallStack::DkmStackWalkFrame*>* pFrames,
            _Out_ bool* pEndOfStack,
            _Deref_out_opt_ CallStack::DkmStackHash** ppActualStackHash,
            _Deref_out_ CallStack::DkmStackWalkContext** ppActualStackWalkContext,
            _Out_ bool* pIsCacheValid
            ) = 0;

        /// <summary>
        /// Attempt to walk the stack without the use of symbols. This will call into various
        /// components that know how to walk portions of the stack (ex: CLR frames will be
        /// walked by the CLR debug monitor). An 'unresolved' frame will be left for portions
        /// of the stack which cannot be walked without information stored within the symbol
        /// file. These 'unresolved' frames have no InstructionAddress or Description.
        /// </summary>
        /// <param name="pStackWalkContext">
        /// [In] DkmStackWalkContext allows the various components which walk, filter, or
        /// examine call stacks to store private data which is associated with this call
        /// stack.
        /// </param>
        /// <param name="RequestSizeHint">
        /// [In] RequestSizeHint is a hint as to the number of frame that the caller needs.
        /// This value is treated as a hint because this API can return frames which are not
        /// yet walked, so this API may return more or less than the hint value.
        /// </param>
        /// <param name="pFrames">
        /// [Out] Array of walked frames. For, unresolved frames, both InstructionAddress and
        /// Description will be null.
        ///
        /// The memory for the DkmArray members is allocated by the method implementation
        /// using DkmAllocBytes/DkmAllocArray. It is freed by the caller using the
        /// CAutoDkmArray template or with DkmFreeMemory and manual element release.
        /// </param>
        /// <param name="pEndOfStack">
        /// [Out] Returns true if the monitor reached the end of the stack.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE RuntimeWalkNextFrames(
            _In_ CallStack::DkmStackWalkContext* pStackWalkContext,
            _In_ UINT32 RequestSizeHint,
            _Out_ DkmArray<CallStack::DkmStackWalkFrame*>* pFrames,
            _Out_ bool* pEndOfStack
            ) = 0;

        /// <summary>
        /// Return the top stack frame for a thread. This frame can come from a runtime
        /// instance, or a monitor unwinder. This can only be called from the server process.
        /// To obtain the top frame in the client process, use GetTopStackFrame.
        /// </summary>
        /// <param name="pThread">
        /// [In] DkmThread represents a thread running in the target process.
        /// </param>
        /// <param name="pRuntimeInstance">
        /// [In] The runtime instance of the frame.
        /// </param>
        /// <param name="ppFrame">
        /// [Out] The top stack frame.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error. E_NO_FRAME
        /// is returned if no native runtime is present and there are no frames on the stack.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE GetTopStackWalkFrame(
            _In_ DkmThread* pThread,
            _In_ DkmRuntimeInstance* pRuntimeInstance,
            _Deref_out_ CallStack::DkmStackWalkFrame** ppFrame
            ) = 0;
    };

    // Obtains information about the minidump being debugged.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // BaseDebugMonitorId, EngineId, TransportKind.
    //
    // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
    #define IID_IDkmMinidumpQuery __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmMinidumpQuery)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("75081e2d-93e7-3cb3-9eda-d8f00ce6b4da") IDkmMinidumpQuery : public IUnknown
    {
        /// <summary>
        /// Returns the path to the primary executable in the minidump being debugged.
        /// </summary>
        /// <param name="pProcess">
        /// [In] DkmProcess represents a target process which is being debugged. The debugger
        /// debugs processes, so this is the basic unit of debugging. A DkmProcess can
        /// represent a system process or a virtual process such as minidumps.
        /// </param>
        /// <param name="ppExePath">
        /// [Out] Path to the debuggee's primary executable file.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE GetDumpExePath(
            _In_ DkmProcess* pProcess,
            _Deref_out_ DkmString** ppExePath
            ) = 0;
    };

    // When managed minidump debugging, determines whether metadata is available for a given
    // module instance.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // BaseDebugMonitorId, EngineId, RuntimeId, SymbolProviderId, TransportKind.
    //
    // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
    #define IID_IDkmModuleMetadataStatusQuery __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmModuleMetadataStatusQuery)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("b4867696-9369-efd5-22e7-dd1d035989f6") IDkmModuleMetadataStatusQuery : public IUnknown
    {
        /// <summary>
        /// Get metadata status.
        /// </summary>
        /// <param name="pClrModuleInstance">
        /// [In] 'DkmClrModuleInstance' is used for modules which are loaded into the Common
        /// Language Runtime.
        /// </param>
        /// <param name="pMetadataStatus">
        /// [Out] Metadata status.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE GetMetadataStatus(
            _In_ Clr::DkmClrModuleInstance* pClrModuleInstance,
            _Out_ Clr::DkmMetadataStatus_t* pMetadataStatus
            ) = 0;
    };

    // Provides decoding of export tables in Windows PE files.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // BaseDebugMonitorId, EngineId, RuntimeId, SymbolProviderId.
    #define IID_IDkmNativeExportTableDecoder __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmNativeExportTableDecoder)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("29e2f2c0-4eb4-2b46-6992-4444cd14e34b") IDkmNativeExportTableDecoder : public IUnknown
    {
        /// <summary>
        /// Finds the nearest module export from the specified instruction address. The
        /// export could either be a function or data export, though function exports are far
        /// more common. Because exports do not have address ranges, the specified address
        /// may not actually be associated with the returned export.
        /// </summary>
        /// <param name="pNativeAddress">
        /// [In] DkmNativeInstructionAddress is used for addresses that resolve to within a
        /// native module. This is used regardless as to if there are symbols for the module.
        /// </param>
        /// <param name="ppExportName">
        /// [Out,Optional] Name of the export.
        /// </param>
        /// <param name="pByteOffset">
        /// [Out] Byte offset from the start of the export.
        /// </param>
        /// <returns>
        /// S_OK is returned if *ppExportName is non-NULL, S_FALSE is returned when
        /// *ppExportName is NULL, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE FindNearestExport(
            _In_ Native::DkmNativeInstructionAddress* pNativeAddress,
            _Deref_out_opt_ DkmString** ppExportName,
            _Out_ INT32* pByteOffset
            ) = 0;

        /// <summary>
        /// Finds the address of the specified named exported function (or data export).
        /// </summary>
        /// <param name="pNativeModuleInstance">
        /// [In] 'DkmNativeModuleInstance' is used for modules which contain CPU code and/or
        /// are loaded by the Win32 loader.
        /// </param>
        /// <param name="pName">
        /// [In] The export name to search for in the module's export table.
        /// </param>
        /// <param name="IgnoreDataExports">
        /// [In] If true, the implementation will ignore any export which is in
        /// non-executable memory.
        /// </param>
        /// <param name="ppAddress">
        /// [Out,Optional] If the export was found in the specified module, this will contain
        /// the target address. Note that this instruction address object may be in a
        /// different module than the searched module. This can happen if the export was
        /// forwarded and the destination module is already loaded. If the destination module
        /// is not loaded, the export will be ignored.
        /// </param>
        /// <returns>
        /// S_OK is returned if *ppAddress is non-NULL, S_FALSE is returned when *ppAddress
        /// is NULL, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE FindExportName(
            _In_ Native::DkmNativeModuleInstance* pNativeModuleInstance,
            _In_ DkmString* pName,
            _In_ bool IgnoreDataExports,
            _Deref_out_opt_ Native::DkmNativeInstructionAddress** ppAddress
            ) = 0;
    };

    // IDkmReturnValuesNotification is implemented by components that want to listen for the
    // ReturnValues event. The target process may continue to run during this notification.
    // The ReturnValues event is sent during a step, when one or more DkmRawReturnValues have
    // been collected.  The actual evaluation will be performed on the StepComplete event on
    // the thread where the Return Values were recorded.
    //
    // ReturnValues events can be suppressed by calling DkmEventDescriptorS.Suppress().
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // BaseDebugMonitorId, EngineId, RuntimeId, SourceId.
    #define IID_IDkmReturnValuesNotification __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmReturnValuesNotification)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("9ec52d3e-017f-65ed-fa75-a6b1c1eebe71") IDkmReturnValuesNotification : public IUnknown
    {
        /// <summary>
        /// OnReturnValues is invoked as part of event processing. See interface definition
        /// for more information.
        /// </summary>
        /// <param name="pStepper">
        /// [In] DkmStepper represents a request to step a thread. It facilitates shared
        /// object lifetime between the various runtime debug monitors that participate in
        /// stepping.
        /// </param>
        /// <param name="pReturnValues">
        /// [In,Optional] DkmRawReturnValues recorded.
        /// </param>
        /// <param name="LastValueInCurrentContext">
        /// [In] If true, it is valid to use the current thread context to evaluate the last
        /// return value.  This is true only in the case immediately after processing the
        /// return instruction, and so should only be set if raising this event immediately
        /// before, and on the same thread, as the StepComplete event.
        /// </param>
        /// <param name="pEventDescriptor">
        /// [In] Describes the event being processed and provides the ability for a component
        /// to suppress this event.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE OnReturnValues(
            _In_ Stepping::DkmStepper* pStepper,
            _In_opt_ DkmReadOnlyCollection<Evaluation::DkmRawReturnValue*>* pReturnValues,
            _In_ bool LastValueInCurrentContext,
            _In_ DkmEventDescriptorS* pEventDescriptor
            ) = 0;
    };

    // Interface implemented by the base DM services to provide a process listing, and
    // provide basic information about running processes without attaching a debugger to the
    // process.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // TransportKind.
    #define IID_IDkmRunningProcessInfoProvider __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmRunningProcessInfoProvider)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("e8a1cd8d-e271-c089-189a-55dc4d08ad66") IDkmRunningProcessInfoProvider : public IUnknown
    {
        /// <summary>
        /// Provides a listing of all the processes running on the target computer (including
        /// processes not being debugged).
        /// </summary>
        /// <param name="pConnection">
        /// [In] This represents a connection between the monitor and the IDE. It can either
        /// be a local connection if the monitor is running in the same process as the IDE,
        /// or it can be a remote connection. In the monitor process, there is only one
        /// connection.
        /// </param>
        /// <param name="IncludeFromAllUsers">
        /// [In] If true, processes from all users should be included.
        /// </param>
        /// <param name="RequestedPropertyMask">
        /// [In] Flags indicating which properties of DkmRunningProcessInfo should be
        /// computed.
        /// </param>
        /// <param name="pProcesses">
        /// [Out] Array of processes running on the target computer.
        ///
        /// The memory for the DkmArray members is allocated by the method implementation
        /// using DkmAllocBytes/DkmAllocArray. It is freed by the caller using the
        /// CAutoDkmArray template or with DkmFreeMemory and manual element release.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE EnumRunningProcesses(
            _In_ DefaultPort::DkmTransportConnection* pConnection,
            _In_ bool IncludeFromAllUsers,
            _In_ DefaultPort::DkmRunningProcessInfoPropertyMask_t RequestedPropertyMask,
            _Out_ DkmArray<DefaultPort::DkmRunningProcessInfo*>* pProcesses
            ) = 0;

        /// <summary>
        /// Obtain information about a process running on the target computer.
        /// </summary>
        /// <param name="pConnection">
        /// [In] This represents a connection between the monitor and the IDE. It can either
        /// be a local connection if the monitor is running in the same process as the IDE,
        /// or it can be a remote connection. In the monitor process, there is only one
        /// connection.
        /// </param>
        /// <param name="Id">
        /// [In] Process Id (PID) assigned by the operating system.
        /// </param>
        /// <param name="StartTime">
        /// [In] 64-bit date time value indicating when the process was started. The start
        /// time along with the id and the machine where the process was started can uniquely
        /// identify a process. '0' can be passed if the start time is unknown.
        /// </param>
        /// <param name="IsDebuggee">
        /// [In] When true, the request will fail if the debugger has insufficient privileges
        /// to complete the request. If false, the implementation should calculate what it
        /// can.
        /// </param>
        /// <param name="RequestedPropertyMask">
        /// [In] Flags indicating which properties of DkmRunningProcessInfo should be
        /// computed.
        /// </param>
        /// <param name="ppProcessInfo">
        /// [Out] Information about the requested process.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE GetRunningProcessInfo(
            _In_ DefaultPort::DkmTransportConnection* pConnection,
            _In_ UINT32 Id,
            _In_ UINT64 StartTime,
            _In_ bool IsDebuggee,
            _In_ DefaultPort::DkmRunningProcessInfoPropertyMask_t RequestedPropertyMask,
            _Deref_out_ DefaultPort::DkmRunningProcessInfo** ppProcessInfo
            ) = 0;

        /// <summary>
        /// Called by the SDM prior to start debugging. It is used to obtain current
        /// information about the process, ensure that the process can be debugged, and to
        /// make any operating system configuration changes (ex: enabling enhanced error
        /// reporting) to improve debugging.
        /// </summary>
        /// <param name="pConnection">
        /// [In] This represents a connection between the monitor and the IDE. It can either
        /// be a local connection if the monitor is running in the same process as the IDE,
        /// or it can be a remote connection. In the monitor process, there is only one
        /// connection.
        /// </param>
        /// <param name="Id">
        /// [In] Process Id (PID) assigned by the operating system.
        /// </param>
        /// <param name="StartTime">
        /// [In] 64-bit date time value indicating when the process was started. The start
        /// time along with the id and the machine where the process was started can uniquely
        /// identify a process. '0' can be passed if the start time is unknown.
        /// </param>
        /// <param name="RequestedPropertyMask">
        /// [In] Flags indicating which properties of DkmRunningProcessInfo should be
        /// computed.
        /// </param>
        /// <param name="ppProcessInfo">
        /// [Out] Information about the requested process.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE PrepareForDebuggingProcess(
            _In_ DefaultPort::DkmTransportConnection* pConnection,
            _In_ UINT32 Id,
            _In_ UINT64 StartTime,
            _In_ DefaultPort::DkmRunningProcessInfoPropertyMask_t RequestedPropertyMask,
            _Deref_out_ DefaultPort::DkmRunningProcessInfo** ppProcessInfo
            ) = 0;

        /// <summary>
        /// Terminates a process running on target computer which is not being debugged.
        /// </summary>
        /// <param name="pConnection">
        /// [In] This represents a connection between the monitor and the IDE. It can either
        /// be a local connection if the monitor is running in the same process as the IDE,
        /// or it can be a remote connection. In the monitor process, there is only one
        /// connection.
        /// </param>
        /// <param name="Id">
        /// [In] Process Id (PID) assigned by the operating system.
        /// </param>
        /// <param name="StartTime">
        /// [In] 64-bit date time value indicating when the process was started. The start
        /// time along with the id and the machine where the process was started can uniquely
        /// identify a process. '0' can be passed if the start time is unknown.
        /// </param>
        /// <param name="ExitCode">
        /// [In] The exit code to be used by the process and threads terminated as a result
        /// of this call. Use the GetExitCodeProcess function to retrieve a process's exit
        /// value. Use the GetExitCodeThread function to retrieve a thread's exit value.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE TerminateRunningProcess(
            _In_ DefaultPort::DkmTransportConnection* pConnection,
            _In_ UINT32 Id,
            _In_ UINT64 StartTime,
            _In_ UINT32 ExitCode
            ) = 0;

        /// <summary>
        /// Provides information about the computer where the debug monitor is running.
        /// </summary>
        /// <param name="pConnection">
        /// [In] This represents a connection between the monitor and the IDE. It can either
        /// be a local connection if the monitor is running in the same process as the IDE,
        /// or it can be a remote connection. In the monitor process, there is only one
        /// connection.
        /// </param>
        /// <param name="NativeSystemInfo">
        /// [In] If true and if the debug monitor is running under WOW64, this function will
        /// return information about the native subsystem rather than WOW. If the debug
        /// monitor is not running under WOW, this function is ignored.
        /// </param>
        /// <param name="ppSystemInfo">
        /// [Out] Object describing the system where the debugger is running.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE GetSystemInformation(
            _In_ DefaultPort::DkmTransportConnection* pConnection,
            _In_ bool NativeSystemInfo,
            _Deref_out_ DefaultPort::DkmSystemInformation** ppSystemInfo
            ) = 0;

        /// <summary>
        /// Provides the version string for the CLR that the debugger expects a given
        /// executable to load. The return value is based on the content of the executable's
        /// PE header (if the exe is managed), the executable's config file, CLR environment
        /// variables, and loader policy in the registry. The return value may be incorrect,
        /// especially in the case of a native executable.
        /// </summary>
        /// <param name="pConnection">
        /// [In] This represents a connection between the monitor and the IDE. It can either
        /// be a local connection if the monitor is running in the same process as the IDE,
        /// or it can be a remote connection. In the monitor process, there is only one
        /// connection.
        /// </param>
        /// <param name="pExePath">
        /// [In] Path to the executable file.
        /// </param>
        /// <param name="ppClrVersionString">
        /// [Out] Version string of the CLR. Ex:'v4.0.30319'.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE GetClrVersionOfExecutable(
            _In_ DefaultPort::DkmTransportConnection* pConnection,
            _In_ DkmString* pExePath,
            _Deref_out_ DkmString** ppClrVersionString
            ) = 0;

        /// <summary>
        /// Determines if the given executable file will execute within WOW64 (Windows On
        /// Windows), which is used to execute 32-bit processes on a 64-bit OS.
        /// </summary>
        /// <param name="pConnection">
        /// [In] This represents a connection between the monitor and the IDE. It can either
        /// be a local connection if the monitor is running in the same process as the IDE,
        /// or it can be a remote connection. In the monitor process, there is only one
        /// connection.
        /// </param>
        /// <param name="pExePath">
        /// [In] Path to the executable file.
        /// </param>
        /// <param name="pResult">
        /// [Out] true if the specified executable file will execute under WOW.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE QueryIsWOW64Executable(
            _In_ DefaultPort::DkmTransportConnection* pConnection,
            _In_ DkmString* pExePath,
            _Out_ bool* pResult
            ) = 0;

        /// <summary>
        /// Returns the version of the CLR which is loaded in the monitor process.
        /// </summary>
        /// <param name="pConnection">
        /// [In] This represents a connection between the monitor and the IDE. It can either
        /// be a local connection if the monitor is running in the same process as the IDE,
        /// or it can be a remote connection. In the monitor process, there is only one
        /// connection.
        /// </param>
        /// <param name="ppClrVersionString">
        /// [Out] Version string of the CLR. Ex:'v4.0.30319'.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE GetDefaultClrVersion(
            _In_ DefaultPort::DkmTransportConnection* pConnection,
            _Deref_out_ DkmString** ppClrVersionString
            ) = 0;
    };

    // This interface is implemented by the breakpoint manager so it can receive notification
    // that a runtime function resolution request has resolved into a new function.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // BaseDebugMonitorId, CompilerVendorId, EngineId, LanguageId.
    #define IID_IDkmRuntimeFunctionResolverClient __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmRuntimeFunctionResolverClient)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("a7e133e3-3039-9082-21da-bc009198b0ae") IDkmRuntimeFunctionResolverClient : public IUnknown
    {
        /// <summary>
        /// Called by runtime function resolvers when a new resolution has been discovered
        /// for a DkmRuntimeFunctionResolutionRequest instance.
        /// </summary>
        /// <param name="pRuntimeFunctionResolutionRequest">
        /// [In] DkmRuntimeFunctionResolutionRequest represents an expression to be parsed
        /// and evaluated by a runtime based expression evaluator and is bound to a
        /// particular process. Resolutions will send DkmModuleInstance::FunctionResolved
        /// events.
        /// </param>
        /// <param name="pAddress">
        /// [In] The address the request bound to. Multiple addresses will result in multiple
        /// calls to this function.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE OnFunctionResolved(
            _In_ FunctionResolution::DkmRuntimeFunctionResolutionRequest* pRuntimeFunctionResolutionRequest,
            _In_ DkmInstructionAddress* pAddress
            ) = 0;

        /// <summary>
        /// Called by runtime function resolvers when the resolver wishes to notify its
        /// client an error/warning occurred while attempting to resolve the breakpoint.
        /// </summary>
        /// <param name="pRuntimeFunctionResolutionRequest">
        /// [In] DkmRuntimeFunctionResolutionRequest represents an expression to be parsed
        /// and evaluated by a runtime based expression evaluator and is bound to a
        /// particular process. Resolutions will send DkmModuleInstance::FunctionResolved
        /// events.
        /// </param>
        /// <param name="Level">
        /// [In] Describes the severity of a message sent from a breakpoint manager back to
        /// the source component. This list is sorted in order of priority, as the UI will
        /// only display the most important warning. All warnings are ignored if the
        /// breakpoint is bound.
        /// </param>
        /// <param name="pMessage">
        /// [In] Message string to display to the user.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE OnResolverMessage(
            _In_ FunctionResolution::DkmRuntimeFunctionResolutionRequest* pRuntimeFunctionResolutionRequest,
            _In_ Breakpoints::DkmBreakpointMessageLevel_t Level,
            _In_ DkmString* pMessage
            ) = 0;
    };

    // This interface allows Concord components to compare two ICorDebugHandleValue objects'
    // values by routing the calls to GetValue through the shim EE in order to have the
    // proper LocalContext set up.  Calling GetValue directly on a ICorDebugHandleValue
    // object from Concord will result in an exception thrown from the VIL host.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // BaseDebugMonitorId, EngineId, RuntimeId, TransportKind.
    #define IID_IDkmRuntimeHandleComparer __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmRuntimeHandleComparer)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("1191179b-74b8-e0a5-b043-951e4ab33484") IDkmRuntimeHandleComparer : public IUnknown
    {
        /// <summary>
        /// This method takes two ICorDebugHandleValues, calls GetValue on each, and compares
        /// the resulting values to see if they are equal.  If necessary, it will set up a
        /// LocalContext for the VIL interpreter.
        /// </summary>
        /// <param name="pClrRuntimeInstance">
        /// [In] Represents a CLR instance running in a target process.
        /// </param>
        /// <param name="pHandleValue1">
        /// [In] The first ICorDebugHandleValue object.
        /// </param>
        /// <param name="pHandleValue2">
        /// [In] The second ICorDebugHandleValue object.
        /// </param>
        /// <param name="pEqual">
        /// [Out] Set to true if the two given ICorDebugHandleValue objects have the same
        /// value, false otherwise.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE CompareHandleValuesThroughVil(
            _In_ Clr::DkmClrRuntimeInstance* pClrRuntimeInstance,
            _In_ ICorDebugHandleValue* pHandleValue1,
            _In_ ICorDebugHandleValue* pHandleValue2,
            _Out_ bool* pEqual
            ) = 0;
    };

    // Interface to update components when the project item path is set for a script
    // document.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // BaseDebugMonitorId, EngineId, RuntimeId, SymbolProviderId.
    #define IID_IDkmScriptDocumentSourceProjectItemChanged __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmScriptDocumentSourceProjectItemChanged)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("c34aab5d-d57c-d163-e4c6-4beaeab324ab") IDkmScriptDocumentSourceProjectItemChanged : public IUnknown
    {
        /// <summary>
        /// Called when 'SourceProjectItem' is changed.
        /// </summary>
        /// <param name="pScriptDocument">
        /// [In] Represents a document which is executing in a script runtime environment.
        /// For example, the Microsoft JavaScript engine.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE OnSourceProjectItemChanged(
            _In_ Script::DkmScriptDocument* pScriptDocument
            ) = 0;
    };

    // IDkmScriptJmcStateChangeNotification is implemented by components that want to be
    // notified when the JMC state changes for a script document.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // BaseDebugMonitorId, EngineId, RuntimeId, SymbolProviderId.
    //
    // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
    #define IID_IDkmScriptJmcStateChangeNotification __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmScriptJmcStateChangeNotification)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("d1472ad3-9aea-c4d7-8fd5-bf9cd2d8a69b") IDkmScriptJmcStateChangeNotification : public IUnknown
    {
        /// <summary>
        /// This method is called by the dispatcher when the JMC state of a script document
        /// changes.
        /// </summary>
        /// <param name="pScriptDocument">
        /// [In] Represents a document which is executing in a script runtime environment.
        /// For example, the Microsoft JavaScript engine.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE OnJmcStateChanged(
            _In_ Script::DkmScriptDocument* pScriptDocument
            ) = 0;
    };

    // Provides the stack for view by the user. This stack has been filtered, annotated, and
    // mixed together.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // BaseDebugMonitorId, EngineId.
    #define IID_IDkmStackProvider __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmStackProvider)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("05a9eaaf-64af-63fa-36b1-2e59b5522b81") IDkmStackProvider : public IUnknown
    {
        /// <summary>
        /// Obtain the next frames from the call stack. If this is the first call on a
        /// particular DkmStackContext then this will return the first frames. This method is
        /// the recommended way to obtain the call stack because the stack provider maintains
        /// a cache of the physical stack.
        /// </summary>
        /// <param name="pStackContext">
        /// [In] DkmStackContext objects are created by components that wish to request the
        /// stack from the stack provider. A component needs to close the context after they
        /// have completed the stack walk. To obtain the stack a component should create this
        /// object and then call GetNextFrames.
        /// </param>
        /// <param name="pWorkList">
        /// WorkList which is currently being processed. This value can be used to check for
        /// cancelation or to append additional work. New work items will not begin executing
        /// until after this function returns.
        /// </param>
        /// <param name="RequestSize">
        /// [In] RequestSize is the number of frames that the caller would like returned. The
        /// implementation of GetNextFrames may return fewer frames in the case that stack
        /// does not contain that many frames. Negative values, or request to read more than
        /// MaxFrames (currently 5,000) will be capped to MaxFrames.
        /// </param>
        /// <param name="pCompletionRoutine">
        /// Routine to fire when the request is complete. This will be implicitly fired if
        /// the implementation returns failure from this interface method. The implementation
        /// must fire this method in all other scenarios.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE GetNextFrames(
            _In_ CallStack::DkmStackContext* pStackContext,
            _In_ DkmWorkList* pWorkList,
            _In_ UINT32 RequestSize,
            _In_ IDkmCompletionRoutine<CallStack::DkmGetNextFramesAsyncResult>* pCompletionRoutine
            ) = 0;

        /// <summary>
        /// Format a DkmStackWalkFrame into a DkmStackFrame. Formatting a frame is one step
        /// of what the stack provider does during GetNextFrames. This method can be used to
        /// format a frame in a different way than was originally performed by the stack
        /// provider in GetNextFrames.
        /// </summary>
        /// <param name="pFrame">
        /// [In] DkmStackWalkFrame represents a frame on a call stack which has been walked,
        /// but may not have been formatted or filtered. Formatted frames are represented by
        /// DkmStackFrame instead.
        /// </param>
        /// <param name="pInspectionSession">
        /// [In] DkmInspectionSession allows the various components which inspect data to
        /// store private data which is associated with a group of evaluations.
        /// </param>
        /// <param name="Options">
        /// [In] Collection of settings that affect how the stack provider formats a
        /// DkmStackFrame.
        /// </param>
        /// <param name="ppFormattedFrame">
        /// [Out] DkmStackFrame represents a frame on the call stack after filtering and
        /// translation.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE Format(
            _In_ CallStack::DkmStackWalkFrame* pFrame,
            _In_ Evaluation::DkmInspectionSession* pInspectionSession,
            _In_ const CallStack::DkmFrameFormatOptions& Options,
            _Deref_out_ CallStack::DkmStackFrame** ppFormattedFrame
            ) = 0;

        /// <summary>
        /// Returns the top call stack frame for a thread. This value is normally cached
        /// after the first stack walk and cleared on continue. This is only callable above
        /// the stack provider in the client process. To obtain the top frame in the server
        /// process, call GetTopStackWalkFrame.
        /// </summary>
        /// <param name="pThread">
        /// [In] DkmThread represents a thread running in the target process.
        /// </param>
        /// <param name="ppTopFrame">
        /// [Out] DkmStackWalkFrame represents a frame on a call stack which has been walked,
        /// but may not have been formatted or filtered. Formatted frames are represented by
        /// DkmStackFrame instead.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE GetTopStackFrame(
            _In_ DkmThread* pThread,
            _Deref_out_ CallStack::DkmStackWalkFrame** ppTopFrame
            ) = 0;
    };

    // IDkmStepCompleteNotification is implemented by components that want to listen for the
    // StepComplete event. IDkmStepCompleteNotification is invoked after all implementations
    // of IDkmStepCompleteReceived. When this notification is called, the target process is
    // stopped and implementers are able to either inspect the process or cause it to execute
    // in a controlled manner (slip, func-eval).
    //
    // Sent by a runtime monitor when a step has completed successfully. Note that the step
    // might actually finish on a different thread than it was started on.
    //
    // StepComplete events can be suppressed by calling DkmEventDescriptorS.Suppress().
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // BaseDebugMonitorId, EngineId, RuntimeId, SourceId.
    #define IID_IDkmStepCompleteNotification __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmStepCompleteNotification)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("89c6cea7-ab24-c1e5-b53d-b1ad5cdc0f3e") IDkmStepCompleteNotification : public IUnknown
    {
        /// <summary>
        /// OnStepComplete is invoked as part of event processing. See interface definition
        /// for more information.
        /// </summary>
        /// <param name="pStepper">
        /// [In] DkmStepper represents a request to step a thread. It facilitates shared
        /// object lifetime between the various runtime debug monitors that participate in
        /// stepping.
        /// </param>
        /// <param name="pThread">
        /// [In] The thread the step actually finished on. Normally, this is the same as the
        /// thread in DkmStepper, but in some scenarios, it could be different.
        /// </param>
        /// <param name="HasException">
        /// [In] Contains true if the source runtime instance can determine that an exception
        /// is in flight on the stepping thread. Currently, only managed runtime instances
        /// ever set this. This is used to quickly determine if exception specific logic
        /// should apply without making another network round-trip.
        /// </param>
        /// <param name="pEventDescriptor">
        /// [In] Describes the event being processed and provides the ability for a component
        /// to suppress this event.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE OnStepComplete(
            _In_ Stepping::DkmStepper* pStepper,
            _In_ DkmThread* pThread,
            _In_ bool HasException,
            _In_ DkmEventDescriptorS* pEventDescriptor
            ) = 0;
    };

    // IDkmStepCompleteReceived is implemented by components that want to listen for the
    // StepComplete event. IDkmStepCompleteReceived is invoked before
    // IDkmStepCompleteNotification. From within this notification, it is not possible to
    // cause the target process to execute (no func-eval, no slipping).
    //
    // Sent by a runtime monitor when a step has completed successfully. Note that the step
    // might actually finish on a different thread than it was started on.
    //
    // StepComplete events can be suppressed by calling DkmEventDescriptorS.Suppress().
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // BaseDebugMonitorId, EngineId, RuntimeId, SourceId.
    #define IID_IDkmStepCompleteReceived __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmStepCompleteReceived)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("af658e40-330a-b079-43ff-a284e8ffb3d1") IDkmStepCompleteReceived : public IUnknown
    {
        /// <summary>
        /// OnStepCompleteReceived is invoked as part of event processing. See interface
        /// definition for more information.
        /// </summary>
        /// <param name="pStepper">
        /// [In] DkmStepper represents a request to step a thread. It facilitates shared
        /// object lifetime between the various runtime debug monitors that participate in
        /// stepping.
        /// </param>
        /// <param name="pThread">
        /// [In] The thread the step actually finished on. Normally, this is the same as the
        /// thread in DkmStepper, but in some scenarios, it could be different.
        /// </param>
        /// <param name="HasException">
        /// [In] Contains true if the source runtime instance can determine that an exception
        /// is in flight on the stepping thread. Currently, only managed runtime instances
        /// ever set this. This is used to quickly determine if exception specific logic
        /// should apply without making another network round-trip.
        /// </param>
        /// <param name="pEventDescriptor">
        /// [In] Describes the event being processed and provides the ability for a component
        /// to suppress this event.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE OnStepCompleteReceived(
            _In_ Stepping::DkmStepper* pStepper,
            _In_ DkmThread* pThread,
            _In_ bool HasException,
            _In_ DkmEventDescriptorS* pEventDescriptor
            ) = 0;
    };

    // Interface of the stepping manager. This component is implemented by Microsoft and it
    // provides stepping arbitration between the various debug monitors active in the
    // process.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // BaseDebugMonitorId, EngineId.
    #define IID_IDkmSteppingManager __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmSteppingManager)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("7f43d33d-d66b-ff27-8806-21d23ced8ad2") IDkmSteppingManager : public IUnknown
    {
        /// <summary>
        /// Called by the stopping event manager before a step operation actually begins The
        /// stopping event manager will notify all runtime instances so they can setup any
        /// necessary state before the the stopping event manager starts blocking function
        /// evaluations.
        /// </summary>
        /// <param name="pStepper">
        /// [In] DkmStepper represents a request to step a thread. It facilitates shared
        /// object lifetime between the various runtime debug monitors that participate in
        /// stepping.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE BeforeEnableNewStepper(
            _In_ Stepping::DkmStepper* pStepper
            ) = 0;

        /// <summary>
        /// Used to initialize a stepper object so that the step will be performed when
        /// execution is next resumed. This method is implemented by the stepping manager by
        /// finding an appropriate runtime debug monitor, and asking this runtime debug
        /// monitor to setup a step. This method should only be called once for a given
        /// stepper object.
        /// </summary>
        /// <param name="pStepper">
        /// [In] DkmStepper represents a request to step a thread. It facilitates shared
        /// object lifetime between the various runtime debug monitors that participate in
        /// stepping.
        /// </param>
        /// <param name="RemoveOtherSteppers">
        /// [In] Set to true if other steppers are to be removed. This is normally only set
        /// in response to user initiated step requests.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE EnableStepper(
            _In_ Stepping::DkmStepper* pStepper,
            _In_ bool RemoveOtherSteppers
            ) = 0;

        /// <summary>
        /// Allows a stepper to be cancelled after creation by the controlling runtime
        /// instance. The calling runtime instance must match the current controlling runtime
        /// instance. This is generally used in cross thread stepping scenarios where the
        /// original stepper may be reactivated. The stepping manager will close the stepper
        /// and not send step complete.
        /// </summary>
        /// <param name="pStepper">
        /// [In] DkmStepper represents a request to step a thread. It facilitates shared
        /// object lifetime between the various runtime debug monitors that participate in
        /// stepping.
        /// </param>
        /// <param name="pCallingRuntimeInstance">
        /// [In] The calling runtime instance that wishes to take control of the step.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE CancelStepper(
            _In_ Stepping::DkmStepper* pStepper,
            _In_ DkmRuntimeInstance* pCallingRuntimeInstance
            ) = 0;

        /// <summary>
        /// Called by the stopping manager prior to resuming execution in order to clear all
        /// steppers from a given thread. The stepping manager will call StopStep on the
        /// controlling runtime instance and then close the stepper objects.
        /// </summary>
        /// <param name="pThread">
        /// [In] DkmThread represents a thread running in the target process.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE ClearSteppers(
            _In_ DkmThread* pThread
            ) = 0;
    };

    // Allows runtime monitors to obtain information from the stepping manager.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // BaseDebugMonitorId, EngineId, RuntimeId, SourceId.
    #define IID_IDkmSteppingManagerCallback __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmSteppingManagerCallback)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("c3ebc33d-5b77-2486-a3b8-256573a63623") IDkmSteppingManagerCallback : public IUnknown
    {
        /// <summary>
        /// Returns the runtime instance currently in-control of this DkmStepper.
        /// </summary>
        /// <param name="pStepper">
        /// [In] DkmStepper represents a request to step a thread. It facilitates shared
        /// object lifetime between the various runtime debug monitors that participate in
        /// stepping.
        /// </param>
        /// <param name="ppRuntimeInstance">
        /// [Out] The runtime instance currently in control of this stepper.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE GetControllingRuntimeInstance(
            _In_ Stepping::DkmStepper* pStepper,
            _Deref_out_ DkmRuntimeInstance** ppRuntimeInstance
            ) = 0;

        /// <summary>
        /// StepControlRequested is called when a non-controlling runtime instance detects
        /// that the thread has hit a transition into its runtime. The stepping manager will
        /// forward the call to the current controlling runtime instance. If the current
        /// controlling runtime instance can stop stepping, it should set Granted to true.
        /// Actual control is not given until the requesting runtime calls
        /// DkmStepper.TakeStepControl. This two part process allows callers to request
        /// control of multiple steppers at the same time.
        /// </summary>
        /// <param name="pStepper">
        /// [In] DkmStepper represents a request to step a thread. It facilitates shared
        /// object lifetime between the various runtime debug monitors that participate in
        /// stepping.
        /// </param>
        /// <param name="Reason">
        /// [In] DkmStepArbitrationReason the reason step arbitration is occurring.
        /// </param>
        /// <param name="pCallingRuntimeInstance">
        /// [In] The calling runtime instance that wishes to take control of the step.
        /// </param>
        /// <param name="pGranted">
        /// [Out] The the controlling runtime can stop the step and give control to the
        /// caller, then it should set this to true.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE StepControlRequested(
            _In_ Stepping::DkmStepper* pStepper,
            _In_ Stepping::DkmStepArbitrationReason_t Reason,
            _In_ DkmRuntimeInstance* pCallingRuntimeInstance,
            _Out_ bool* pGranted
            ) = 0;

        /// <summary>
        /// TakeStepControl is called when a non-controlling runtime instance detects that
        /// the thread has hit a transition into its runtime. The stepping manager will
        /// forward the call to the current controlling runtime instance. The runtime
        /// instance requesting control should first call StepControlRequested on all
        /// steppers it wants control of. If they all set Granted to true, the runtime
        /// instance should then call this method on each stepper it is taking control of.
        /// </summary>
        /// <param name="pStepper">
        /// [In] DkmStepper represents a request to step a thread. It facilitates shared
        /// object lifetime between the various runtime debug monitors that participate in
        /// stepping.
        /// </param>
        /// <param name="LeaveGuardsInPlace">
        /// [In] Set to true by the caller if it would like the current controlling runtime
        /// instance to leave guards in place to stop the step if necessary. For instance,
        /// this can be used to leave guard breakpoints after a call instruction so another
        /// runtime can step back out if the target of the call doesn't have source. However,
        /// any stepping state that affects the immediate step, such as trap flags, should be
        /// removed by the controlling runtime instance.
        /// </param>
        /// <param name="Reason">
        /// [In] DkmStepArbitrationReason the reason step arbitration is occurring.
        /// </param>
        /// <param name="pCallingRuntimeInstance">
        /// [In] The calling runtime instance that wishes to take control of the step.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE TakeStepControl(
            _In_ Stepping::DkmStepper* pStepper,
            _In_ bool LeaveGuardsInPlace,
            _In_ Stepping::DkmStepArbitrationReason_t Reason,
            _In_ DkmRuntimeInstance* pCallingRuntimeInstance
            ) = 0;

        /// <summary>
        /// Called by a runtime monitor when a step has left the confines of what the runtime
        /// monitor understands or a potential transition into another runtime has been
        /// encountered during a step. The stepping manager will initiate stepping
        /// arbitration to give each runtime monitor a chance to inspect the process and
        /// determine which runtime should complete the step. The runtimes are called in
        /// priority order. After this process is complete, the stepping manager will call
        /// AfterSteppingArbitration on the monitor that requested arbitration so it can
        /// respond to the new controlling monitor if one was found, or finish the step if
        /// one was not found.
        /// </summary>
        /// <param name="pStepper">
        /// [In] DkmStepper represents a request to step a thread. It facilitates shared
        /// object lifetime between the various runtime debug monitors that participate in
        /// stepping.
        /// </param>
        /// <param name="Reason">
        /// [In] DkmStepArbitrationReason the reason step arbitration is occurring.
        /// </param>
        /// <param name="pCurrentControllingRuntimeInstance">
        /// [In] The runtime instance requesting arbitration.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE OnStepArbitration(
            _In_ Stepping::DkmStepper* pStepper,
            _In_ Stepping::DkmStepArbitrationReason_t Reason,
            _In_ DkmRuntimeInstance* pCurrentControllingRuntimeInstance
            ) = 0;

        /// <summary>
        /// Called by a runtime monitor when a step is continuing on a different thread. The
        /// stepping manager will create a new DkmStepper to be used on the new thread and
        /// initiate stepping arbitration to determine which runtime should complete the step
        /// just as OnStepArbitration does. The new stepper uses the same step kind and step
        /// unit as the original stepper. A new starting instruction address must be given
        /// and is set as the stepper's starting address. The original stepper remains alive
        /// and when the new stepper completes the stepping manager will suppress the event
        /// and notify the original stepper of the completion.
        /// </summary>
        /// <param name="pStepper">
        /// [In] DkmStepper represents a request to step a thread. It facilitates shared
        /// object lifetime between the various runtime debug monitors that participate in
        /// stepping.
        /// </param>
        /// <param name="Reason">
        /// [In] DkmStepArbitrationReason the reason step arbitration is occurring.
        /// </param>
        /// <param name="pCurrentControllingRuntimeInstance">
        /// [In] The runtime instance requesting arbitration.
        /// </param>
        /// <param name="pNewThread">
        /// [In] The thread on which to create the new stepper.
        /// </param>
        /// <param name="pNewStartingInstructionAddress">
        /// [In] Starting address of the new stepper.
        /// </param>
        /// <param name="ppNewStepper">
        /// [Out,Optional] The new stepper.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE OnCrossThreadStepArbitration(
            _In_ Stepping::DkmStepper* pStepper,
            _In_ Stepping::DkmStepArbitrationReason_t Reason,
            _In_ DkmRuntimeInstance* pCurrentControllingRuntimeInstance,
            _In_ DkmThread* pNewThread,
            _In_ DkmInstructionAddress* pNewStartingInstructionAddress,
            _Deref_out_opt_ Stepping::DkmStepper** ppNewStepper
            ) = 0;
    };

    // Extends the information runtime monitors can obtain from the stepping manager.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // BaseDebugMonitorId, EngineId, RuntimeId, SourceId.
    //
    // This API was introduced in Visual Studio 11 Update 1 (DkmApiVersion.VS11FeaturePack1).
    #define IID_IDkmSteppingManagerCallback11a __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmSteppingManagerCallback11a)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("302768d4-02fd-3b75-570f-444ecae444c4") IDkmSteppingManagerCallback11a : public IUnknown
    {
        /// <summary>
        /// Runtime monitors call this to set or clear a flag on the DkmStepper that can be
        /// used by cooperating runtimes to change the behavior of stepping if an exception
        /// is current in flight. Called by runtime monitors when an exception is encountered
        /// while stepping.
        /// </summary>
        /// <param name="pStepper">
        /// [In] DkmStepper represents a request to step a thread. It facilitates shared
        /// object lifetime between the various runtime debug monitors that participate in
        /// stepping.
        /// </param>
        /// <param name="Enable">
        /// [In] If true, the exception in flight flag is set. If false, it is cleared.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE SetExceptionInFlight(
            _In_ Stepping::DkmStepper* pStepper,
            _In_ bool Enable
            ) = 0;

        /// <summary>
        /// Gets the flag on the DkmStepper that states if a runtime monitor believes an
        /// exception is currently in flight during this step. This can be used by runtime
        /// monitors to change the behavior of stepping.
        /// </summary>
        /// <param name="pStepper">
        /// [In] DkmStepper represents a request to step a thread. It facilitates shared
        /// object lifetime between the various runtime debug monitors that participate in
        /// stepping.
        /// </param>
        /// <param name="pEnabled">
        /// [Out] If true, the exception in flight flag is set. If false, it is cleared.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE IsExceptionInFlight(
            _In_ Stepping::DkmStepper* pStepper,
            _Out_ bool* pEnabled
            ) = 0;
    };

    // Interface implemented by the Minidump BDM in order to query for Stowed Exception
    // information.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // BaseDebugMonitorId, EngineId, TransportKind.
    //
    // This API was introduced in Visual Studio 12 Update 3 (DkmApiVersion.VS12Update3).
    #define IID_IDkmStowedExceptionProvider __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmStowedExceptionProvider)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("df3b3c8a-aa98-00cc-f7b7-6c7fdb6c2a8e") IDkmStowedExceptionProvider : public IUnknown
    {
        /// <summary>
        /// Get the stowed exceptions from a dump.
        /// </summary>
        /// <param name="pProcess">
        /// [In] DkmProcess represents a target process which is being debugged. The debugger
        /// debugs processes, so this is the basic unit of debugging. A DkmProcess can
        /// represent a system process or a virtual process such as minidumps.
        /// </param>
        /// <param name="pStowedExceptions">
        /// [Out] An array of stowed exception records contained in the dump.
        ///
        /// The memory for the DkmArray members is allocated by the method implementation
        /// using DkmAllocBytes/DkmAllocArray. It is freed by the caller using the
        /// CAutoDkmArray template or with DkmFreeMemory and manual element release.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE GetStowedExceptions(
            _In_ DkmProcess* pProcess,
            _Out_ DkmArray<Exceptions::DkmStowedExceptionInformation*>* pStowedExceptions
            ) = 0;

        /// <summary>
        /// Get the native stowed exception from a dump. This will return S_FALSE if there is
        /// no native stowed exception.
        /// </summary>
        /// <param name="pProcess">
        /// [In] DkmProcess represents a target process which is being debugged. The debugger
        /// debugs processes, so this is the basic unit of debugging. A DkmProcess can
        /// represent a system process or a virtual process such as minidumps.
        /// </param>
        /// <param name="ppNativeStowedException">
        /// [Out,Optional] The native stowed exception from the dump, or NULL if there is no
        /// native stowed exception.
        /// </param>
        /// <returns>
        /// S_OK is returned if *ppNativeStowedException is non-NULL, S_FALSE is returned
        /// when *ppNativeStowedException is NULL, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE GetNativeStowedException(
            _In_ DkmProcess* pProcess,
            _Deref_out_opt_ Exceptions::DkmStowedExceptionInformation** ppNativeStowedException
            ) = 0;

        /// <summary>
        /// Get the managed stowed exception from a dump. This will return S_FALSE if there
        /// is no managed stowed exception.
        /// </summary>
        /// <param name="pProcess">
        /// [In] DkmProcess represents a target process which is being debugged. The debugger
        /// debugs processes, so this is the basic unit of debugging. A DkmProcess can
        /// represent a system process or a virtual process such as minidumps.
        /// </param>
        /// <param name="ppManagedStowedException">
        /// [Out,Optional] The managed stowed exception from the dump, or NULL if there is no
        /// managed stowed exception.
        /// </param>
        /// <returns>
        /// S_OK is returned if *ppManagedStowedException is non-NULL, S_FALSE is returned
        /// when *ppManagedStowedException is NULL, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE GetManagedStowedException(
            _In_ DkmProcess* pProcess,
            _Deref_out_opt_ Exceptions::DkmStowedExceptionInformation** ppManagedStowedException
            ) = 0;
    };

    // Provides the location of a thread, as visible in the threads window, or threads drop
    // down in the debug location toolbar. This is implemented by the Microsoft stack
    // provider component.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // BaseDebugMonitorId, EngineId, TransportKind.
    #define IID_IDkmThreadLocationProvider __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmThreadLocationProvider)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("eb604088-3862-4590-1ddf-3906a9b43ed4") IDkmThreadLocationProvider : public IUnknown
    {
        /// <summary>
        /// Provides the location of a thread, as visible in the threads window, or threads
        /// drop down in the debug location toolbar.
        /// </summary>
        /// <param name="pThread">
        /// [In] DkmThread represents a thread running in the target process.
        /// </param>
        /// <param name="pWorkList">
        /// WorkList which is currently being processed. This value can be used to check for
        /// cancelation or to append additional work. New work items will not begin executing
        /// until after this function returns.
        /// </param>
        /// <param name="pCompletionRoutine">
        /// Routine to fire when the request is complete. This will be implicitly fired if
        /// the implementation returns failure from this interface method. The implementation
        /// must fire this method in all other scenarios.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE GetCurrentLocation(
            _In_ DkmThread* pThread,
            _In_ DkmWorkList* pWorkList,
            _In_ IDkmCompletionRoutine<CallStack::DkmGetCurrentLocationAsyncResult>* pCompletionRoutine
            ) = 0;
    };

    // Returns the stack base and limit of a thread.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // BaseDebugMonitorId, EngineId, TransportKind.
    #define IID_IDkmThreadStackRangeProvider __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmThreadStackRangeProvider)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("498145fc-1ad4-1faf-ac1c-214ee568f19a") IDkmThreadStackRangeProvider : public IUnknown
    {
        /// <summary>
        /// Retrieves the stack limit/stack base of the given thread. Note that its possible
        /// for this value to change over time, for example, in the case of fibers.
        /// </summary>
        /// <param name="pThread">
        /// [In] DkmThread represents a thread running in the target process.
        /// </param>
        /// <param name="pMemoryRange">
        /// [Out] The limit/base address for the memory containing a thread's stack.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// E_INVALID_MEMORY_ADDRESS indicates that the address containing the TEB structure
        /// could not be read from the target process. This may be returned for minidumps
        /// without heap.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE GetStackAddressRange(
            _In_ DkmThread* pThread,
            _Out_ CallStack::DkmStackMemoryRange* pMemoryRange
            ) = 0;
    };

    // Provides the ability to read and write from Win32 TLS slots within the target process.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // BaseDebugMonitorId, EngineId, TransportKind.
    #define IID_IDkmTlsReadWrite __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmTlsReadWrite)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("61ab705f-f69a-b4d9-c1f6-ef69e5cb0fa9") IDkmTlsReadWrite : public IUnknown
    {
        /// <summary>
        /// Retrieves the value in the debuggee thread's thread local storage (TLS) slot for
        /// the specified TLS index. Each thread of a process has its own slot for each TLS
        /// index.
        /// </summary>
        /// <param name="pThread">
        /// [In] DkmThread represents a thread running in the target process.
        /// </param>
        /// <param name="TlsIndex">
        /// [In] The TLS index that was allocated when the target process called the TlsAlloc
        /// function.
        /// </param>
        /// <param name="pValue">
        /// [Out] The pointer-sized value which was stored in the thread's TLS slot. If the
        /// target thread is 32-bit, the upper 32-bits of this value will be zero.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE GetTlsValue(
            _In_ DkmThread* pThread,
            _In_ UINT32 TlsIndex,
            _Out_ UINT64* pValue
            ) = 0;

        /// <summary>
        /// Stores a value in the debuggee thread's thread local storage (TLS) slot for the
        /// specified TLS index. Each thread of a process has its own slot for each TLS
        /// index.
        /// </summary>
        /// <param name="pThread">
        /// [In] DkmThread represents a thread running in the target process.
        /// </param>
        /// <param name="TlsIndex">
        /// [In] The TLS index that was allocated when the target process called the TlsAlloc
        /// function.
        /// </param>
        /// <param name="Value">
        /// [In] The pointer-sized value to store in the thread's TLS slot. If the target
        /// thread is 32-bit, the upper 32-bits of this value will be ignored.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE SetTlsValue(
            _In_ DkmThread* pThread,
            _In_ UINT32 TlsIndex,
            _In_ UINT64 Value
            ) = 0;
    };

    // Interface implemented by the AD7AL as a gateway to services provided by the rest of
    // Visual Studio.
    //
    // Implementations of this interface are always called (no filtering is supported). To
    // reduce memory impact, it is suggested that this interface be implemented in a small
    // dll, or that the implementation is configured with 'CallOnlyWhenLoaded="true"'.
    #define IID_IDkmVisualStudioServices __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmVisualStudioServices)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("39fc0e53-030a-7710-05f2-fb8a31e7380c") IDkmVisualStudioServices : public IUnknown
    {
        /// <summary>
        /// Displays a message to the user inside the Visual Studio debugger IDE. This
        /// function does not block waiting for the user to dismiss the error message.
        /// </summary>
        /// <param name="pUserMessage">
        /// [In] Contains information about a message that is to be displayed to the user.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE PostUserMessage(
            _In_ DkmUserMessage* pUserMessage
            ) = 0;

        /// <summary>
        /// Displays a message to the user inside the Visual Studio debugger IDE. This
        /// function waits for the Visual Studio IDE to complete processing this message.
        /// This method may not be called from code that runs as part of UI event processing.
        /// Doing so will cause a deadlock. This method requires DkmUserMessage.Process to be
        /// non-null.
        /// </summary>
        /// <param name="pUserMessage">
        /// [In] Contains information about a message that is to be displayed to the user.
        /// </param>
        /// <param name="pResult">
        /// [Out] Win32 'ID' code from displaying the message box (ex: IDYES). These codes
        /// are defined in winuser.h from the Windows SDK.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE DisplayUserMessagePrompt(
            _In_ DkmUserMessage* pUserMessage,
            _Out_ UINT32* pResult
            ) = 0;

        /// <summary>
        /// Returns the enumeration of DkmCodeViewCompilerId values. This enumeration may
        /// then be used by a symbol provider to map the information within a code view
        /// record to the DkmCompilerId structure.
        /// </summary>
        /// <param name="pSettings">
        /// [In] Contains the session-wide debug settings. There is one instance of this
        /// object per engine Guid (ex: one instance for COMPlusOnlyEng2, one instance for
        /// COMPlusNativeEng).
        /// </param>
        /// <param name="pCodeViewCompilers">
        /// [Out] DkmCodeViewCompilerId[] is used to translate information that is within the
        /// S_COMPILE* code view records into a DkmCompilerId. This allows the debugger to
        /// load an appropriate expression evaluator for a stack frame. Symbol providers may
        /// obtain this collection through DkmEngineSettings. Expression evaluators may add
        /// additional entries to this collection by having their setup add sub key(s) to the
        /// '%VSRegistryRoot%\Debugger\CodeView Compilers' registry key.
        ///
        /// The memory for the DkmArray members is allocated by the method implementation
        /// using DkmAllocBytes/DkmAllocArray. It is freed by the caller using the
        /// CAutoDkmArray template or with DkmFreeMemory and manual element release.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE GetCodeViewCompilers(
            _In_ DkmEngineSettings* pSettings,
            _Out_ DkmArray<Symbols::DkmCodeViewCompilerId>* pCodeViewCompilers
            ) = 0;

        /// <summary>
        /// Sends a custom message to a Visual Studio package. This can be used, for example,
        /// to drive a custom UI or make a custom UI visible by enabling a command context
        /// (IVsMonitorSelection.SetCmdUIContext).
        ///
        /// For local 32-bit debugging, the custom message parameters
        /// (DkmCustomMessage.Parameter1/2), may contain any value (ex: object/IUnknown,
        /// string, etc), however, values are transferred between threads without
        /// marshalling, so in cases where this will not work, the sender is responsible for
        /// converting the parameter into a form which can be used from the VS service (ex:
        /// calling ole32!CoMarshalInterThreadInterfaceInStream).
        ///
        /// For remote debugging, and 64-bit debugging, the custom message parameters are
        /// marshalled across machines, and so the restrictions describe in the
        /// DkmCustomMessage.Parameter1 documentation applies.
        /// </summary>
        /// <param name="pCustomMessage">
        /// [In] Message structure used to pass information between custom debugger backend
        /// components and custom visual studio UI components (packages, add-ins, etc).
        /// </param>
        /// <param name="VsService">
        /// [In] Visual Studio service that this event should be sent to. A VS package must
        /// register this service id. The service class must implement the
        /// IVsCustomDebuggerEventHandler110 interface. Services can be registered in the
        /// registry ($RootKey$\Services\{VsService}), or through the VS shell
        /// IProfferService interface. Registry keys may be set through .pkgdef files. If the
        /// service should be called even if it is not already loaded, then the registry
        /// approach should be used. If the service should only be called if it has already
        /// been started, then IProfferService should be used.
        /// </param>
        /// <param name="IsBlocking">
        /// [In] True if SendToPackage should block waiting for the package to finish
        /// processing this message.
        ///
        /// Note that before Visual Studio 2015, when true, DkmCustomMessage.Process must be
        /// non-null. This requirement was dropped in Visual Studio 2015.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE SendToVsService(
            _In_ DkmCustomMessage* pCustomMessage,
            _In_ const GUID& VsService,
            _In_ bool IsBlocking
            ) = 0;

        /// <summary>
        /// Reads language-specific from the registry.  The settings are stored under
        /// HKLM\Software\Microsoft\VisualStudio\14.0\AD7Metrics\ExpressionEvaluator\[Languag
        ///  Guid]\[Vendor Guid].
        /// </summary>
        /// <param name="pLanguage">
        /// [In] Describes a programming language.
        /// </param>
        /// <param name="pSettings">
        /// [Out] Pairing between the name of a setting and its value.
        ///
        /// The memory for the DkmArray members is allocated by the method implementation
        /// using DkmAllocBytes/DkmAllocArray. It is freed by the caller using the
        /// CAutoDkmArray template or with DkmFreeMemory and manual element release.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE GetLanguageSettings(
            _In_ Evaluation::DkmLanguage* pLanguage,
            _Out_ DkmArray<DkmLanguageRegistrySetting*>* pSettings
            ) = 0;

        /// <summary>
        /// Get the user document visual studio folder path.
        /// </summary>
        /// <param name="pSettings">
        /// [In] Contains the session-wide debug settings. There is one instance of this
        /// object per engine Guid (ex: one instance for COMPlusOnlyEng2, one instance for
        /// COMPlusNativeEng).
        /// </param>
        /// <param name="ppUserDocumentPath">
        /// [Out] Returns the user document visual studio path.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE GetUserDocumentPath(
            _In_ DkmEngineSettings* pSettings,
            _Deref_out_ DkmString** ppUserDocumentPath
            ) = 0;

        /// <summary>
        /// Queries the language service (IVsLanguageDebugInfoScript) to obtain script block
        /// information from the associated project item of the specified script document.
        /// </summary>
        /// <param name="pScriptDocument">
        /// [In] Represents a document which is executing in a script runtime environment.
        /// For example, the Microsoft JavaScript engine.
        /// </param>
        /// <param name="ppScriptBlocks">
        /// [Out] Set of script blocks returned from the language service.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE GetProjectItemScriptBlocks(
            _In_ Script::DkmScriptDocument* pScriptDocument,
            _Deref_out_ DkmReadOnlyCollection<Script::DkmScriptBlockMappingInfo*>** ppScriptBlocks
            ) = 0;
    };

    // Interface implemented by the AD7AL as a gateway to services provided by the rest of
    // Visual Studio.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // BaseDebugMonitorId, EngineId, TransportKind.
    //
    // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
    #define IID_IDkmVisualStudioServices120 __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmVisualStudioServices120)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("9149fbca-eb46-9e45-2689-bf597e4099e1") IDkmVisualStudioServices120 : public IUnknown
    {
        /// <summary>
        /// Displays a message to the user inside the Visual Studio debugger IDE. This method
        /// is the Async implementation.  Once it is executed the completion routine will be
        /// called with the DkmProcess and the user response (Yes/No).  This method requires
        /// DkmUserMessage.Process to be non-null.
        /// </summary>
        /// <param name="pUserMessage">
        /// [In] Contains information about a message that is to be displayed to the user.
        /// </param>
        /// <param name="pWorkList">
        /// WorkList which is currently being processed. This value can be used to check for
        /// cancelation or to append additional work. New work items will not begin executing
        /// until after this function returns.
        /// </param>
        /// <param name="pCompletionRoutine">
        /// Routine to fire when the request is complete. This will be implicitly fired if
        /// the implementation returns failure from this interface method. The implementation
        /// must fire this method in all other scenarios.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE DisplayUserMessagePrompt(
            _In_ DkmUserMessage* pUserMessage,
            _In_ DkmWorkList* pWorkList,
            _In_ IDkmCompletionRoutine<DkmDisplayUserMessagePromptAsyncResult>* pCompletionRoutine
            ) = 0;
    };

}; // end of Microsoft implemented interfaces


// Disassembly providers interfaces
// Components that can disassemble instructions in the debuggee address space.
namespace ComponentInterfaces
{
    // Used to disassemble instructions in the debuggee address space.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // BaseDebugMonitorId, EngineId, TransportKind.
    #define IID_IDkmDisassemblyProvider __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmDisassemblyProvider)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("867cafe9-35a7-36b0-f567-955c81ae4316") IDkmDisassemblyProvider : public IUnknown
    {
        /// <summary>
        /// Disassemble an address range in the debuggee process.
        /// </summary>
        /// <param name="pProcess">
        /// [In] DkmProcess represents a target process which is being debugged. The debugger
        /// debugs processes, so this is the basic unit of debugging. A DkmProcess can
        /// represent a system process or a virtual process such as minidumps.
        /// </param>
        /// <param name="pAddress">
        /// [In] The address where disassembly should start.
        /// </param>
        /// <param name="Count">
        /// [In] The number of instructions to disassemble.
        /// </param>
        /// <param name="pDisassembledInstructions">
        /// [Out] The results of disassembling the address range.
        ///
        /// The memory for the DkmArray members is allocated by the method implementation
        /// using DkmAllocBytes/DkmAllocArray. It is freed by the caller using the
        /// CAutoDkmArray template or with DkmFreeMemory and manual element release.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE Disassemble(
            _In_ DkmProcess* pProcess,
            _In_ DkmInstructionAddress* pAddress,
            _In_ UINT32 Count,
            _Out_ DkmArray<Disassembly::DkmDisassembledInstruction*>* pDisassembledInstructions
            ) = 0;

        /// <summary>
        /// Returns the address of the kth instruction relative to a starting address. For
        /// constant length instruction sets, this is simple arithmetic. For variable length
        /// instruction sets, reverse-disassembly is required to obtain this address.
        /// </summary>
        /// <param name="pProcess">
        /// [In] DkmProcess represents a target process which is being debugged. The debugger
        /// debugs processes, so this is the basic unit of debugging. A DkmProcess can
        /// represent a system process or a virtual process such as minidumps.
        /// </param>
        /// <param name="pStartAddress">
        /// [In] The address of the current instruction where the offset should begin.
        /// </param>
        /// <param name="InstructionOffset">
        /// [In] The number of instructions relative to StartAddress to find the desired
        /// address. This value can be negative.
        /// </param>
        /// <param name="ppAddress">
        /// [Out] The address of the instruction InstructionOffset instructions from
        /// StartAddress.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE GetInstructionAddress(
            _In_ DkmProcess* pProcess,
            _In_ DkmInstructionAddress* pStartAddress,
            _In_ INT32 InstructionOffset,
            _Deref_out_ DkmInstructionAddress** ppAddress
            ) = 0;

        /// <summary>
        /// A method that calculates and returns the effective addresses for the requested
        /// address. The effective address is the calculated address that an instruction
        /// operand represents. For instance, on x86, an instruction may be of the form
        /// dwordptr [esp-12]. The effective address of this operand will be the result of
        /// subtracting 12 from esp. The number of operands and effective addresses are
        /// architecture specific.
        /// </summary>
        /// <param name="pFrame">
        /// [In] DkmStackFrame represents a frame on the call stack after filtering and
        /// translation.
        /// </param>
        /// <param name="pAddress">
        /// [In] The address for which to obtain the effective addresses.
        /// </param>
        /// <param name="ppEffectiveAddresses">
        /// [Out] The collection of effective addresses for this instruction if any.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE GetEffectiveAddresses(
            _In_ CallStack::DkmStackFrame* pFrame,
            _In_ DkmInstructionAddress* pAddress,
            _Deref_out_ DkmReadOnlyCollection<Disassembly::DkmEffectiveAddress>** ppEffectiveAddresses
            ) = 0;
    };

    // Used to disassemble instructions in the debuggee address space with respect to a
    // specific runtime.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // BaseDebugMonitorId, EngineId, RuntimeId, TransportKind.
    //
    // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
    #define IID_IDkmRuntimeDisassemblyProvider __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmRuntimeDisassemblyProvider)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("2fd9551e-2957-9c1e-ce24-c73f59463200") IDkmRuntimeDisassemblyProvider : public IUnknown
    {
        /// <summary>
        /// Disassemble an address range in the debuggee runtime.
        /// </summary>
        /// <param name="pRuntimeInstance">
        /// [In] The DkmRuntimeInstance class represents an execution environment which is
        /// loaded into a DkmProcess and which contains code to be debugged.
        /// </param>
        /// <param name="pAddress">
        /// [In] The address where disassembly should start.
        /// </param>
        /// <param name="Count">
        /// [In] The number of instructions to disassemble.
        /// </param>
        /// <param name="pDisassembledInstructions">
        /// [Out] The results of disassembling the address range.
        ///
        /// The memory for the DkmArray members is allocated by the method implementation
        /// using DkmAllocBytes/DkmAllocArray. It is freed by the caller using the
        /// CAutoDkmArray template or with DkmFreeMemory and manual element release.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE Disassemble(
            _In_ DkmRuntimeInstance* pRuntimeInstance,
            _In_ DkmInstructionAddress* pAddress,
            _In_ UINT32 Count,
            _Out_ DkmArray<Disassembly::DkmDisassembledInstruction*>* pDisassembledInstructions
            ) = 0;

        /// <summary>
        /// Returns the address of the kth instruction relative to a starting address. For
        /// constant length instruction sets, this is simple arithmetic. For variable length
        /// instruction sets, reverse-disassembly is required to obtain this address.
        /// </summary>
        /// <param name="pRuntimeInstance">
        /// [In] The DkmRuntimeInstance class represents an execution environment which is
        /// loaded into a DkmProcess and which contains code to be debugged.
        /// </param>
        /// <param name="pStartAddress">
        /// [In] The address of the current instruction where the offset should begin.
        /// </param>
        /// <param name="InstructionOffset">
        /// [In] The number of instructions relative to StartAddress to find the desired
        /// address. This value can be negative.
        /// </param>
        /// <param name="ppAddress">
        /// [Out] The address of the instruction InstructionOffset instructions from
        /// StartAddress.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE GetInstructionAddress(
            _In_ DkmRuntimeInstance* pRuntimeInstance,
            _In_ DkmInstructionAddress* pStartAddress,
            _In_ INT32 InstructionOffset,
            _Deref_out_ DkmInstructionAddress** ppAddress
            ) = 0;
    };

}; // end of Disassembly providers interfaces


// GPU component interfaces
// Provides GPU debugging functionality such as operations on GPU compute kernel and its
// hierarchy of GPU compute threads, operations on GPU memory, registers, and
// disassembly.
namespace ComponentInterfaces
{
    // Interface for querying the GPU debugging breakpoint behavior.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // BaseDebugMonitorId, EngineId, TransportKind.
    #define IID_IDkmGPUBreakpointBehaviorQuery __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmGPUBreakpointBehaviorQuery)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("26e132aa-dd1d-eb87-7df2-1e44ec6d3f99") IDkmGPUBreakpointBehaviorQuery : public IUnknown
    {
        /// <summary>
        /// Get the breakpoint behavior of the process.
        /// </summary>
        /// <param name="pProcess">
        /// [In] DkmProcess represents a target process which is being debugged. The debugger
        /// debugs processes, so this is the basic unit of debugging. A DkmProcess can
        /// represent a system process or a virtual process such as minidumps.
        /// </param>
        /// <param name="pBreakpointBehavior">
        /// [Out] The breakpoint behavior of the process.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE GetGPUBreakpointBehavior(
            _In_ DkmProcess* pProcess,
            _Out_ GPU::DkmGPUBreakpointBehaviorFlags_t* pBreakpointBehavior
            ) = 0;
    };

    // Provides the compute kernel hierarchy, i.e., the thread group, compute vector and
    // compute thread for view by the user.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // BaseDebugMonitorId, EngineId, TransportKind.
    #define IID_IDkmGPUComputeKernelOperation __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmGPUComputeKernelOperation)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("5f2afaed-ff79-0b4d-c849-40d37db4c5c5") IDkmGPUComputeKernelOperation : public IUnknown
    {
        /// <summary>
        /// Obtain the warp size of the hardware or emulator.
        /// </summary>
        /// <param name="pComputeKernel">
        /// [In] DkmGPUComputeKernel represents a GPU compute kernel running in the target
        /// process.
        /// </param>
        /// <param name="pWidth">
        /// [Out] Width of the hardware.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE GetComputeVectorWidth(
            _In_ GPU::DkmGPUComputeKernel* pComputeKernel,
            _Out_ UINT32* pWidth
            ) = 0;

        /// <summary>
        /// Obtain the active thread groups from the compute kernel.
        /// </summary>
        /// <param name="pComputeKernel">
        /// [In] DkmGPUComputeKernel represents a GPU compute kernel running in the target
        /// process.
        /// </param>
        /// <param name="pActiveThreadGroups">
        /// [Out] List of global Thread group id of all active thread groups.
        ///
        /// The memory for the DkmArray members is allocated by the method implementation
        /// using DkmAllocBytes/DkmAllocArray. It is freed by the caller using the
        /// CAutoDkmArray template or with DkmFreeMemory and manual element release.
        /// </param>
        /// <param name="pNumberOfGroups">
        /// [Out] Number of active thread groups in the compute kernel.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE GetActiveThreadGroups(
            _In_ GPU::DkmGPUComputeKernel* pComputeKernel,
            _Out_ DkmArray<UINT64>* pActiveThreadGroups,
            _Out_ UINT32* pNumberOfGroups
            ) = 0;

        /// <summary>
        /// Get the dimension of the thread block.
        /// </summary>
        /// <param name="pComputeKernel">
        /// [In] DkmGPUComputeKernel represents a GPU compute kernel running in the target
        /// process.
        /// </param>
        /// <param name="pThreadDimensions">
        /// [Out] Thread group dimensions.
        ///
        /// The memory for the DkmArray members is allocated by the method implementation
        /// using DkmAllocBytes/DkmAllocArray. It is freed by the caller using the
        /// CAutoDkmArray template or with DkmFreeMemory and manual element release.
        /// </param>
        /// <param name="pNumberOfDimensions">
        /// [Out] Number of Thread block dimensions.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE GetCurrentThreadDimensions(
            _In_ GPU::DkmGPUComputeKernel* pComputeKernel,
            _Out_ DkmArray<UINT32>* pThreadDimensions,
            _Out_ UINT32* pNumberOfDimensions
            ) = 0;

        /// <summary>
        /// Get the dimension of the thread block.
        /// </summary>
        /// <param name="pComputeKernel">
        /// [In] DkmGPUComputeKernel represents a GPU compute kernel running in the target
        /// process.
        /// </param>
        /// <param name="pGroupDimensions">
        /// [Out] Grid Dimensions.
        ///
        /// The memory for the DkmArray members is allocated by the method implementation
        /// using DkmAllocBytes/DkmAllocArray. It is freed by the caller using the
        /// CAutoDkmArray template or with DkmFreeMemory and manual element release.
        /// </param>
        /// <param name="pNumberOfDimensions">
        /// [Out] Number of Grid dimensions.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE GetCurrentGroupDimensions(
            _In_ GPU::DkmGPUComputeKernel* pComputeKernel,
            _Out_ DkmArray<UINT32>* pGroupDimensions,
            _Out_ UINT32* pNumberOfDimensions
            ) = 0;

        /// <summary>
        /// Get the dimension of the thread block.
        /// </summary>
        /// <param name="pComputeThread">
        /// [In] DkmGPUComputeThread represents a compute thread running in the GPU target
        /// process.
        /// </param>
        /// <param name="pThreadDimensions">
        /// [Out] Thread group dimensions.
        ///
        /// The memory for the DkmArray members is allocated by the method implementation
        /// using DkmAllocBytes/DkmAllocArray. It is freed by the caller using the
        /// CAutoDkmArray template or with DkmFreeMemory and manual element release.
        /// </param>
        /// <param name="pNumberOfDimensions">
        /// [Out] Number of Thread block dimensions.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE GetThisThreadDimension(
            _In_ GPU::DkmGPUComputeThread* pComputeThread,
            _Out_ DkmArray<UINT32>* pThreadDimensions,
            _Out_ UINT32* pNumberOfDimensions
            ) = 0;

        /// <summary>
        /// Get the dimension of the thread block.
        /// </summary>
        /// <param name="pComputeThread">
        /// [In] DkmGPUComputeThread represents a compute thread running in the GPU target
        /// process.
        /// </param>
        /// <param name="pGroupDimensions">
        /// [Out] Grid dimensions.
        ///
        /// The memory for the DkmArray members is allocated by the method implementation
        /// using DkmAllocBytes/DkmAllocArray. It is freed by the caller using the
        /// CAutoDkmArray template or with DkmFreeMemory and manual element release.
        /// </param>
        /// <param name="pNumberOfDimensions">
        /// [Out] Number of Grid dimensions.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE GetThisGroupDimension(
            _In_ GPU::DkmGPUComputeThread* pComputeThread,
            _Out_ DkmArray<UINT32>* pGroupDimensions,
            _Out_ UINT32* pNumberOfDimensions
            ) = 0;

        /// <summary>
        /// Get the name of compute kernel.
        /// </summary>
        /// <param name="pComputeKernel">
        /// [In] DkmGPUComputeKernel represents a GPU compute kernel running in the target
        /// process.
        /// </param>
        /// <param name="ppComputeKernelName">
        /// [Out] Name of the ComputeKernel that is launched.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE GetComputeKernelName(
            _In_ GPU::DkmGPUComputeKernel* pComputeKernel,
            _Deref_out_ DkmString** ppComputeKernelName
            ) = 0;

        /// <summary>
        /// Get properties of the compute kernel.
        /// </summary>
        /// <param name="pComputeKernel">
        /// [In] DkmGPUComputeKernel represents a GPU compute kernel running in the target
        /// process.
        /// </param>
        /// <param name="pComputeProperties">
        /// [Out] List of Compute kernel properties.
        ///
        /// The memory for the DkmArray members is allocated by the method implementation
        /// using DkmAllocBytes/DkmAllocArray. It is freed by the caller using the
        /// CAutoDkmArray template or with DkmFreeMemory and manual element release.
        /// </param>
        /// <param name="pNumberOfProperties">
        /// [Out] Number of properties in the compute kernel.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE GetComputeKernelProperties(
            _In_ GPU::DkmGPUComputeKernel* pComputeKernel,
            _Out_ DkmArray<GPU::DkmComputeProperty>* pComputeProperties,
            _Out_ UINT32* pNumberOfProperties
            ) = 0;

        /// <summary>
        /// Get the dimension of the thread block.
        /// </summary>
        /// <param name="pComputeThread">
        /// [In] DkmGPUComputeThread represents a compute thread running in the GPU target
        /// process.
        /// </param>
        /// <param name="pThreadDimensions">
        /// [Out] Thread group dimensions.
        ///
        /// The memory for the DkmArray members is allocated by the method implementation
        /// using DkmAllocBytes/DkmAllocArray. It is freed by the caller using the
        /// CAutoDkmArray template or with DkmFreeMemory and manual element release.
        /// </param>
        /// <param name="pNumberOfDimensions">
        /// [Out] Number of Thread block dimensions.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE GetThreadId(
            _In_ GPU::DkmGPUComputeThread* pComputeThread,
            _Out_ DkmArray<UINT32>* pThreadDimensions,
            _Out_ UINT32* pNumberOfDimensions
            ) = 0;

        /// <summary>
        /// Get the dimension of the thread block.
        /// </summary>
        /// <param name="pComputeThread">
        /// [In] DkmGPUComputeThread represents a compute thread running in the GPU target
        /// process.
        /// </param>
        /// <param name="pGroupDimensions">
        /// [Out] Grid dimensions.
        ///
        /// The memory for the DkmArray members is allocated by the method implementation
        /// using DkmAllocBytes/DkmAllocArray. It is freed by the caller using the
        /// CAutoDkmArray template or with DkmFreeMemory and manual element release.
        /// </param>
        /// <param name="pNumberOfDimensions">
        /// [Out] Number of Grid dimensions.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE GetGroupId(
            _In_ GPU::DkmGPUComputeThread* pComputeThread,
            _Out_ DkmArray<UINT32>* pGroupDimensions,
            _Out_ UINT32* pNumberOfDimensions
            ) = 0;

        /// <summary>
        /// Runs the select query on thread info objects.
        /// </summary>
        /// <param name="pComputeKernel">
        /// [In] DkmGPUComputeKernel represents a GPU compute kernel running in the target
        /// process.
        /// </param>
        /// <param name="pFrom">
        /// [In] From clause specification for selection (can be empty to select from all
        /// available threads).
        /// </param>
        /// <param name="Where">
        /// [In] Where clause specification for selection.
        /// </param>
        /// <param name="pThreadInfoArray">
        /// [Out] The result set of compute thread info objects.
        ///
        /// The memory for the DkmArray members is allocated by the method implementation
        /// using DkmAllocBytes/DkmAllocArray. It is freed by the caller using the
        /// CAutoDkmArray template or with DkmFreeMemory and manual element release.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE Select(
            _In_ GPU::DkmGPUComputeKernel* pComputeKernel,
            _In_ DkmReadOnlyCollection<UINT64>* pFrom,
            _In_ const GPU::DkmWhereClause& Where,
            _Out_ DkmArray<GPU::DkmComputeThreadInfo>* pThreadInfoArray
            ) = 0;

        /// <summary>
        /// Runs the group by query on thread info objects.
        /// </summary>
        /// <param name="pComputeKernel">
        /// [In] DkmGPUComputeKernel represents a GPU compute kernel running in the target
        /// process.
        /// </param>
        /// <param name="GroupByFlags">
        /// [In] Flags specifying on which columns the group by is run.
        /// </param>
        /// <param name="pFrom">
        /// [In] From clause specification for selection (can be empty to select from all
        /// available threads).
        /// </param>
        /// <param name="Where">
        /// [In] Where clause specification for group by.
        /// </param>
        /// <param name="pThreadInfoArray">
        /// [Out] The result set of compute thread info objects.
        ///
        /// The memory for the DkmArray members is allocated by the method implementation
        /// using DkmAllocBytes/DkmAllocArray. It is freed by the caller using the
        /// CAutoDkmArray template or with DkmFreeMemory and manual element release.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE GroupBy(
            _In_ GPU::DkmGPUComputeKernel* pComputeKernel,
            _In_ GPU::DkmQueryComputeThreadInfoFlags_t GroupByFlags,
            _In_ DkmReadOnlyCollection<UINT64>* pFrom,
            _In_ const GPU::DkmWhereClause& Where,
            _Out_ DkmArray<GPU::DkmComputeThreadInfo>* pThreadInfoArray
            ) = 0;

        /// <summary>
        /// Get all threads that hit breakpoint.
        /// </summary>
        /// <param name="pComputeKernel">
        /// [In] DkmGPUComputeKernel represents a GPU compute kernel running in the target
        /// process.
        /// </param>
        /// <param name="pThreadIdArray">
        /// [Out] The result set of compute thread ids that hit breakpoint.
        ///
        /// The memory for the DkmArray members is allocated by the method implementation
        /// using DkmAllocBytes/DkmAllocArray. It is freed by the caller using the
        /// CAutoDkmArray template or with DkmFreeMemory and manual element release.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE GetStoppedThreads(
            _In_ GPU::DkmGPUComputeKernel* pComputeKernel,
            _Out_ DkmArray<UINT64>* pThreadIdArray
            ) = 0;

        /// <summary>
        /// Gets the DkmGPUComputeThread object for a given thread ID.
        /// </summary>
        /// <param name="pComputeKernel">
        /// [In] DkmGPUComputeKernel represents a GPU compute kernel running in the target
        /// process.
        /// </param>
        /// <param name="ThreadId">
        /// [In] ID of the thread to return.
        /// </param>
        /// <param name="ppThread">
        /// [Out] Thread object that matches the given thread ID.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE GetThreadFromId(
            _In_ GPU::DkmGPUComputeKernel* pComputeKernel,
            _In_ UINT64 ThreadId,
            _Deref_out_ GPU::DkmGPUComputeThread** ppThread
            ) = 0;

        /// <summary>
        /// Update flagged state of compute threads.
        /// </summary>
        /// <param name="pComputeKernel">
        /// [In] DkmGPUComputeKernel represents a GPU compute kernel running in the target
        /// process.
        /// </param>
        /// <param name="Where">
        /// [In] Where clause specification for update.
        /// </param>
        /// <param name="Flagged">
        /// [In] The value to update with.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE UpdateFlaggedState(
            _In_ GPU::DkmGPUComputeKernel* pComputeKernel,
            _In_ const GPU::DkmWhereClause& Where,
            _In_ bool Flagged
            ) = 0;

        /// <summary>
        /// Update frozen state of compute threads.
        /// </summary>
        /// <param name="pComputeKernel">
        /// [In] DkmGPUComputeKernel represents a GPU compute kernel running in the target
        /// process.
        /// </param>
        /// <param name="Where">
        /// [In] Where clause specification for update.
        /// </param>
        /// <param name="Frozen">
        /// [In] The value to update with.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE UpdateFrozenState(
            _In_ GPU::DkmGPUComputeKernel* pComputeKernel,
            _In_ const GPU::DkmWhereClause& Where,
            _In_ bool Frozen
            ) = 0;

        /// <summary>
        /// Get the dimension of the thread block.
        /// </summary>
        /// <param name="pComputeKernel">
        /// [In] DkmGPUComputeKernel represents a GPU compute kernel running in the target
        /// process.
        /// </param>
        /// <param name="pFlatThreadDimensions">
        /// [Out] Thread group dimensions.
        ///
        /// The memory for the DkmArray members is allocated by the method implementation
        /// using DkmAllocBytes/DkmAllocArray. It is freed by the caller using the
        /// CAutoDkmArray template or with DkmFreeMemory and manual element release.
        /// </param>
        /// <param name="pFlatIndexBase">
        /// [Out] Thread group dimensions.
        ///
        /// The memory for the DkmArray members is allocated by the method implementation
        /// using DkmAllocBytes/DkmAllocArray. It is freed by the caller using the
        /// CAutoDkmArray template or with DkmFreeMemory and manual element release.
        /// </param>
        /// <param name="pNumberOfDimensions">
        /// [Out] Number of Thread block dimensions.
        /// </param>
        /// <param name="pModel">
        /// [Out] Model Type.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE GetFlatComputeKernelDimensions(
            _In_ GPU::DkmGPUComputeKernel* pComputeKernel,
            _Out_ DkmArray<UINT32>* pFlatThreadDimensions,
            _Out_ DkmArray<INT32>* pFlatIndexBase,
            _Out_ UINT32* pNumberOfDimensions,
            _Out_ GPU::DkmComputeKernelModel_t* pModel
            ) = 0;
    };

    // Used to query raw disassembly in the GPU debuggee byte code.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // BaseDebugMonitorId, EngineId, RuntimeId, SymbolProviderId, TransportKind.
    #define IID_IDkmGPUDisassemblyQuery __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmGPUDisassemblyQuery)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("5ac63247-f76d-3014-8c80-1ca6672fb9d6") IDkmGPUDisassemblyQuery : public IUnknown
    {
        /// <summary>
        /// Obtain the disassembly of the address range in the debuggee module instance.
        /// </summary>
        /// <param name="pModuleInstance">
        /// [In] The Module Instance class represent a code bundle (ex: dll or exe) which is
        /// loaded into a particular process at a particular location. Module Instance
        /// objects are 1:1 with the execution environment's notion of a code bundle. For
        /// example, in native code, Module Instance objects are 1:1 with base address.
        /// </param>
        /// <param name="Address">
        /// [In] The address where disassembly should start.
        /// </param>
        /// <param name="Count">
        /// [In] The number of instructions to disassemble.
        /// </param>
        /// <param name="IsForward">
        /// [In] True if this is forward disassembling, otherwise this is reverse
        /// disassembling.
        /// </param>
        /// <param name="pDisassembly">
        /// [Out] The results of disassembly read from the debuggee byte code.
        ///
        /// The memory for the DkmArray members is allocated by the method implementation
        /// using DkmAllocBytes/DkmAllocArray. It is freed by the caller using the
        /// CAutoDkmArray template or with DkmFreeMemory and manual element release.
        /// </param>
        /// <param name="pIsEnd">
        /// [Out] True if the disassembly has reached the end of byte code, false otherwise.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE GetGPUDisassembly(
            _In_ DkmModuleInstance* pModuleInstance,
            _In_ UINT64 Address,
            _In_ UINT32 Count,
            _In_ bool IsForward,
            _Out_ DkmArray<BYTE>* pDisassembly,
            _Out_ bool* pIsEnd
            ) = 0;

        /// <summary>
        /// Returns the disassembly size in the debuggee module instance.
        /// </summary>
        /// <param name="pModuleInstance">
        /// [In] The Module Instance class represent a code bundle (ex: dll or exe) which is
        /// loaded into a particular process at a particular location. Module Instance
        /// objects are 1:1 with the execution environment's notion of a code bundle. For
        /// example, in native code, Module Instance objects are 1:1 with base address.
        /// </param>
        /// <param name="pSize">
        /// [Out] The disassembly size.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE GetGPUDisassemblySize(
            _In_ DkmModuleInstance* pModuleInstance,
            _Out_ UINT64* pSize
            ) = 0;

        /// <summary>
        /// Returns the address of the next instruction relative to a starting address.
        /// </summary>
        /// <param name="pModuleInstance">
        /// [In] The Module Instance class represent a code bundle (ex: dll or exe) which is
        /// loaded into a particular process at a particular location. Module Instance
        /// objects are 1:1 with the execution environment's notion of a code bundle. For
        /// example, in native code, Module Instance objects are 1:1 with base address.
        /// </param>
        /// <param name="StartAddress">
        /// [In] The address of the current instruction.
        /// </param>
        /// <param name="pNextAddress">
        /// [Out] The address of the next instruction from StartAddress.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE GetNextGPUInstructionAddress(
            _In_ DkmModuleInstance* pModuleInstance,
            _In_ UINT64 StartAddress,
            _Out_ UINT64* pNextAddress
            ) = 0;
    };

    // Implemented by base debug monitors to provide access to the memory of the target GPU
    // process. Base debug monitors are responsible for performing the memory I/O.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // BaseDebugMonitorId, EngineId, TransportKind.
    #define IID_IDkmGPUMemoryOperation __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmGPUMemoryOperation)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("23e4188c-7499-b774-7878-d13b3ba8410f") IDkmGPUMemoryOperation : public IUnknown
    {
        /// <summary>
        /// Read the memory of the target GPU process. The method is on DkmGPUComputeThread
        /// because it may read thread local memory, group shared memory or global memory.
        /// </summary>
        /// <param name="pComputeThread">
        /// [In] DkmGPUComputeThread represents a compute thread running in the GPU target
        /// process.
        /// </param>
        /// <param name="Address">
        /// [In] The address from which to read the target GPU process's memory.
        /// </param>
        /// <param name="InstructionPointer">
        /// [In] The instruction pointer where to resolve address to register location.
        /// </param>
        /// <param name="Flags">
        /// [In] Flags controlling the behavior of DkmProcess.ReadMemory and
        /// DkmProcess.ReadMemoryString.
        /// </param>
        /// <param name="pBuffer">
        /// [In,Out] A buffer that receives the contents from the address space of the target
        /// process. On failure, the content of this buffer is unspecified.
        /// </param>
        /// <param name="Size">
        /// [In] The number of bytes to be read from the process. In scenarios where the call
        /// is marshalled to the remote debugger from the IDE, this must be less than 25 MBs.
        /// </param>
        /// <param name="pBytesRead">
        /// [Out] Indicates the number of bytes read from the target GPU process. If
        /// DkmReadMemoryFlags.AllowPartialRead is clear, on success this value will always
        /// be exactly equal to the input size. If DkmReadMemoryFlags.AllowPartialRead is
        /// specified, on success, this value will be greater than zero.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE ReadMemory(
            _In_ GPU::DkmGPUComputeThread* pComputeThread,
            _In_ UINT64 Address,
            _In_ UINT64 InstructionPointer,
            _In_ DkmReadMemoryFlags_t Flags,
            _Out_capcount_(Size) void* pBuffer,
            _In_ UINT32 Size,
            _Out_ UINT32* pBytesRead
            ) = 0;

        /// <summary>
        /// Writes memory to the target GPU process. The method is on DkmGPUComputeThread
        /// because it may write thread local memory, group shared memory or global memory.
        /// </summary>
        /// <param name="pComputeThread">
        /// [In] DkmGPUComputeThread represents a compute thread running in the GPU target
        /// process.
        /// </param>
        /// <param name="Address">
        /// [In] The base address from which to write the target GPU process's memory.
        /// </param>
        /// <param name="InstructionPointer">
        /// [In] The instruction pointer where to resolve address to register location.
        /// </param>
        /// <param name="Data">
        /// [In] Data to be written in the address space of the specified GPU process.
        ///
        /// The memory for the DkmArray members is allocated by the caller, and can be from
        /// any source (stack memory, static buffer, heap, etc). The implementation should
        /// not modify the members.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE WriteMemory(
            _In_ GPU::DkmGPUComputeThread* pComputeThread,
            _In_ UINT64 Address,
            _In_ UINT64 InstructionPointer,
            _In_ const DkmArray<BYTE>& Data
            ) = 0;

        /// <summary>
        /// Checks if a tag for a buffer has been forwarded for this kernel execution.
        /// </summary>
        /// <param name="pComputeThread">
        /// [In] DkmGPUComputeThread represents a compute thread running in the GPU target
        /// process.
        /// </param>
        /// <param name="InputTag">
        /// [In] The C++ AMP pointer tag.
        /// </param>
        /// <param name="pForwardedTag">
        /// [Out] The forwarded tag value.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE UpdateBufferTag(
            _In_ GPU::DkmGPUComputeThread* pComputeThread,
            _In_ UINT32 InputTag,
            _Out_ UINT32* pForwardedTag
            ) = 0;

        /// <summary>
        /// Validate the specified GPU memory address.
        /// </summary>
        /// <param name="pComputeThread">
        /// [In] DkmGPUComputeThread represents a compute thread running in the GPU target
        /// process.
        /// </param>
        /// <param name="Address">
        /// [In] The address to validate.
        /// </param>
        /// <param name="pIsValidGpuMemoryAddress">
        /// [Out] True if the specified address is a valid GPU memory address, false
        /// otherwise.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE ValidateAddress(
            _In_ GPU::DkmGPUComputeThread* pComputeThread,
            _In_ UINT64 Address,
            _Out_ bool* pIsValidGpuMemoryAddress
            ) = 0;
    };

    // Implemented by base debug monitors to provide access to the registers of the GPU
    // compute thread.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // BaseDebugMonitorId, EngineId, TransportKind.
    #define IID_IDkmGPURegisterOperation __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmGPURegisterOperation)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("bfd79470-a01a-6335-ce95-6cded602ba8f") IDkmGPURegisterOperation : public IUnknown
    {
        /// <summary>
        /// Obtain the list of all register descriptions from the GPU compute thread.
        /// </summary>
        /// <param name="pComputeThread">
        /// [In] DkmGPUComputeThread represents a compute thread running in the GPU target
        /// process.
        /// </param>
        /// <param name="pRegisterDescriptions">
        /// [Out] The list of all register descriptions from the GPU compute thread.
        ///
        /// The memory for the DkmArray members is allocated by the method implementation
        /// using DkmAllocBytes/DkmAllocArray. It is freed by the caller using the
        /// CAutoDkmArray template or with DkmFreeMemory and manual element release.
        /// </param>
        /// <returns>
        /// S_OK is returned if pRegisterDescriptions contains any elements, S_FALSE is
        /// indicates the array is empty, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE GetRegisterDescriptions(
            _In_ GPU::DkmGPUComputeThread* pComputeThread,
            _Out_ DkmArray<GPU::DkmGPURegisterDescription>* pRegisterDescriptions
            ) = 0;

        /// <summary>
        /// Set the value of a register in the GPU compute thread.
        /// </summary>
        /// <param name="pComputeThread">
        /// [In] DkmGPUComputeThread represents a compute thread running in the GPU target
        /// process.
        /// </param>
        /// <param name="RegisterDescription">
        /// [In] The description of a register from the GPU compute thread.
        /// </param>
        /// <param name="pRegisterValue">
        /// [In] The value bytes of a register to be written in the GPU compute thread.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE SetRegisterValue(
            _In_ GPU::DkmGPUComputeThread* pComputeThread,
            _In_ const GPU::DkmGPURegisterDescription& RegisterDescription,
            _In_ DkmReadOnlyCollection<BYTE>* pRegisterValue
            ) = 0;
    };

    // IDkmGPUSetMemoryAccessWarningOperation is used to configure GPU memory access warnings
    // on the debugged GPU device. It is implemented by base debug monitors which support
    // reporting GPU Memory Access Exceptions.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // BaseDebugMonitorId, EngineId, TransportKind.
    #define IID_IDkmGPUSetMemoryAccessWarningOperation __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmGPUSetMemoryAccessWarningOperation)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("aab60381-4616-c94a-c4a3-e31442a3804b") IDkmGPUSetMemoryAccessWarningOperation : public IUnknown
    {
        /// <summary>
        /// Enables / disables a particular GPU memory access warning.
        /// </summary>
        /// <param name="pProcess">
        /// [In] DkmProcess represents a target process which is being debugged. The debugger
        /// debugs processes, so this is the basic unit of debugging. A DkmProcess can
        /// represent a system process or a virtual process such as minidumps.
        /// </param>
        /// <param name="WarningCode">
        /// [In] Warning code to set.
        /// </param>
        /// <param name="Enable">
        /// [In] True to set the warning, false to clear it.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE SetGPUMemoryAccessWarning(
            _In_ DkmProcess* pProcess,
            _In_ UINT32 WarningCode,
            _In_ bool Enable
            ) = 0;

        /// <summary>
        /// Disables all active GPU memory access warnings.
        /// </summary>
        /// <param name="pProcess">
        /// [In] DkmProcess represents a target process which is being debugged. The debugger
        /// debugs processes, so this is the basic unit of debugging. A DkmProcess can
        /// represent a system process or a virtual process such as minidumps.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE ClearAllGPUMemoryAccessWarnings(
            _In_ DkmProcess* pProcess
            ) = 0;
    };

    // Callback interface which is implemented by GPU symbol providers to provide information
    // from the symbol store to base debug monitors.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // SymbolProviderId.
    #define IID_IDkmGPUSymbolProviderCallback __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmGPUSymbolProviderCallback)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("06ae9ecf-5ee1-86c4-23e1-2e4ebea8ed4d") IDkmGPUSymbolProviderCallback : public IUnknown
    {
        /// <summary>
        /// Translate accelerator pointer tag into HLSL register attributes.
        /// </summary>
        /// <param name="pModule">
        /// [In] The DkmModule class represents a code bundle (ex: dll or exe) which is or
        /// once was loaded into one or more processes. The DkmModule class is the central
        /// object to the symbol APIs, and is 1:1 with the symbol handler's notation of what
        /// is loaded. If a code bundle loads into three different processes (or the same
        /// process but with three different base addresses or three different app domains)
        /// but the symbol handler thinks of all of these as being identical, there will be
        /// only one module object.
        /// </param>
        /// <param name="InputTag">
        /// [In] Accelerator pointer tag found in symbols.
        /// </param>
        /// <param name="InstructionPointer">
        /// [In] current instruction pointer used to get scope for pointer translation.
        /// </param>
        /// <param name="pRegisterType">
        /// [Out] HLSL register type.
        /// </param>
        /// <param name="pRegisterIndex">
        /// [Out] HLSL register index.
        /// </param>
        /// <param name="pFirstElement">
        /// [Out] Index of first vector element.
        /// </param>
        /// <param name="pVectorElements">
        /// [Out] Number of vector elements.
        /// </param>
        /// <param name="pByteOffset">
        /// [Out] Offset in bytes.
        /// </param>
        /// <param name="pVectorElementSize">
        /// [Out] Size of each vector element.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE TranslateAcceleratorTagByIP(
            _In_ Symbols::DkmModule* pModule,
            _In_ UINT32 InputTag,
            _In_ UINT32 InstructionPointer,
            _Out_ UINT32* pRegisterType,
            _Out_ UINT32* pRegisterIndex,
            _Out_ UINT32* pFirstElement,
            _Out_ UINT32* pVectorElements,
            _Out_ UINT32* pByteOffset,
            _Out_ UINT32* pVectorElementSize
            ) = 0;

        /// <summary>
        /// This method returns address information to the GPU debug monitor.
        /// </summary>
        /// <param name="pInstruction">
        /// [In] DkmInstructionSymbol represents a method in the target process.
        /// </param>
        /// <param name="pInstructionAddress">
        /// [In,Optional] Abstract representation of an executable code location (ex: EIP
        /// value). If resolved, an Instruction Address will be within a particular module
        /// instance. An Instruction Address is always within a particular Runtime Instance.
        /// </param>
        /// <param name="pNextInstruction">
        /// [In] The next instruction address which is used to determine inline function
        /// call.
        /// </param>
        /// <param name="pMetadata">
        /// [Out,Optional] The address type information.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE GetGPUInstructionMetadataCallback(
            _In_ Symbols::DkmInstructionSymbol* pInstruction,
            _In_opt_ DkmInstructionAddress* pInstructionAddress,
            _In_ Symbols::DkmInstructionSymbol* pNextInstruction,
            _Out_ GPU::DkmGPUAddressType_t* pMetadata
            ) = 0;

        /// <summary>
        /// This method returns compiler flags of the given GPU module.
        /// </summary>
        /// <param name="pModule">
        /// [In] The DkmModule class represents a code bundle (ex: dll or exe) which is or
        /// once was loaded into one or more processes. The DkmModule class is the central
        /// object to the symbol APIs, and is 1:1 with the symbol handler's notation of what
        /// is loaded. If a code bundle loads into three different processes (or the same
        /// process but with three different base addresses or three different app domains)
        /// but the symbol handler thinks of all of these as being identical, there will be
        /// only one module object.
        /// </param>
        /// <param name="ppCompilerOptions">
        /// [Out,Optional] returns the compiler flags.
        /// </param>
        /// <returns>
        /// S_OK is returned if *ppCompilerOptions is non-NULL, S_FALSE is returned when
        /// *ppCompilerOptions is NULL, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE GetCompilerOptions(
            _In_ Symbols::DkmModule* pModule,
            _Deref_out_opt_ DkmString** ppCompilerOptions
            ) = 0;

        /// <summary>
        /// Queries the symbol provider to determine the ranges of instructions which do not
        /// correspond to any user source statements and are used by the base debug monitor
        /// to always step through during stepping.
        /// </summary>
        /// <param name="pInstruction">
        /// [In] DkmInstructionSymbol represents a method in the target process.
        /// </param>
        /// <param name="pRanges">
        /// [Out] Array of no source ranges to always step through. This array will be empty
        /// if there are no no-source ranges for the given instruction.
        ///
        /// The memory for the DkmArray members is allocated by the method implementation
        /// using DkmAllocBytes/DkmAllocArray. It is freed by the caller using the
        /// CAutoDkmArray template or with DkmFreeMemory and manual element release.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE GetNoSourceRanges(
            _In_ Symbols::DkmInstructionSymbol* pInstruction,
            _Out_ DkmArray<Symbols::DkmSteppingRange>* pRanges
            ) = 0;
    };

    // This API is used to read information about a symbol for DPC++.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // CompilerVendorId, LanguageId, SymbolProviderId, TransportKind.
    #define IID_IDkmGPUSymbolQuery __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmGPUSymbolQuery)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("7dd1cb8a-dd52-259e-ca92-61571659aaec") IDkmGPUSymbolQuery : public IUnknown
    {
        /// <summary>
        /// Translate accelerator pointer tag into HLSL register attributes using relative
        /// virtual address.
        /// </summary>
        /// <param name="pModule">
        /// [In] The DkmModule class represents a code bundle (ex: dll or exe) which is or
        /// once was loaded into one or more processes. The DkmModule class is the central
        /// object to the symbol APIs, and is 1:1 with the symbol handler's notation of what
        /// is loaded. If a code bundle loads into three different processes (or the same
        /// process but with three different base addresses or three different app domains)
        /// but the symbol handler thinks of all of these as being identical, there will be
        /// only one module object.
        /// </param>
        /// <param name="InputTag">
        /// [In] Accelerator pointer tag found in symbols.
        /// </param>
        /// <param name="Rva">
        /// [In] RVA to use for filtering; ignored if zero.
        /// </param>
        /// <param name="pRegisterType">
        /// [Out] HLSL register type.
        /// </param>
        /// <param name="pRegisterIndex">
        /// [Out] HLSL register index.
        /// </param>
        /// <param name="pFirstElement">
        /// [Out] Index of first vector element.
        /// </param>
        /// <param name="pVectorElements">
        /// [Out] Number of vector elements.
        /// </param>
        /// <param name="pByteOffset">
        /// [Out] Offset in bytes.
        /// </param>
        /// <param name="pVectorElementSize">
        /// [Out] Size of each vector element.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE TranslateAcceleratorTagByRva(
            _In_ Symbols::DkmModule* pModule,
            _In_ UINT32 InputTag,
            _In_ UINT32 Rva,
            _Out_ UINT32* pRegisterType,
            _Out_ UINT32* pRegisterIndex,
            _Out_ UINT32* pFirstElement,
            _Out_ UINT32* pVectorElements,
            _Out_ UINT32* pByteOffset,
            _Out_ UINT32* pVectorElementSize
            ) = 0;

        /// <summary>
        /// Verify if the accelerator pointer tag is valid.
        /// </summary>
        /// <param name="pModule">
        /// [In] The DkmModule class represents a code bundle (ex: dll or exe) which is or
        /// once was loaded into one or more processes. The DkmModule class is the central
        /// object to the symbol APIs, and is 1:1 with the symbol handler's notation of what
        /// is loaded. If a code bundle loads into three different processes (or the same
        /// process but with three different base addresses or three different app domains)
        /// but the symbol handler thinks of all of these as being identical, there will be
        /// only one module object.
        /// </param>
        /// <param name="InputTag">
        /// [In] Accelerator pointer tag found in symbols.
        /// </param>
        /// <param name="Rva">
        /// [In] RVA to use for filtering; ignored if zero.
        /// </param>
        /// <param name="pIsValid">
        /// [Out] True if the given accelerator tag is valid at the given RVA.  If RVA is
        /// zero, checks if the tag is valid anywhere including as a dynamically created tag.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE IsValidAcceleratorTag(
            _In_ Symbols::DkmModule* pModule,
            _In_ UINT32 InputTag,
            _In_ UINT32 Rva,
            _Out_ bool* pIsValid
            ) = 0;

        /// <summary>
        /// Gets a C++ AMP address for a register.
        /// </summary>
        /// <param name="pModule">
        /// [In] The DkmModule class represents a code bundle (ex: dll or exe) which is or
        /// once was loaded into one or more processes. The DkmModule class is the central
        /// object to the symbol APIs, and is 1:1 with the symbol handler's notation of what
        /// is loaded. If a code bundle loads into three different processes (or the same
        /// process but with three different base addresses or three different app domains)
        /// but the symbol handler thinks of all of these as being identical, there will be
        /// only one module object.
        /// </param>
        /// <param name="RegisterType">
        /// [In] Type of HLSL register.
        /// </param>
        /// <param name="RegisterIndex">
        /// [In] Index of HLSL register.
        /// </param>
        /// <param name="FirstElement">
        /// [In] Index of first vector element.
        /// </param>
        /// <param name="VectorElements">
        /// [In] Number of vector elements.
        /// </param>
        /// <param name="ByteOffset">
        /// [In] Offset from beginning of register.
        /// </param>
        /// <param name="VectorElementSize">
        /// [In] Size of vector element.
        /// </param>
        /// <param name="Rva">
        /// [In] RVA to use for mapping register information and tag address.
        /// </param>
        /// <param name="StartLiveRange">
        /// [In] Start of live range for the symbol.
        /// </param>
        /// <param name="EndLiveRange">
        /// [In] End of live range for the symbol.
        /// </param>
        /// <param name="pAddress">
        /// [Out] Address for register.
        /// </param>
        /// <param name="pIsNewDynamicTag">
        /// [Out] Is the address newly generated using dynamic tag.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE GetPointerToHLSLRegister(
            _In_ Symbols::DkmModule* pModule,
            _In_ CV_HREG_e RegisterType,
            _In_ UINT32 RegisterIndex,
            _In_ UINT32 FirstElement,
            _In_ UINT32 VectorElements,
            _In_ UINT32 ByteOffset,
            _In_ UINT32 VectorElementSize,
            _In_ UINT32 Rva,
            _In_ UINT32 StartLiveRange,
            _In_ UINT32 EndLiveRange,
            _Out_ UINT64* pAddress,
            _Out_ bool* pIsNewDynamicTag
            ) = 0;

        /// <summary>
        /// Sets a C++ AMP address for a register.
        /// </summary>
        /// <param name="pModule">
        /// [In] The DkmModule class represents a code bundle (ex: dll or exe) which is or
        /// once was loaded into one or more processes. The DkmModule class is the central
        /// object to the symbol APIs, and is 1:1 with the symbol handler's notation of what
        /// is loaded. If a code bundle loads into three different processes (or the same
        /// process but with three different base addresses or three different app domains)
        /// but the symbol handler thinks of all of these as being identical, there will be
        /// only one module object.
        /// </param>
        /// <param name="Address">
        /// [In] Address for register.
        /// </param>
        /// <param name="RegisterType">
        /// [In] Type of HLSL register.
        /// </param>
        /// <param name="RegisterIndex">
        /// [In] Index of HLSL register.
        /// </param>
        /// <param name="FirstElement">
        /// [In] Index of first vector element.
        /// </param>
        /// <param name="VectorElements">
        /// [In] Number of vector elements.
        /// </param>
        /// <param name="ByteOffset">
        /// [In] Offset from beginning of register.
        /// </param>
        /// <param name="VectorElementSize">
        /// [In] Size of vector element.
        /// </param>
        /// <param name="StartLiveRange">
        /// [In] Start of live range for the symbol.
        /// </param>
        /// <param name="EndLiveRange">
        /// [In] End of live range for the symbol.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE SetPointerToHLSLRegister(
            _In_ Symbols::DkmModule* pModule,
            _In_ UINT64 Address,
            _In_ CV_HREG_e RegisterType,
            _In_ UINT32 RegisterIndex,
            _In_ UINT32 FirstElement,
            _In_ UINT32 VectorElements,
            _In_ UINT32 ByteOffset,
            _In_ UINT32 VectorElementSize,
            _In_ UINT32 StartLiveRange,
            _In_ UINT32 EndLiveRange
            ) = 0;

        /// <summary>
        /// Gets a C++ AMP address for a register.
        /// </summary>
        /// <param name="pModule">
        /// [In] The DkmModule class represents a code bundle (ex: dll or exe) which is or
        /// once was loaded into one or more processes. The DkmModule class is the central
        /// object to the symbol APIs, and is 1:1 with the symbol handler's notation of what
        /// is loaded. If a code bundle loads into three different processes (or the same
        /// process but with three different base addresses or three different app domains)
        /// but the symbol handler thinks of all of these as being identical, there will be
        /// only one module object.
        /// </param>
        /// <param name="pSize">
        /// [Out] Maximum tag value found in actual C++ AMP pointers plus one.
        /// </param>
        /// <param name="pSizeOfForwardedTags">
        /// [Out] Maximum tag value that may be subject to buffer forwarding plus one.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE GetAcceleratorTagTableSize(
            _In_ Symbols::DkmModule* pModule,
            _Out_ UINT32* pSize,
            _Out_ UINT32* pSizeOfForwardedTags
            ) = 0;

        /// <summary>
        /// GetInstructionOffsetForRva is used by components to query symbol provider to
        /// perform instruction offset and RVA translation for DPC++.
        /// </summary>
        /// <param name="pModule">
        /// [In] The DkmModule class represents a code bundle (ex: dll or exe) which is or
        /// once was loaded into one or more processes. The DkmModule class is the central
        /// object to the symbol APIs, and is 1:1 with the symbol handler's notation of what
        /// is loaded. If a code bundle loads into three different processes (or the same
        /// process but with three different base addresses or three different app domains)
        /// but the symbol handler thinks of all of these as being identical, there will be
        /// only one module object.
        /// </param>
        /// <param name="RVA">
        /// [In] The RVA within a module.
        /// </param>
        /// <param name="pInstructionOffset">
        /// [Out] The instruction offset from stub function.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE GetInstructionOffsetForRva(
            _In_ Symbols::DkmModule* pModule,
            _In_ UINT32 RVA,
            _Out_ UINT32* pInstructionOffset
            ) = 0;
    };

    // Allows remote components to obtain source position information for DPC++ when the
    // symbol provider is on the VS machine.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // RuntimeId, SymbolProviderId.
    #define IID_IDkmGPUSymbolQueryCallback __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmGPUSymbolQueryCallback)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("52865d52-5245-7027-62c1-9e2f652923fc") IDkmGPUSymbolQueryCallback : public IUnknown
    {
        /// <summary>
        /// Returns the source file position (ex: example.cs, line 12) of this instruction
        /// symbol. If this instruction symbol is not associated with a source file or not in
        /// user code then null is returned (E_INSTRUCTION_NO_SOURCE return code).
        /// </summary>
        /// <param name="pInstruction">
        /// [In] DkmInstructionSymbol represents a method in the target process.
        /// </param>
        /// <param name="pInspectionSession">
        /// [In,Optional] A reference object describing the current inspection session.
        /// Common usage is for symbol providers to cache lookups using its data container.
        /// </param>
        /// <param name="ppSourcePosition">
        /// [Out,Optional] Source code position which corresponds to a code element. The
        /// could represent a location which has been extracted from a symbol (PDB) file, or
        /// it could be the location of a breakpoint in the IDE.
        /// </param>
        /// <returns>
        /// S_OK is returned if *ppSourcePosition is non-NULL, S_FALSE is returned when
        /// *ppSourcePosition is NULL, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE GetUserCodeSourcePositionCallback(
            _In_ Symbols::DkmInstructionSymbol* pInstruction,
            _In_opt_ Evaluation::DkmInspectionSession* pInspectionSession,
            _Deref_out_opt_ Symbols::DkmSourcePosition** ppSourcePosition
            ) = 0;
    };

    // Interface implemented by GPU base debug monitors to enable temporary instruction
    // breakpoints in stepping. The temporary instruction breakpoints are passed to
    // ContinueDebugEvent.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // BaseDebugMonitorId, EngineId, SourceId.
    #define IID_IDkmGPUTempBreakStepper __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmGPUTempBreakStepper)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("18ce801c-c0ae-8b7f-d688-500517cd84b2") IDkmGPUTempBreakStepper : public IUnknown
    {
        /// <summary>
        /// Enable temporary breakpoint in stepping on a thread. This is similar to single
        /// step except one or more instructions are advanced. When breakpoint is hit, step
        /// complete event is sent.
        /// </summary>
        /// <param name="pSingleStepRequest">
        /// [In] DkmSingleStepRequest represents a request to single step a thread.
        /// </param>
        /// <param name="TempBreakInstructions">
        /// [In] The instruction offset of temporary breakpoints to set.
        ///
        /// The memory for the DkmArray members is allocated by the caller, and can be from
        /// any source (stack memory, static buffer, heap, etc). The implementation should
        /// not modify the members.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE EnableTempBreak(
            _In_ Stepping::DkmSingleStepRequest* pSingleStepRequest,
            _In_ const DkmArray<UINT64>& TempBreakInstructions
            ) = 0;

        /// <summary>
        /// Clear temporary breakpoint in stepping on a thread.
        /// </summary>
        /// <param name="pSingleStepRequest">
        /// [In] DkmSingleStepRequest represents a request to single step a thread.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE ClearTempBreak(
            _In_ Stepping::DkmSingleStepRequest* pSingleStepRequest
            ) = 0;
    };

    // Interface implemented by base debug monitors which read symbols from debuggee's memory
    // at runtime. This interface would be implemented by base debug monitors to deal with
    // symbol formats which are generated or loaded at runtime in the debuggee's memory.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // BaseDebugMonitorId, EngineId, RuntimeId, SymbolProviderId, TransportKind.
    #define IID_IDkmSymbolMemoryReader __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmSymbolMemoryReader)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("1605c794-5589-65c7-49da-5b1f767678af") IDkmSymbolMemoryReader : public IUnknown
    {
        /// <summary>
        /// This method is invoked by symbol handlers to read symbols for DkmModuleInstances
        /// whose symbols reside in debuggee's memory.
        /// </summary>
        /// <param name="pModuleInstance">
        /// [In] The Module Instance class represent a code bundle (ex: dll or exe) which is
        /// loaded into a particular process at a particular location. Module Instance
        /// objects are 1:1 with the execution environment's notion of a code bundle. For
        /// example, in native code, Module Instance objects are 1:1 with base address.
        /// </param>
        /// <param name="ppSymbolBuffer">
        /// [Out,Optional] The symbol buffer that is read from debuggee's memory at runtime.
        /// </param>
        /// <returns>
        /// S_OK is returned if *ppSymbolBuffer is non-NULL, S_FALSE is returned when
        /// *ppSymbolBuffer is NULL, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE ReadSymbols(
            _In_ DkmModuleInstance* pModuleInstance,
            _Deref_out_opt_ DkmReadOnlyCollection<BYTE>** ppSymbolBuffer
            ) = 0;
    };

}; // end of GPU component interfaces


// Script Document Manager interfaces
// Interfaces implemented by components that create DkmScriptDocument objects.
namespace ComponentInterfaces
{
    // Implemented by components which create DkmScriptDocument objects in order to provide
    // document content and notifications when the content changes.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // BaseDebugMonitorId, EngineId, RuntimeId, SymbolProviderId.
    #define IID_IDkmScriptDocumentProvider __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmScriptDocumentProvider)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("101af814-9a31-dfdb-1df5-d6b7299b3ef7") IDkmScriptDocumentProvider : public IUnknown
    {
        /// <summary>
        /// Provides the current content of the specified document object.
        /// </summary>
        /// <param name="pScriptDocument">
        /// [In] Represents a document which is executing in a script runtime environment.
        /// For example, the Microsoft JavaScript engine.
        /// </param>
        /// <param name="EnableContentEvents">
        /// [In] If true, the script document provider should raise events when the content
        /// of this document changes. Passing true is equivalent to calling
        /// SetRaiseContentEvents(true). If false, the RaiseContentEvent state remains the
        /// same.
        /// </param>
        /// <param name="ppContent">
        /// [Out] The current content of this document.
        /// </param>
        /// <param name="pSectionDividers">
        /// [Out] For aggregate documents (DkmScriptDocumentFlags.AggregateDocument is set),
        /// this is the 1-based line numbers for where the section dividers should be drawn.
        /// For standard documents, an empty array is returned.
        ///
        /// The memory for the DkmArray members is allocated by the method implementation
        /// using DkmAllocBytes/DkmAllocArray. It is freed by the caller using the
        /// CAutoDkmArray template or with DkmFreeMemory and manual element release.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE GetContent(
            _In_ Script::DkmScriptDocument* pScriptDocument,
            _In_ bool EnableContentEvents,
            _Deref_out_ DkmString** ppContent,
            _Out_ DkmArray<UINT32>* pSectionDividers
            ) = 0;

        /// <summary>
        /// Enables or disables raising events when the content of the document is changed.
        /// By default, documents do not generate content events. So this method should be
        /// called by any component that wishes to receive content events. The script
        /// document manager maintains a count of the number of calls to enable content
        /// events, and will raise events whenever this count is greater than 0. Callers
        /// should take care to ensure that SetRaiseContentEvents(false) is called ONLY after
        /// a successful call to SetRaiseContentEvents(true). Content events are
        /// automatically disabled when the document is unloaded.
        /// </summary>
        /// <param name="pScriptDocument">
        /// [In] Represents a document which is executing in a script runtime environment.
        /// For example, the Microsoft JavaScript engine.
        /// </param>
        /// <param name="Enable">
        /// [In] If true, content events should be enabled for this document. If false, the
        /// count of content event listeners is decremented. When the count reaches zero, no
        /// further events will be sent.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE SetRaiseContentEvents(
            _In_ Script::DkmScriptDocument* pScriptDocument,
            _In_ bool Enable
            ) = 0;
    };

    // API implemented by the script local agent to match script documents against breakpoint
    // requests.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // BaseDebugMonitorId, EngineId, RuntimeId, SymbolProviderId.
    #define IID_IDkmScriptDocumentQuery __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmScriptDocumentQuery)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("ec355278-62b4-d986-e384-28c7442b1b2f") IDkmScriptDocumentQuery : public IUnknown
    {
        /// <summary>
        /// This method is called when a script document is created or when the project item
        /// path is set to try and bind breakpoints against the given script document.
        /// </summary>
        /// <param name="pScriptDocument">
        /// [In] Represents a document which is executing in a script runtime environment.
        /// For example, the Microsoft JavaScript engine.
        /// </param>
        /// <param name="pSourceFileId">
        /// [In] Identifies a source file and provides the information which a symbol handler
        /// could use to search a symbol file (PDB) for information on this source file.
        /// </param>
        /// <param name="ppResolvedDocument">
        /// [Out,Optional] If the given script document matches the given source file id,
        /// this returns a DkmResolvedDocument for the match. Otherwise, null is returned.
        /// </param>
        /// <returns>
        /// S_OK is returned if *ppResolvedDocument is non-NULL, S_FALSE is returned when
        /// *ppResolvedDocument is NULL, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE TryResolve(
            _In_ Script::DkmScriptDocument* pScriptDocument,
            _In_ Symbols::DkmSourceFileId* pSourceFileId,
            _Deref_out_opt_ Symbols::DkmResolvedDocument** ppResolvedDocument
            ) = 0;
    };

    // Implemented by components which create DkmScriptDocument objects, and use them as the
    // basis of symbol resolution. This interface doesn't need to be implemented by script
    // document system which leave DkmResolvedDocument.ScriptDocument as null.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // BaseDebugMonitorId, EngineId, RuntimeId, SymbolProviderId.
    #define IID_IDkmScriptDocumentSymbolProvider __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmScriptDocumentSymbolProvider)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("4b084d09-68a5-af61-49d0-e47525eb163c") IDkmScriptDocumentSymbolProvider : public IUnknown
    {
        /// <summary>
        /// Enables or disables raising ScriptSymbolsUpdated when symbols in the document are
        /// changed. By default, documents do not generate symbol events. So this method
        /// should be called by any component that wishes to receive symbol events. The
        /// script document manager maintains a count of the number of calls to enable symbol
        /// events, and will raise events whenever this count is greater than 0. Callers
        /// should take care to ensure that SetRaiseSymbolEvents(false) is called ONLY after
        /// a successful call to SetRaiseSymbolEvents(true). Symbol events are automatically
        /// disabled when the document is unloaded.
        /// </summary>
        /// <param name="pScriptDocument">
        /// [In] Represents a document which is executing in a script runtime environment.
        /// For example, the Microsoft JavaScript engine.
        /// </param>
        /// <param name="Enable">
        /// [In] If true, symbol events should be enabled for this document. If false, the
        /// count of symbol event listeners is decremented. When the count reaches zero, no
        /// further events will be sent.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE SetRaiseSymbolEvents(
            _In_ Script::DkmScriptDocument* pScriptDocument,
            _In_ bool Enable
            ) = 0;
    };

}; // end of Script Document Manager interfaces


// Task providers interfaces
// Components that can decode the data structures of a parallel task API running in the
// target process.
namespace ComponentInterfaces
{
    // Walk async call stack and task creation stacks.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // EngineId, RuntimeId, TaskProviderId.
    //
    // This API was introduced in Visual Studio 12 RTM (DkmApiVersion.VS12RTM).
    #define IID_IDkmAsyncTaskDecoder __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmAsyncTaskDecoder)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("a666d01b-4bad-179a-7f02-2ec334fac1dd") IDkmAsyncTaskDecoder : public IUnknown
    {
        /// <summary>
        /// Gets the logged creation stack of this task.
        /// </summary>
        /// <param name="pAsyncStackWalkContext">
        /// [In] Provides a context for walking async return stacks and task creation stacks.
        /// </param>
        /// <param name="pWorkList">
        /// WorkList which is currently being processed. This value can be used to check for
        /// cancelation or to append additional work. New work items will not begin executing
        /// until after this function returns.
        /// </param>
        /// <param name="pThread">
        /// [In] The thread that the resultant frames should belong to.
        /// </param>
        /// <param name="pCompletionRoutine">
        /// Routine to fire when the request is complete. This will be implicitly fired if
        /// the implementation returns failure from this interface method. The implementation
        /// must fire this method in all other scenarios.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE GetTaskCreationStack(
            _In_ CallStack::DkmAsyncStackWalkContext* pAsyncStackWalkContext,
            _In_ DkmWorkList* pWorkList,
            _In_ DkmThread* pThread,
            _In_ IDkmCompletionRoutine<CallStack::DkmGetTaskCreationStackAsyncResult>* pCompletionRoutine
            ) = 0;

        /// <summary>
        /// Returns a list of frames that will execute when this task completes.  The order
        /// that the frames will execute in is arbitrary and might not be the order returned
        /// here.  Only frames that will execute as a direct result of this task are
        /// included, not frames that will execute as a result of another task that will
        /// execute after this task completes.
        /// </summary>
        /// <param name="pAsyncStackWalkContext">
        /// [In] Provides a context for walking async return stacks and task creation stacks.
        /// </param>
        /// <param name="pWorkList">
        /// WorkList which is currently being processed. This value can be used to check for
        /// cancelation or to append additional work. New work items will not begin executing
        /// until after this function returns.
        /// </param>
        /// <param name="pThread">
        /// [In] The thread that the resultant frames should belong to.
        /// </param>
        /// <param name="pCompletionRoutine">
        /// Routine to fire when the request is complete. This will be implicitly fired if
        /// the implementation returns failure from this interface method. The implementation
        /// must fire this method in all other scenarios.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE GetTaskContinuationFrames(
            _In_ CallStack::DkmAsyncStackWalkContext* pAsyncStackWalkContext,
            _In_ DkmWorkList* pWorkList,
            _In_ DkmThread* pThread,
            _In_ IDkmCompletionRoutine<CallStack::DkmGetTaskContinuationFramesAsyncResult>* pCompletionRoutine
            ) = 0;

        /// <summary>
        /// Gets the async call stack of this thread.
        /// </summary>
        /// <param name="pAsyncStackWalkContext">
        /// [In] Provides a context for walking async return stacks and task creation stacks.
        /// </param>
        /// <param name="pWorkList">
        /// WorkList which is currently being processed. This value can be used to check for
        /// cancelation or to append additional work. New work items will not begin executing
        /// until after this function returns.
        /// </param>
        /// <param name="pThread">
        /// [In] The thread that the resultant frames should belong to.
        /// </param>
        /// <param name="pCompletionRoutine">
        /// Routine to fire when the request is complete. This will be implicitly fired if
        /// the implementation returns failure from this interface method. The implementation
        /// must fire this method in all other scenarios.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE GetAsyncCallStack(
            _In_ CallStack::DkmAsyncStackWalkContext* pAsyncStackWalkContext,
            _In_ DkmWorkList* pWorkList,
            _In_ DkmThread* pThread,
            _In_ IDkmCompletionRoutine<CallStack::DkmGetAsyncCallStackAsyncResult>* pCompletionRoutine
            ) = 0;
    };

    // Interface implemented by the task provider component to obtain information about
    // tasks. This interface is subject to change in future versions of Visual Studio.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // BaseDebugMonitorId, EngineId, TaskProviderId.
    #define IID_IDkmTaskProvider __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmTaskProvider)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("dab4a095-1346-8117-18b5-0586e1fe5852") IDkmTaskProvider : public IUnknown
    {
        /// <summary>
        /// Enumerates the current set of tasks running in the target process.
        /// </summary>
        /// <param name="pTaskProvider">
        /// [In] Represents a task provider which is loaded into the target process.
        /// </param>
        /// <param name="IsRoot">
        /// [In] TODO.
        /// </param>
        /// <param name="RequestCount">
        /// [In] Count of tasks requested.
        /// </param>
        /// <param name="pScheduledTaskCount">
        /// [Out] Number of scheduled tasks.
        /// </param>
        /// <param name="pItems">
        /// [Out] Array contained the found tasks.
        ///
        /// The memory for the DkmArray members is allocated by the method implementation
        /// using DkmAllocBytes/DkmAllocArray. It is freed by the caller using the
        /// CAutoDkmArray template or with DkmFreeMemory and manual element release.
        /// </param>
        /// <param name="pTaskEnumFlags">
        /// [Out] TODO.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE GetTasks(
            _In_ ParallelTasks::DkmTaskProvider* pTaskProvider,
            _In_ bool IsRoot,
            _In_ UINT32 RequestCount,
            _Out_ UINT32* pScheduledTaskCount,
            _Out_ DkmArray<ParallelTasks::DkmTask*>* pItems,
            _Out_ UINT32* pTaskEnumFlags
            ) = 0;

        /// <summary>
        /// TODO.
        /// </summary>
        /// <param name="pTaskProvider">
        /// [In] Represents a task provider which is loaded into the target process.
        /// </param>
        /// <param name="pNames">
        /// [Out] TODO.
        ///
        /// The memory for the DkmArray members is allocated by the method implementation
        /// using DkmAllocBytes/DkmAllocArray. It is freed by the caller using the
        /// CAutoDkmArray template or with DkmFreeMemory and manual element release.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE GetPropertyNames(
            _In_ ParallelTasks::DkmTaskProvider* pTaskProvider,
            _Out_ DkmArray<DkmString*>* pNames
            ) = 0;

        /// <summary>
        /// Returns children tasks.
        /// </summary>
        /// <param name="pTask">
        /// [In] Represents either a managed TPL task or a native Concurrency Runtime task.
        /// </param>
        /// <param name="pItems">
        /// [Out] TODO.
        ///
        /// The memory for the DkmArray members is allocated by the method implementation
        /// using DkmAllocBytes/DkmAllocArray. It is freed by the caller using the
        /// CAutoDkmArray template or with DkmFreeMemory and manual element release.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE GetChildTasks(
            _In_ ParallelTasks::DkmTask* pTask,
            _Out_ DkmArray<ParallelTasks::DkmTask*>* pItems
            ) = 0;

        /// <summary>
        /// Returns task properties.
        /// </summary>
        /// <param name="pTask">
        /// [In] Represents either a managed TPL task or a native Concurrency Runtime task.
        /// </param>
        /// <param name="Radix">
        /// [In] TODO.
        /// </param>
        /// <param name="Fields">
        /// [In] TODO.
        /// </param>
        /// <param name="pProperties">
        /// [Out] TODO.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE GetTaskProperties(
            _In_ ParallelTasks::DkmTask* pTask,
            _In_ UINT32 Radix,
            _In_ UINT32 Fields,
            _Out_ ParallelTasks::DkmTaskProperties* pProperties
            ) = 0;
    };

    // Optional interface implemented by task providers to receive a notification when task
    // providers are first requested for a particular process. This interface is subject to
    // change in future versions of Visual Studio.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // BaseDebugMonitorId, EngineId, TransportKind.
    #define IID_IDkmTaskProviderInitialize __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmTaskProviderInitialize)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("28e075cf-d77d-e3a7-3360-6e4df64e541c") IDkmTaskProviderInitialize : public IUnknown
    {
        /// <summary>
        /// Invoked by the AD7 AL to provide a notification when task providers are first
        /// requested from the UI for a particular process. This allows implementations to
        /// delay initialization to when the task UI if first shown.
        /// </summary>
        /// <param name="pProcess">
        /// [In] DkmProcess represents a target process which is being debugged. The debugger
        /// debugs processes, so this is the basic unit of debugging. A DkmProcess can
        /// represent a system process or a virtual process such as minidumps.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE InitializeTaskProviders(
            _In_ DkmProcess* pProcess
            ) = 0;
    };

    // Interface implemented by task provider components to provide the set of
    // synchronization objects owned by a task. This interface is subject to change in future
    // versions of Visual Studio.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // BaseDebugMonitorId, EngineId, TaskProviderId.
    #define IID_IDkmTaskSynchronizationObjectProvider __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmTaskSynchronizationObjectProvider)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("5b455d6f-d085-6c84-9949-ab7dc0d1204e") IDkmTaskSynchronizationObjectProvider : public IUnknown
    {
        /// <summary>
        /// TODO.
        /// </summary>
        /// <param name="pTask">
        /// [In] Represents either a managed TPL task or a native Concurrency Runtime task.
        /// </param>
        /// <param name="pItems">
        /// [Out] TODO.
        ///
        /// The memory for the DkmArray members is allocated by the method implementation
        /// using DkmAllocBytes/DkmAllocArray. It is freed by the caller using the
        /// CAutoDkmArray template or with DkmFreeMemory and manual element release.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE GetSynchronizationObjects(
            _In_ ParallelTasks::DkmTask* pTask,
            _Out_ DkmArray<ParallelTasks::DkmTaskSynchronizationObject*>* pItems
            ) = 0;
    };

}; // end of Task providers interfaces


// Native edit and continue engines interfaces
// Components that provide edit and continue support for native language.
namespace ComponentInterfaces
{
    // Interface implemented by edit and continue engine to support status query service.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // RuntimeId, SymbolProviderId.
    //
    // This API was introduced in Visual Studio 14 RTM (DkmApiVersion.VS14RTM).
    #define IID_IDkmEditAndContinueService __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmEditAndContinueService)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("a2520263-e612-24cf-b02f-640bc260db16") IDkmEditAndContinueService : public IUnknown
    {
        /// <summary>
        /// Check if the address is in stale code or not.
        /// </summary>
        /// <param name="pInstruction">
        /// [In] DkmInstructionSymbol represents a method in the target process.
        /// </param>
        /// <param name="pModule">
        /// [In] The owning module instance of the checking address.
        /// </param>
        /// <param name="IsLeafFrame">
        /// [In] Specify if this address belongs to leaf frame or not.
        /// </param>
        /// <param name="pIsStale">
        /// [Out] True if address is in stale code, False otherwise.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE IsStaleCode(
            _In_ Symbols::DkmInstructionSymbol* pInstruction,
            _In_ DkmModuleInstance* pModule,
            _In_ bool IsLeafFrame,
            _Out_ bool* pIsStale
            ) = 0;
    };

    // Interface implemented by native edit and continue engine to provide apply pending code
    // change, validation and commit.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // BaseDebugMonitorId, EngineId, RuntimeId, TransportKind.
    //
    // This API was introduced in Visual Studio 14 RTM (DkmApiVersion.VS14RTM).
    #define IID_IDkmNativeEditAndContinueUpdate __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmNativeEditAndContinueUpdate)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("372d0735-e3a6-1019-498b-33514320d86e") IDkmNativeEditAndContinueUpdate : public IUnknown
    {
        /// <summary>
        /// Validate and merge code/symbols for the previous added pending edit compiland.
        /// Note: All the code/symbols merging are pending in memory and no debuggee is
        /// modified until Commit() is called.
        /// </summary>
        /// <param name="pNativeRuntimeInstance">
        /// [In] Represents the native code executing in a target process.
        /// </param>
        /// <param name="ModifiedStackIPAddresses">
        /// [In] The IPs of the stack frames that have been modified. Required to use the
        /// line hints for IP remapping.
        ///
        /// The memory for the DkmArray members is allocated by the caller, and can be from
        /// any source (stack memory, static buffer, heap, etc). The implementation should
        /// not modify the members.
        /// </param>
        /// <param name="LineHints">
        /// [In] The 1-based source line number hints for the edited stack IPs.
        ///
        /// The memory for the DkmArray members is allocated by the caller, and can be from
        /// any source (stack memory, static buffer, heap, etc). The implementation should
        /// not modify the members.
        /// </param>
        /// <param name="ppWarnings">
        /// [Out,Optional] Warning messages, if any.
        /// </param>
        /// <param name="ppErrors">
        /// [Out,Optional] Error messages, if any.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE ApplyCodeChange(
            _In_ Native::DkmNativeRuntimeInstance* pNativeRuntimeInstance,
            _In_ const DkmArray<Native::DkmNativeInstructionAddress*>& ModifiedStackIPAddresses,
            _In_ const DkmArray<UINT32>& LineHints,
            _Deref_out_opt_ DkmReadOnlyCollection<DkmString*>** ppWarnings,
            _Deref_out_opt_ DkmReadOnlyCollection<DkmString*>** ppErrors
            ) = 0;

        /// <summary>
        /// Commit all the pending in-memory edit to debuggee.
        /// </summary>
        /// <param name="pNativeRuntimeInstance">
        /// [In] Represents the native code executing in a target process.
        /// </param>
        /// <param name="ppWarnings">
        /// [Out,Optional] Warning messages, if any.
        /// </param>
        /// <param name="ppErrors">
        /// [Out,Optional] Error messages, if any.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE CommitCodeChange(
            _In_ Native::DkmNativeRuntimeInstance* pNativeRuntimeInstance,
            _Deref_out_opt_ DkmReadOnlyCollection<DkmString*>** ppWarnings,
            _Deref_out_opt_ DkmReadOnlyCollection<DkmString*>** ppErrors
            ) = 0;
    };

}; // end of Native edit and continue engines interfaces


// Performance monitors interfaces
// Components that provide timing information about a debuggee.
namespace ComponentInterfaces
{
    // Interface used to gather performance data from the debuggee.
    //
    // Implementations of this interface may restrict when they are called using a filter
    // defined in their component configuration. The following properties may be used:
    // BaseDebugMonitorId, EngineId, TransportKind.
    //
    // This API was introduced in Visual Studio 14 RTM (DkmApiVersion.VS14RTM).
    #define IID_IDkmPerformanceMeasurement140 __uuidof(Microsoft::VisualStudio::Debugger::ComponentInterfaces::IDkmPerformanceMeasurement140)
    interface DECLSPEC_NOVTABLE DECLSPEC_UUID("baa4631d-a350-a100-18b4-27bbb4afe0f6") IDkmPerformanceMeasurement140 : public IUnknown
    {
        /// <summary>
        /// Asynchronous Method to obtain the timing data from the
        /// IDkmPerformanceMeasurementDispatcherService gathered from events emitted by the
        /// runtimes in the process. This is called asynchronously because obtaining the
        /// debugger overhead can be very expensive.
        /// </summary>
        /// <param name="pProcess">
        /// [In] DkmProcess represents a target process which is being debugged. The debugger
        /// debugs processes, so this is the basic unit of debugging. A DkmProcess can
        /// represent a system process or a virtual process such as minidumps.
        /// </param>
        /// <param name="pWorkList">
        /// WorkList which is currently being processed. This value can be used to check for
        /// cancelation or to append additional work. New work items will not begin executing
        /// until after this function returns.
        /// </param>
        /// <param name="pCompletionRoutine">
        /// Routine to fire when the request is complete. This will be implicitly fired if
        /// the implementation returns failure from this interface method. The implementation
        /// must fire this method in all other scenarios.
        /// </param>
        /// <returns>
        /// S_OK is returned on success, and failure codes are used for any error.
        /// </returns>
        virtual HRESULT STDMETHODCALLTYPE QueryPerformanceCounters(
            _In_ DkmProcess* pProcess,
            _In_ DkmWorkList* pWorkList,
            _In_ IDkmCompletionRoutine<DkmPerformanceCountersAsyncResult>* pCompletionRoutine
            ) = 0;
    };

}; // end of Performance monitors interfaces


// Collection element traits
struct DkmCollectionElementDescriptor
{
    const enum
    {
        NoDispose,
        IUnknownDispose,
        StructureDispose
    } DisposeKind;
    const DWORD Size;
    const GUID& Id;

    // **********************************************************************************
    // READ ME: DkmCollectionElementDescriptor
    // **********************************************************************************
    // DkmCollectionElementDescriptor describes an element in a collection.
    //
    // Errors in this class are caused by one of the following:
    // 1. Accidental declaration of a template on an interface (T=IUnknown) instead of
    // an interface pointer (T=IUnknown*)
    // 2. An attempt to declare a template on a type which is not defined in this header
    // file. DkmCollectionElementDescriptor is NOT general purpose and was designed to
    // only deal with types which are in this header file and interface pointers. It is
    // recommended to use a more general collection class in these cases, such as one
    // from the ATL or STL.
    // **********************************************************************************

    template <class T> explicit DkmCollectionElementDescriptor(const T*) :
        DisposeKind(IUnknownDispose),
        Size(sizeof(IUnknown*)),
        Id(__uuidof(T))
    {
        // *NOTE*: This function (the non-specialized version of the constructor). Is for
        //  interface pointers. The remainder of this function enforces the constraint
        // that 'T' is an interface pointer (ex: 'T'='IDispatch*'). See comment above.

        // Interface pointers are always the size of a pointer
        C_ASSERT(sizeof(T) == sizeof(IUnknown*));

        // Interface pointers can be implicitly converted to IUnknown
        IUnknown* implicit_cast_test = (T)0x00000004;

        // When interface pointers are converted to IUnknown, the compiler does not need
        // to apply a this adjustment
        if (implicit_cast_test != (IUnknown*)0x00000004)
        {
#ifdef _DEBUG
            __debugbreak();
#endif
        }
    }
};
template <> inline DkmCollectionElementDescriptor::DkmCollectionElementDescriptor(const DkmDataCreationDisposition_t*) :
    DisposeKind(NoDispose), Size(sizeof(DkmDataCreationDisposition_t)), Id(GUID_NULL)
{}
template <> inline DECLSPEC_NOTHROW void STDMETHODCALLTYPE DkmReleaseElement(DkmDataCreationDisposition_t& element)
{ /* no cleanup is necessary */ }
template <> inline DkmCollectionElementDescriptor::DkmCollectionElementDescriptor(const DkmDispatcherObjectFlags_t*) :
    DisposeKind(NoDispose), Size(sizeof(DkmDispatcherObjectFlags_t)), Id(GUID_NULL)
{}
template <> inline DECLSPEC_NOTHROW void STDMETHODCALLTYPE DkmReleaseElement(DkmDispatcherObjectFlags_t& element)
{ /* no cleanup is necessary */ }
template <> inline DkmCollectionElementDescriptor::DkmCollectionElementDescriptor(const DkmApiVersion_t*) :
    DisposeKind(NoDispose), Size(sizeof(DkmApiVersion_t)), Id(GUID_NULL)
{}
template <> inline DECLSPEC_NOTHROW void STDMETHODCALLTYPE DkmReleaseElement(DkmApiVersion_t& element)
{ /* no cleanup is necessary */ }
template <> inline DkmCollectionElementDescriptor::DkmCollectionElementDescriptor(const DkmEventCode_t*) :
    DisposeKind(NoDispose), Size(sizeof(DkmEventCode_t)), Id(GUID_NULL)
{}
template <> inline DECLSPEC_NOTHROW void STDMETHODCALLTYPE DkmReleaseElement(DkmEventCode_t& element)
{ /* no cleanup is necessary */ }
template <> inline DkmCollectionElementDescriptor::DkmCollectionElementDescriptor(const CV_HREG_e*) :
    DisposeKind(NoDispose), Size(sizeof(CV_HREG_e)), Id(GUID_NULL)
{}
template <> inline DECLSPEC_NOTHROW void STDMETHODCALLTYPE DkmReleaseElement(CV_HREG_e& element)
{ /* no cleanup is necessary */ }
template <> inline DkmCollectionElementDescriptor::DkmCollectionElementDescriptor(const UINT16*) :
    DisposeKind(NoDispose), Size(sizeof(UINT16)), Id(GUID_NULL)
{}
template <> inline DECLSPEC_NOTHROW void STDMETHODCALLTYPE DkmReleaseElement(UINT16& element)
{ /* no cleanup is necessary */ }
template <> inline DkmCollectionElementDescriptor::DkmCollectionElementDescriptor(const DkmXmm128*) :
    DisposeKind(NoDispose), Size(sizeof(DkmXmm128)), Id(GUID_NULL)
{}
template <> inline DECLSPEC_NOTHROW void STDMETHODCALLTYPE DkmReleaseElement(DkmXmm128& element)
{ /* no cleanup is necessary */ }
template <> inline DkmCollectionElementDescriptor::DkmCollectionElementDescriptor(const float*) :
    DisposeKind(NoDispose), Size(sizeof(float)), Id(GUID_NULL)
{}
template <> inline DECLSPEC_NOTHROW void STDMETHODCALLTYPE DkmReleaseElement(float& element)
{ /* no cleanup is necessary */ }
template <> inline DkmCollectionElementDescriptor::DkmCollectionElementDescriptor(const double*) :
    DisposeKind(NoDispose), Size(sizeof(double)), Id(GUID_NULL)
{}
template <> inline DECLSPEC_NOTHROW void STDMETHODCALLTYPE DkmReleaseElement(double& element)
{ /* no cleanup is necessary */ }
template <> inline DkmCollectionElementDescriptor::DkmCollectionElementDescriptor(const CorGCReferenceType*) :
    DisposeKind(NoDispose), Size(sizeof(CorGCReferenceType)), Id(GUID_NULL)
{}
template <> inline DECLSPEC_NOTHROW void STDMETHODCALLTYPE DkmReleaseElement(CorGCReferenceType& element)
{ /* no cleanup is necessary */ }
template <> inline DkmCollectionElementDescriptor::DkmCollectionElementDescriptor(const GUID*) :
    DisposeKind(NoDispose), Size(sizeof(GUID)), Id(GUID_NULL)
{}
template <> inline DECLSPEC_NOTHROW void STDMETHODCALLTYPE DkmReleaseElement(GUID& element)
{ /* no cleanup is necessary */ }
#ifdef WIN32
template <> inline DkmCollectionElementDescriptor::DkmCollectionElementDescriptor(const HRESULT*) :
    DisposeKind(NoDispose), Size(sizeof(HRESULT)), Id(GUID_NULL)
{}
template <> inline DECLSPEC_NOTHROW void STDMETHODCALLTYPE DkmReleaseElement(HRESULT& element)
{ /* no cleanup is necessary */ }
#endif // WIN32
template <> inline DkmCollectionElementDescriptor::DkmCollectionElementDescriptor(const INT32*) :
    DisposeKind(NoDispose), Size(sizeof(INT32)), Id(GUID_NULL)
{}
template <> inline DECLSPEC_NOTHROW void STDMETHODCALLTYPE DkmReleaseElement(INT32& element)
{ /* no cleanup is necessary */ }
template <> inline DkmCollectionElementDescriptor::DkmCollectionElementDescriptor(const INT64*) :
    DisposeKind(NoDispose), Size(sizeof(INT64)), Id(GUID_NULL)
{}
template <> inline DECLSPEC_NOTHROW void STDMETHODCALLTYPE DkmReleaseElement(INT64& element)
{ /* no cleanup is necessary */ }
template <> inline DkmCollectionElementDescriptor::DkmCollectionElementDescriptor(const UINT32*) :
    DisposeKind(NoDispose), Size(sizeof(UINT32)), Id(GUID_NULL)
{}
template <> inline DECLSPEC_NOTHROW void STDMETHODCALLTYPE DkmReleaseElement(UINT32& element)
{ /* no cleanup is necessary */ }
template <> inline DkmCollectionElementDescriptor::DkmCollectionElementDescriptor(const MINIDUMP_TYPE*) :
    DisposeKind(NoDispose), Size(sizeof(MINIDUMP_TYPE)), Id(GUID_NULL)
{}
template <> inline DECLSPEC_NOTHROW void STDMETHODCALLTYPE DkmReleaseElement(MINIDUMP_TYPE& element)
{ /* no cleanup is necessary */ }
template <> inline DkmCollectionElementDescriptor::DkmCollectionElementDescriptor(const LPCVOID*) :
    DisposeKind(NoDispose), Size(sizeof(LPCVOID)), Id(GUID_NULL)
{}
template <> inline DECLSPEC_NOTHROW void STDMETHODCALLTYPE DkmReleaseElement(LPCVOID& element)
{ /* no cleanup is necessary */ }
template <> inline DkmCollectionElementDescriptor::DkmCollectionElementDescriptor(const enum_TASKLOAD_FLAGS*) :
    DisposeKind(NoDispose), Size(sizeof(enum_TASKLOAD_FLAGS)), Id(GUID_NULL)
{}
template <> inline DECLSPEC_NOTHROW void STDMETHODCALLTYPE DkmReleaseElement(enum_TASKLOAD_FLAGS& element)
{ /* no cleanup is necessary */ }
template <> inline DkmCollectionElementDescriptor::DkmCollectionElementDescriptor(const enum_TASKPROPERTIES_FIELDS*) :
    DisposeKind(NoDispose), Size(sizeof(enum_TASKPROPERTIES_FIELDS)), Id(GUID_NULL)
{}
template <> inline DECLSPEC_NOTHROW void STDMETHODCALLTYPE DkmReleaseElement(enum_TASKPROPERTIES_FIELDS& element)
{ /* no cleanup is necessary */ }
template <> inline DkmCollectionElementDescriptor::DkmCollectionElementDescriptor(const enum_TASKPROPERTIES_FLAGS*) :
    DisposeKind(NoDispose), Size(sizeof(enum_TASKPROPERTIES_FLAGS)), Id(GUID_NULL)
{}
template <> inline DECLSPEC_NOTHROW void STDMETHODCALLTYPE DkmReleaseElement(enum_TASKPROPERTIES_FLAGS& element)
{ /* no cleanup is necessary */ }
template <> inline DkmCollectionElementDescriptor::DkmCollectionElementDescriptor(const enum_TASKSTATE_TYPE*) :
    DisposeKind(NoDispose), Size(sizeof(enum_TASKSTATE_TYPE)), Id(GUID_NULL)
{}
template <> inline DECLSPEC_NOTHROW void STDMETHODCALLTYPE DkmReleaseElement(enum_TASKSTATE_TYPE& element)
{ /* no cleanup is necessary */ }
template <> inline DkmCollectionElementDescriptor::DkmCollectionElementDescriptor(const UINT64*) :
    DisposeKind(NoDispose), Size(sizeof(UINT64)), Id(GUID_NULL)
{}
template <> inline DECLSPEC_NOTHROW void STDMETHODCALLTYPE DkmReleaseElement(UINT64& element)
{ /* no cleanup is necessary */ }
template <> inline DkmCollectionElementDescriptor::DkmCollectionElementDescriptor(const BYTE*) :
    DisposeKind(NoDispose), Size(sizeof(BYTE)), Id(GUID_NULL)
{}
template <> inline DECLSPEC_NOTHROW void STDMETHODCALLTYPE DkmReleaseElement(BYTE& element)
{ /* no cleanup is necessary */ }
template <> inline DkmCollectionElementDescriptor::DkmCollectionElementDescriptor(const FunctionResolution::DkmAddressSearchFlags_t*) :
    DisposeKind(NoDispose), Size(sizeof(FunctionResolution::DkmAddressSearchFlags_t)), Id(GUID_NULL)
{}
template <> inline DECLSPEC_NOTHROW void STDMETHODCALLTYPE DkmReleaseElement(FunctionResolution::DkmAddressSearchFlags_t& element)
{ /* no cleanup is necessary */ }
template <> inline DkmCollectionElementDescriptor::DkmCollectionElementDescriptor(const DkmAsyncBreakStatus_t*) :
    DisposeKind(NoDispose), Size(sizeof(DkmAsyncBreakStatus_t)), Id(GUID_NULL)
{}
template <> inline DECLSPEC_NOTHROW void STDMETHODCALLTYPE DkmReleaseElement(DkmAsyncBreakStatus_t& element)
{ /* no cleanup is necessary */ }
template <> inline DkmCollectionElementDescriptor::DkmCollectionElementDescriptor(const Breakpoints::DkmBreakpointConditionOperator_t*) :
    DisposeKind(NoDispose), Size(sizeof(Breakpoints::DkmBreakpointConditionOperator_t)), Id(GUID_NULL)
{}
template <> inline DECLSPEC_NOTHROW void STDMETHODCALLTYPE DkmReleaseElement(Breakpoints::DkmBreakpointConditionOperator_t& element)
{ /* no cleanup is necessary */ }
template <> inline DkmCollectionElementDescriptor::DkmCollectionElementDescriptor(const Breakpoints::DkmBreakpointHitCountConditionOperator_t*) :
    DisposeKind(NoDispose), Size(sizeof(Breakpoints::DkmBreakpointHitCountConditionOperator_t)), Id(GUID_NULL)
{}
template <> inline DECLSPEC_NOTHROW void STDMETHODCALLTYPE DkmReleaseElement(Breakpoints::DkmBreakpointHitCountConditionOperator_t& element)
{ /* no cleanup is necessary */ }
template <> inline DkmCollectionElementDescriptor::DkmCollectionElementDescriptor(const Breakpoints::DkmBreakpointMessageLevel_t*) :
    DisposeKind(NoDispose), Size(sizeof(Breakpoints::DkmBreakpointMessageLevel_t)), Id(GUID_NULL)
{}
template <> inline DECLSPEC_NOTHROW void STDMETHODCALLTYPE DkmReleaseElement(Breakpoints::DkmBreakpointMessageLevel_t& element)
{ /* no cleanup is necessary */ }
template <> inline DkmCollectionElementDescriptor::DkmCollectionElementDescriptor(const Breakpoints::DkmBreakpointUnboundReason_t*) :
    DisposeKind(NoDispose), Size(sizeof(Breakpoints::DkmBreakpointUnboundReason_t)), Id(GUID_NULL)
{}
template <> inline DECLSPEC_NOTHROW void STDMETHODCALLTYPE DkmReleaseElement(Breakpoints::DkmBreakpointUnboundReason_t& element)
{ /* no cleanup is necessary */ }
template <> inline DkmCollectionElementDescriptor::DkmCollectionElementDescriptor(const CallStack::DkmCallStackFilterOptions_t*) :
    DisposeKind(NoDispose), Size(sizeof(CallStack::DkmCallStackFilterOptions_t)), Id(GUID_NULL)
{}
template <> inline DECLSPEC_NOTHROW void STDMETHODCALLTYPE DkmReleaseElement(CallStack::DkmCallStackFilterOptions_t& element)
{ /* no cleanup is necessary */ }
template <> inline DkmCollectionElementDescriptor::DkmCollectionElementDescriptor(const Clr::DkmClrAsyncMethodLocation_t*) :
    DisposeKind(NoDispose), Size(sizeof(Clr::DkmClrAsyncMethodLocation_t)), Id(GUID_NULL)
{}
template <> inline DECLSPEC_NOTHROW void STDMETHODCALLTYPE DkmReleaseElement(Clr::DkmClrAsyncMethodLocation_t& element)
{ /* no cleanup is necessary */ }
template <> inline DkmCollectionElementDescriptor::DkmCollectionElementDescriptor(const Clr::DkmClrAwaitExpressionInfo*) :
    DisposeKind(NoDispose), Size(sizeof(Clr::DkmClrAwaitExpressionInfo)), Id(GUID_NULL)
{}
template <> inline DECLSPEC_NOTHROW void STDMETHODCALLTYPE DkmReleaseElement(Clr::DkmClrAwaitExpressionInfo& element)
{ /* no cleanup is necessary */ }
template <> inline DkmCollectionElementDescriptor::DkmCollectionElementDescriptor(const Clr::DkmClrDebuggingServicesId_t*) :
    DisposeKind(NoDispose), Size(sizeof(Clr::DkmClrDebuggingServicesId_t)), Id(GUID_NULL)
{}
template <> inline DECLSPEC_NOTHROW void STDMETHODCALLTYPE DkmReleaseElement(Clr::DkmClrDebuggingServicesId_t& element)
{ /* no cleanup is necessary */ }
template <> inline DkmCollectionElementDescriptor::DkmCollectionElementDescriptor(const Clr::DkmClrHeaderStatus_t*) :
    DisposeKind(NoDispose), Size(sizeof(Clr::DkmClrHeaderStatus_t)), Id(GUID_NULL)
{}
template <> inline DECLSPEC_NOTHROW void STDMETHODCALLTYPE DkmReleaseElement(Clr::DkmClrHeaderStatus_t& element)
{ /* no cleanup is necessary */ }
template <> inline DkmCollectionElementDescriptor::DkmCollectionElementDescriptor(const Clr::DkmClrMethodId*) :
    DisposeKind(NoDispose), Size(sizeof(Clr::DkmClrMethodId)), Id(GUID_NULL)
{}
template <> inline DECLSPEC_NOTHROW void STDMETHODCALLTYPE DkmReleaseElement(Clr::DkmClrMethodId& element)
{ /* no cleanup is necessary */ }
template <> inline DkmCollectionElementDescriptor::DkmCollectionElementDescriptor(const Clr::DkmClrMethodScopeData*) :
    DisposeKind(StructureDispose), Size(sizeof(Clr::DkmClrMethodScopeData)), Id(__uuidof(Clr::DkmClrMethodScopeData))
{}
template <> inline DECLSPEC_NOTHROW void STDMETHODCALLTYPE DkmReleaseElement(Clr::DkmClrMethodScopeData& element)
{
    return Clr::DkmClrMethodScopeData::Release(&element);
}
template <> inline DkmCollectionElementDescriptor::DkmCollectionElementDescriptor(const Clr::DkmClrModuleFlags_t*) :
    DisposeKind(NoDispose), Size(sizeof(Clr::DkmClrModuleFlags_t)), Id(GUID_NULL)
{}
template <> inline DECLSPEC_NOTHROW void STDMETHODCALLTYPE DkmReleaseElement(Clr::DkmClrModuleFlags_t& element)
{ /* no cleanup is necessary */ }
template <> inline DkmCollectionElementDescriptor::DkmCollectionElementDescriptor(const Clr::DkmClrNativeCodeMapEntry*) :
    DisposeKind(NoDispose), Size(sizeof(Clr::DkmClrNativeCodeMapEntry)), Id(GUID_NULL)
{}
template <> inline DECLSPEC_NOTHROW void STDMETHODCALLTYPE DkmReleaseElement(Clr::DkmClrNativeCodeMapEntry& element)
{ /* no cleanup is necessary */ }
template <> inline DkmCollectionElementDescriptor::DkmCollectionElementDescriptor(const Symbols::DkmCodeViewCompilerId*) :
    DisposeKind(StructureDispose), Size(sizeof(Symbols::DkmCodeViewCompilerId)), Id(__uuidof(Symbols::DkmCodeViewCompilerId))
{}
template <> inline DECLSPEC_NOTHROW void STDMETHODCALLTYPE DkmReleaseElement(Symbols::DkmCodeViewCompilerId& element)
{
    return Symbols::DkmCodeViewCompilerId::Release(&element);
}
template <> inline DkmCollectionElementDescriptor::DkmCollectionElementDescriptor(const Evaluation::DkmCompilerId*) :
    DisposeKind(NoDispose), Size(sizeof(Evaluation::DkmCompilerId)), Id(GUID_NULL)
{}
template <> inline DECLSPEC_NOTHROW void STDMETHODCALLTYPE DkmReleaseElement(Evaluation::DkmCompilerId& element)
{ /* no cleanup is necessary */ }
template <> inline DkmCollectionElementDescriptor::DkmCollectionElementDescriptor(const GPU::DkmComputeKernelModel_t*) :
    DisposeKind(NoDispose), Size(sizeof(GPU::DkmComputeKernelModel_t)), Id(GUID_NULL)
{}
template <> inline DECLSPEC_NOTHROW void STDMETHODCALLTYPE DkmReleaseElement(GPU::DkmComputeKernelModel_t& element)
{ /* no cleanup is necessary */ }
template <> inline DkmCollectionElementDescriptor::DkmCollectionElementDescriptor(const GPU::DkmComputeProperty*) :
    DisposeKind(StructureDispose), Size(sizeof(GPU::DkmComputeProperty)), Id(__uuidof(GPU::DkmComputeProperty))
{}
template <> inline DECLSPEC_NOTHROW void STDMETHODCALLTYPE DkmReleaseElement(GPU::DkmComputeProperty& element)
{
    return GPU::DkmComputeProperty::Release(&element);
}
template <> inline DkmCollectionElementDescriptor::DkmCollectionElementDescriptor(const GPU::DkmComputeThreadInfo*) :
    DisposeKind(NoDispose), Size(sizeof(GPU::DkmComputeThreadInfo)), Id(GUID_NULL)
{}
template <> inline DECLSPEC_NOTHROW void STDMETHODCALLTYPE DkmReleaseElement(GPU::DkmComputeThreadInfo& element)
{ /* no cleanup is necessary */ }
template <> inline DkmCollectionElementDescriptor::DkmCollectionElementDescriptor(const GPU::DkmComputeThreadState_t*) :
    DisposeKind(NoDispose), Size(sizeof(GPU::DkmComputeThreadState_t)), Id(GUID_NULL)
{}
template <> inline DECLSPEC_NOTHROW void STDMETHODCALLTYPE DkmReleaseElement(GPU::DkmComputeThreadState_t& element)
{ /* no cleanup is necessary */ }
template <> inline DkmCollectionElementDescriptor::DkmCollectionElementDescriptor(const Breakpoints::DkmDataAccessStopMask_t*) :
    DisposeKind(NoDispose), Size(sizeof(Breakpoints::DkmDataAccessStopMask_t)), Id(GUID_NULL)
{}
template <> inline DECLSPEC_NOTHROW void STDMETHODCALLTYPE DkmReleaseElement(Breakpoints::DkmDataAccessStopMask_t& element)
{ /* no cleanup is necessary */ }
template <> inline DkmCollectionElementDescriptor::DkmCollectionElementDescriptor(const DefaultPort::DkmDeploymentCommandFlags_t*) :
    DisposeKind(NoDispose), Size(sizeof(DefaultPort::DkmDeploymentCommandFlags_t)), Id(GUID_NULL)
{}
template <> inline DECLSPEC_NOTHROW void STDMETHODCALLTYPE DkmReleaseElement(DefaultPort::DkmDeploymentCommandFlags_t& element)
{ /* no cleanup is necessary */ }
template <> inline DkmCollectionElementDescriptor::DkmCollectionElementDescriptor(const Symbols::DkmDocumentMatchStrength_t*) :
    DisposeKind(NoDispose), Size(sizeof(Symbols::DkmDocumentMatchStrength_t)), Id(GUID_NULL)
{}
template <> inline DECLSPEC_NOTHROW void STDMETHODCALLTYPE DkmReleaseElement(Symbols::DkmDocumentMatchStrength_t& element)
{ /* no cleanup is necessary */ }
template <> inline DkmCollectionElementDescriptor::DkmCollectionElementDescriptor(const DkmDumpType_t*) :
    DisposeKind(NoDispose), Size(sizeof(DkmDumpType_t)), Id(GUID_NULL)
{}
template <> inline DECLSPEC_NOTHROW void STDMETHODCALLTYPE DkmReleaseElement(DkmDumpType_t& element)
{ /* no cleanup is necessary */ }
template <> inline DkmCollectionElementDescriptor::DkmCollectionElementDescriptor(const Disassembly::DkmEffectiveAddress*) :
    DisposeKind(NoDispose), Size(sizeof(Disassembly::DkmEffectiveAddress)), Id(GUID_NULL)
{}
template <> inline DECLSPEC_NOTHROW void STDMETHODCALLTYPE DkmReleaseElement(Disassembly::DkmEffectiveAddress& element)
{ /* no cleanup is necessary */ }
template <> inline DkmCollectionElementDescriptor::DkmCollectionElementDescriptor(const Disassembly::DkmEffectiveAddressFlags_t*) :
    DisposeKind(NoDispose), Size(sizeof(Disassembly::DkmEffectiveAddressFlags_t)), Id(GUID_NULL)
{}
template <> inline DECLSPEC_NOTHROW void STDMETHODCALLTYPE DkmReleaseElement(Disassembly::DkmEffectiveAddressFlags_t& element)
{ /* no cleanup is necessary */ }
template <> inline DkmCollectionElementDescriptor::DkmCollectionElementDescriptor(const DkmEngineFlags_t*) :
    DisposeKind(NoDispose), Size(sizeof(DkmEngineFlags_t)), Id(GUID_NULL)
{}
template <> inline DECLSPEC_NOTHROW void STDMETHODCALLTYPE DkmReleaseElement(DkmEngineFlags_t& element)
{ /* no cleanup is necessary */ }
template <> inline DkmCollectionElementDescriptor::DkmCollectionElementDescriptor(const Evaluation::DkmEvaluationFlags_t*) :
    DisposeKind(NoDispose), Size(sizeof(Evaluation::DkmEvaluationFlags_t)), Id(GUID_NULL)
{}
template <> inline DECLSPEC_NOTHROW void STDMETHODCALLTYPE DkmReleaseElement(Evaluation::DkmEvaluationFlags_t& element)
{ /* no cleanup is necessary */ }
template <> inline DkmCollectionElementDescriptor::DkmCollectionElementDescriptor(const Evaluation::DkmEvaluationResultAccessType_t*) :
    DisposeKind(NoDispose), Size(sizeof(Evaluation::DkmEvaluationResultAccessType_t)), Id(GUID_NULL)
{}
template <> inline DECLSPEC_NOTHROW void STDMETHODCALLTYPE DkmReleaseElement(Evaluation::DkmEvaluationResultAccessType_t& element)
{ /* no cleanup is necessary */ }
template <> inline DkmCollectionElementDescriptor::DkmCollectionElementDescriptor(const Evaluation::DkmEvaluationResultCategory_t*) :
    DisposeKind(NoDispose), Size(sizeof(Evaluation::DkmEvaluationResultCategory_t)), Id(GUID_NULL)
{}
template <> inline DECLSPEC_NOTHROW void STDMETHODCALLTYPE DkmReleaseElement(Evaluation::DkmEvaluationResultCategory_t& element)
{ /* no cleanup is necessary */ }
template <> inline DkmCollectionElementDescriptor::DkmCollectionElementDescriptor(const Evaluation::DkmEvaluationResultFlags_t*) :
    DisposeKind(NoDispose), Size(sizeof(Evaluation::DkmEvaluationResultFlags_t)), Id(GUID_NULL)
{}
template <> inline DECLSPEC_NOTHROW void STDMETHODCALLTYPE DkmReleaseElement(Evaluation::DkmEvaluationResultFlags_t& element)
{ /* no cleanup is necessary */ }
template <> inline DkmCollectionElementDescriptor::DkmCollectionElementDescriptor(const Evaluation::DkmEvaluationResultStorageType_t*) :
    DisposeKind(NoDispose), Size(sizeof(Evaluation::DkmEvaluationResultStorageType_t)), Id(GUID_NULL)
{}
template <> inline DECLSPEC_NOTHROW void STDMETHODCALLTYPE DkmReleaseElement(Evaluation::DkmEvaluationResultStorageType_t& element)
{ /* no cleanup is necessary */ }
template <> inline DkmCollectionElementDescriptor::DkmCollectionElementDescriptor(const Evaluation::DkmEvaluationResultTypeModifierFlags_t*) :
    DisposeKind(NoDispose), Size(sizeof(Evaluation::DkmEvaluationResultTypeModifierFlags_t)), Id(GUID_NULL)
{}
template <> inline DECLSPEC_NOTHROW void STDMETHODCALLTYPE DkmReleaseElement(Evaluation::DkmEvaluationResultTypeModifierFlags_t& element)
{ /* no cleanup is necessary */ }
template <> inline DkmCollectionElementDescriptor::DkmCollectionElementDescriptor(const Exceptions::DkmExceptionInterceptActionFlags_t*) :
    DisposeKind(NoDispose), Size(sizeof(Exceptions::DkmExceptionInterceptActionFlags_t)), Id(GUID_NULL)
{}
template <> inline DECLSPEC_NOTHROW void STDMETHODCALLTYPE DkmReleaseElement(Exceptions::DkmExceptionInterceptActionFlags_t& element)
{ /* no cleanup is necessary */ }
template <> inline DkmCollectionElementDescriptor::DkmCollectionElementDescriptor(const Exceptions::DkmExceptionProcessingStage_t*) :
    DisposeKind(NoDispose), Size(sizeof(Exceptions::DkmExceptionProcessingStage_t)), Id(GUID_NULL)
{}
template <> inline DECLSPEC_NOTHROW void STDMETHODCALLTYPE DkmReleaseElement(Exceptions::DkmExceptionProcessingStage_t& element)
{ /* no cleanup is necessary */ }
template <> inline DkmCollectionElementDescriptor::DkmCollectionElementDescriptor(const CallStack::DkmFrameFormatOptions*) :
    DisposeKind(NoDispose), Size(sizeof(CallStack::DkmFrameFormatOptions)), Id(GUID_NULL)
{}
template <> inline DECLSPEC_NOTHROW void STDMETHODCALLTYPE DkmReleaseElement(CallStack::DkmFrameFormatOptions& element)
{ /* no cleanup is necessary */ }
template <> inline DkmCollectionElementDescriptor::DkmCollectionElementDescriptor(const CallStack::DkmFrameNameFormatOptions_t*) :
    DisposeKind(NoDispose), Size(sizeof(CallStack::DkmFrameNameFormatOptions_t)), Id(GUID_NULL)
{}
template <> inline DECLSPEC_NOTHROW void STDMETHODCALLTYPE DkmReleaseElement(CallStack::DkmFrameNameFormatOptions_t& element)
{ /* no cleanup is necessary */ }
template <> inline DkmCollectionElementDescriptor::DkmCollectionElementDescriptor(const Evaluation::DkmFuncEvalFlags_t*) :
    DisposeKind(NoDispose), Size(sizeof(Evaluation::DkmFuncEvalFlags_t)), Id(GUID_NULL)
{}
template <> inline DECLSPEC_NOTHROW void STDMETHODCALLTYPE DkmReleaseElement(Evaluation::DkmFuncEvalFlags_t& element)
{ /* no cleanup is necessary */ }
template <> inline DkmCollectionElementDescriptor::DkmCollectionElementDescriptor(const DkmFuncEvalMode_t*) :
    DisposeKind(NoDispose), Size(sizeof(DkmFuncEvalMode_t)), Id(GUID_NULL)
{}
template <> inline DECLSPEC_NOTHROW void STDMETHODCALLTYPE DkmReleaseElement(DkmFuncEvalMode_t& element)
{ /* no cleanup is necessary */ }
template <> inline DkmCollectionElementDescriptor::DkmCollectionElementDescriptor(const GPU::DkmGPUAddressType_t*) :
    DisposeKind(NoDispose), Size(sizeof(GPU::DkmGPUAddressType_t)), Id(GUID_NULL)
{}
template <> inline DECLSPEC_NOTHROW void STDMETHODCALLTYPE DkmReleaseElement(GPU::DkmGPUAddressType_t& element)
{ /* no cleanup is necessary */ }
template <> inline DkmCollectionElementDescriptor::DkmCollectionElementDescriptor(const GPU::DkmGPUBreakpointBehaviorFlags_t*) :
    DisposeKind(NoDispose), Size(sizeof(GPU::DkmGPUBreakpointBehaviorFlags_t)), Id(GUID_NULL)
{}
template <> inline DECLSPEC_NOTHROW void STDMETHODCALLTYPE DkmReleaseElement(GPU::DkmGPUBreakpointBehaviorFlags_t& element)
{ /* no cleanup is necessary */ }
template <> inline DkmCollectionElementDescriptor::DkmCollectionElementDescriptor(const GPU::DkmGPURegisterDescription*) :
    DisposeKind(StructureDispose), Size(sizeof(GPU::DkmGPURegisterDescription)), Id(__uuidof(GPU::DkmGPURegisterDescription))
{}
template <> inline DECLSPEC_NOTHROW void STDMETHODCALLTYPE DkmReleaseElement(GPU::DkmGPURegisterDescription& element)
{
    return GPU::DkmGPURegisterDescription::Release(&element);
}
template <> inline DkmCollectionElementDescriptor::DkmCollectionElementDescriptor(const GPU::DkmHlslThreadIdComponents_t*) :
    DisposeKind(NoDispose), Size(sizeof(GPU::DkmHlslThreadIdComponents_t)), Id(GUID_NULL)
{}
template <> inline DECLSPEC_NOTHROW void STDMETHODCALLTYPE DkmReleaseElement(GPU::DkmHlslThreadIdComponents_t& element)
{ /* no cleanup is necessary */ }
template <> inline DkmCollectionElementDescriptor::DkmCollectionElementDescriptor(const Evaluation::IL::DkmILCallingConvention_t*) :
    DisposeKind(NoDispose), Size(sizeof(Evaluation::IL::DkmILCallingConvention_t)), Id(GUID_NULL)
{}
template <> inline DECLSPEC_NOTHROW void STDMETHODCALLTYPE DkmReleaseElement(Evaluation::IL::DkmILCallingConvention_t& element)
{ /* no cleanup is necessary */ }
template <> inline DkmCollectionElementDescriptor::DkmCollectionElementDescriptor(const Evaluation::IL::DkmILFailureReason_t*) :
    DisposeKind(NoDispose), Size(sizeof(Evaluation::IL::DkmILFailureReason_t)), Id(GUID_NULL)
{}
template <> inline DECLSPEC_NOTHROW void STDMETHODCALLTYPE DkmReleaseElement(Evaluation::IL::DkmILFailureReason_t& element)
{ /* no cleanup is necessary */ }
template <> inline DkmCollectionElementDescriptor::DkmCollectionElementDescriptor(const Evaluation::IL::DkmILFunctionEvaluationArgumentFlags_t*) :
    DisposeKind(NoDispose), Size(sizeof(Evaluation::IL::DkmILFunctionEvaluationArgumentFlags_t)), Id(GUID_NULL)
{}
template <> inline DECLSPEC_NOTHROW void STDMETHODCALLTYPE DkmReleaseElement(Evaluation::IL::DkmILFunctionEvaluationArgumentFlags_t& element)
{ /* no cleanup is necessary */ }
template <> inline DkmCollectionElementDescriptor::DkmCollectionElementDescriptor(const Evaluation::IL::DkmILFunctionEvaluationFlags_t*) :
    DisposeKind(NoDispose), Size(sizeof(Evaluation::IL::DkmILFunctionEvaluationFlags_t)), Id(GUID_NULL)
{}
template <> inline DECLSPEC_NOTHROW void STDMETHODCALLTYPE DkmReleaseElement(Evaluation::IL::DkmILFunctionEvaluationFlags_t& element)
{ /* no cleanup is necessary */ }
template <> inline DkmCollectionElementDescriptor::DkmCollectionElementDescriptor(const Clr::DkmILRange*) :
    DisposeKind(NoDispose), Size(sizeof(Clr::DkmILRange)), Id(GUID_NULL)
{}
template <> inline DECLSPEC_NOTHROW void STDMETHODCALLTYPE DkmReleaseElement(Clr::DkmILRange& element)
{ /* no cleanup is necessary */ }
template <> inline DkmCollectionElementDescriptor::DkmCollectionElementDescriptor(const Symbols::DkmImageDebugDirectoryFormat*) :
    DisposeKind(NoDispose), Size(sizeof(Symbols::DkmImageDebugDirectoryFormat)), Id(GUID_NULL)
{}
template <> inline DECLSPEC_NOTHROW void STDMETHODCALLTYPE DkmReleaseElement(Symbols::DkmImageDebugDirectoryFormat& element)
{ /* no cleanup is necessary */ }
template <> inline DkmCollectionElementDescriptor::DkmCollectionElementDescriptor(const Stepping::DkmLanguageStepIntoFlags_t*) :
    DisposeKind(NoDispose), Size(sizeof(Stepping::DkmLanguageStepIntoFlags_t)), Id(GUID_NULL)
{}
template <> inline DECLSPEC_NOTHROW void STDMETHODCALLTYPE DkmReleaseElement(Stepping::DkmLanguageStepIntoFlags_t& element)
{ /* no cleanup is necessary */ }
template <> inline DkmCollectionElementDescriptor::DkmCollectionElementDescriptor(const Start::DkmLaunchedProcessInfo*) :
    DisposeKind(NoDispose), Size(sizeof(Start::DkmLaunchedProcessInfo)), Id(GUID_NULL)
{}
template <> inline DECLSPEC_NOTHROW void STDMETHODCALLTYPE DkmReleaseElement(Start::DkmLaunchedProcessInfo& element)
{ /* no cleanup is necessary */ }
template <> inline DkmCollectionElementDescriptor::DkmCollectionElementDescriptor(const Symbols::DkmMD5HashValue*) :
    DisposeKind(NoDispose), Size(sizeof(Symbols::DkmMD5HashValue)), Id(GUID_NULL)
{}
template <> inline DECLSPEC_NOTHROW void STDMETHODCALLTYPE DkmReleaseElement(Symbols::DkmMD5HashValue& element)
{ /* no cleanup is necessary */ }
template <> inline DkmCollectionElementDescriptor::DkmCollectionElementDescriptor(const DkmModuleFlags_t*) :
    DisposeKind(NoDispose), Size(sizeof(DkmModuleFlags_t)), Id(GUID_NULL)
{}
template <> inline DECLSPEC_NOTHROW void STDMETHODCALLTYPE DkmReleaseElement(DkmModuleFlags_t& element)
{ /* no cleanup is necessary */ }
template <> inline DkmCollectionElementDescriptor::DkmCollectionElementDescriptor(const Symbols::DkmModuleId*) :
    DisposeKind(NoDispose), Size(sizeof(Symbols::DkmModuleId)), Id(GUID_NULL)
{}
template <> inline DECLSPEC_NOTHROW void STDMETHODCALLTYPE DkmReleaseElement(Symbols::DkmModuleId& element)
{ /* no cleanup is necessary */ }
template <> inline DkmCollectionElementDescriptor::DkmCollectionElementDescriptor(const DkmModuleMemoryLayout_t*) :
    DisposeKind(NoDispose), Size(sizeof(DkmModuleMemoryLayout_t)), Id(GUID_NULL)
{}
template <> inline DECLSPEC_NOTHROW void STDMETHODCALLTYPE DkmReleaseElement(DkmModuleMemoryLayout_t& element)
{ /* no cleanup is necessary */ }
template <> inline DkmCollectionElementDescriptor::DkmCollectionElementDescriptor(const CallStack::DkmMonitorStackWalkResult*) :
    DisposeKind(StructureDispose), Size(sizeof(CallStack::DkmMonitorStackWalkResult)), Id(__uuidof(CallStack::DkmMonitorStackWalkResult))
{}
template <> inline DECLSPEC_NOTHROW void STDMETHODCALLTYPE DkmReleaseElement(CallStack::DkmMonitorStackWalkResult& element)
{
    return CallStack::DkmMonitorStackWalkResult::Release(&element);
}
template <> inline DkmCollectionElementDescriptor::DkmCollectionElementDescriptor(const Native::DkmNativeAddressStepType_t*) :
    DisposeKind(NoDispose), Size(sizeof(Native::DkmNativeAddressStepType_t)), Id(GUID_NULL)
{}
template <> inline DECLSPEC_NOTHROW void STDMETHODCALLTYPE DkmReleaseElement(Native::DkmNativeAddressStepType_t& element)
{ /* no cleanup is necessary */ }
template <> inline DkmCollectionElementDescriptor::DkmCollectionElementDescriptor(const Native::DkmNativeAddressType_t*) :
    DisposeKind(NoDispose), Size(sizeof(Native::DkmNativeAddressType_t)), Id(GUID_NULL)
{}
template <> inline DECLSPEC_NOTHROW void STDMETHODCALLTYPE DkmReleaseElement(Native::DkmNativeAddressType_t& element)
{ /* no cleanup is necessary */ }
template <> inline DkmCollectionElementDescriptor::DkmCollectionElementDescriptor(const Clr::DkmNonUserCodeFlags_t*) :
    DisposeKind(NoDispose), Size(sizeof(Clr::DkmNonUserCodeFlags_t)), Id(GUID_NULL)
{}
template <> inline DECLSPEC_NOTHROW void STDMETHODCALLTYPE DkmReleaseElement(Clr::DkmNonUserCodeFlags_t& element)
{ /* no cleanup is necessary */ }
template <> inline DkmCollectionElementDescriptor::DkmCollectionElementDescriptor(const DefaultPort::DkmPackageExecutionState_t*) :
    DisposeKind(NoDispose), Size(sizeof(DefaultPort::DkmPackageExecutionState_t)), Id(GUID_NULL)
{}
template <> inline DECLSPEC_NOTHROW void STDMETHODCALLTYPE DkmReleaseElement(DefaultPort::DkmPackageExecutionState_t& element)
{ /* no cleanup is necessary */ }
template <> inline DkmCollectionElementDescriptor::DkmCollectionElementDescriptor(const DefaultPort::DkmPackagedAppPlatform_t*) :
    DisposeKind(NoDispose), Size(sizeof(DefaultPort::DkmPackagedAppPlatform_t)), Id(GUID_NULL)
{}
template <> inline DECLSPEC_NOTHROW void STDMETHODCALLTYPE DkmReleaseElement(DefaultPort::DkmPackagedAppPlatform_t& element)
{ /* no cleanup is necessary */ }
template <> inline DkmCollectionElementDescriptor::DkmCollectionElementDescriptor(const Evaluation::IL::DkmPrimitiveObjectType_t*) :
    DisposeKind(NoDispose), Size(sizeof(Evaluation::IL::DkmPrimitiveObjectType_t)), Id(GUID_NULL)
{}
template <> inline DECLSPEC_NOTHROW void STDMETHODCALLTYPE DkmReleaseElement(Evaluation::IL::DkmPrimitiveObjectType_t& element)
{ /* no cleanup is necessary */ }
template <> inline DkmCollectionElementDescriptor::DkmCollectionElementDescriptor(const Start::DkmProcessLaunchEnvironmentFilterScenario_t*) :
    DisposeKind(NoDispose), Size(sizeof(Start::DkmProcessLaunchEnvironmentFilterScenario_t)), Id(GUID_NULL)
{}
template <> inline DECLSPEC_NOTHROW void STDMETHODCALLTYPE DkmReleaseElement(Start::DkmProcessLaunchEnvironmentFilterScenario_t& element)
{ /* no cleanup is necessary */ }
template <> inline DkmCollectionElementDescriptor::DkmCollectionElementDescriptor(const Start::DkmProcessLaunchModeFlags_t*) :
    DisposeKind(NoDispose), Size(sizeof(Start::DkmProcessLaunchModeFlags_t)), Id(GUID_NULL)
{}
template <> inline DECLSPEC_NOTHROW void STDMETHODCALLTYPE DkmReleaseElement(Start::DkmProcessLaunchModeFlags_t& element)
{ /* no cleanup is necessary */ }
template <> inline DkmCollectionElementDescriptor::DkmCollectionElementDescriptor(const DefaultPort::DkmProcessorFeatures_t*) :
    DisposeKind(NoDispose), Size(sizeof(DefaultPort::DkmProcessorFeatures_t)), Id(GUID_NULL)
{}
template <> inline DECLSPEC_NOTHROW void STDMETHODCALLTYPE DkmReleaseElement(DefaultPort::DkmProcessorFeatures_t& element)
{ /* no cleanup is necessary */ }
template <> inline DkmCollectionElementDescriptor::DkmCollectionElementDescriptor(const GPU::DkmQueryComputeThreadInfoFlags_t*) :
    DisposeKind(NoDispose), Size(sizeof(GPU::DkmQueryComputeThreadInfoFlags_t)), Id(GUID_NULL)
{}
template <> inline DECLSPEC_NOTHROW void STDMETHODCALLTYPE DkmReleaseElement(GPU::DkmQueryComputeThreadInfoFlags_t& element)
{ /* no cleanup is necessary */ }
template <> inline DkmCollectionElementDescriptor::DkmCollectionElementDescriptor(const Symbols::DkmRVASizePair*) :
    DisposeKind(NoDispose), Size(sizeof(Symbols::DkmRVASizePair)), Id(GUID_NULL)
{}
template <> inline DECLSPEC_NOTHROW void STDMETHODCALLTYPE DkmReleaseElement(Symbols::DkmRVASizePair& element)
{ /* no cleanup is necessary */ }
template <> inline DkmCollectionElementDescriptor::DkmCollectionElementDescriptor(const DkmReadMemoryFlags_t*) :
    DisposeKind(NoDispose), Size(sizeof(DkmReadMemoryFlags_t)), Id(GUID_NULL)
{}
template <> inline DECLSPEC_NOTHROW void STDMETHODCALLTYPE DkmReleaseElement(DkmReadMemoryFlags_t& element)
{ /* no cleanup is necessary */ }
template <> inline DkmCollectionElementDescriptor::DkmCollectionElementDescriptor(const DefaultPort::DkmRemoteAuthenticationMode_t*) :
    DisposeKind(NoDispose), Size(sizeof(DefaultPort::DkmRemoteAuthenticationMode_t)), Id(GUID_NULL)
{}
template <> inline DECLSPEC_NOTHROW void STDMETHODCALLTYPE DkmReleaseElement(DefaultPort::DkmRemoteAuthenticationMode_t& element)
{ /* no cleanup is necessary */ }
template <> inline DkmCollectionElementDescriptor::DkmCollectionElementDescriptor(const Symbols::DkmResolvedDocumentWarning_t*) :
    DisposeKind(NoDispose), Size(sizeof(Symbols::DkmResolvedDocumentWarning_t)), Id(GUID_NULL)
{}
template <> inline DECLSPEC_NOTHROW void STDMETHODCALLTYPE DkmReleaseElement(Symbols::DkmResolvedDocumentWarning_t& element)
{ /* no cleanup is necessary */ }
template <> inline DkmCollectionElementDescriptor::DkmCollectionElementDescriptor(const Evaluation::DkmRootVisualizedExpressionFlags_t*) :
    DisposeKind(NoDispose), Size(sizeof(Evaluation::DkmRootVisualizedExpressionFlags_t)), Id(GUID_NULL)
{}
template <> inline DECLSPEC_NOTHROW void STDMETHODCALLTYPE DkmReleaseElement(Evaluation::DkmRootVisualizedExpressionFlags_t& element)
{ /* no cleanup is necessary */ }
template <> inline DkmCollectionElementDescriptor::DkmCollectionElementDescriptor(const DefaultPort::DkmRunningProcessFlags_t*) :
    DisposeKind(NoDispose), Size(sizeof(DefaultPort::DkmRunningProcessFlags_t)), Id(GUID_NULL)
{}
template <> inline DECLSPEC_NOTHROW void STDMETHODCALLTYPE DkmReleaseElement(DefaultPort::DkmRunningProcessFlags_t& element)
{ /* no cleanup is necessary */ }
template <> inline DkmCollectionElementDescriptor::DkmCollectionElementDescriptor(const DefaultPort::DkmRunningProcessInfoPropertyMask_t*) :
    DisposeKind(NoDispose), Size(sizeof(DefaultPort::DkmRunningProcessInfoPropertyMask_t)), Id(GUID_NULL)
{}
template <> inline DECLSPEC_NOTHROW void STDMETHODCALLTYPE DkmReleaseElement(DefaultPort::DkmRunningProcessInfoPropertyMask_t& element)
{ /* no cleanup is necessary */ }
template <> inline DkmCollectionElementDescriptor::DkmCollectionElementDescriptor(const DkmRuntimeInstanceId*) :
    DisposeKind(NoDispose), Size(sizeof(DkmRuntimeInstanceId)), Id(GUID_NULL)
{}
template <> inline DECLSPEC_NOTHROW void STDMETHODCALLTYPE DkmReleaseElement(DkmRuntimeInstanceId& element)
{ /* no cleanup is necessary */ }
template <> inline DkmCollectionElementDescriptor::DkmCollectionElementDescriptor(const Symbols::DkmSHA1HashValue*) :
    DisposeKind(NoDispose), Size(sizeof(Symbols::DkmSHA1HashValue)), Id(GUID_NULL)
{}
template <> inline DECLSPEC_NOTHROW void STDMETHODCALLTYPE DkmReleaseElement(Symbols::DkmSHA1HashValue& element)
{ /* no cleanup is necessary */ }
template <> inline DkmCollectionElementDescriptor::DkmCollectionElementDescriptor(const Script::DkmScriptDocumentFlags_t*) :
    DisposeKind(NoDispose), Size(sizeof(Script::DkmScriptDocumentFlags_t)), Id(GUID_NULL)
{}
template <> inline DECLSPEC_NOTHROW void STDMETHODCALLTYPE DkmReleaseElement(Script::DkmScriptDocumentFlags_t& element)
{ /* no cleanup is necessary */ }
template <> inline DkmCollectionElementDescriptor::DkmCollectionElementDescriptor(const Script::DkmScriptSymbolNextSteppingAction_t*) :
    DisposeKind(NoDispose), Size(sizeof(Script::DkmScriptSymbolNextSteppingAction_t)), Id(GUID_NULL)
{}
template <> inline DECLSPEC_NOTHROW void STDMETHODCALLTYPE DkmReleaseElement(Script::DkmScriptSymbolNextSteppingAction_t& element)
{ /* no cleanup is necessary */ }
template <> inline DkmCollectionElementDescriptor::DkmCollectionElementDescriptor(const Symbols::DkmSourcePositionFlags_t*) :
    DisposeKind(NoDispose), Size(sizeof(Symbols::DkmSourcePositionFlags_t)), Id(GUID_NULL)
{}
template <> inline DECLSPEC_NOTHROW void STDMETHODCALLTYPE DkmReleaseElement(Symbols::DkmSourcePositionFlags_t& element)
{ /* no cleanup is necessary */ }
template <> inline DkmCollectionElementDescriptor::DkmCollectionElementDescriptor(const CallStack::DkmStackMemoryRange*) :
    DisposeKind(NoDispose), Size(sizeof(CallStack::DkmStackMemoryRange)), Id(GUID_NULL)
{}
template <> inline DECLSPEC_NOTHROW void STDMETHODCALLTYPE DkmReleaseElement(CallStack::DkmStackMemoryRange& element)
{ /* no cleanup is necessary */ }
template <> inline DkmCollectionElementDescriptor::DkmCollectionElementDescriptor(const CallStack::DkmStackWalkFrameFlags_t*) :
    DisposeKind(NoDispose), Size(sizeof(CallStack::DkmStackWalkFrameFlags_t)), Id(GUID_NULL)
{}
template <> inline DECLSPEC_NOTHROW void STDMETHODCALLTYPE DkmReleaseElement(CallStack::DkmStackWalkFrameFlags_t& element)
{ /* no cleanup is necessary */ }
template <> inline DkmCollectionElementDescriptor::DkmCollectionElementDescriptor(const CallStack::DkmStackWalkStatus_t*) :
    DisposeKind(NoDispose), Size(sizeof(CallStack::DkmStackWalkStatus_t)), Id(GUID_NULL)
{}
template <> inline DECLSPEC_NOTHROW void STDMETHODCALLTYPE DkmReleaseElement(CallStack::DkmStackWalkStatus_t& element)
{ /* no cleanup is necessary */ }
template <> inline DkmCollectionElementDescriptor::DkmCollectionElementDescriptor(const Start::DkmStartMethod_t*) :
    DisposeKind(NoDispose), Size(sizeof(Start::DkmStartMethod_t)), Id(GUID_NULL)
{}
template <> inline DECLSPEC_NOTHROW void STDMETHODCALLTYPE DkmReleaseElement(Start::DkmStartMethod_t& element)
{ /* no cleanup is necessary */ }
template <> inline DkmCollectionElementDescriptor::DkmCollectionElementDescriptor(const Stepping::DkmStepArbitrationReason_t*) :
    DisposeKind(NoDispose), Size(sizeof(Stepping::DkmStepArbitrationReason_t)), Id(GUID_NULL)
{}
template <> inline DECLSPEC_NOTHROW void STDMETHODCALLTYPE DkmReleaseElement(Stepping::DkmStepArbitrationReason_t& element)
{ /* no cleanup is necessary */ }
template <> inline DkmCollectionElementDescriptor::DkmCollectionElementDescriptor(const Stepping::DkmStepKind_t*) :
    DisposeKind(NoDispose), Size(sizeof(Stepping::DkmStepKind_t)), Id(GUID_NULL)
{}
template <> inline DECLSPEC_NOTHROW void STDMETHODCALLTYPE DkmReleaseElement(Stepping::DkmStepKind_t& element)
{ /* no cleanup is necessary */ }
template <> inline DkmCollectionElementDescriptor::DkmCollectionElementDescriptor(const Stepping::DkmStepUnit_t*) :
    DisposeKind(NoDispose), Size(sizeof(Stepping::DkmStepUnit_t)), Id(GUID_NULL)
{}
template <> inline DECLSPEC_NOTHROW void STDMETHODCALLTYPE DkmReleaseElement(Stepping::DkmStepUnit_t& element)
{ /* no cleanup is necessary */ }
template <> inline DkmCollectionElementDescriptor::DkmCollectionElementDescriptor(const Symbols::DkmSteppingRange*) :
    DisposeKind(NoDispose), Size(sizeof(Symbols::DkmSteppingRange)), Id(GUID_NULL)
{}
template <> inline DECLSPEC_NOTHROW void STDMETHODCALLTYPE DkmReleaseElement(Symbols::DkmSteppingRange& element)
{ /* no cleanup is necessary */ }
template <> inline DkmCollectionElementDescriptor::DkmCollectionElementDescriptor(const Symbols::DkmSteppingRangeBoundary_t*) :
    DisposeKind(NoDispose), Size(sizeof(Symbols::DkmSteppingRangeBoundary_t)), Id(GUID_NULL)
{}
template <> inline DECLSPEC_NOTHROW void STDMETHODCALLTYPE DkmReleaseElement(Symbols::DkmSteppingRangeBoundary_t& element)
{ /* no cleanup is necessary */ }
template <> inline DkmCollectionElementDescriptor::DkmCollectionElementDescriptor(const DkmStoppingEventProcessingNextAction_t*) :
    DisposeKind(NoDispose), Size(sizeof(DkmStoppingEventProcessingNextAction_t)), Id(GUID_NULL)
{}
template <> inline DECLSPEC_NOTHROW void STDMETHODCALLTYPE DkmReleaseElement(DkmStoppingEventProcessingNextAction_t& element)
{ /* no cleanup is necessary */ }
template <> inline DkmCollectionElementDescriptor::DkmCollectionElementDescriptor(const DefaultPort::DkmSystemInformationFlags_t*) :
    DisposeKind(NoDispose), Size(sizeof(DefaultPort::DkmSystemInformationFlags_t)), Id(GUID_NULL)
{}
template <> inline DECLSPEC_NOTHROW void STDMETHODCALLTYPE DkmReleaseElement(DefaultPort::DkmSystemInformationFlags_t& element)
{ /* no cleanup is necessary */ }
template <> inline DkmCollectionElementDescriptor::DkmCollectionElementDescriptor(const ParallelTasks::DkmTaskProperties*) :
    DisposeKind(StructureDispose), Size(sizeof(ParallelTasks::DkmTaskProperties)), Id(__uuidof(ParallelTasks::DkmTaskProperties))
{}
template <> inline DECLSPEC_NOTHROW void STDMETHODCALLTYPE DkmReleaseElement(ParallelTasks::DkmTaskProperties& element)
{
    return ParallelTasks::DkmTaskProperties::Release(&element);
}
template <> inline DkmCollectionElementDescriptor::DkmCollectionElementDescriptor(const ParallelTasks::DkmTaskStackSegment*) :
    DisposeKind(NoDispose), Size(sizeof(ParallelTasks::DkmTaskStackSegment)), Id(GUID_NULL)
{}
template <> inline DECLSPEC_NOTHROW void STDMETHODCALLTYPE DkmReleaseElement(ParallelTasks::DkmTaskStackSegment& element)
{ /* no cleanup is necessary */ }
template <> inline DkmCollectionElementDescriptor::DkmCollectionElementDescriptor(const Symbols::DkmTextSpan*) :
    DisposeKind(NoDispose), Size(sizeof(Symbols::DkmTextSpan)), Id(GUID_NULL)
{}
template <> inline DECLSPEC_NOTHROW void STDMETHODCALLTYPE DkmReleaseElement(Symbols::DkmTextSpan& element)
{ /* no cleanup is necessary */ }
template <> inline DkmCollectionElementDescriptor::DkmCollectionElementDescriptor(const DefaultPort::DkmTransportConnectionFlags_t*) :
    DisposeKind(NoDispose), Size(sizeof(DefaultPort::DkmTransportConnectionFlags_t)), Id(GUID_NULL)
{}
template <> inline DECLSPEC_NOTHROW void STDMETHODCALLTYPE DkmReleaseElement(DefaultPort::DkmTransportConnectionFlags_t& element)
{ /* no cleanup is necessary */ }
template <> inline DkmCollectionElementDescriptor::DkmCollectionElementDescriptor(const DkmUserMessageOutputKind_t*) :
    DisposeKind(NoDispose), Size(sizeof(DkmUserMessageOutputKind_t)), Id(GUID_NULL)
{}
template <> inline DECLSPEC_NOTHROW void STDMETHODCALLTYPE DkmReleaseElement(DkmUserMessageOutputKind_t& element)
{ /* no cleanup is necessary */ }
template <> inline DkmCollectionElementDescriptor::DkmCollectionElementDescriptor(const Evaluation::DkmVariableInfoFlags_t*) :
    DisposeKind(NoDispose), Size(sizeof(Evaluation::DkmVariableInfoFlags_t)), Id(GUID_NULL)
{}
template <> inline DECLSPEC_NOTHROW void STDMETHODCALLTYPE DkmReleaseElement(Evaluation::DkmVariableInfoFlags_t& element)
{ /* no cleanup is necessary */ }
template <> inline DkmCollectionElementDescriptor::DkmCollectionElementDescriptor(const ThreadProperties::DkmVolatileThreadFlags_t*) :
    DisposeKind(NoDispose), Size(sizeof(ThreadProperties::DkmVolatileThreadFlags_t)), Id(GUID_NULL)
{}
template <> inline DECLSPEC_NOTHROW void STDMETHODCALLTYPE DkmReleaseElement(ThreadProperties::DkmVolatileThreadFlags_t& element)
{ /* no cleanup is necessary */ }
template <> inline DkmCollectionElementDescriptor::DkmCollectionElementDescriptor(const GPU::DkmWhereClause*) :
    DisposeKind(NoDispose), Size(sizeof(GPU::DkmWhereClause)), Id(GUID_NULL)
{}
template <> inline DECLSPEC_NOTHROW void STDMETHODCALLTYPE DkmReleaseElement(GPU::DkmWhereClause& element)
{ /* no cleanup is necessary */ }
template <> inline DkmCollectionElementDescriptor::DkmCollectionElementDescriptor(const Evaluation::DkmCompiledVisualizationDataPriority_t*) :
    DisposeKind(NoDispose), Size(sizeof(Evaluation::DkmCompiledVisualizationDataPriority_t)), Id(GUID_NULL)
{}
template <> inline DECLSPEC_NOTHROW void STDMETHODCALLTYPE DkmReleaseElement(Evaluation::DkmCompiledVisualizationDataPriority_t& element)
{ /* no cleanup is necessary */ }
template <> inline DkmCollectionElementDescriptor::DkmCollectionElementDescriptor(const Clr::DkmILInterpreterOptions_t*) :
    DisposeKind(NoDispose), Size(sizeof(Clr::DkmILInterpreterOptions_t)), Id(GUID_NULL)
{}
template <> inline DECLSPEC_NOTHROW void STDMETHODCALLTYPE DkmReleaseElement(Clr::DkmILInterpreterOptions_t& element)
{ /* no cleanup is necessary */ }
template <> inline DkmCollectionElementDescriptor::DkmCollectionElementDescriptor(const Clr::DkmManagedHeapObjectInfo*) :
    DisposeKind(NoDispose), Size(sizeof(Clr::DkmManagedHeapObjectInfo)), Id(GUID_NULL)
{}
template <> inline DECLSPEC_NOTHROW void STDMETHODCALLTYPE DkmReleaseElement(Clr::DkmManagedHeapObjectInfo& element)
{ /* no cleanup is necessary */ }
template <> inline DkmCollectionElementDescriptor::DkmCollectionElementDescriptor(const Clr::DkmManagedHeapRootInfo*) :
    DisposeKind(StructureDispose), Size(sizeof(Clr::DkmManagedHeapRootInfo)), Id(__uuidof(Clr::DkmManagedHeapRootInfo))
{}
template <> inline DECLSPEC_NOTHROW void STDMETHODCALLTYPE DkmReleaseElement(Clr::DkmManagedHeapRootInfo& element)
{
    return Clr::DkmManagedHeapRootInfo::Release(&element);
}
template <> inline DkmCollectionElementDescriptor::DkmCollectionElementDescriptor(const Clr::DkmManagedHeapSegmentInfo*) :
    DisposeKind(NoDispose), Size(sizeof(Clr::DkmManagedHeapSegmentInfo)), Id(GUID_NULL)
{}
template <> inline DECLSPEC_NOTHROW void STDMETHODCALLTYPE DkmReleaseElement(Clr::DkmManagedHeapSegmentInfo& element)
{ /* no cleanup is necessary */ }
template <> inline DkmCollectionElementDescriptor::DkmCollectionElementDescriptor(const Clr::DkmManagedHeapTypeInfo*) :
    DisposeKind(StructureDispose), Size(sizeof(Clr::DkmManagedHeapTypeInfo)), Id(__uuidof(Clr::DkmManagedHeapTypeInfo))
{}
template <> inline DECLSPEC_NOTHROW void STDMETHODCALLTYPE DkmReleaseElement(Clr::DkmManagedHeapTypeInfo& element)
{
    return Clr::DkmManagedHeapTypeInfo::Release(&element);
}
template <> inline DkmCollectionElementDescriptor::DkmCollectionElementDescriptor(const Clr::DkmManagedObjectReferenceInfo*) :
    DisposeKind(NoDispose), Size(sizeof(Clr::DkmManagedObjectReferenceInfo)), Id(GUID_NULL)
{}
template <> inline DECLSPEC_NOTHROW void STDMETHODCALLTYPE DkmReleaseElement(Clr::DkmManagedObjectReferenceInfo& element)
{ /* no cleanup is necessary */ }
template <> inline DkmCollectionElementDescriptor::DkmCollectionElementDescriptor(const ParallelTasks::DkmManagedTaskInfo*) :
    DisposeKind(StructureDispose), Size(sizeof(ParallelTasks::DkmManagedTaskInfo)), Id(__uuidof(ParallelTasks::DkmManagedTaskInfo))
{}
template <> inline DECLSPEC_NOTHROW void STDMETHODCALLTYPE DkmReleaseElement(ParallelTasks::DkmManagedTaskInfo& element)
{
    return ParallelTasks::DkmManagedTaskInfo::Release(&element);
}
template <> inline DkmCollectionElementDescriptor::DkmCollectionElementDescriptor(const Clr::DkmManagedTypeId*) :
    DisposeKind(NoDispose), Size(sizeof(Clr::DkmManagedTypeId)), Id(GUID_NULL)
{}
template <> inline DECLSPEC_NOTHROW void STDMETHODCALLTYPE DkmReleaseElement(Clr::DkmManagedTypeId& element)
{ /* no cleanup is necessary */ }
template <> inline DkmCollectionElementDescriptor::DkmCollectionElementDescriptor(const Clr::DkmMetadataStatus_t*) :
    DisposeKind(NoDispose), Size(sizeof(Clr::DkmMetadataStatus_t)), Id(GUID_NULL)
{}
template <> inline DECLSPEC_NOTHROW void STDMETHODCALLTYPE DkmReleaseElement(Clr::DkmMetadataStatus_t& element)
{ /* no cleanup is necessary */ }
template <> inline DkmCollectionElementDescriptor::DkmCollectionElementDescriptor(const DkmRuntimeCapabilities_t*) :
    DisposeKind(NoDispose), Size(sizeof(DkmRuntimeCapabilities_t)), Id(GUID_NULL)
{}
template <> inline DECLSPEC_NOTHROW void STDMETHODCALLTYPE DkmReleaseElement(DkmRuntimeCapabilities_t& element)
{ /* no cleanup is necessary */ }
template <> inline DkmCollectionElementDescriptor::DkmCollectionElementDescriptor(const Script::DkmScriptDocumentContentType_t*) :
    DisposeKind(NoDispose), Size(sizeof(Script::DkmScriptDocumentContentType_t)), Id(GUID_NULL)
{}
template <> inline DECLSPEC_NOTHROW void STDMETHODCALLTYPE DkmReleaseElement(Script::DkmScriptDocumentContentType_t& element)
{ /* no cleanup is necessary */ }
template <> inline DkmCollectionElementDescriptor::DkmCollectionElementDescriptor(const Script::DkmScriptDocumentJmcState_t*) :
    DisposeKind(NoDispose), Size(sizeof(Script::DkmScriptDocumentJmcState_t)), Id(GUID_NULL)
{}
template <> inline DECLSPEC_NOTHROW void STDMETHODCALLTYPE DkmReleaseElement(Script::DkmScriptDocumentJmcState_t& element)
{ /* no cleanup is necessary */ }
template <> inline DkmCollectionElementDescriptor::DkmCollectionElementDescriptor(const Script::DkmScriptEmbeddedDocumentKind_t*) :
    DisposeKind(NoDispose), Size(sizeof(Script::DkmScriptEmbeddedDocumentKind_t)), Id(GUID_NULL)
{}
template <> inline DECLSPEC_NOTHROW void STDMETHODCALLTYPE DkmReleaseElement(Script::DkmScriptEmbeddedDocumentKind_t& element)
{ /* no cleanup is necessary */ }
template <> inline DkmCollectionElementDescriptor::DkmCollectionElementDescriptor(const CallStack::DkmStackWalkOperation_t*) :
    DisposeKind(NoDispose), Size(sizeof(CallStack::DkmStackWalkOperation_t)), Id(GUID_NULL)
{}
template <> inline DECLSPEC_NOTHROW void STDMETHODCALLTYPE DkmReleaseElement(CallStack::DkmStackWalkOperation_t& element)
{ /* no cleanup is necessary */ }
template <> inline DkmCollectionElementDescriptor::DkmCollectionElementDescriptor(const ParallelTasks::DkmTaskProviderCapabilityFlags_t*) :
    DisposeKind(NoDispose), Size(sizeof(ParallelTasks::DkmTaskProviderCapabilityFlags_t)), Id(GUID_NULL)
{}
template <> inline DECLSPEC_NOTHROW void STDMETHODCALLTYPE DkmReleaseElement(ParallelTasks::DkmTaskProviderCapabilityFlags_t& element)
{ /* no cleanup is necessary */ }
template <> inline DkmCollectionElementDescriptor::DkmCollectionElementDescriptor(const ParallelTasks::DkmTaskReturnStatus_t*) :
    DisposeKind(NoDispose), Size(sizeof(ParallelTasks::DkmTaskReturnStatus_t)), Id(GUID_NULL)
{}
template <> inline DECLSPEC_NOTHROW void STDMETHODCALLTYPE DkmReleaseElement(ParallelTasks::DkmTaskReturnStatus_t& element)
{ /* no cleanup is necessary */ }
template <> inline DkmCollectionElementDescriptor::DkmCollectionElementDescriptor(const Exceptions::DkmStowedExceptionNestedType_t*) :
    DisposeKind(NoDispose), Size(sizeof(Exceptions::DkmStowedExceptionNestedType_t)), Id(GUID_NULL)
{}
template <> inline DECLSPEC_NOTHROW void STDMETHODCALLTYPE DkmReleaseElement(Exceptions::DkmStowedExceptionNestedType_t& element)
{ /* no cleanup is necessary */ }
template <> inline DkmCollectionElementDescriptor::DkmCollectionElementDescriptor(const Clr::DkmClrAliasKind_t*) :
    DisposeKind(NoDispose), Size(sizeof(Clr::DkmClrAliasKind_t)), Id(GUID_NULL)
{}
template <> inline DECLSPEC_NOTHROW void STDMETHODCALLTYPE DkmReleaseElement(Clr::DkmClrAliasKind_t& element)
{ /* no cleanup is necessary */ }
template <> inline DkmCollectionElementDescriptor::DkmCollectionElementDescriptor(const Evaluation::ClrCompilation::DkmClrCompilationResultFlags_t*) :
    DisposeKind(NoDispose), Size(sizeof(Evaluation::ClrCompilation::DkmClrCompilationResultFlags_t)), Id(GUID_NULL)
{}
template <> inline DECLSPEC_NOTHROW void STDMETHODCALLTYPE DkmReleaseElement(Evaluation::ClrCompilation::DkmClrCompilationResultFlags_t& element)
{ /* no cleanup is necessary */ }
template <> inline DkmCollectionElementDescriptor::DkmCollectionElementDescriptor(const Evaluation::DkmClrCustomVisualizerAssemblyLocation_t*) :
    DisposeKind(NoDispose), Size(sizeof(Evaluation::DkmClrCustomVisualizerAssemblyLocation_t)), Id(GUID_NULL)
{}
template <> inline DECLSPEC_NOTHROW void STDMETHODCALLTYPE DkmReleaseElement(Evaluation::DkmClrCustomVisualizerAssemblyLocation_t& element)
{ /* no cleanup is necessary */ }
template <> inline DkmCollectionElementDescriptor::DkmCollectionElementDescriptor(const Evaluation::ClrCompilation::DkmClrDebuggerBrowsableAttributeState_t*) :
    DisposeKind(NoDispose), Size(sizeof(Evaluation::ClrCompilation::DkmClrDebuggerBrowsableAttributeState_t)), Id(GUID_NULL)
{}
template <> inline DECLSPEC_NOTHROW void STDMETHODCALLTYPE DkmReleaseElement(Evaluation::ClrCompilation::DkmClrDebuggerBrowsableAttributeState_t& element)
{ /* no cleanup is necessary */ }
template <> inline DkmCollectionElementDescriptor::DkmCollectionElementDescriptor(const Evaluation::DkmClrValueFlags_t*) :
    DisposeKind(NoDispose), Size(sizeof(Evaluation::DkmClrValueFlags_t)), Id(GUID_NULL)
{}
template <> inline DECLSPEC_NOTHROW void STDMETHODCALLTYPE DkmReleaseElement(Evaluation::DkmClrValueFlags_t& element)
{ /* no cleanup is necessary */ }
template <> inline DkmCollectionElementDescriptor::DkmCollectionElementDescriptor(const Start::DkmDebugProcessRequestFlags_t*) :
    DisposeKind(NoDispose), Size(sizeof(Start::DkmDebugProcessRequestFlags_t)), Id(GUID_NULL)
{}
template <> inline DECLSPEC_NOTHROW void STDMETHODCALLTYPE DkmReleaseElement(Start::DkmDebugProcessRequestFlags_t& element)
{ /* no cleanup is necessary */ }
template <> inline DkmCollectionElementDescriptor::DkmCollectionElementDescriptor(const Enc::DkmNativeEncNotify_t*) :
    DisposeKind(NoDispose), Size(sizeof(Enc::DkmNativeEncNotify_t)), Id(GUID_NULL)
{}
template <> inline DECLSPEC_NOTHROW void STDMETHODCALLTYPE DkmReleaseElement(Enc::DkmNativeEncNotify_t& element)
{ /* no cleanup is necessary */ }
template <> inline DkmCollectionElementDescriptor::DkmCollectionElementDescriptor(const Start::DkmProcessLaunchFlags_t*) :
    DisposeKind(NoDispose), Size(sizeof(Start::DkmProcessLaunchFlags_t)), Id(GUID_NULL)
{}
template <> inline DECLSPEC_NOTHROW void STDMETHODCALLTYPE DkmReleaseElement(Start::DkmProcessLaunchFlags_t& element)
{ /* no cleanup is necessary */ }
template <> inline DkmCollectionElementDescriptor::DkmCollectionElementDescriptor(const bool*) :
    DisposeKind(NoDispose), Size(sizeof(bool)), Id(GUID_NULL)
{}
template <> inline DECLSPEC_NOTHROW void STDMETHODCALLTYPE DkmReleaseElement(bool& element)
{ /* no cleanup is necessary */ }

};};}; // end namespace Microsoft::VisualStudio::Debugger

#ifndef __INTELLISENSE__
extern "C"
__declspec(dllimport)
DECLSPEC_NOTHROW
HRESULT STDMETHODCALLTYPE ProcDkmDataContainerSet(
    IUnknown*,
    Microsoft::VisualStudio::Debugger::DkmDataCreationDisposition_t,
    const Microsoft::VisualStudio::Debugger::DkmDataItem&
    );
extern "C"
__declspec(dllimport)
DECLSPEC_NOTHROW
HRESULT STDMETHODCALLTYPE ProcDkmDataContainerGet(
    IUnknown*,
    REFGUID,
    _Deref_out_ IUnknown**
    );
extern "C"
__declspec(dllimport)
DECLSPEC_NOTHROW
HRESULT STDMETHODCALLTYPE ProcDkmDataContainerRemove(
    IUnknown*,
    REFGUID
    );
extern "C"
__declspec(dllimport)
DECLSPEC_NOTHROW
HRESULT STDMETHODCALLTYPE ProcDkmAlloc(
    size_t bytes,
    void** ppMemory
    );
extern "C"
__declspec(dllimport)
DECLSPEC_NOTHROW
void STDMETHODCALLTYPE ProcDkmFree(
    void* pMemory
    );
extern "C"
__declspec(dllimport)
DECLSPEC_NOTHROW
void STDMETHODCALLTYPE ProcDkmReleaseInterface(
    IUnknown* pObject
    );
extern "C"
__declspec(dllimport)
DECLSPEC_NOTHROW
void* STDMETHODCALLTYPE ProcDkmGetExtendedPart(
    IUnknown* pObject,
    REFGUID PartId
    );

extern "C"
__declspec(dllimport)
DECLSPEC_NOTHROW
HRESULT STDMETHODCALLTYPE ProcDkmInitializeThread(
    REFGUID guidComponentId,
    void* Reserved
    );
extern "C"
__declspec(dllimport)
DECLSPEC_NOTHROW
HRESULT STDMETHODCALLTYPE ProcDkmUninitializeThread(
    REFGUID guidComponentId
    );
extern "C"
__declspec(dllimport)
DECLSPEC_NOTHROW
HRESULT STDMETHODCALLTYPE ProcDkmGetCurrentComponentId(
    GUID* pComponentId
    );
extern "C"
__declspec(dllimport)
DECLSPEC_NOTHROW
HRESULT STDMETHODCALLTYPE ProcDkmAllowComponentReentrancy(
    );
extern "C"
__declspec(dllimport)
DECLSPEC_NOTHROW
HRESULT STDMETHODCALLTYPE ProcDkmDisableComponentReentrancy(
    );
extern "C"
__declspec(dllimport)
DECLSPEC_NOTHROW
bool STDMETHODCALLTYPE ProcDkmIsApiVersionSupported(
    Microsoft::VisualStudio::Debugger::DkmApiVersion_t apiVersion
    );
extern "C"
__declspec(dllimport)
DECLSPEC_NOTHROW
HRESULT STDMETHODCALLTYPE ProcDkmFindComponentHandle(
    _In_ REFGUID componentInfo,
    _Deref_out_ Microsoft::VisualStudio::Debugger::DkmComponentHandle* componentHandle
    );
extern "C"
__declspec(dllimport)
DECLSPEC_NOTHROW
HRESULT STDMETHODCALLTYPE ProcDkmPopComponentTransition(
    _Out_ Microsoft::VisualStudio::Debugger::DkmComponentHandle pComponentHandle
    );
extern "C"
__declspec(dllimport)
DECLSPEC_NOTHROW
HRESULT STDMETHODCALLTYPE ProcDkmPushComponentTransition(
    _In_ Microsoft::VisualStudio::Debugger::DkmComponentHandle componentHandle
    );

extern "C"
__declspec(dllimport)
DECLSPEC_NOTHROW
HRESULT STDMETHODCALLTYPE ProcDkmInitializeThreadByHandle(
    _In_ Microsoft::VisualStudio::Debugger::DkmComponentHandle componentHandle
    );

extern "C"
__declspec(dllimport)
DECLSPEC_NOTHROW
HRESULT STDMETHODCALLTYPE ProcDkmUninitializeThreadByHandle(
    _In_ Microsoft::VisualStudio::Debugger::DkmComponentHandle componentHandle
    );

extern "C"
__declspec(dllimport)
DECLSPEC_NOTHROW
UINT64 STDMETHODCALLTYPE ProcDkmGetCurrentEventTimeStamp(
);



extern "C"
__declspec(dllimport)
DECLSPEC_NOTHROW
HRESULT STDMETHODCALLTYPE ProcDkmWorkListCreate(
    Microsoft::VisualStudio::Debugger::IDkmWorkListCompletionRoutine* pCompletionRoutine,
    Microsoft::VisualStudio::Debugger::DkmWorkList** ppCreatedObject
    );
extern "C"
__declspec(dllimport)
DECLSPEC_NOTHROW
HRESULT STDMETHODCALLTYPE ProcDkmWorkListQueryIsCurrentInstanceCanceled(
    );
extern "C"
__declspec(dllimport)
DECLSPEC_NOTHROW
HRESULT STDMETHODCALLTYPE ProcDkmWorkListBeginExecution(
    Microsoft::VisualStudio::Debugger::DkmWorkList*
    );
extern "C"
__declspec(dllimport)
DECLSPEC_NOTHROW
HRESULT STDMETHODCALLTYPE ProcDkmWorkListExecute(
    Microsoft::VisualStudio::Debugger::DkmWorkList*
    );
extern "C"
__declspec(dllimport)
DECLSPEC_NOTHROW
HRESULT STDMETHODCALLTYPE ProcDkmWorkListCancel(
    Microsoft::VisualStudio::Debugger::DkmWorkList*
    );

enum VSDEBUGENG_HRESULT
{
    // Symbols are not loaded for the target dll.
    E_SYMBOLS_NOT_LOADED__ = 0x92330000,
    // Symbols for the target dll do not contain source information.
    E_SYMBOLS_STRIPPED__ = 0x92330001,
    // Breakpoint could not be written at the specified instruction address.
    E_BP_INVALID_ADDRESS__ = 0x92330002,
    // Breakpoints cannot be set in optimized code when the debugger option 'Just My Code' is enabled.
    E_BP_IN_OPTIMIZED_CODE__ = 0x92330004,
    // The Common Language Runtime was unable to set the breakpoint.
    E_BP_CLR_ERROR__ = 0x92330006,
    // Cannot set breakpoints in .NET Framework methods which are implemented in native code (ex: 'extern' function).
    E_BP_CLR_EXTERN_FUNCTION__ = 0x92330007,
    // Cannot set breakpoint, target module is currently unloaded.
    E_BP_MODULE_UNLOADED__ = 0x92330008,
    // Stopping events cannot be sent. See stopping event processing documentation for more information.
    E_STOPPING_EVENT_REJECTED__ = 0x92330009,
    // This operation is not permitted because the target process is already stopped.
    E_TARGET_ALREADY_STOPPED__ = 0x9233000A,
    // This operation is not permitted because the target process is not stopped.
    E_TARGET_NOT_STOPPED__ = 0x9233000B,
    // This operation is not allowed on this thread.
    E_WRONG_THREAD__ = 0x9233000C,
    // This operation is not allowed at this time.
    E_WRONG_TIME__ = 0x9233000D,
    // The caller is not allowed to request this operation. This operation must be requested by a different component.
    E_WRONG_COMPONENT__ = 0x9233000E,
    // Operation is only permitted on the latest version of an editted method.
    E_WRONG_METHOD_VERSION__ = 0x9233000F,
    // A memory read or write operation failed because the specified memory address is not currently valid.
    E_INVALID_MEMORY_ADDRESS__ = 0x92330010,
    // No source information is available for this instruction.
    E_INSTRUCTION_NO_SOURCE__ = 0x92330011,
    // Failed to load localizable resource from vsdebugeng.impl.resources.dll. If this problem persists, please repair your Visual Studio installation via 'Add or Remove Programs' in Control Panel.
    E_VSDEBUGENG_RESOURCE_LOAD_FAILURE__ = 0x92330012,
    // DkmVariant is of a form that marshalling is not supported. Marshalling is supported for primitives types, strings, and safe arrays of primitives.
    E_UNMARSHALLABLE_VARIANT__ = 0x92330013,
    // An incorrect version of vsdebugeng.dll was loaded into Visual Studio. Please repair your Visual Studio installation.
    E_VSDEBUGENG_DEPLOYMENT_ERROR__ = 0x92330014,
    // The remote debugger was unable to initialize Microsoft Windows Web Services (webservices.dll). If the problem continues, try reinstalling the Windows Web Services redistributable. This redistributable can be found under the 'Remote Debugger\\Common Resources\\Windows Updates' folder.
    E_WEBSERVICES_LOAD_FAILURE__ = 0x92330015,
    // Visual Studio encountered an error while loading a Windows component (Global Interface Table). If the problem persists, this may be an indication of operating system corruption, and Windows may need to be reinstalled.
    E_GLOBAL_INTERFACE_POINTER_FAILURE__ = 0x92330016,
    // Windows authentication was unable to establish a secure connection to the remote computer.
    E_REMOTE_AUTHENTICATION_ERROR__ = 0x92330017,
    // The Remote Debugger was unable to locate a resource dll (vsdebugeng.impl.resources.dll). Please ensure that the complete remote debugger folder was copied or installed on the target computer.
    E_CANNOT_FIND_REMOTE_RESOURCES__ = 0x92330018,
    // The hardware does not support monitoring the requested number of bytes.
    E_INVALID_DATABP_SIZE__ = 0x92330020,
    // The maximum number of data breakpoints have already been set.
    E_INVALID_DATABP_ALLREGSUSED__ = 0x92330021,
    // Breakpoints cannot be set while debugging a minidump.
    E_DUMPS_DO_NOT_SUPPORT_BREAKPOINTS__ = 0x92330022,
    // The minidump is from an ARM-based computer and can only be debugged on an ARM computer.
    E_DUMP_ARM_ARCHITECTURE__ = 0x92330023,
    // The minidump is from an unknown processor, and cannot be debugged with this version of Visual Studio.
    E_DUMP_UNKNOWN_ARCHITECTURE__ = 0x92330024,
    // The shell failed to find a checksum for this file.
    E_NO_CHECKSUM__ = 0x92330025,
    // On x64, context control must be included in a SetThreadContext
    E_CONTEXT_CONTROL_REQUIRED__ = 0x92330026,
    // The size of the buffer does not match the size of the register.
    E_INVALID_REGISTER_SIZE__ = 0x92330027,
    // The requested register was not found in the stack frame's unwound register collection.
    E_REGISTER_NOT_FOUND__ = 0x92330028,
    // Cannot set a read-only register.
    E_REGISTER_READONLY__ = 0x92330029,
    // Cannot set a register in a frame that is not the top of the stack.
    E_REG_NOT_TOP_STACK__ = 0x92330030,
    // String could not be read within the specified maximum number of characters.
    E_STRING_TOO_LONG__ = 0x92330031,
    // The memory region does not meet the requested protection flags.
    E_INVALID_MEMORY_PROTECT__ = 0x92330032,
    // Instruction is invalid or unknown to the disassembler.
    E_UNKNOWN_CPU_INSTRUCTION__ = 0x92330033,
    // An invliad runtime was specified for this operation.
    E_INVALID_RUNTIME__ = 0x92330034,
    // Variable is optimized away.
    E_VARIABLE_OPTIMIZED_AWAY__ = 0x92330035,
    // The text span is not currently loaded in the specified script document.
    E_TEXT_SPAN_NOT_LOADED__ = 0x92330036,
    // This location could not be mapped to client side script.
    E_SCRIPT_SPAN_MAPPING_FAILED__ = 0x92330037,
    // The file requested must be less than 100 megabytes in size
    E_DEPLOY_FILE_TOO_LARGE__ = 0x92330038,
    // The file path requested could not be written to as it is invalid. Ensure the path does not contain a file where a directory is expected.
    E_DEPLOY_FILE_PATH_INVALID__ = 0x92330039,
    // Script debugging is not enabled for WWAHost.exe.
    E_SCRIPT_DEBUGGING_DISABLED_WWAHOST_ATTACH_FAILED__ = 0x92330040,
    // The file path requested for deletion does not exist.
    E_DEPLOY_FILE_NOT_EXIST__ = 0x92330041,
    // A command is already executing, only one may execute at a time. Please wait for the executable to exit, or abort the command.
    E_EXECUTE_COMMAND_IN_PROGRESS__ = 0x92330042,
    // The specified file path is a relative or unknown path format. File paths must be fully qualified.
    E_INVALID_FULL_PATH__ = 0x92330043,
    // Windows Store app debugging is not possible when the remote debugger is running as a service. Run the Remote Debugger Configuration Wizard on the target computer, and uncheck the option to start the remote debugger service. Then start the Visual Studio Remote Debugger application.
    E_CANNOT_DEBUG_APP_PACKAGE_IN_RDBSERVICE__ = 0x92330044,
    // Applications cannot be launched under the debugger when the remote debugger is running as a service. Run the Remote Debugger Configuration Wizard on the target computer, and uncheck the option to start the remote debugger service. Then start the Visual Studio Remote Debugger application.
    E_CANNOT_LAUNCH_IN_RDBSERVICE__ = 0x92330045,
    // The AD7 AL Causality bridge has already been initialized.
    E_CAUSALITY_BRIDGE_ALREADY_INITIALIZED__ = 0x92330046,
    // App Packages may only be shutdown as part of a Visual Studio build operation.
    E_DEPLOY_APPX_SHUTDOWN_WRONG_TIME__ = 0x92330047,
    // A Microsoft Windows component is not correctly registered. If the problem persists, try repairing your Windows installation, or reinstalling Windows.
    E_WINDOWS_REG_ERROR__ = 0x92330048,
    // The application never reached a suspended state.
    E_APP_PACKAGE_NEVER_SUSPENDED__ = 0x92330049,
    // A different version of this script file has been loaded by the debugged process. The script file may need to be reloaded.
    E_SCRIPT_FILE_DIFFERENT_CONTENT__ = 0x9233004A,
    // No stack frame was found.
    E_NO_FRAME__ = 0x9233004B,
    // Operation is not supported while interop debugging.
    E_NOT_SUPPORTED_INTEROP__ = 0x9233004C,
    // The selected accelerator does not support the run current tile to cursor operation.
    E_GPU_BARRIER_BREAKPOINT_NOT_SUPPORTED__ = 0x9233004D,
    // Data breakpoints are not supported on this platform.
    E_DATABPS_NOTSUPPORTED__ = 0x9233004E,
    // The debugger failed to attach to the process requested in the DkmDebugProcessRequest.
    E_DEBUG_PROCESS_REQUEST_FAILED__ = 0x9233004F,
    // An invalid NativeOffset or CPUInstructionPart value was used with a DkmClrInstructionAddress or DkmClrInstructionSymbol
    E_INVALID_CLR_INSTRUCTION_NATIVE_OFFSET__ = 0x92330055,
    // Managed heap is not in a state that can be enumerated
    E_MANAGED_HEAP_NOT_ENUMERABLE__ = 0x92330056,
    // This operation is unavailable when mixed mode debugging with Script
    E_OPERATION_UNAVAILABLE_SCRIPT_INTEROP__ = 0x92330057,
    // This operation is unavailable when debugging native-compiled .NET code.
    E_OPERATION_UNAVAILABLE_CLR_NC__ = 0x92330058,
    // Symbol file contains data which is in an unexpected format.
    E_BAD_SYMBOL_DATA__ = 0x92330059,
    // Dynamically enabling script debugging in the target process failed.
    E_ENABLE_SCRIPT_DEBUGGING_FAILED__ = 0x9233005A,
    // Expression evaluation is not available in async call stack frames.
    E_SCRIPT_ASYNC_FRAME_EE_UNAVAILABLE__ = 0x9233005B,
    // This dump does not contain any thread information or the thread information is corrupt. Visual Studio does not support debugging of dumps without valid thread information.
    E_DUMP_NO_THREADS__ = 0x9233005C,
    // DkmLoadCompleteEventDeferral.Add cannot be called after the load complete event has been sent.
    E_LOAD_COMPLETE_ALREADY_SENT__ = 0x9233005D,
    // DkmLoadCompleteEventDeferral was not present in the list during a call to DkmLoadCompleteEventDeferral.Remove.
    E_LOAD_COMPLETE_DEFERRAL_NOT_FOUND__ = 0x9233005E,
    // The buffer size specified was too large to marshal over the remote boundary.
    E_MARSHALLING_SIZE_TOO_LARGE__ = 0x9233005F,
    // Emulation of iterator for results view failed. This is typically caused when the iterator calls into native code.
    E_CANNOT_EMULATE_RESULTS_VIEW__ = 0x92330060,
    // Managed heap enumeration is attempted on running target. This is typically caused by continuing the process while heap enumeration is in progress.
    E_MANAGED_HEAP_ENUMERATION_TARGET_NOT_STOPPED__ = 0x92330061,
    // The Microsoft .NET Core CLR Debugging Services Loader (dbgshim.dll) could not be loaded or initialized.
    E_DBGSHIM_INIT_ERROR__ = 0x92330062,
    // Breakpoints cannot be set in modules that contain the implementation of the underlying runtime, such as clr.dll.
    E_BP_IN_RUNTIME_MODULE_BLOCKED__ = 0x92330063,
    // Detach is not allowed after changes have been applied through Edit and Continue.
    E_DETACH_FAILED_ON_ENC__ = 0x92330064,
    // Managed heap enumeration ran into an issue reading objects from the heap, not all objects were captured
    E_MANAGED_HEAP_ENUMERATION_PARTIAL__ = 0x92330065
};
#define E_SYMBOLS_NOT_LOADED _HRESULT_TYPEDEF_(E_SYMBOLS_NOT_LOADED__)
#define E_SYMBOLS_STRIPPED _HRESULT_TYPEDEF_(E_SYMBOLS_STRIPPED__)
#define E_BP_INVALID_ADDRESS _HRESULT_TYPEDEF_(E_BP_INVALID_ADDRESS__)
#define E_BP_IN_OPTIMIZED_CODE _HRESULT_TYPEDEF_(E_BP_IN_OPTIMIZED_CODE__)
#define E_BP_CLR_ERROR _HRESULT_TYPEDEF_(E_BP_CLR_ERROR__)
#define E_BP_CLR_EXTERN_FUNCTION _HRESULT_TYPEDEF_(E_BP_CLR_EXTERN_FUNCTION__)
#define E_BP_MODULE_UNLOADED _HRESULT_TYPEDEF_(E_BP_MODULE_UNLOADED__)
#define E_STOPPING_EVENT_REJECTED _HRESULT_TYPEDEF_(E_STOPPING_EVENT_REJECTED__)
#define E_TARGET_ALREADY_STOPPED _HRESULT_TYPEDEF_(E_TARGET_ALREADY_STOPPED__)
#define E_TARGET_NOT_STOPPED _HRESULT_TYPEDEF_(E_TARGET_NOT_STOPPED__)
#define E_WRONG_THREAD _HRESULT_TYPEDEF_(E_WRONG_THREAD__)
#define E_WRONG_TIME _HRESULT_TYPEDEF_(E_WRONG_TIME__)
#define E_WRONG_COMPONENT _HRESULT_TYPEDEF_(E_WRONG_COMPONENT__)
#define E_WRONG_METHOD_VERSION _HRESULT_TYPEDEF_(E_WRONG_METHOD_VERSION__)
#define E_INVALID_MEMORY_ADDRESS _HRESULT_TYPEDEF_(E_INVALID_MEMORY_ADDRESS__)
#define E_INSTRUCTION_NO_SOURCE _HRESULT_TYPEDEF_(E_INSTRUCTION_NO_SOURCE__)
#define E_VSDEBUGENG_RESOURCE_LOAD_FAILURE _HRESULT_TYPEDEF_(E_VSDEBUGENG_RESOURCE_LOAD_FAILURE__)
#define E_UNMARSHALLABLE_VARIANT _HRESULT_TYPEDEF_(E_UNMARSHALLABLE_VARIANT__)
#define E_VSDEBUGENG_DEPLOYMENT_ERROR _HRESULT_TYPEDEF_(E_VSDEBUGENG_DEPLOYMENT_ERROR__)
#define E_WEBSERVICES_LOAD_FAILURE _HRESULT_TYPEDEF_(E_WEBSERVICES_LOAD_FAILURE__)
#define E_GLOBAL_INTERFACE_POINTER_FAILURE _HRESULT_TYPEDEF_(E_GLOBAL_INTERFACE_POINTER_FAILURE__)
#define E_REMOTE_AUTHENTICATION_ERROR _HRESULT_TYPEDEF_(E_REMOTE_AUTHENTICATION_ERROR__)
#define E_CANNOT_FIND_REMOTE_RESOURCES _HRESULT_TYPEDEF_(E_CANNOT_FIND_REMOTE_RESOURCES__)
#define E_INVALID_DATABP_SIZE _HRESULT_TYPEDEF_(E_INVALID_DATABP_SIZE__)
#define E_INVALID_DATABP_ALLREGSUSED _HRESULT_TYPEDEF_(E_INVALID_DATABP_ALLREGSUSED__)
#define E_DUMPS_DO_NOT_SUPPORT_BREAKPOINTS _HRESULT_TYPEDEF_(E_DUMPS_DO_NOT_SUPPORT_BREAKPOINTS__)
#define E_DUMP_ARM_ARCHITECTURE _HRESULT_TYPEDEF_(E_DUMP_ARM_ARCHITECTURE__)
#define E_DUMP_UNKNOWN_ARCHITECTURE _HRESULT_TYPEDEF_(E_DUMP_UNKNOWN_ARCHITECTURE__)
#define E_NO_CHECKSUM _HRESULT_TYPEDEF_(E_NO_CHECKSUM__)
#define E_CONTEXT_CONTROL_REQUIRED _HRESULT_TYPEDEF_(E_CONTEXT_CONTROL_REQUIRED__)
#define E_INVALID_REGISTER_SIZE _HRESULT_TYPEDEF_(E_INVALID_REGISTER_SIZE__)
#define E_REGISTER_NOT_FOUND _HRESULT_TYPEDEF_(E_REGISTER_NOT_FOUND__)
#define E_REGISTER_READONLY _HRESULT_TYPEDEF_(E_REGISTER_READONLY__)
#define E_REG_NOT_TOP_STACK _HRESULT_TYPEDEF_(E_REG_NOT_TOP_STACK__)
#define E_STRING_TOO_LONG _HRESULT_TYPEDEF_(E_STRING_TOO_LONG__)
#define E_INVALID_MEMORY_PROTECT _HRESULT_TYPEDEF_(E_INVALID_MEMORY_PROTECT__)
#define E_UNKNOWN_CPU_INSTRUCTION _HRESULT_TYPEDEF_(E_UNKNOWN_CPU_INSTRUCTION__)
#define E_INVALID_RUNTIME _HRESULT_TYPEDEF_(E_INVALID_RUNTIME__)
#define E_VARIABLE_OPTIMIZED_AWAY _HRESULT_TYPEDEF_(E_VARIABLE_OPTIMIZED_AWAY__)
#define E_TEXT_SPAN_NOT_LOADED _HRESULT_TYPEDEF_(E_TEXT_SPAN_NOT_LOADED__)
#define E_SCRIPT_SPAN_MAPPING_FAILED _HRESULT_TYPEDEF_(E_SCRIPT_SPAN_MAPPING_FAILED__)
#define E_DEPLOY_FILE_TOO_LARGE _HRESULT_TYPEDEF_(E_DEPLOY_FILE_TOO_LARGE__)
#define E_DEPLOY_FILE_PATH_INVALID _HRESULT_TYPEDEF_(E_DEPLOY_FILE_PATH_INVALID__)
#define E_SCRIPT_DEBUGGING_DISABLED_WWAHOST_ATTACH_FAILED _HRESULT_TYPEDEF_(E_SCRIPT_DEBUGGING_DISABLED_WWAHOST_ATTACH_FAILED__)
#define E_DEPLOY_FILE_NOT_EXIST _HRESULT_TYPEDEF_(E_DEPLOY_FILE_NOT_EXIST__)
#define E_EXECUTE_COMMAND_IN_PROGRESS _HRESULT_TYPEDEF_(E_EXECUTE_COMMAND_IN_PROGRESS__)
#define E_INVALID_FULL_PATH _HRESULT_TYPEDEF_(E_INVALID_FULL_PATH__)
#define E_CANNOT_DEBUG_APP_PACKAGE_IN_RDBSERVICE _HRESULT_TYPEDEF_(E_CANNOT_DEBUG_APP_PACKAGE_IN_RDBSERVICE__)
#define E_CANNOT_LAUNCH_IN_RDBSERVICE _HRESULT_TYPEDEF_(E_CANNOT_LAUNCH_IN_RDBSERVICE__)
#define E_CAUSALITY_BRIDGE_ALREADY_INITIALIZED _HRESULT_TYPEDEF_(E_CAUSALITY_BRIDGE_ALREADY_INITIALIZED__)
#define E_DEPLOY_APPX_SHUTDOWN_WRONG_TIME _HRESULT_TYPEDEF_(E_DEPLOY_APPX_SHUTDOWN_WRONG_TIME__)
#define E_WINDOWS_REG_ERROR _HRESULT_TYPEDEF_(E_WINDOWS_REG_ERROR__)
#define E_APP_PACKAGE_NEVER_SUSPENDED _HRESULT_TYPEDEF_(E_APP_PACKAGE_NEVER_SUSPENDED__)
#define E_SCRIPT_FILE_DIFFERENT_CONTENT _HRESULT_TYPEDEF_(E_SCRIPT_FILE_DIFFERENT_CONTENT__)
#define E_NO_FRAME _HRESULT_TYPEDEF_(E_NO_FRAME__)
#define E_NOT_SUPPORTED_INTEROP _HRESULT_TYPEDEF_(E_NOT_SUPPORTED_INTEROP__)
#define E_GPU_BARRIER_BREAKPOINT_NOT_SUPPORTED _HRESULT_TYPEDEF_(E_GPU_BARRIER_BREAKPOINT_NOT_SUPPORTED__)
#define E_DATABPS_NOTSUPPORTED _HRESULT_TYPEDEF_(E_DATABPS_NOTSUPPORTED__)
#define E_DEBUG_PROCESS_REQUEST_FAILED _HRESULT_TYPEDEF_(E_DEBUG_PROCESS_REQUEST_FAILED__)
#define E_INVALID_CLR_INSTRUCTION_NATIVE_OFFSET _HRESULT_TYPEDEF_(E_INVALID_CLR_INSTRUCTION_NATIVE_OFFSET__)
#define E_MANAGED_HEAP_NOT_ENUMERABLE _HRESULT_TYPEDEF_(E_MANAGED_HEAP_NOT_ENUMERABLE__)
#define E_OPERATION_UNAVAILABLE_SCRIPT_INTEROP _HRESULT_TYPEDEF_(E_OPERATION_UNAVAILABLE_SCRIPT_INTEROP__)
#define E_OPERATION_UNAVAILABLE_CLR_NC _HRESULT_TYPEDEF_(E_OPERATION_UNAVAILABLE_CLR_NC__)
#define E_BAD_SYMBOL_DATA _HRESULT_TYPEDEF_(E_BAD_SYMBOL_DATA__)
#define E_ENABLE_SCRIPT_DEBUGGING_FAILED _HRESULT_TYPEDEF_(E_ENABLE_SCRIPT_DEBUGGING_FAILED__)
#define E_SCRIPT_ASYNC_FRAME_EE_UNAVAILABLE _HRESULT_TYPEDEF_(E_SCRIPT_ASYNC_FRAME_EE_UNAVAILABLE__)
#define E_DUMP_NO_THREADS _HRESULT_TYPEDEF_(E_DUMP_NO_THREADS__)
#define E_LOAD_COMPLETE_ALREADY_SENT _HRESULT_TYPEDEF_(E_LOAD_COMPLETE_ALREADY_SENT__)
#define E_LOAD_COMPLETE_DEFERRAL_NOT_FOUND _HRESULT_TYPEDEF_(E_LOAD_COMPLETE_DEFERRAL_NOT_FOUND__)
#define E_MARSHALLING_SIZE_TOO_LARGE _HRESULT_TYPEDEF_(E_MARSHALLING_SIZE_TOO_LARGE__)
#define E_CANNOT_EMULATE_RESULTS_VIEW _HRESULT_TYPEDEF_(E_CANNOT_EMULATE_RESULTS_VIEW__)
#define E_MANAGED_HEAP_ENUMERATION_TARGET_NOT_STOPPED _HRESULT_TYPEDEF_(E_MANAGED_HEAP_ENUMERATION_TARGET_NOT_STOPPED__)
#define E_DBGSHIM_INIT_ERROR _HRESULT_TYPEDEF_(E_DBGSHIM_INIT_ERROR__)
#define E_BP_IN_RUNTIME_MODULE_BLOCKED _HRESULT_TYPEDEF_(E_BP_IN_RUNTIME_MODULE_BLOCKED__)
#define E_DETACH_FAILED_ON_ENC _HRESULT_TYPEDEF_(E_DETACH_FAILED_ON_ENC__)
#define E_MANAGED_HEAP_ENUMERATION_PARTIAL _HRESULT_TYPEDEF_(E_MANAGED_HEAP_ENUMERATION_PARTIAL__)
enum XAPI_HRESULT
{
    // A component dll failed to load. Try to restart this application. If failures continue, try disabling any installed add-ins or repair your installation.
    E_XAPI_COMPONENT_LOAD_FAILURE__ = 0x8EDE0000,
    // Xapi has not been initialized on this thread. Call ComponentManager.InitializeThread.
    E_XAPI_NOT_INITIALIZED__ = 0x8EDE0001,
    // Xapi has already been initialized on this thread.
    E_XAPI_ALREADY_INITIALIZED__ = 0x8EDE0002,
    // Xapi event thread aborted unexpectedly.
    E_XAPI_THREAD_ABORTED__ = 0x8EDE0003,
    // Component failed a call to QueryInterface. QueryInterface implementation or component configuration is incorrect.
    E_XAPI_BAD_QUERY_INTERFACE__ = 0x8EDE0004,
    // Object requested which is not available at the caller's component level.
    E_XAPI_UNAVAILABLE_OBJECT__ = 0x8EDE0005,
    // Failed to process configuration file. Try to restart this application. If failures continue, try to repair your installation.
    E_XAPI_BAD_CONFIG__ = 0x8EDE0006,
    // Failed to initialize managed/native marshalling system. Try to restart this application. If failures continue, try to repair your installation.
    E_XAPI_MANAGED_DISPATCHER_CONNECT_FAILURE__ = 0x8EDE0007,
    // This operation may only be preformed while processing the object's 'Create' event.
    E_XAPI_DURING_CREATE_EVENT_REQUIRED__ = 0x8EDE0008,
    // This operation may only be preformed by the component which created the object.
    E_XAPI_CREATOR_REQUIRED__ = 0x8EDE0009,
    // The work item cannot be appended to the work list because it is already complete.
    E_XAPI_WORK_LIST_COMPLETE__ = 0x8EDE000A,
    // 'Execute' may not be called on a work list which has already started.
    E_XAPI_WORKLIST_ALREADY_STARTED__ = 0x8EDE000B,
    // The interface implementation released the completion routine without calling it.
    E_XAPI_COMPLETION_ROUTINE_RELEASED__ = 0x8EDE000C,
    // Operation is not supported on this thread.
    E_XAPI_WRONG_THREAD__ = 0x8EDE000D,
    // No component with the given component id could be found in the configuration store.
    E_XAPI_COMPONENTID_NOT_FOUND__ = 0x8EDE000E,
    // Call was attempted to a remote connection from a server-side component (component level > 100000). This is not allowed.
    E_XAPI_WRONG_CONNECTION_OBJECT__ = 0x8EDE000F,
    // Destination of this call is on a remote connection and this method doesn't support remoting.
    E_XAPI_METHOD_NOT_REMOTED__ = 0x8EDE0010,
    // The network connection to the Visual Studio Remote Debugger was lost.
    E_XAPI_REMOTE_DISCONNECTED__ = 0x8EDE0011,
    // The network connection to the Visual Studio Remote Debugger has been closed.
    E_XAPI_REMOTE_CLOSED__ = 0x8EDE0012,
    // A protocol compatibility error occurred between Visual Studio and the Remote Debugger. Please ensure that the Visual Studio and Remote debugger versions match.
    E_XAPI_INCOMPATIBLE_PROTOCOL__ = 0x8EDE0013,
    // Maximum allocation size exceeded while processing a remoting message.
    E_XAPI_MAX_PACKET_EXCEEDED__ = 0x8EDE0014,
    // An object already exists with the same key value.
    E_XAPI_OBJECT_ALREADY_EXISTS__ = 0x8EDE0015,
    // An object cannot be found with the given key value.
    E_XAPI_OBJECT_NOT_FOUND__ = 0x8EDE0016,
    // A data item already exists with the same key value.
    E_XAPI_DATA_ITEM_ALREADY_EXISTS__ = 0x8EDE0017,
    // A data item cannot be for this component found with the given data item ID.
    E_XAPI_DATA_ITEM_NOT_FOUND__ = 0x8EDE0018,
    // Interface implementation failed to provide a required out param.
    E_XAPI_NULL_OUT_PARAM__ = 0x8EDE0019,
    // Strong name signature validation error while trying to load the managed dispatcher
    E_XAPI_MANAGED_DISPATCHER_SIGNATURE_ERROR__ = 0x8EDE0020,
    // Method may only be called by components which load in the IDE process (copmonent level > 100000).
    E_XAPI_CLIENT_ONLY_METHOD__ = 0x8EDE0021,
    // Method may only be called by components which load in the remote debugger process (copmonent level < 100000).
    E_XAPI_SERVER_ONLY_METHOD__ = 0x8EDE0022,
    // A component dll could not be found. If failures continue, try disabling any installed add-ins or repairing your installation.
    E_XAPI_COMPONENT_DLL_NOT_FOUND__ = 0x8EDE0023,
    // Operation requires the remote debugger be updated to a newer version.
    E_XAPI_REMOTE_NEW_VER_REQUIRED__ = 0x8EDE0024,
    // An exception was thrown from a debugger component.
    E_XAPI_CALL_EXCEPTION_THROWN__ = 0x8EDE0025,
    // STA threads are not supported in the remote debugger.
    E_XAPI_STA_THREADS_NOT_SUPPORTED__ = 0x8EDE0026
};
#define E_XAPI_COMPONENT_LOAD_FAILURE _HRESULT_TYPEDEF_(E_XAPI_COMPONENT_LOAD_FAILURE__)
#define E_XAPI_NOT_INITIALIZED _HRESULT_TYPEDEF_(E_XAPI_NOT_INITIALIZED__)
#define E_XAPI_ALREADY_INITIALIZED _HRESULT_TYPEDEF_(E_XAPI_ALREADY_INITIALIZED__)
#define E_XAPI_THREAD_ABORTED _HRESULT_TYPEDEF_(E_XAPI_THREAD_ABORTED__)
#define E_XAPI_BAD_QUERY_INTERFACE _HRESULT_TYPEDEF_(E_XAPI_BAD_QUERY_INTERFACE__)
#define E_XAPI_UNAVAILABLE_OBJECT _HRESULT_TYPEDEF_(E_XAPI_UNAVAILABLE_OBJECT__)
#define E_XAPI_BAD_CONFIG _HRESULT_TYPEDEF_(E_XAPI_BAD_CONFIG__)
#define E_XAPI_MANAGED_DISPATCHER_CONNECT_FAILURE _HRESULT_TYPEDEF_(E_XAPI_MANAGED_DISPATCHER_CONNECT_FAILURE__)
#define E_XAPI_DURING_CREATE_EVENT_REQUIRED _HRESULT_TYPEDEF_(E_XAPI_DURING_CREATE_EVENT_REQUIRED__)
#define E_XAPI_CREATOR_REQUIRED _HRESULT_TYPEDEF_(E_XAPI_CREATOR_REQUIRED__)
#define E_XAPI_WORK_LIST_COMPLETE _HRESULT_TYPEDEF_(E_XAPI_WORK_LIST_COMPLETE__)
#define E_XAPI_WORKLIST_ALREADY_STARTED _HRESULT_TYPEDEF_(E_XAPI_WORKLIST_ALREADY_STARTED__)
#define E_XAPI_COMPLETION_ROUTINE_RELEASED _HRESULT_TYPEDEF_(E_XAPI_COMPLETION_ROUTINE_RELEASED__)
#define E_XAPI_WRONG_THREAD _HRESULT_TYPEDEF_(E_XAPI_WRONG_THREAD__)
#define E_XAPI_COMPONENTID_NOT_FOUND _HRESULT_TYPEDEF_(E_XAPI_COMPONENTID_NOT_FOUND__)
#define E_XAPI_WRONG_CONNECTION_OBJECT _HRESULT_TYPEDEF_(E_XAPI_WRONG_CONNECTION_OBJECT__)
#define E_XAPI_METHOD_NOT_REMOTED _HRESULT_TYPEDEF_(E_XAPI_METHOD_NOT_REMOTED__)
#define E_XAPI_REMOTE_DISCONNECTED _HRESULT_TYPEDEF_(E_XAPI_REMOTE_DISCONNECTED__)
#define E_XAPI_REMOTE_CLOSED _HRESULT_TYPEDEF_(E_XAPI_REMOTE_CLOSED__)
#define E_XAPI_INCOMPATIBLE_PROTOCOL _HRESULT_TYPEDEF_(E_XAPI_INCOMPATIBLE_PROTOCOL__)
#define E_XAPI_MAX_PACKET_EXCEEDED _HRESULT_TYPEDEF_(E_XAPI_MAX_PACKET_EXCEEDED__)
#define E_XAPI_OBJECT_ALREADY_EXISTS _HRESULT_TYPEDEF_(E_XAPI_OBJECT_ALREADY_EXISTS__)
#define E_XAPI_OBJECT_NOT_FOUND _HRESULT_TYPEDEF_(E_XAPI_OBJECT_NOT_FOUND__)
#define E_XAPI_DATA_ITEM_ALREADY_EXISTS _HRESULT_TYPEDEF_(E_XAPI_DATA_ITEM_ALREADY_EXISTS__)
#define E_XAPI_DATA_ITEM_NOT_FOUND _HRESULT_TYPEDEF_(E_XAPI_DATA_ITEM_NOT_FOUND__)
#define E_XAPI_NULL_OUT_PARAM _HRESULT_TYPEDEF_(E_XAPI_NULL_OUT_PARAM__)
#define E_XAPI_MANAGED_DISPATCHER_SIGNATURE_ERROR _HRESULT_TYPEDEF_(E_XAPI_MANAGED_DISPATCHER_SIGNATURE_ERROR__)
#define E_XAPI_CLIENT_ONLY_METHOD _HRESULT_TYPEDEF_(E_XAPI_CLIENT_ONLY_METHOD__)
#define E_XAPI_SERVER_ONLY_METHOD _HRESULT_TYPEDEF_(E_XAPI_SERVER_ONLY_METHOD__)
#define E_XAPI_COMPONENT_DLL_NOT_FOUND _HRESULT_TYPEDEF_(E_XAPI_COMPONENT_DLL_NOT_FOUND__)
#define E_XAPI_REMOTE_NEW_VER_REQUIRED _HRESULT_TYPEDEF_(E_XAPI_REMOTE_NEW_VER_REQUIRED__)
#define E_XAPI_CALL_EXCEPTION_THROWN _HRESULT_TYPEDEF_(E_XAPI_CALL_EXCEPTION_THROWN__)
#define E_XAPI_STA_THREADS_NOT_SUPPORTED _HRESULT_TYPEDEF_(E_XAPI_STA_THREADS_NOT_SUPPORTED__)

extern "C"
__declspec(dllimport)
DECLSPEC_NOTHROW
HRESULT STDMETHODCALLTYPE ProcDkmString0(
    const Microsoft::VisualStudio::Debugger::DkmSourceString& InputString,
    Microsoft::VisualStudio::Debugger::DkmString** ppString
    );

extern "C"
__declspec(dllimport)
DECLSPEC_NOTHROW
HRESULT STDMETHODCALLTYPE ProcDkmString1(
    DWORD CodePage,
    _In_bytecount_(cbMultiByte) const char* pMultiByteString,
    size_t cbMultiByte,
    Microsoft::VisualStudio::Debugger::DkmString** ppString
    );

extern "C"
__declspec(dllimport)
DECLSPEC_NOTHROW
int STDMETHODCALLTYPE ProcDkmString2(
    const Microsoft::VisualStudio::Debugger::DkmSourceString& a,
    const Microsoft::VisualStudio::Debugger::DkmSourceString& b
    );

extern "C"
__declspec(dllimport)
DECLSPEC_NOTHROW
int STDMETHODCALLTYPE ProcDkmString3(
    const Microsoft::VisualStudio::Debugger::DkmSourceString& a,
    const Microsoft::VisualStudio::Debugger::DkmSourceString& b
    );


extern "C"
__declspec(dllimport)
DECLSPEC_NOTHROW
HRESULT STDMETHODCALLTYPE ProcDkmString4(
    _In_count_(cSources) const Microsoft::VisualStudio::Debugger::DkmSourceString sources[],
    DWORD cSources,
    Microsoft::VisualStudio::Debugger::DkmString** ppString
    );

extern "C"
__declspec(dllimport)
DECLSPEC_NOTHROW
Microsoft::VisualStudio::Debugger::DkmString* STDMETHODCALLTYPE ProcDkmString5(
    );


extern "C"
__declspec(dllimport)
DECLSPEC_NOTHROW
HRESULT STDMETHODCALLTYPE ProcDkmReadOnlyCollectionCreate(
    _In_count_(ElementCount) const void* source,
    DWORD ElementCount,
    const Microsoft::VisualStudio::Debugger::DkmCollectionElementDescriptor& elementDescriptor,
    void** ppCollection
    );

extern "C"
__declspec(dllimport)
DECLSPEC_NOTHROW
void* STDMETHODCALLTYPE ProcDkmReadOnlyCollectionEmpty(
    );

extern "C"
__declspec(dllimport)
DECLSPEC_NOTHROW
void __declspec(noreturn) STDMETHODCALLTYPE ProcDkmReadOnlyCollectionBadIndex(
    void* pCollection,
    size_t index
    );

extern "C"
__declspec(dllimport)
DECLSPEC_NOTHROW
HRESULT STDMETHODCALLTYPE ProcDkmVariant0(
    _Inout_ VARIANT* pSource,
    _Deref_out_opt_ Microsoft::VisualStudio::Debugger::DkmVariant** ppVariant
    );

extern "C"
__declspec(dllimport)
DECLSPEC_NOTHROW
HRESULT STDMETHODCALLTYPE ProcDkmVariant1(
    _In_count_(size) const BYTE* pValue,
    DWORD size,
    _Deref_out_ Microsoft::VisualStudio::Debugger::DkmVariant** ppVariant
    );

extern "C"
__declspec(dllimport)
DECLSPEC_NOTHROW
LCID STDMETHODCALLTYPE ProcDkmGlobalSettings0();

extern "C"
__declspec(dllimport)
DECLSPEC_NOTHROW
HRESULT STDMETHODCALLTYPE ProcDkmGlobalSettings1(Microsoft::VisualStudio::Debugger::DkmString**);

extern "C"
__declspec(dllimport)
DECLSPEC_NOTHROW
HRESULT STDMETHODCALLTYPE ProcDkmGlobalSettings2(Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<Microsoft::VisualStudio::Debugger::DkmString*>**);

extern "C"
__declspec(dllimport)
DECLSPEC_NOTHROW
HRESULT STDMETHODCALLTYPE ProcDkmGlobalSettings3(Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<Microsoft::VisualStudio::Debugger::DkmString*>**);

extern "C"
__declspec(dllimport)
DECLSPEC_NOTHROW
DWORD STDMETHODCALLTYPE ProcDkmGlobalSettings4();

extern "C"
__declspec(dllimport)
DECLSPEC_NOTHROW
HRESULT STDMETHODCALLTYPE ProcDkmGlobalSettings5(Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<Microsoft::VisualStudio::Debugger::DkmString*>**);

extern "C"
__declspec(dllimport)
DECLSPEC_NOTHROW
HRESULT STDMETHODCALLTYPE ProcDkmGlobalSettings6(LPCWSTR szSubKey, HKEY* phkResult);

extern "C"
__declspec(dllimport)
DECLSPEC_NOTHROW
HRESULT STDMETHODCALLTYPE ProcDkmGlobalSettings7(IUnknown** ppTelemetryService);

#ifndef EXCLUDE_IDE_ONLY_APIS
extern "C"
__declspec(dllimport)
DECLSPEC_NOTHROW
HRESULT STDMETHODCALLTYPE ProcDkmMainVsThread0(Microsoft::VisualStudio::Debugger::IDkmMainThreadRoutine*);
#endif

DECLSPEC_NOTHROW /*static*/ inline HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmString::Create(
    const Microsoft::VisualStudio::Debugger::DkmSourceString& InputString,
    _Deref_out_ Microsoft::VisualStudio::Debugger::DkmString** ppString
    )
{
    return ProcDkmString0(InputString, ppString);
}

DECLSPEC_NOTHROW /*static*/ inline HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmString::Create(
    _In_ DWORD CodePage,
    _In_bytecount_(cbMultiByte) const char* pMultiByteString,
    _In_ size_t cbMultiByte,
    _Deref_out_ Microsoft::VisualStudio::Debugger::DkmString** ppString
    )
{
    return ProcDkmString1(CodePage, pMultiByteString, cbMultiByte, ppString);
}

DECLSPEC_NOTHROW /*static*/ inline int STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmString::CompareOrdinal(
    const Microsoft::VisualStudio::Debugger::DkmSourceString& a,
    const Microsoft::VisualStudio::Debugger::DkmSourceString& b
    )
{
    return ProcDkmString2(a,b);
}

DECLSPEC_NOTHROW /*static*/ inline int STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmString::CompareOrdinalIgnoreCase(
    const Microsoft::VisualStudio::Debugger::DkmSourceString& a,
    const Microsoft::VisualStudio::Debugger::DkmSourceString& b
    )
{
    return ProcDkmString3(a,b);
}

DECLSPEC_NOTHROW /*static*/ inline HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmString::Concat(
    const Microsoft::VisualStudio::Debugger::DkmSourceString& item0,
    const Microsoft::VisualStudio::Debugger::DkmSourceString& item1,
    _Deref_out_ Microsoft::VisualStudio::Debugger::DkmString** ppString
    )
{
    const DkmSourceString sources[] = { item0, item1 };
    return ConcatV(sources, _countof(sources), ppString);
}

DECLSPEC_NOTHROW /*static*/ inline HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmString::Concat(
    const Microsoft::VisualStudio::Debugger::DkmSourceString& item0,
    const Microsoft::VisualStudio::Debugger::DkmSourceString& item1,
    const Microsoft::VisualStudio::Debugger::DkmSourceString& item2,
    _Deref_out_ Microsoft::VisualStudio::Debugger::DkmString** ppString
    )
{
    const DkmSourceString sources[] = { item0, item1, item2 };
    return ConcatV(sources, _countof(sources), ppString);
}

DECLSPEC_NOTHROW /*static*/ inline HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmString::Concat(
    const Microsoft::VisualStudio::Debugger::DkmSourceString& item0,
    const Microsoft::VisualStudio::Debugger::DkmSourceString& item1,
    const Microsoft::VisualStudio::Debugger::DkmSourceString& item2,
    const Microsoft::VisualStudio::Debugger::DkmSourceString& item3,
    _Deref_out_ Microsoft::VisualStudio::Debugger::DkmString** ppString
    )
{
    const DkmSourceString sources[] = { item0, item1, item2, item3 };
    return ConcatV(sources, _countof(sources), ppString);
}

DECLSPEC_NOTHROW /*static*/ inline HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmString::Concat(
    const Microsoft::VisualStudio::Debugger::DkmSourceString& item0,
    const Microsoft::VisualStudio::Debugger::DkmSourceString& item1,
    const Microsoft::VisualStudio::Debugger::DkmSourceString& item2,
    const Microsoft::VisualStudio::Debugger::DkmSourceString& item3,
    const Microsoft::VisualStudio::Debugger::DkmSourceString& item4,
    _Deref_out_ Microsoft::VisualStudio::Debugger::DkmString** ppString
    )
{
    const DkmSourceString sources[] = { item0, item1, item2, item3, item4 };
    return ConcatV(sources, _countof(sources), ppString);
}

DECLSPEC_NOTHROW /*static*/ inline HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmString::Concat(
    const Microsoft::VisualStudio::Debugger::DkmSourceString& item0,
    const Microsoft::VisualStudio::Debugger::DkmSourceString& item1,
    const Microsoft::VisualStudio::Debugger::DkmSourceString& item2,
    const Microsoft::VisualStudio::Debugger::DkmSourceString& item3,
    const Microsoft::VisualStudio::Debugger::DkmSourceString& item4,
    const Microsoft::VisualStudio::Debugger::DkmSourceString& item5,
    _Deref_out_ Microsoft::VisualStudio::Debugger::DkmString** ppString
    )
{
    const DkmSourceString sources[] = { item0, item1, item2, item3, item4, item5 };
    return ConcatV(sources, _countof(sources), ppString);
}

DECLSPEC_NOTHROW /*static*/ inline HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmString::Concat(
    const Microsoft::VisualStudio::Debugger::DkmSourceString& item0,
    const Microsoft::VisualStudio::Debugger::DkmSourceString& item1,
    const Microsoft::VisualStudio::Debugger::DkmSourceString& item2,
    const Microsoft::VisualStudio::Debugger::DkmSourceString& item3,
    const Microsoft::VisualStudio::Debugger::DkmSourceString& item4,
    const Microsoft::VisualStudio::Debugger::DkmSourceString& item5,
    const Microsoft::VisualStudio::Debugger::DkmSourceString& item6,
    _Deref_out_ Microsoft::VisualStudio::Debugger::DkmString** ppString
    )
{
    const DkmSourceString sources[] = { item0, item1, item2, item3, item4, item5, item6 };
    return ConcatV(sources, _countof(sources), ppString);
}

DECLSPEC_NOTHROW /*static*/ inline HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmString::Concat(
    const Microsoft::VisualStudio::Debugger::DkmSourceString& item0,
    const Microsoft::VisualStudio::Debugger::DkmSourceString& item1,
    const Microsoft::VisualStudio::Debugger::DkmSourceString& item2,
    const Microsoft::VisualStudio::Debugger::DkmSourceString& item3,
    const Microsoft::VisualStudio::Debugger::DkmSourceString& item4,
    const Microsoft::VisualStudio::Debugger::DkmSourceString& item5,
    const Microsoft::VisualStudio::Debugger::DkmSourceString& item6,
    const Microsoft::VisualStudio::Debugger::DkmSourceString& item7,
    _Deref_out_ Microsoft::VisualStudio::Debugger::DkmString** ppString
    )
{
    const DkmSourceString sources[] = { item0, item1, item2, item3, item4, item5, item6, item7 };
    return ConcatV(sources, _countof(sources), ppString);
}

DECLSPEC_NOTHROW /*static*/ inline HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmString::Concat(
    const Microsoft::VisualStudio::Debugger::DkmSourceString& item0,
    const Microsoft::VisualStudio::Debugger::DkmSourceString& item1,
    const Microsoft::VisualStudio::Debugger::DkmSourceString& item2,
    const Microsoft::VisualStudio::Debugger::DkmSourceString& item3,
    const Microsoft::VisualStudio::Debugger::DkmSourceString& item4,
    const Microsoft::VisualStudio::Debugger::DkmSourceString& item5,
    const Microsoft::VisualStudio::Debugger::DkmSourceString& item6,
    const Microsoft::VisualStudio::Debugger::DkmSourceString& item7,
    const Microsoft::VisualStudio::Debugger::DkmSourceString& item8,
    _Deref_out_ Microsoft::VisualStudio::Debugger::DkmString** ppString
    )
{
    const DkmSourceString sources[] = { item0, item1, item2, item3, item4, item5, item6, item7, item8 };
    return ConcatV(sources, _countof(sources), ppString);
}

DECLSPEC_NOTHROW /*static*/ inline HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmString::Concat(
    const Microsoft::VisualStudio::Debugger::DkmSourceString& item0,
    const Microsoft::VisualStudio::Debugger::DkmSourceString& item1,
    const Microsoft::VisualStudio::Debugger::DkmSourceString& item2,
    const Microsoft::VisualStudio::Debugger::DkmSourceString& item3,
    const Microsoft::VisualStudio::Debugger::DkmSourceString& item4,
    const Microsoft::VisualStudio::Debugger::DkmSourceString& item5,
    const Microsoft::VisualStudio::Debugger::DkmSourceString& item6,
    const Microsoft::VisualStudio::Debugger::DkmSourceString& item7,
    const Microsoft::VisualStudio::Debugger::DkmSourceString& item8,
    const Microsoft::VisualStudio::Debugger::DkmSourceString& item9,
    _Deref_out_ Microsoft::VisualStudio::Debugger::DkmString** ppString
    )
{
    const DkmSourceString sources[] = { item0, item1, item2, item3, item4, item5, item6, item7, item8, item9 };
    return ConcatV(sources, _countof(sources), ppString);
}

DECLSPEC_NOTHROW /*static*/ inline HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmString::ConcatV(
    _In_count_(cSources) const Microsoft::VisualStudio::Debugger::DkmSourceString sources[],
    _In_ DWORD cSources,
    _Deref_out_ DkmString** ppString
    )
{
#pragma warning(suppress:6385) // Disable 'Invalid data: accessing 'argument 1', the readable size is 'cSources*0' bytes, but '8' bytes might be read'
    return ProcDkmString4(sources, cSources, ppString);
}

_Ret_ DECLSPEC_NOTHROW /*static*/ inline Microsoft::VisualStudio::Debugger::DkmString* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmString::Empty(
    )
{
    return ProcDkmString5();
}

template <class T>
DECLSPEC_NOTHROW /*static*/ inline HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<T>::Create(
    _In_count_(Count) const T* pItemArray,
    _In_ DWORD Count,
    _Deref_out_ DkmReadOnlyCollection<T>** ppCollection
    )
{
    C_ASSERT(__alignof(T) <= 16); // This collection class can only be used with types that require 16-byte alignment or less
    DkmCollectionElementDescriptor elementDescriptor(pItemArray);

    return ProcDkmReadOnlyCollectionCreate(pItemArray, Count, elementDescriptor, (void**)ppCollection);
}

template <class T>
DECLSPEC_NOTHROW /*static*/ inline const T& STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<T>::Element(
    size_t index
    )
{
    if (index >= m_Count)
    {
        ProcDkmReadOnlyCollectionBadIndex(this, index);
    }

    return m_Items[index];
}

template <class T>
_Ret_ DECLSPEC_NOTHROW /*static*/ inline Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<T>* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<T>::Empty(
    )
{
    return (DkmReadOnlyCollection<T>*)ProcDkmReadOnlyCollectionEmpty();
}

DECLSPEC_NOTHROW /*static*/ inline HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmVariant::Convert(
    _Inout_ VARIANT* pSource,
    _Deref_out_opt_ Microsoft::VisualStudio::Debugger::DkmVariant** ppVariant
    )
{
    return ProcDkmVariant0(pSource, ppVariant);
}

DECLSPEC_NOTHROW /*static*/ inline HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmVariant::Create(
    _In_count_(size) const BYTE* pValue,
    DWORD size,
    _Deref_out_ Microsoft::VisualStudio::Debugger::DkmVariant** ppVariant
    )
{
    return ProcDkmVariant1(pValue, size, ppVariant);
}


DECLSPEC_NOTHROW /*static*/ inline LCID STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmGlobalSettings::Locale()
{
    return ProcDkmGlobalSettings0();
}
DECLSPEC_NOTHROW /*static*/ inline HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmGlobalSettings::GetRegistryRoot(_Deref_out_opt_ DkmString** ppValue)
{
    return ProcDkmGlobalSettings1(ppValue);
}
DECLSPEC_NOTHROW /*static*/ inline HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmGlobalSettings::GetVisualizerPaths(_Deref_out_opt_ DkmReadOnlyCollection<DkmString*>** ppValue)
{
    return ProcDkmGlobalSettings2(ppValue);
}
DECLSPEC_NOTHROW /*static*/ inline HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmGlobalSettings::GetStepFilterPaths(_Deref_out_opt_ DkmReadOnlyCollection<DkmString*>** ppValue)
{
    return ProcDkmGlobalSettings3(ppValue);
}
DECLSPEC_NOTHROW /*static*/ inline DWORD STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmGlobalSettings::RootProcessId()
{
    // This method was introduced after the initial version of the API. The caller is
    // responsible for taking steps to ensure that this method is not called when running
    // against earlier versions of vsdebugeng.dll.
    ATLASSERT(DkmComponentManager::IsApiVersionSupported(DkmApiVersion::VS11FeaturePack1) || !"Invalid usage detected. Process will crash or bogus data will be returned");
    return ProcDkmGlobalSettings4();
}
DECLSPEC_NOTHROW /*static*/ inline HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmGlobalSettings::GetJustMyCodePaths(_Deref_out_opt_ DkmReadOnlyCollection<DkmString*>** ppValue)
{
    return ProcDkmGlobalSettings5(ppValue);
}
DECLSPEC_NOTHROW /*static*/ inline HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmGlobalSettings::OpenVSSettingsKey(
    _In_opt_z_ LPCWSTR szSubKey,
    _Out_ HKEY* phkResult
    )
{
    // This method was introduced after the initial version of the API. The caller is
    // responsible for taking steps to ensure that this method is not called when running
    // against earlier versions of vsdebugeng.dll.
    ATLASSERT(DkmComponentManager::IsApiVersionSupported(DkmApiVersion::VS12Update3) || !"Invalid usage detected. Process will crash or bogus data will be returned");
    return ProcDkmGlobalSettings6(szSubKey, phkResult);
}
#ifndef EXCLUDE_IDE_ONLY_APIS
DECLSPEC_NOTHROW /*static*/ inline HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmGlobalSettings::GetVsTelemetryService(_Deref_out_ IUnknown** ppTelemetryService)
{
    // This method was introduced after the initial version of the API. The caller is
    // responsible for taking steps to ensure that this method is not called when running
    // against earlier versions of vsdebugeng.dll.
    ATLASSERT(DkmComponentManager::IsApiVersionSupported(DkmApiVersion::VS14RTM) || !"Invalid usage detected. Process will crash or bogus data will be returned");
    return ProcDkmGlobalSettings7(ppTelemetryService);
}
#endif

#ifndef EXCLUDE_IDE_ONLY_APIS
DECLSPEC_NOTHROW /*static*/ inline HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmMainVsThread::Invoke(_In_ IDkmMainThreadRoutine* pMainThreadRoutine)
{
    return ProcDkmMainVsThread0(pMainThreadRoutine);
}
#endif

extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc1E8D5F0C922FF9B67FDDD80B2ED6503B(Microsoft::VisualStudio::Debugger::DefaultPort::DkmPackagedAppPlatform_t, Microsoft::VisualStudio::Debugger::DkmString*, Microsoft::VisualStudio::Debugger::DefaultPort::DkmAppPackageId**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcEDC75945D166F34184CD05BE77F99EE5(Microsoft::VisualStudio::Debugger::Breakpoints::DkmBoundBreakpoint*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcCAF4269E8986B80CE0D8D9E03E81B4D3(Microsoft::VisualStudio::Debugger::Breakpoints::DkmPendingBreakpoint*, Microsoft::VisualStudio::Debugger::Breakpoints::DkmRuntimeBreakpoint*, Microsoft::VisualStudio::Debugger::Symbols::DkmSourcePosition*, const Microsoft::VisualStudio::Debugger::DkmDataItem&, Microsoft::VisualStudio::Debugger::Breakpoints::DkmBoundBreakpoint**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc220C93F26AF511DF6CEB8F7ED67347FD(Microsoft::VisualStudio::Debugger::Breakpoints::DkmBoundBreakpoint*, Microsoft::VisualStudio::Debugger::DkmThread*, bool);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc8CB5A7081B1ECE9D3867EC558F028B01(Microsoft::VisualStudio::Debugger::Breakpoints::DkmBoundBreakpoint*, Microsoft::VisualStudio::Debugger::DkmWorkList*, Microsoft::VisualStudio::Debugger::IDkmCompletionRoutine<Microsoft::VisualStudio::Debugger::Breakpoints::DkmEnableBoundBreakpointAsyncResult>*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcC8789CC74E265D785FAC9687BCA58590(Microsoft::VisualStudio::Debugger::Breakpoints::DkmBoundBreakpoint*, Microsoft::VisualStudio::Debugger::DkmWorkList*, Microsoft::VisualStudio::Debugger::IDkmCompletionRoutine<Microsoft::VisualStudio::Debugger::Breakpoints::DkmDisableBoundBreakpointAsyncResult>*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcF294D5B58C198B7ACF2AF61B645BFE5E(Microsoft::VisualStudio::Debugger::Breakpoints::DkmBoundBreakpoint*, bool*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcD12950265C8C561E2385E7B1918F3B8B(Microsoft::VisualStudio::Debugger::Breakpoints::DkmBoundBreakpoint*, Microsoft::VisualStudio::Debugger::Breakpoints::DkmBreakpointCondition*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc10B0816A10DF6638455B6A097A890E3A(Microsoft::VisualStudio::Debugger::Breakpoints::DkmBoundBreakpoint*, Microsoft::VisualStudio::Debugger::Breakpoints::DkmBreakpointHitCountCondition*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcDFB5690535A81F9A14E31EEFC96C6363(Microsoft::VisualStudio::Debugger::Breakpoints::DkmBoundBreakpoint*, UINT32);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcB6A0881929281E26ADD0F69F08CB7E3B(Microsoft::VisualStudio::Debugger::Breakpoints::DkmBoundBreakpoint*, Microsoft::VisualStudio::Debugger::DkmWorkList*, Microsoft::VisualStudio::Debugger::IDkmCompletionRoutine<Microsoft::VisualStudio::Debugger::Breakpoints::DkmGetBoundBreakpointHitCountValueAsyncResult>*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcDBD59238A6D89616EAEA09CCF81580D0(Microsoft::VisualStudio::Debugger::Breakpoints::DkmBreakpointConditionOperator_t, const Microsoft::VisualStudio::Debugger::Evaluation::DkmCompilerId&, Microsoft::VisualStudio::Debugger::Evaluation::DkmEvaluationFlags_t, Microsoft::VisualStudio::Debugger::DkmString*, UINT32, Microsoft::VisualStudio::Debugger::Breakpoints::DkmBreakpointCondition**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc06959BB0D92CB78ACC5BB9232D136227(Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<Microsoft::VisualStudio::Debugger::DkmString*>*, Microsoft::VisualStudio::Debugger::Breakpoints::DkmBreakpointFileUpdateNotification**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc15ECE005CF581C5BE953A8E33738CF90(Microsoft::VisualStudio::Debugger::Breakpoints::DkmBreakpointFileUpdateNotification*, Microsoft::VisualStudio::Debugger::DkmWorkList*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc897268949AF157149CA77541A54929EF(Microsoft::VisualStudio::Debugger::Breakpoints::DkmBreakpointHitCountConditionOperator_t, UINT32, Microsoft::VisualStudio::Debugger::Breakpoints::DkmBreakpointHitCountCondition**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc95D0D3C69B29592470F0BAE106585FD5(Microsoft::VisualStudio::Debugger::CallStack::DkmCallStackFilterList*, UINT32, Microsoft::VisualStudio::Debugger::CallStack::DkmStackContext*, Microsoft::VisualStudio::Debugger::CallStack::DkmStackWalkFrame*, Microsoft::VisualStudio::Debugger::DkmArray<Microsoft::VisualStudio::Debugger::CallStack::DkmStackWalkFrame*>*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc8CD293451372A9D9382BD97F8B7920A6(Microsoft::VisualStudio::Debugger::CallStack::DkmCallStackFilterList**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc7076BF819350B9FA03C236373E15B497(Microsoft::VisualStudio::Debugger::Evaluation::DkmInspectionContext*, const GUID&, const GUID&, Microsoft::VisualStudio::Debugger::CallStack::DkmStackWalkFrame*, Microsoft::VisualStudio::Debugger::Evaluation::DkmExpressionValueHome*, Microsoft::VisualStudio::Debugger::Evaluation::DkmEvaluationResult*, Microsoft::VisualStudio::Debugger::Evaluation::DkmVisualizedExpression*, UINT32, const Microsoft::VisualStudio::Debugger::DkmDataItem&, Microsoft::VisualStudio::Debugger::Evaluation::DkmChildVisualizedExpression**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetEE6D45A22822D04D9205C8DEAAD59330(Microsoft::VisualStudio::Debugger::Clr::DkmClrAppDomain*, Microsoft::VisualStudio::Debugger::DkmString**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc547EB931F10F0693AD8703D28E7D7E56(Microsoft::VisualStudio::Debugger::Clr::DkmClrAppDomain*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc04C30C6994A0A82EB150AF86435B3156(UINT32, Microsoft::VisualStudio::Debugger::Clr::DkmClrRuntimeInstance*, Microsoft::VisualStudio::Debugger::DkmString*, const Microsoft::VisualStudio::Debugger::DkmDataItem&, Microsoft::VisualStudio::Debugger::Clr::DkmClrAppDomain**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc433E97E57EED993B1935CE0F8FCDFBC9(Microsoft::VisualStudio::Debugger::Clr::DkmClrAppDomain*, const GUID&, Microsoft::VisualStudio::Debugger::Clr::DkmClrModuleInstance**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcA3074544DDDC4B69C83EE3A63BB51CC0(Microsoft::VisualStudio::Debugger::Clr::DkmClrAppDomain*, Microsoft::VisualStudio::Debugger::DkmArray<Microsoft::VisualStudio::Debugger::Clr::DkmClrModuleInstance*>*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc29ECFBE77883E77E9949C40B2DDD0D24(Microsoft::VisualStudio::Debugger::Clr::DkmClrAppDomain*, ICorDebugAppDomain**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc1A0826709868B99EFD98472E97E97AA8(Microsoft::VisualStudio::Debugger::Clr::DkmClrAppDomain*, Microsoft::VisualStudio::Debugger::Clr::DkmClrModuleInstance**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc956DC35526BAB8F0F7566B0A7A687DB9(Microsoft::VisualStudio::Debugger::Clr::DkmClrAppDomain*, Microsoft::VisualStudio::Debugger::DkmString*, UINT32*, LPCVOID*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc1EC7EADF185F4D6340751CB2DDFA761B(Microsoft::VisualStudio::Debugger::Clr::DkmClrAppDomain*, Microsoft::VisualStudio::Debugger::DkmString*, GUID*, Microsoft::VisualStudio::Debugger::DkmArray<BYTE>*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcEA3353C032D68329DA4409146C8B241F(Microsoft::VisualStudio::Debugger::Clr::DkmClrAppDomain*, Microsoft::VisualStudio::Debugger::DkmString*, GUID*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc46C70E124C967BA573D28ABE0C365815(Microsoft::VisualStudio::Debugger::DkmRuntimeInstance*, Microsoft::VisualStudio::Debugger::DkmThread*, Microsoft::VisualStudio::Debugger::Exceptions::DkmExceptionProcessingStage_t, Microsoft::VisualStudio::Debugger::DkmString*, Microsoft::VisualStudio::Debugger::Clr::DkmClrInstructionAddress*, Microsoft::VisualStudio::Debugger::Clr::DkmClrExceptionInformation**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc86E901A98609A3892236B80CC83BC545(Microsoft::VisualStudio::Debugger::Clr::DkmClrRuntimeInstance*, Microsoft::VisualStudio::Debugger::Clr::DkmClrModuleInstance*, const Microsoft::VisualStudio::Debugger::Clr::DkmClrMethodId&, UINT32, UINT32, const Microsoft::VisualStudio::Debugger::DkmInstructionAddress::CPUInstruction*, Microsoft::VisualStudio::Debugger::Clr::DkmClrInstructionAddress**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcCA87389EB16C25D55399B86CC7697716(Microsoft::VisualStudio::Debugger::Clr::DkmClrInstructionAddress*, Microsoft::VisualStudio::Debugger::Clr::DkmNonUserCodeFlags_t*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc68D78BE71363649843A328B368564247(Microsoft::VisualStudio::Debugger::Clr::DkmClrInstructionAddress*, Microsoft::VisualStudio::Debugger::CallStack::DkmStackWalkFrame*, Microsoft::VisualStudio::Debugger::DkmArray<Microsoft::VisualStudio::Debugger::Clr::DkmClrNativeCodeMapEntry>*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc9514CD34D91549CCC50F8A227CDD1ACD(Microsoft::VisualStudio::Debugger::Clr::DkmClrInstructionAddress*, ICorDebugFunction**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc04CC599737BBF61C58A0FFFE1C870BEE(Microsoft::VisualStudio::Debugger::Clr::DkmClrInstructionAddress*, bool*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcCE0EAB9E1275E364CAA5CDF5BF2BF219(Microsoft::VisualStudio::Debugger::Symbols::DkmModule*, const Microsoft::VisualStudio::Debugger::Clr::DkmClrMethodId&, UINT32, Microsoft::VisualStudio::Debugger::Clr::DkmClrInstructionSymbol**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc49AD48ADCB8A261A843D2BA12C9F32C5(Microsoft::VisualStudio::Debugger::Clr::DkmClrInstructionSymbol*, Microsoft::VisualStudio::Debugger::Clr::DkmClrAsyncMethodLocation_t*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc27CEF809C4A5195C4D6661A549F86174(Microsoft::VisualStudio::Debugger::Clr::DkmClrInstructionSymbol*, Microsoft::VisualStudio::Debugger::DkmWorkList*, Microsoft::VisualStudio::Debugger::IDkmCompletionRoutine<Microsoft::VisualStudio::Debugger::Clr::DkmGetAsyncMethodLocationAsyncResult>*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc55C9EB068F3F789821C74F5AA300C95A(Microsoft::VisualStudio::Debugger::Clr::DkmClrInstructionSymbol*, Microsoft::VisualStudio::Debugger::DkmArray<Microsoft::VisualStudio::Debugger::Clr::DkmClrAwaitExpressionInfo>*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcA4C73DE4731C0DDF331ED2FDB8844E4D(Microsoft::VisualStudio::Debugger::Clr::DkmClrInstructionSymbol*, Microsoft::VisualStudio::Debugger::DkmWorkList*, Microsoft::VisualStudio::Debugger::IDkmCompletionRoutine<Microsoft::VisualStudio::Debugger::Clr::DkmGetAllAwaitExpressionInfoForStatementAsyncResult>*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcE4BE46E4F2212642D86BC4DCBC0F16DE(Microsoft::VisualStudio::Debugger::Clr::DkmClrInstructionSymbol*, bool*, UINT32*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc0AB3766D13B1A2E65AADEEF04F334E90(Microsoft::VisualStudio::Debugger::Clr::DkmClrInstructionSymbol*, Microsoft::VisualStudio::Debugger::Clr::DkmClrAwaitExpressionInfo*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc73D36C87372025D0A2C8F5A4D47D55B8(Microsoft::VisualStudio::Debugger::Clr::DkmClrInstructionSymbol*, Microsoft::VisualStudio::Debugger::DkmWorkList*, Microsoft::VisualStudio::Debugger::IDkmCompletionRoutine<Microsoft::VisualStudio::Debugger::Clr::DkmGetNextAwaitExpressionInfoAsyncResult>*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcA02F1303E8DBAEECF20626244D70D1FE(Microsoft::VisualStudio::Debugger::Clr::DkmClrInstructionSymbol*, UINT32*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc98766C6DD35ADF90EA215031CEB4FDCB(Microsoft::VisualStudio::Debugger::Clr::DkmClrInstructionSymbol*, Microsoft::VisualStudio::Debugger::DkmWorkList*, Microsoft::VisualStudio::Debugger::IDkmCompletionRoutine<Microsoft::VisualStudio::Debugger::Clr::DkmGetAsyncKickoffMethodAsyncResult>*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcA933649E990648AA1B06DB796A61472B(Microsoft::VisualStudio::Debugger::Clr::DkmClrInstructionSymbol*, Microsoft::VisualStudio::Debugger::DkmArray<Microsoft::VisualStudio::Debugger::Clr::DkmClrMethodScopeData>*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc54648C4626062C911464BDF85C437D99(Microsoft::VisualStudio::Debugger::Clr::DkmClrInstructionSymbol*, Microsoft::VisualStudio::Debugger::DkmWorkList*, Microsoft::VisualStudio::Debugger::IDkmCompletionRoutine<Microsoft::VisualStudio::Debugger::Clr::DkmGetMethodLocalSymbolsAsyncResult>*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc0FEE6D1828309260C0A02D36CE0D615B(Microsoft::VisualStudio::Debugger::Clr::DkmClrInstructionSymbol*, Microsoft::VisualStudio::Debugger::DkmString*, Microsoft::VisualStudio::Debugger::DkmArray<BYTE>*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcB66B51DF3FDA3AB6DBF96A21F58208D6(Microsoft::VisualStudio::Debugger::Clr::DkmClrInstructionSymbol*, Microsoft::VisualStudio::Debugger::DkmWorkList*, Microsoft::VisualStudio::Debugger::DkmString*, Microsoft::VisualStudio::Debugger::IDkmCompletionRoutine<Microsoft::VisualStudio::Debugger::Clr::DkmGetMethodSymbolStoreAttributeAsyncResult>*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc149EE765B2389BDD6C5B91E33BDBE963(Microsoft::VisualStudio::Debugger::Symbols::DkmModule*, Microsoft::VisualStudio::Debugger::DkmString*, Microsoft::VisualStudio::Debugger::DkmVariant*, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<BYTE>*, Microsoft::VisualStudio::Debugger::Clr::DkmClrLocalConstant**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc69943C1ACC9E2BF01923C60E0ADABD4A(Microsoft::VisualStudio::Debugger::Clr::DkmClrLocalConstant*, Microsoft::VisualStudio::Debugger::DkmArray<BYTE>*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcC58244BD2C547AB8EB3BF80233F4021A(Microsoft::VisualStudio::Debugger::Symbols::DkmModule*, Microsoft::VisualStudio::Debugger::DkmString*, UINT32, UINT32, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<BYTE>*, Microsoft::VisualStudio::Debugger::Clr::DkmClrLocalVariable**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc65A467389235866CD2C6B92C00AE6D2A(Microsoft::VisualStudio::Debugger::Clr::DkmClrLocalVariable*, Microsoft::VisualStudio::Debugger::DkmArray<BYTE>*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW int STDMETHODCALLTYPE Proc876A5E63BBBE04526596CB8A99A5E9E0(const Microsoft::VisualStudio::Debugger::Clr::DkmClrMethodId&, const Microsoft::VisualStudio::Debugger::Clr::DkmClrMethodId&);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW void STDMETHODCALLTYPE ProcC0378E1124166D86890CA327620CB640(Microsoft::VisualStudio::Debugger::Clr::DkmClrMethodScopeData*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcA9BDAC6B67EE4CBC82EDEA2AB8AA48EF(Microsoft::VisualStudio::Debugger::DkmString*, Microsoft::VisualStudio::Debugger::DkmString*, UINT64, Microsoft::VisualStudio::Debugger::DkmModuleVersion*, Microsoft::VisualStudio::Debugger::Symbols::DkmSymbolFileId*, Microsoft::VisualStudio::Debugger::DkmModuleFlags_t, Microsoft::VisualStudio::Debugger::DkmModuleMemoryLayout_t, UINT64, UINT32, UINT32, Microsoft::VisualStudio::Debugger::DkmString*, Microsoft::VisualStudio::Debugger::Clr::DkmClrRuntimeInstance*, const GUID&, Microsoft::VisualStudio::Debugger::Clr::DkmClrModuleFlags_t, Microsoft::VisualStudio::Debugger::Clr::DkmClrAppDomain*, bool, Microsoft::VisualStudio::Debugger::Symbols::DkmModule*, const Microsoft::VisualStudio::Debugger::DkmModuleInstance::MinidumpInfo*, const Microsoft::VisualStudio::Debugger::DkmDataItem&, Microsoft::VisualStudio::Debugger::Clr::DkmClrModuleInstance**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcAEA58B7861C86E08A55546A1C4D0ACAD(Microsoft::VisualStudio::Debugger::DkmString*, Microsoft::VisualStudio::Debugger::DkmString*, UINT64, Microsoft::VisualStudio::Debugger::DkmModuleVersion*, Microsoft::VisualStudio::Debugger::Symbols::DkmSymbolFileId*, Microsoft::VisualStudio::Debugger::DkmModuleFlags_t, Microsoft::VisualStudio::Debugger::DkmModuleMemoryLayout_t, UINT64, UINT32, UINT32, Microsoft::VisualStudio::Debugger::DkmString*, Microsoft::VisualStudio::Debugger::Clr::DkmClrRuntimeInstance*, const GUID&, Microsoft::VisualStudio::Debugger::Clr::DkmClrModuleFlags_t, Microsoft::VisualStudio::Debugger::Clr::DkmClrAppDomain*, UINT32, bool, Microsoft::VisualStudio::Debugger::Symbols::DkmModule*, const Microsoft::VisualStudio::Debugger::DkmModuleInstance::MinidumpInfo*, const Microsoft::VisualStudio::Debugger::DkmDataItem&, Microsoft::VisualStudio::Debugger::Clr::DkmClrModuleInstance**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcF4BC786AEBAC294EE9C4C0BB1B0F56A7(Microsoft::VisualStudio::Debugger::Clr::DkmClrModuleInstance*, IUnknown**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc423E0CAAC5C839003AD794CCD62FA0AC(Microsoft::VisualStudio::Debugger::Clr::DkmClrModuleInstance*, Microsoft::VisualStudio::Debugger::DkmArray<BYTE>*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc007981F40FEA39E044F4D8CF4A9AC416(Microsoft::VisualStudio::Debugger::Clr::DkmClrModuleInstance*, ICorDebugModule**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcCFC27B46EBDEFADA1E91D0A90B77634C(Microsoft::VisualStudio::Debugger::Clr::DkmClrModuleInstance*, Microsoft::VisualStudio::Debugger::DkmString*, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<Microsoft::VisualStudio::Debugger::Clr::DkmClrType*>*, Microsoft::VisualStudio::Debugger::Clr::DkmClrType**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcC2A7595A78323D9ED538F97DF8858518(Microsoft::VisualStudio::Debugger::Clr::DkmClrModuleInstance*, const Microsoft::VisualStudio::Debugger::Clr::DkmClrMethodId&, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<Microsoft::VisualStudio::Debugger::Clr::DkmClrType*>*, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<Microsoft::VisualStudio::Debugger::Clr::DkmClrType*>*, Microsoft::VisualStudio::Debugger::Clr::DkmILInterpreterValue*, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<Microsoft::VisualStudio::Debugger::Clr::DkmILInterpreterValue*>*, UINT32, Microsoft::VisualStudio::Debugger::Clr::DkmILInterpreterOptions_t, Microsoft::VisualStudio::Debugger::Clr::DkmILInterpreterValue**, Microsoft::VisualStudio::Debugger::DkmString**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcBA9A7ADBEAC8F47A27529954272992A2(Microsoft::VisualStudio::Debugger::Clr::DkmClrModuleInstance*, Microsoft::VisualStudio::Debugger::Clr::DkmMetadataStatus_t*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc21CE24614A03FAC406FB8A39D7D56627(Microsoft::VisualStudio::Debugger::Clr::DkmClrModuleInstance*, UINT32*, LPCVOID*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcF2D46E24A8C073A9344BD0846AEF9CA1(Microsoft::VisualStudio::Debugger::Clr::DkmClrModuleInstance*, UINT32, UINT32*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc7BA9C35CB6604944814CAD70CD48C7AD(Microsoft::VisualStudio::Debugger::Clr::DkmClrModuleInstance*, Microsoft::VisualStudio::Debugger::DkmString*, Microsoft::VisualStudio::Debugger::DkmString*, Microsoft::VisualStudio::Debugger::DkmArray<UINT32>*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc0CDF6394547B1FFF45B26226166278EC(Microsoft::VisualStudio::Debugger::Clr::DkmClrModuleInstance*, Microsoft::VisualStudio::Debugger::DkmWorkList*, Microsoft::VisualStudio::Debugger::DkmString*, Microsoft::VisualStudio::Debugger::DkmString*, Microsoft::VisualStudio::Debugger::IDkmCompletionRoutine<Microsoft::VisualStudio::Debugger::Clr::DkmGetMethodTokensAsyncResult>*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcA5B161350506D3C0213719EA3CA946C7(Microsoft::VisualStudio::Debugger::DkmProcess*, const Microsoft::VisualStudio::Debugger::DkmRuntimeInstanceId&, Microsoft::VisualStudio::Debugger::DkmString*, Microsoft::VisualStudio::Debugger::DkmString*, const Microsoft::VisualStudio::Debugger::DkmDataItem&, Microsoft::VisualStudio::Debugger::Clr::DkmClrRuntimeInstance**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcA8484D0DF6D845608CC611EB2C6E61F9(Microsoft::VisualStudio::Debugger::DkmProcess*, const Microsoft::VisualStudio::Debugger::DkmRuntimeInstanceId&, Microsoft::VisualStudio::Debugger::DkmRuntimeCapabilities_t, Microsoft::VisualStudio::Debugger::DkmRuntimeInstance*, Microsoft::VisualStudio::Debugger::DkmString*, Microsoft::VisualStudio::Debugger::DkmString*, const Microsoft::VisualStudio::Debugger::DkmDataItem&, Microsoft::VisualStudio::Debugger::Clr::DkmClrRuntimeInstance**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc494202493BBFB43009A6715156984C4D(Microsoft::VisualStudio::Debugger::Clr::DkmClrRuntimeInstance*, UINT32, Microsoft::VisualStudio::Debugger::Clr::DkmClrAppDomain**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc30CD194706F2789B39BDA5888D5809D6(Microsoft::VisualStudio::Debugger::Clr::DkmClrRuntimeInstance*, Microsoft::VisualStudio::Debugger::DkmArray<Microsoft::VisualStudio::Debugger::Clr::DkmClrAppDomain*>*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc81F4DF12CD2E79C82CFA7D02F085DE1D(Microsoft::VisualStudio::Debugger::Clr::DkmClrRuntimeInstance*, ICorDebugModule*, Microsoft::VisualStudio::Debugger::Clr::DkmClrModuleInstance**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc7AC8F22DCEDC5109A8CFCCDB1698A28C(Microsoft::VisualStudio::Debugger::Clr::DkmClrRuntimeInstance*, Microsoft::VisualStudio::Debugger::DkmThread*, ICorDebugThread**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc4F2ACCA282DF893ACD2710806F488982(Microsoft::VisualStudio::Debugger::Clr::DkmClrRuntimeInstance*, ICorDebugProcess**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc47E089E532D16825286594316453806D(Microsoft::VisualStudio::Debugger::Clr::DkmClrRuntimeInstance*, Microsoft::VisualStudio::Debugger::DkmThread*, bool*, UINT64*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc0132C3722F8DEFF0E84DABDD6B5DCCBA(Microsoft::VisualStudio::Debugger::Clr::DkmClrRuntimeInstance*, Microsoft::VisualStudio::Debugger::DkmThread*, bool);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcA58F0A1DAF5C4DEA3A4923BA8F90EF34(Microsoft::VisualStudio::Debugger::Clr::DkmClrRuntimeInstance*, Microsoft::VisualStudio::Debugger::DkmThread*, ICorDebugEval*, Microsoft::VisualStudio::Debugger::Evaluation::DkmFuncEvalFlags_t, UINT32, Microsoft::VisualStudio::Debugger::DkmString*, HRESULT*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc4C53A066D18791671CC9C01BFA0C6D8D(Microsoft::VisualStudio::Debugger::Clr::DkmClrRuntimeInstance*, Microsoft::VisualStudio::Debugger::DkmThread*, HRESULT*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc7FA2ACD6DAD998180F54B053E883C4E7(Microsoft::VisualStudio::Debugger::Clr::DkmClrRuntimeInstance*, Microsoft::VisualStudio::Debugger::Evaluation::DkmInspectionContext*, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<Microsoft::VisualStudio::Debugger::Clr::DkmClrAlias*>**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc0AAAE1549C1585A26F4F8EE8C9257B0E(Microsoft::VisualStudio::Debugger::Clr::DkmClrRuntimeInstance*, UINT32*, LPCVOID*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc401508E48EF424452285528230DAFD68(Microsoft::VisualStudio::Debugger::Clr::DkmClrRuntimeInstance*, Microsoft::VisualStudio::Debugger::DkmThread*, UINT64, const GUID&, IUnknown**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW void STDMETHODCALLTYPE ProcC3CB7743B5DBB83116E9365BACFA6AF3(Microsoft::VisualStudio::Debugger::Symbols::DkmCodeViewCompilerId*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc0C158E97206654F945E7158521D7796B(Microsoft::VisualStudio::Debugger::DkmRuntimeInstance*, const GUID&, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<BYTE>*, Microsoft::VisualStudio::Debugger::Evaluation::DkmCompiledCustomInspectionQuery**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcF163E94993A30EF0B0CE551E602CAB26(Microsoft::VisualStudio::Debugger::DkmRuntimeInstance*, const GUID&, Microsoft::VisualStudio::Debugger::Evaluation::DkmCustomDataContainer*, const Microsoft::VisualStudio::Debugger::Evaluation::DkmCompilerId&, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<BYTE>*, Microsoft::VisualStudio::Debugger::Evaluation::DkmCompiledCustomInspectionQuery**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcB0E7C63F4B37AB192D3B02A003BD771F(Microsoft::VisualStudio::Debugger::DkmRuntimeInstance*, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILInstruction*>*, Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmCompiledILInspectionQuery**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc15E2FB5FD78B7B4EFDEAE0EBD5FEC28A(Microsoft::VisualStudio::Debugger::DkmRuntimeInstance*, Microsoft::VisualStudio::Debugger::Evaluation::DkmCustomDataContainer*, const Microsoft::VisualStudio::Debugger::Evaluation::DkmCompilerId&, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILInstruction*>*, Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmCompiledILInspectionQuery**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc52A14AC059F0DEB8A5DD37CE238BCAA4(Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmCompiledILInspectionQuery*, Microsoft::VisualStudio::Debugger::Evaluation::DkmILContext*, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<UINT64>*, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<Microsoft::VisualStudio::Debugger::Evaluation::Group::DkmILParameterValueCollection*>*, Microsoft::VisualStudio::Debugger::Evaluation::Group::DkmContextGroupEvaluationILResult**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc99FA7DE19BFA48E79B8C772F04C5C0F7(Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmCompiledILInspectionQuery*, Microsoft::VisualStudio::Debugger::DkmWorkList*, Microsoft::VisualStudio::Debugger::Evaluation::DkmILContext*, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<UINT64>*, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<Microsoft::VisualStudio::Debugger::Evaluation::Group::DkmILParameterValueCollection*>*, Microsoft::VisualStudio::Debugger::IDkmCompletionRoutine<Microsoft::VisualStudio::Debugger::Evaluation::Group::DkmExecuteQueryOnThreadsAsyncResult>*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc830BF1EC32B2D50A6F454C73132E8D95(Microsoft::VisualStudio::Debugger::Evaluation::DkmCompiledInspectionQuery*, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILParameterValue*>*, Microsoft::VisualStudio::Debugger::Evaluation::DkmILContext*, UINT32, Microsoft::VisualStudio::Debugger::Evaluation::DkmFuncEvalFlags_t, Microsoft::VisualStudio::Debugger::DkmArray<Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILEvaluationResult*>*, Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILFailureReason_t*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcDAC5F1C0332F717B7A78BCF000B235F3(Microsoft::VisualStudio::Debugger::Evaluation::DkmCompiledInspectionQuery*, Microsoft::VisualStudio::Debugger::DkmWorkList*, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILParameterValue*>*, Microsoft::VisualStudio::Debugger::Evaluation::DkmILContext*, UINT32, Microsoft::VisualStudio::Debugger::Evaluation::DkmFuncEvalFlags_t, Microsoft::VisualStudio::Debugger::IDkmCompletionRoutine<Microsoft::VisualStudio::Debugger::Evaluation::DkmExecuteQueryAsyncResult>*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcFB899FA0AA542ED4551771DA143A14EC(Microsoft::VisualStudio::Debugger::Evaluation::DkmCompiledInspectionQuery*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc8EE5D07204FC6772B1A9B4184A9B15A8(Microsoft::VisualStudio::Debugger::Evaluation::DkmCompiledInspectionQuery*, Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILFailureReason_t, Microsoft::VisualStudio::Debugger::DkmString**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW int STDMETHODCALLTYPE Proc558180C0AA1756192A5B4EECD2C72DAE(const Microsoft::VisualStudio::Debugger::Evaluation::DkmCompilerId&, const Microsoft::VisualStudio::Debugger::Evaluation::DkmCompilerId&);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW void STDMETHODCALLTYPE Proc2CC5FE15ED9552B8D71D8052FAB0ABA3(Microsoft::VisualStudio::Debugger::GPU::DkmComputeProperty*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcD1951845DC0A598B7D01BE514C5C6242(HRESULT, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<Microsoft::VisualStudio::Debugger::Evaluation::Group::DkmThreadEvaluationResultCollection*>*, Microsoft::VisualStudio::Debugger::Evaluation::Group::DkmContextGroupEvaluationILResult**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc99CFA8EC6ABD1D93AFE145CA709A7FBD(Microsoft::VisualStudio::Debugger::Evaluation::Group::DkmContextGroupEvaluationResult*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcA53162B525391FF931A42627F7AAD6A9(Microsoft::VisualStudio::Debugger::DkmRuntimeInstance*, Microsoft::VisualStudio::Debugger::DkmThread*, Microsoft::VisualStudio::Debugger::DkmInstructionAddress*, Microsoft::VisualStudio::Debugger::Exceptions::DkmExceptionProcessingStage_t, Microsoft::VisualStudio::Debugger::Exceptions::DkmExceptionInformation*, Microsoft::VisualStudio::Debugger::DkmString*, UINT64, UINT64, Microsoft::VisualStudio::Debugger::Native::DkmCppWinRTExceptionInformation*, Microsoft::VisualStudio::Debugger::Native::DkmCppExceptionInformation**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc6DFAC5682AB3B324F2B704053BEE6004(Microsoft::VisualStudio::Debugger::DkmString*, Microsoft::VisualStudio::Debugger::DkmString*, Microsoft::VisualStudio::Debugger::DkmString*, Microsoft::VisualStudio::Debugger::DkmString*, HRESULT, Microsoft::VisualStudio::Debugger::Native::DkmCppWinRTExceptionInformation**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc424C754CDDD2CF45A942C20EED3CC893(Microsoft::VisualStudio::Debugger::DkmString*, Microsoft::VisualStudio::Debugger::DkmString*, Microsoft::VisualStudio::Debugger::DkmString*, Microsoft::VisualStudio::Debugger::DkmString*, HRESULT, UINT64, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<Microsoft::VisualStudio::Debugger::DkmInstructionAddress*>*, Microsoft::VisualStudio::Debugger::Native::DkmCppWinRTExceptionInformation**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc0293D2889DE6E0C14B909BC2A4CE0670(Microsoft::VisualStudio::Debugger::DkmRuntimeInstance*, const GUID&, Microsoft::VisualStudio::Debugger::DkmThread*, Microsoft::VisualStudio::Debugger::DkmInstructionAddress*, Microsoft::VisualStudio::Debugger::DkmString*, UINT32, Microsoft::VisualStudio::Debugger::Exceptions::DkmExceptionProcessingStage_t, Microsoft::VisualStudio::Debugger::Exceptions::DkmExceptionInformation*, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<BYTE>*, Microsoft::VisualStudio::Debugger::CustomRuntimes::DkmCustomExceptionInformation**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcE315DFDB6AEB76AA580E27B52F91F5AF(Microsoft::VisualStudio::Debugger::DkmRuntimeInstance*, Microsoft::VisualStudio::Debugger::CustomRuntimes::DkmCustomModuleInstance*, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<BYTE>*, UINT64, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<BYTE>*, const Microsoft::VisualStudio::Debugger::DkmInstructionAddress::CPUInstruction*, Microsoft::VisualStudio::Debugger::CustomRuntimes::DkmCustomInstructionAddress**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc166F47D8BD25C8CC59B1502B3F4A5DDB(Microsoft::VisualStudio::Debugger::Symbols::DkmModule*, const GUID&, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<BYTE>*, UINT64, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<BYTE>*, Microsoft::VisualStudio::Debugger::CustomRuntimes::DkmCustomInstructionSymbol**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc6D698C640DFDABA88B6B6A8B78565B1C(Microsoft::VisualStudio::Debugger::DefaultPort::DkmTransportConnection*, Microsoft::VisualStudio::Debugger::DkmProcess*, const GUID&, UINT32, Microsoft::VisualStudio::Debugger::DkmVariant*, Microsoft::VisualStudio::Debugger::DkmVariant*, Microsoft::VisualStudio::Debugger::DkmCustomMessage**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc5C808A6463557CF774E01775628F0DCA(Microsoft::VisualStudio::Debugger::DkmCustomMessage*, Microsoft::VisualStudio::Debugger::DkmThread*, const GUID&);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc1BAFA69EABAF1980E4618AC80AEECB47(Microsoft::VisualStudio::Debugger::DkmCustomMessage*, Microsoft::VisualStudio::Debugger::DkmCustomMessage**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcA035DEDBF7F91EB78B75DE7CDEB4644C(Microsoft::VisualStudio::Debugger::DkmCustomMessage*, Microsoft::VisualStudio::Debugger::DkmCustomMessage**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc73CBBC77F9E0A5C530459780952936FE(Microsoft::VisualStudio::Debugger::DkmCustomMessage*, Microsoft::VisualStudio::Debugger::DkmWorkList*, Microsoft::VisualStudio::Debugger::IDkmCompletionRoutine<Microsoft::VisualStudio::Debugger::DkmSendLowerAsyncResult>*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc387497D446792B6386776489669D2D7B(Microsoft::VisualStudio::Debugger::DkmCustomMessage*, const GUID&, bool);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcCCE122D321D1AFDE76D7CACE58F839C7(Microsoft::VisualStudio::Debugger::DkmString*, Microsoft::VisualStudio::Debugger::DkmString*, UINT64, Microsoft::VisualStudio::Debugger::DkmRuntimeInstance*, Microsoft::VisualStudio::Debugger::DkmModuleVersion*, Microsoft::VisualStudio::Debugger::Symbols::DkmSymbolFileId*, Microsoft::VisualStudio::Debugger::DkmModuleFlags_t, Microsoft::VisualStudio::Debugger::DkmModuleMemoryLayout_t, UINT64, UINT32, UINT32, Microsoft::VisualStudio::Debugger::DkmString*, bool, Microsoft::VisualStudio::Debugger::Symbols::DkmModule*, const Microsoft::VisualStudio::Debugger::DkmModuleInstance::MinidumpInfo*, const Microsoft::VisualStudio::Debugger::DkmDataItem&, Microsoft::VisualStudio::Debugger::CustomRuntimes::DkmCustomModuleInstance**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc3C62BEDE7059A6F82EF5950D9B08F212(Microsoft::VisualStudio::Debugger::DkmInstructionAddress*, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<BYTE>*, Microsoft::VisualStudio::Debugger::Evaluation::DkmCustomRawReturnValue**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc0F93893A27AD0F7C9A3E108C73ABCEF6(Microsoft::VisualStudio::Debugger::DkmProcess*, const Microsoft::VisualStudio::Debugger::DkmRuntimeInstanceId&, const Microsoft::VisualStudio::Debugger::DkmDataItem&, Microsoft::VisualStudio::Debugger::CustomRuntimes::DkmCustomRuntimeInstance**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc1A4BA89C2192C5ED79E0F488CA118164(Microsoft::VisualStudio::Debugger::DkmProcess*, const Microsoft::VisualStudio::Debugger::DkmRuntimeInstanceId&, Microsoft::VisualStudio::Debugger::DkmRuntimeCapabilities_t, Microsoft::VisualStudio::Debugger::DkmRuntimeInstance*, const Microsoft::VisualStudio::Debugger::DkmDataItem&, Microsoft::VisualStudio::Debugger::CustomRuntimes::DkmCustomRuntimeInstance**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc439EB6AA207DB70F8ED3430FFCAB70A6(const GUID&, UINT32, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<BYTE>*, Microsoft::VisualStudio::Debugger::Symbols::DkmCustomSymbolFileId**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcA9F782A3E84B2CDB9646FDCE26477F26(UINT32, Microsoft::VisualStudio::Debugger::DkmString*, Microsoft::VisualStudio::Debugger::DkmString*, Microsoft::VisualStudio::Debugger::DkmString*, Microsoft::VisualStudio::Debugger::Evaluation::DkmCustomUIVisualizerInfo**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcB483EE2298133236098B18BE15BBBC8C(UINT32, Microsoft::VisualStudio::Debugger::DkmString*, Microsoft::VisualStudio::Debugger::DkmString*, Microsoft::VisualStudio::Debugger::DkmString*, Microsoft::VisualStudio::Debugger::DkmString*, Microsoft::VisualStudio::Debugger::DkmString*, Microsoft::VisualStudio::Debugger::Evaluation::DkmClrCustomVisualizerAssemblyLocation_t, Microsoft::VisualStudio::Debugger::DkmString*, Microsoft::VisualStudio::Debugger::DkmString*, Microsoft::VisualStudio::Debugger::Evaluation::DkmCustomUIVisualizerInfo**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc76C4E68C18BC734895D4A803EED86642(Microsoft::VisualStudio::Debugger::DkmRuntimeInstance*, UINT64, Microsoft::VisualStudio::Debugger::DkmInstructionAddress*, Microsoft::VisualStudio::Debugger::Evaluation::DkmDataAddress**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcD1BDFF0E74198F9E97B1200C099D36B2(Microsoft::VisualStudio::Debugger::DkmString*, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<GUID>*, Microsoft::VisualStudio::Debugger::Start::DkmDebugLaunchSettings**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc3B2F13165414C4F66EE876593C947FF7(Microsoft::VisualStudio::Debugger::Start::DkmDebugLaunchSettings*, Microsoft::VisualStudio::Debugger::Start::DkmProcessLaunchEnvironmentFilterScenario_t, Microsoft::VisualStudio::Debugger::DkmString**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc1770D48A2E0076C5FD8CC68B89308134(Microsoft::VisualStudio::Debugger::Start::DkmDebugLaunchSettings*, Microsoft::VisualStudio::Debugger::DkmEngineSettings*, bool*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc55CE06AE749FE4FDB97CE54A455619A3(Microsoft::VisualStudio::Debugger::DefaultPort::DkmDeploymentCommand*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc8FCA18285F43AB559217B26B94231774(Microsoft::VisualStudio::Debugger::DefaultPort::DkmTransportConnection*, const GUID&, Microsoft::VisualStudio::Debugger::DkmString*, Microsoft::VisualStudio::Debugger::DkmString*, Microsoft::VisualStudio::Debugger::DkmString*, Microsoft::VisualStudio::Debugger::DefaultPort::DkmDeploymentCommandFlags_t, const Microsoft::VisualStudio::Debugger::DkmDataItem&, Microsoft::VisualStudio::Debugger::DefaultPort::DkmDeploymentCommand**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc533B990E9F9B15A54DDC4E3E1D2E1078(Microsoft::VisualStudio::Debugger::DefaultPort::DkmDeploymentCommand*, UINT32);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcCE2CA685D8412F7CDB1945E19E677AEA(Microsoft::VisualStudio::Debugger::DefaultPort::DkmDeploymentCommand*, Microsoft::VisualStudio::Debugger::DkmString*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcA8DA7BD7B83089DE1427BED550F265FD(Microsoft::VisualStudio::Debugger::DefaultPort::DkmDeploymentCommand*, Microsoft::VisualStudio::Debugger::DkmString*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc72A6761FCC1029893756B99ADC6B9E6C(Microsoft::VisualStudio::Debugger::DefaultPort::DkmDeploymentCommand*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc86DE7C8070519AEDC00A37E1FA5E127C(Microsoft::VisualStudio::Debugger::DefaultPort::DkmDeploymentCommand*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc3416010C84D4A08CE249F39B46310F4B(Microsoft::VisualStudio::Debugger::DkmProcess*, UINT64, UINT32, Microsoft::VisualStudio::Debugger::DkmString*, Microsoft::VisualStudio::Debugger::DkmString*, Microsoft::VisualStudio::Debugger::DkmString*, Microsoft::VisualStudio::Debugger::DkmString*, Microsoft::VisualStudio::Debugger::DkmString*, Microsoft::VisualStudio::Debugger::DkmString*, Microsoft::VisualStudio::Debugger::DkmString*, Microsoft::VisualStudio::Debugger::DkmString*, Microsoft::VisualStudio::Debugger::Symbols::DkmSourcePosition*, UINT32, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<CV_HREG_e>*, bool, Microsoft::VisualStudio::Debugger::Disassembly::DkmDisassembledInstruction**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc2CDF0821065EEEAF4BF0768BBC714CF9(const GUID&, Microsoft::VisualStudio::Debugger::Symbols::DkmDynamicSymbolFileId**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc0AD4448F733B3969810D3200D16F7571(Microsoft::VisualStudio::Debugger::DkmProcess*, const Microsoft::VisualStudio::Debugger::DkmDataItem&, Microsoft::VisualStudio::Debugger::Internal::DkmEELocalObject**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc212CD04490F098DD69043824CE41E472(Microsoft::VisualStudio::Debugger::Internal::DkmEELocalObject*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc5CB574B305F260A0A4DC51E163157D25(Microsoft::VisualStudio::Debugger::Internal::DkmEELocalObject*, Microsoft::VisualStudio::Debugger::DkmString*, UINT32, UINT32*, UINT32*, UINT32*, UINT32*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc19D6B8616421D55B78D376D6CD3A5C5D(Microsoft::VisualStudio::Debugger::Internal::DkmEELocalObject*, Microsoft::VisualStudio::Debugger::DkmString*, UINT32*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc71288BA136E46AD8363AFD5AA013391E(Microsoft::VisualStudio::Debugger::Internal::DkmEELocalObject*, UINT32, UINT32, UINT32*, Microsoft::VisualStudio::Debugger::DkmString**, Microsoft::VisualStudio::Debugger::DkmArray<BYTE>*, Microsoft::VisualStudio::Debugger::DkmArray<BYTE>*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcD089BFE2A48AC9E0A8F4B1DDDC4A9F71(Microsoft::VisualStudio::Debugger::Internal::DkmEELocalObject*, UINT32, Microsoft::VisualStudio::Debugger::DkmArray<BYTE>*, Microsoft::VisualStudio::Debugger::DkmArray<BYTE>*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcB619FA0B30165B806D34B9DE6755888B(Microsoft::VisualStudio::Debugger::Internal::DkmEELocalObject*, UINT32, UINT32, Microsoft::VisualStudio::Debugger::DkmString**, UINT32*, Microsoft::VisualStudio::Debugger::DkmString**, Microsoft::VisualStudio::Debugger::DkmString**, Microsoft::VisualStudio::Debugger::DkmString**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcFD5E0390E2DDF834E43AC2E8528EFDE3(Microsoft::VisualStudio::Debugger::Internal::DkmEELocalObject*, UINT32, UINT32, Microsoft::VisualStudio::Debugger::DkmString**, UINT32*, Microsoft::VisualStudio::Debugger::DkmString**, UINT32*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc94B68F827E58FE88F3FA8771B9D09337(Microsoft::VisualStudio::Debugger::Internal::DkmEELocalObject*, UINT32, UINT32, Microsoft::VisualStudio::Debugger::DkmString**, UINT32*, Microsoft::VisualStudio::Debugger::DkmString**, UINT32*, Microsoft::VisualStudio::Debugger::DkmString**, UINT32*, Microsoft::VisualStudio::Debugger::DkmString**, UINT32*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Get250481482FAEDAA4BBEBC807B24DD715(Microsoft::VisualStudio::Debugger::DkmEngineSettings*, Microsoft::VisualStudio::Debugger::Symbols::DkmEngineSymbolSettings**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Get5A5033115F5D59291645BEAAE598F0BD(Microsoft::VisualStudio::Debugger::DkmEngineSettings*, Microsoft::VisualStudio::Debugger::DkmString**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcEAB82333D65B545623818EFFC257B255(const GUID&, Microsoft::VisualStudio::Debugger::DkmEngineSettings**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcB58779AE70E61CE2C137F2DC7C7E39A2(Microsoft::VisualStudio::Debugger::DkmArray<Microsoft::VisualStudio::Debugger::DkmEngineSettings*>*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc66C5B8466345C8B890DE700EC642A0DF(Microsoft::VisualStudio::Debugger::DkmEngineSettings*, const GUID&, Microsoft::VisualStudio::Debugger::DkmProcess**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcCFA56E1A30696A54C78DD3B62C48CB58(Microsoft::VisualStudio::Debugger::DkmEngineSettings*, Microsoft::VisualStudio::Debugger::DkmArray<Microsoft::VisualStudio::Debugger::DkmProcess*>*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc55C239704FB9EE8A91BCDFF2A41E9307(Microsoft::VisualStudio::Debugger::DkmEngineSettings*, const Microsoft::VisualStudio::Debugger::Evaluation::DkmCompilerId&, Microsoft::VisualStudio::Debugger::Evaluation::DkmLanguage**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc712AEE7B1CBFE90A27AABC87EDA764C0(Microsoft::VisualStudio::Debugger::DkmEngineSettings*, Microsoft::VisualStudio::Debugger::DkmArray<Microsoft::VisualStudio::Debugger::Symbols::DkmCodeViewCompilerId>*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc785B704BB677152C77F39C102DD245C6(Microsoft::VisualStudio::Debugger::DkmEngineSettings*, Microsoft::VisualStudio::Debugger::DkmString**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc22A1D0256F691113C635408F3AB12787(Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<Microsoft::VisualStudio::Debugger::DkmString*>*, Microsoft::VisualStudio::Debugger::DkmString*, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<Microsoft::VisualStudio::Debugger::DkmString*>*, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<Microsoft::VisualStudio::Debugger::DkmString*>*, bool, bool, Microsoft::VisualStudio::Debugger::Symbols::DkmEngineSymbolSettings**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc7DFB0CC45F58E9F2422E3D6ADD30D56C(Microsoft::VisualStudio::Debugger::Breakpoints::DkmEvaluationBreakpointCondition*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcDA01083FD1F7BC6E21CF70FEBE852E08(Microsoft::VisualStudio::Debugger::Breakpoints::DkmRuntimeBreakpoint*, Microsoft::VisualStudio::Debugger::Breakpoints::DkmBreakpointCondition*, Microsoft::VisualStudio::Debugger::Evaluation::DkmLanguage*, const Microsoft::VisualStudio::Debugger::DkmDataItem&, Microsoft::VisualStudio::Debugger::Breakpoints::DkmEvaluationBreakpointCondition**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcC551A87289B36A81E4E7DC67503FA13B(Microsoft::VisualStudio::Debugger::Breakpoints::DkmEvaluationBreakpointCondition*, Microsoft::VisualStudio::Debugger::DkmString**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc22969485654512BB4766B642E35146B1(Microsoft::VisualStudio::Debugger::Breakpoints::DkmEvaluationBreakpointCondition*, Microsoft::VisualStudio::Debugger::CallStack::DkmStackWalkFrame*, bool*, Microsoft::VisualStudio::Debugger::DkmString**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc18F3F98E2BDA11EE2E0551E6EB174A15(Microsoft::VisualStudio::Debugger::Evaluation::DkmEvaluationResult*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc304D6F6048468BB211A98ECADD5190CC(Microsoft::VisualStudio::Debugger::Evaluation::DkmEvaluationResult*, Microsoft::VisualStudio::Debugger::DkmWorkList*, UINT32, Microsoft::VisualStudio::Debugger::Evaluation::DkmInspectionContext*, Microsoft::VisualStudio::Debugger::IDkmCompletionRoutine<Microsoft::VisualStudio::Debugger::Evaluation::DkmGetChildrenAsyncResult>*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc0D96A87BB543F851A5DE00719E779D3C(Microsoft::VisualStudio::Debugger::Evaluation::DkmEvaluationResult*, Microsoft::VisualStudio::Debugger::DkmString*, UINT32, Microsoft::VisualStudio::Debugger::DkmString**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc4943C591B2842416B41CCEDF949F0CAA(Microsoft::VisualStudio::Debugger::Evaluation::DkmEvaluationResult*, Microsoft::VisualStudio::Debugger::DkmString**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc4F92F70F3E82F62D90F9A64274110E0E(Microsoft::VisualStudio::Debugger::Evaluation::DkmEvaluationResult*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcE7EB085795DD0AF19384C3FEDDC02346(Microsoft::VisualStudio::Debugger::Evaluation::DkmEvaluationResult*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc893685F10EC87472D047E00FE7DBEF94(Microsoft::VisualStudio::Debugger::Evaluation::DkmEvaluationResultEnumContext*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcF0C60D4E64737DC5E907AC0500338F29(UINT32, Microsoft::VisualStudio::Debugger::CallStack::DkmStackWalkFrame*, Microsoft::VisualStudio::Debugger::Evaluation::DkmInspectionContext*, const Microsoft::VisualStudio::Debugger::DkmDataItem&, Microsoft::VisualStudio::Debugger::Evaluation::DkmEvaluationResultEnumContext**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcD2CB7DED0F650EA239322E6F3A6CB5A2(Microsoft::VisualStudio::Debugger::Evaluation::DkmEvaluationResultEnumContext*, Microsoft::VisualStudio::Debugger::DkmWorkList*, UINT32, UINT32, Microsoft::VisualStudio::Debugger::IDkmCompletionRoutine<Microsoft::VisualStudio::Debugger::Evaluation::DkmEvaluationEnumAsyncResult>*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcA277FC9EA1AD7D48A50697B88E56D01A(Microsoft::VisualStudio::Debugger::Exceptions::DkmExceptionProcessingStage_t, Microsoft::VisualStudio::Debugger::DkmThread*, const GUID&, Microsoft::VisualStudio::Debugger::Exceptions::DkmExceptionCategoryTrigger**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcDC69BC0A967710B649D98D8171E6AB4E(Microsoft::VisualStudio::Debugger::Exceptions::DkmExceptionProcessingStage_t, Microsoft::VisualStudio::Debugger::DkmThread*, const GUID&, UINT32, Microsoft::VisualStudio::Debugger::Exceptions::DkmExceptionCodeTrigger**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcD3051BA529DC1A0C80DE71D6B8A5D237(Microsoft::VisualStudio::Debugger::Exceptions::DkmExceptionProcessingStage_t, Microsoft::VisualStudio::Debugger::DkmThread*, Microsoft::VisualStudio::Debugger::Exceptions::DkmExceptionGlobalTrigger**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc46F4EBD73CFB584D76BA34433F61DB86(Microsoft::VisualStudio::Debugger::Exceptions::DkmExceptionInformation*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc2BDC566C9437414EFB44DCA2FB0655BF(Microsoft::VisualStudio::Debugger::Exceptions::DkmExceptionInformation*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcC4606A8DA0BC602AF74AB3F9240E24F8(Microsoft::VisualStudio::Debugger::Exceptions::DkmExceptionInformation*, bool*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc7CBBB15E9B8502248D458346A2C09640(Microsoft::VisualStudio::Debugger::Exceptions::DkmExceptionInformation*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc6D04FF97A36E6FBE5A873E9E4D373191(Microsoft::VisualStudio::Debugger::Exceptions::DkmExceptionInformation*, Microsoft::VisualStudio::Debugger::DkmString**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcA507F5EA1FFFB25DB6C264A1A3E9D9A0(Microsoft::VisualStudio::Debugger::Exceptions::DkmExceptionInformation*, Microsoft::VisualStudio::Debugger::DkmString**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc32C54A299942A4DF0FC187766A44B6D8(Microsoft::VisualStudio::Debugger::Exceptions::DkmExceptionInformation*, Microsoft::VisualStudio::Debugger::DkmString**, Microsoft::VisualStudio::Debugger::DkmString**, Microsoft::VisualStudio::Debugger::DkmString**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc8DE481C3F9EEB3173D2DF9D68D38D3BE(Microsoft::VisualStudio::Debugger::Exceptions::DkmExceptionInformation*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc4102811B876B002C9EBF58B1231D3419(Microsoft::VisualStudio::Debugger::Exceptions::DkmExceptionInformation*, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<Microsoft::VisualStudio::Debugger::DkmInstructionAddress*>**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc2997D2B4489466E485DF7E7BA9519AA0(Microsoft::VisualStudio::Debugger::Exceptions::DkmExceptionProcessingStage_t, Microsoft::VisualStudio::Debugger::DkmThread*, const GUID&, Microsoft::VisualStudio::Debugger::DkmString*, Microsoft::VisualStudio::Debugger::Exceptions::DkmExceptionNameTrigger**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc82C475324C56B876A52EA3F7C064EFC7(Microsoft::VisualStudio::Debugger::Exceptions::DkmExceptionInformation*, Microsoft::VisualStudio::Debugger::DkmString*, Microsoft::VisualStudio::Debugger::DkmString*, Microsoft::VisualStudio::Debugger::DkmString*, Microsoft::VisualStudio::Debugger::DkmString*, Microsoft::VisualStudio::Debugger::DkmString*, const GUID&, Microsoft::VisualStudio::Debugger::Exceptions::DkmExceptionTriggerHit**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc7C607E439F8FC343B781AA531EE6CBEB(Microsoft::VisualStudio::Debugger::Exceptions::DkmExceptionInformation*, Microsoft::VisualStudio::Debugger::DkmString*, Microsoft::VisualStudio::Debugger::DkmString*, Microsoft::VisualStudio::Debugger::DkmString*, Microsoft::VisualStudio::Debugger::DkmString*, Microsoft::VisualStudio::Debugger::DkmString*, const GUID&, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<Microsoft::VisualStudio::Debugger::DkmInstructionAddress*>*, Microsoft::VisualStudio::Debugger::Exceptions::DkmExceptionTriggerHit**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcB462A99D32FCE88A7D5A90C41736C64D(Microsoft::VisualStudio::Debugger::Exceptions::DkmExceptionTriggerHit*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcF87D21978E9C526845E798A88842F450(Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<UINT64>*, HRESULT, Microsoft::VisualStudio::Debugger::DkmString*, Microsoft::VisualStudio::Debugger::DkmString*, Microsoft::VisualStudio::Debugger::DkmRuntimeInstance*, Microsoft::VisualStudio::Debugger::DkmString*, bool, const Microsoft::VisualStudio::Debugger::DkmDataItem&, Microsoft::VisualStudio::Debugger::Evaluation::Group::DkmFailedContextGroupEvaluationResult**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc25600235530C4F6D98FFF804F230681D(Microsoft::VisualStudio::Debugger::Evaluation::DkmInspectionContext*, Microsoft::VisualStudio::Debugger::CallStack::DkmStackWalkFrame*, Microsoft::VisualStudio::Debugger::DkmString*, Microsoft::VisualStudio::Debugger::DkmString*, Microsoft::VisualStudio::Debugger::DkmString*, Microsoft::VisualStudio::Debugger::Evaluation::DkmEvaluationResultFlags_t, const Microsoft::VisualStudio::Debugger::DkmDataItem&, Microsoft::VisualStudio::Debugger::Evaluation::DkmFailedEvaluationResult**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcCB940B4E5BD2C7FE35C1403BA8667C6F(Microsoft::VisualStudio::Debugger::Evaluation::DkmInspectionContext*, Microsoft::VisualStudio::Debugger::CallStack::DkmStackWalkFrame*, Microsoft::VisualStudio::Debugger::DkmString*, Microsoft::VisualStudio::Debugger::DkmString*, Microsoft::VisualStudio::Debugger::DkmString*, Microsoft::VisualStudio::Debugger::Evaluation::DkmEvaluationResultFlags_t, Microsoft::VisualStudio::Debugger::DkmString*, const Microsoft::VisualStudio::Debugger::DkmDataItem&, Microsoft::VisualStudio::Debugger::Evaluation::DkmFailedEvaluationResult**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcD1DED409EDEADF892DF44AC593A875CA(UINT64, Microsoft::VisualStudio::Debugger::Evaluation::DkmFakeValueHome**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc128B9579786732D548FB332A0B330884(Microsoft::VisualStudio::Debugger::DkmString*, Microsoft::VisualStudio::Debugger::DkmString*, UINT32, UINT64, UINT64, UINT64, UINT64, Microsoft::VisualStudio::Debugger::DefaultPort::DkmFileInfo**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcE20B1EDA2CA598DA00992416EE3EBC95(Microsoft::VisualStudio::Debugger::DefaultPort::DkmFileTransferStream*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc512DAF21364C293BE3611EE0A2AB259B(Microsoft::VisualStudio::Debugger::DefaultPort::DkmTransportConnection*, Microsoft::VisualStudio::Debugger::DkmString*, const Microsoft::VisualStudio::Debugger::DkmDataItem&, Microsoft::VisualStudio::Debugger::DefaultPort::DkmFileTransferStream**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcBF5C3FB352B37CE289A04F7F698B6005(Microsoft::VisualStudio::Debugger::DefaultPort::DkmFileTransferStream*, const Microsoft::VisualStudio::Debugger::DkmArray<BYTE>&, UINT64, UINT64, bool);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc394EABA320D7CFF611EB0D16BA910E50(Microsoft::VisualStudio::Debugger::DefaultPort::DkmFileTransferStream*, const Microsoft::VisualStudio::Debugger::DkmArray<BYTE>&);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc8213AA4FF03A692BCCC88DDB65068B50(Microsoft::VisualStudio::Debugger::DefaultPort::DkmFileTransferStream*, void*, UINT32, UINT32*, UINT64*, UINT64*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc9B59AAB03E31F3B304B956E0EAA505B4(Microsoft::VisualStudio::Debugger::DefaultPort::DkmFileTransferStream*, void*, UINT32, UINT32*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc0B7E2AD76C535C1C35C3948F1F2C45DF(Microsoft::VisualStudio::Debugger::CallStack::DkmFrameRegisters*, UINT64*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcC0AB0BE9B5D47BDCB64470DFC9FA2B70(Microsoft::VisualStudio::Debugger::CallStack::DkmFrameRegisters*, UINT64*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc14365162F719EE309833526528F9F58D(Microsoft::VisualStudio::Debugger::CallStack::DkmFrameRegisters*, UINT32, void*, UINT32, UINT32*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc70432FE96C3AD9E0FF944F8DEDE6D609(UINT32, UINT64, UINT64, UINT64, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<UINT32>*, UINT64, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<UINT32>*, UINT32, Microsoft::VisualStudio::Debugger::DkmProcess*, const Microsoft::VisualStudio::Debugger::DkmDataItem&, Microsoft::VisualStudio::Debugger::GPU::DkmGPUComputeKernel**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcD8C5AEC94B361E4D97A914AAFF227264(Microsoft::VisualStudio::Debugger::GPU::DkmGPUComputeKernel*, UINT32);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc7555F39063D612CCEC13E6563676F002(Microsoft::VisualStudio::Debugger::GPU::DkmGPUComputeKernel*, UINT64, Microsoft::VisualStudio::Debugger::GPU::DkmGPUComputeThread**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc6DE89FDFD6A2F6751D3C5B48FF2E1B99(Microsoft::VisualStudio::Debugger::GPU::DkmGPUComputeKernel*, UINT32*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc08309D087A5DE326E3C34B180D4043BE(Microsoft::VisualStudio::Debugger::GPU::DkmGPUComputeKernel*, Microsoft::VisualStudio::Debugger::DkmArray<UINT64>*, UINT32*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc26BA35089930A40C5436AE4DC5794A7A(Microsoft::VisualStudio::Debugger::GPU::DkmGPUComputeKernel*, Microsoft::VisualStudio::Debugger::DkmArray<UINT32>*, UINT32*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc3E4C247AE33A7932565EF80AD32F3135(Microsoft::VisualStudio::Debugger::GPU::DkmGPUComputeKernel*, Microsoft::VisualStudio::Debugger::DkmArray<UINT32>*, UINT32*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc00D7D596CD9722CDE7B7901FFBB9DBF2(Microsoft::VisualStudio::Debugger::GPU::DkmGPUComputeKernel*, Microsoft::VisualStudio::Debugger::DkmString**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc2E465FDD46A4B4DC92D709FF51472ADC(Microsoft::VisualStudio::Debugger::GPU::DkmGPUComputeKernel*, Microsoft::VisualStudio::Debugger::DkmArray<Microsoft::VisualStudio::Debugger::GPU::DkmComputeProperty>*, UINT32*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc9C1FD869706730AA7EFF44A78D267C92(Microsoft::VisualStudio::Debugger::GPU::DkmGPUComputeKernel*, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<UINT64>*, const Microsoft::VisualStudio::Debugger::GPU::DkmWhereClause&, Microsoft::VisualStudio::Debugger::DkmArray<Microsoft::VisualStudio::Debugger::GPU::DkmComputeThreadInfo>*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcD4C3C1C4B0F5F1BAA4647C8F7EF693FD(Microsoft::VisualStudio::Debugger::GPU::DkmGPUComputeKernel*, Microsoft::VisualStudio::Debugger::GPU::DkmQueryComputeThreadInfoFlags_t, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<UINT64>*, const Microsoft::VisualStudio::Debugger::GPU::DkmWhereClause&, Microsoft::VisualStudio::Debugger::DkmArray<Microsoft::VisualStudio::Debugger::GPU::DkmComputeThreadInfo>*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc9EB53CEDD4070927EF381FE18879D14F(Microsoft::VisualStudio::Debugger::GPU::DkmGPUComputeKernel*, Microsoft::VisualStudio::Debugger::DkmArray<UINT64>*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcAA5382361712FF7C2DB61AF2F559F507(Microsoft::VisualStudio::Debugger::GPU::DkmGPUComputeKernel*, UINT64, Microsoft::VisualStudio::Debugger::GPU::DkmGPUComputeThread**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc91AD1E7974AB8724E982A8D9BDA27FAF(Microsoft::VisualStudio::Debugger::GPU::DkmGPUComputeKernel*, const Microsoft::VisualStudio::Debugger::GPU::DkmWhereClause&, bool);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcA153D09816AF6B9868DED1F2AA6D1A13(Microsoft::VisualStudio::Debugger::GPU::DkmGPUComputeKernel*, const Microsoft::VisualStudio::Debugger::GPU::DkmWhereClause&, bool);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcC21FFEF8BC14B5A4DD66728B44AE9EC2(Microsoft::VisualStudio::Debugger::GPU::DkmGPUComputeKernel*, Microsoft::VisualStudio::Debugger::DkmArray<UINT32>*, Microsoft::VisualStudio::Debugger::DkmArray<INT32>*, UINT32*, Microsoft::VisualStudio::Debugger::GPU::DkmComputeKernelModel_t*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcE1CD74A61F4598BDC8CE45676C134C2C(Microsoft::VisualStudio::Debugger::DkmProcess*, UINT64, bool, UINT64, Microsoft::VisualStudio::Debugger::GPU::DkmGPUComputeKernel*, const Microsoft::VisualStudio::Debugger::DkmThread::System*, const Microsoft::VisualStudio::Debugger::DkmDataItem&, Microsoft::VisualStudio::Debugger::GPU::DkmGPUComputeThread**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc5E4EC8BBF3CBA2610A47A3950747990A(Microsoft::VisualStudio::Debugger::DkmProcess*, UINT64, bool, UINT64, Microsoft::VisualStudio::Debugger::GPU::DkmGPUComputeKernel*, Microsoft::VisualStudio::Debugger::DkmThread*, const Microsoft::VisualStudio::Debugger::DkmThread::System*, const Microsoft::VisualStudio::Debugger::DkmDataItem&, Microsoft::VisualStudio::Debugger::GPU::DkmGPUComputeThread**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcDE293BC2897E94BBAB8BAC9654D13D93(Microsoft::VisualStudio::Debugger::GPU::DkmGPUComputeThread*, Microsoft::VisualStudio::Debugger::DkmArray<UINT32>*, UINT32*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcFE2ED3D7FCB8CBBF9CB8C6E5DAF90BED(Microsoft::VisualStudio::Debugger::GPU::DkmGPUComputeThread*, Microsoft::VisualStudio::Debugger::DkmArray<UINT32>*, UINT32*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc835E736595E58DBBC0780B8878972850(Microsoft::VisualStudio::Debugger::GPU::DkmGPUComputeThread*, Microsoft::VisualStudio::Debugger::DkmArray<UINT32>*, UINT32*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc064A81821D7B41B5152C78C6D4D1B1F8(Microsoft::VisualStudio::Debugger::GPU::DkmGPUComputeThread*, Microsoft::VisualStudio::Debugger::DkmArray<UINT32>*, UINT32*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc2FAC62524E17B80FA70A0CC17E6ACC59(Microsoft::VisualStudio::Debugger::GPU::DkmGPUComputeThread*, UINT64, UINT64, Microsoft::VisualStudio::Debugger::DkmReadMemoryFlags_t, void*, UINT32, UINT32*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcD076451B3D57BBE20AF66FD87DB7A3CA(Microsoft::VisualStudio::Debugger::GPU::DkmGPUComputeThread*, UINT64, UINT64, const Microsoft::VisualStudio::Debugger::DkmArray<BYTE>&);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc9DBDC9183214716614E7527CD4D03D0B(Microsoft::VisualStudio::Debugger::GPU::DkmGPUComputeThread*, UINT32, UINT32*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc48C49A28A6651642540A84275D9B1CA0(Microsoft::VisualStudio::Debugger::GPU::DkmGPUComputeThread*, UINT64, bool*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcFB143392ABCA694056F9F89070E283E4(Microsoft::VisualStudio::Debugger::GPU::DkmGPUComputeThread*, Microsoft::VisualStudio::Debugger::DkmArray<Microsoft::VisualStudio::Debugger::GPU::DkmGPURegisterDescription>*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcB4B5B53005AB2ACB4A337CC2906C6988(Microsoft::VisualStudio::Debugger::GPU::DkmGPUComputeThread*, const Microsoft::VisualStudio::Debugger::GPU::DkmGPURegisterDescription&, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<BYTE>*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc865C2DC79B308E28B79594200F171F1B(Microsoft::VisualStudio::Debugger::DkmRuntimeInstance*, UINT64, Microsoft::VisualStudio::Debugger::DkmInstructionAddress*, Microsoft::VisualStudio::Debugger::GPU::DkmGPUComputeThread*, UINT64, Microsoft::VisualStudio::Debugger::GPU::DkmGPUDataAddress**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc55A345846D53FC406B1E062190CCBFF1(Microsoft::VisualStudio::Debugger::DkmRuntimeInstance*, Microsoft::VisualStudio::Debugger::DkmThread*, Microsoft::VisualStudio::Debugger::DkmInstructionAddress*, Microsoft::VisualStudio::Debugger::DkmString*, UINT32, Microsoft::VisualStudio::Debugger::Exceptions::DkmExceptionProcessingStage_t, UINT64, UINT64, Microsoft::VisualStudio::Debugger::GPU::DkmGPUMemoryAccessExceptionInformation**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW void STDMETHODCALLTYPE Proc5685DA4F5C12B2EFEE7911100FE853C7(Microsoft::VisualStudio::Debugger::GPU::DkmGPURegisterDescription*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc59332EB271778BB3304504B24A36496A(Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmPrimitiveObjectType_t, Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILAdd**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc7AC349E33ACBF2C7B296609A50B19D40(Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILAmpAdjustBufferTag**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcF71648263D0EBB6AB423F469F8345896(Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILCatchBlock*>*, Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILBeginTry**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc274F93BAEC7EDA11FB3D8D31398F3E66(Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmPrimitiveObjectType_t, Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILBitAnd**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcE164CFE08792BADA3AFC457FC373E7CD(UINT32, UINT32, Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmPrimitiveObjectType_t, Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILBitFieldRead**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc3CC641081A4F8E38DBA8B9D7F910E648(UINT32, UINT32, UINT32, Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmPrimitiveObjectType_t, Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILBitFieldReadFromBytes**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcC88C854EE79528CEF5806D3E9A5AAD3E(UINT32, UINT32, Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILBitFieldWrite**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcC065B509F9ABC0BAC4BBD770D73E7FEB(UINT32, UINT32, UINT32, Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILBitFieldWriteToBytes**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcFD8A3508ABF025DFCBF615679CA43098(Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmPrimitiveObjectType_t, Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILBitNot**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc67294CD5516F29DD623A0335B01E2B2D(Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmPrimitiveObjectType_t, Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILBitOr**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcF28A7C520914A2C602F64AC12940AEDD(Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmPrimitiveObjectType_t, Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILBitShiftLeft**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcB1F5C35BB7205E5859519C63CAB11717(Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmPrimitiveObjectType_t, Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILBitShiftRight**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcF7DC8A9B604DB7991F313B300879DB14(Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmPrimitiveObjectType_t, Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILBitXor**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc513A853ACBA57C6224E96AFED178B6FC(Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILFailureReason_t, UINT32, Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILCatchBlock**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc7F719CBB10CD5D871FFE04E029F3DB2E(Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmPrimitiveObjectType_t, Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILCompareEqual**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcF61679F72873B9BAE44FF902F92DDDCC(Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmPrimitiveObjectType_t, Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILCompareGreaterThan**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc42D2B23BCA47F96E95181509DEC12952(Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmPrimitiveObjectType_t, Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILCompareGreaterThanOrEqual**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc651C8C57EB784CC5D51DA3D9F911EC27(Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmPrimitiveObjectType_t, Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILCompareLessThan**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc5F637D126578416C0D844318F488E927(Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmPrimitiveObjectType_t, Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILCompareLessThanOrEqual**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc4C34599EEC6D0C6D02539A6CE0D3F759(Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmPrimitiveObjectType_t, Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILCompareNotEqual**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcA18DDACFF36E48D6F0D56719700A0A68(Microsoft::VisualStudio::Debugger::CallStack::DkmStackWalkFrame*, const Microsoft::VisualStudio::Debugger::Evaluation::DkmILContext::ThreadOverride*, Microsoft::VisualStudio::Debugger::Evaluation::DkmILContext**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc73B7F93E9843CE3F03DCE965DE48D1BD(Microsoft::VisualStudio::Debugger::CallStack::DkmStackWalkFrame*, Microsoft::VisualStudio::Debugger::Evaluation::DkmCustomDataContainer*, const Microsoft::VisualStudio::Debugger::Evaluation::DkmILContext::ThreadOverride*, Microsoft::VisualStudio::Debugger::Evaluation::DkmILContext**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcD90E2CBB49C005FC3439C6A37E4DD05E(Microsoft::VisualStudio::Debugger::Evaluation::DkmILContext*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc9F997DC1F7AF29677A4047813E08FDCB(Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmPrimitiveObjectType_t, Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmPrimitiveObjectType_t, Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILConvert**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcF41F3F1AB2ABAEF7FFBC76C3B591E7F9(Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmPrimitiveObjectType_t, Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILDivide**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcC1CC800269002F7E3A1DA22DF715FE41(Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILDuplicateTop**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc5C9051E01C0BD1E2540034FD47353BE5(Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILEndTry**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcA2F8C324E55FE9F51080FF9117FD8A9C(const GUID&, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<BYTE>*, Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILEvaluationResult**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcBDD5283BDC1037CAEB03E474486393D9(const GUID&, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<BYTE>*, bool, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<BYTE>*, Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILEvaluationResult**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc6E64A892D574E60D055678E92E919AB5(UINT32, UINT32, Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILCallingConvention_t, Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILFunctionEvaluationFlags_t, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILFunctionEvaluationArgumentFlags_t>*, UINT32, Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILExecuteFunction**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcBBA18CD27180C60E9E997C0A6FE75438(const GUID&, const GUID&, UINT32, UINT32, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<Microsoft::VisualStudio::Debugger::Evaluation::DkmCompiledInspectionQuery*>*, Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILExecuteIntrinsic**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc97F5838B80CF47DFBB5C7A66C074A06E(Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILExecuteIntrinsic*, Microsoft::VisualStudio::Debugger::Evaluation::DkmILContext*, const Microsoft::VisualStudio::Debugger::DkmArray<Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILEvaluationResult*>&, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<Microsoft::VisualStudio::Debugger::Evaluation::DkmCompiledInspectionQuery*>*, Microsoft::VisualStudio::Debugger::DkmArray<Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILEvaluationResult*>*, Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILFailureReason_t*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc8C672BDBCF020F7AE79341774958AEB9(Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILExecuteIntrinsic*, Microsoft::VisualStudio::Debugger::Evaluation::DkmILContext*, Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmCompiledILInspectionQuery*, const Microsoft::VisualStudio::Debugger::DkmArray<Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILEvaluationResult*>&, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<Microsoft::VisualStudio::Debugger::Evaluation::DkmCompiledInspectionQuery*>*, Microsoft::VisualStudio::Debugger::DkmArray<Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILEvaluationResult*>*, Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILFailureReason_t*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcB3E3D0B3952EE50F42598DF26DF31016(UINT32, UINT32, Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILExtractBytes**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcEF0A249A2437F16F1944B917B7FD8CB2(CV_HREG_e, UINT32, UINT32, Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILHlslBufferRead**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc85D3C05E777E3DDC1C1378AC47BC997D(Microsoft::VisualStudio::Debugger::GPU::DkmHlslThreadIdComponents_t, Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILHlslGetGroupId**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcFD5E9535C1990A0F26896BACBB2E116E(bool, bool, Microsoft::VisualStudio::Debugger::GPU::DkmHlslThreadIdComponents_t, Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILHlslGetThreadId**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc9D1082BBE4C79FA90A9A6DB49A461250(CV_HREG_e, UINT32, UINT32, UINT32, UINT32, Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILHlslIndexedRegisterRead**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc0E7C3B425A75C063D8423649080FECF2(CV_HREG_e, UINT32, UINT32, UINT32, UINT32, UINT32, Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILHlslRegisterRead**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc54CE95E6EDCFE52433F058A2FCD32205(Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmPrimitiveObjectType_t, Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILIsFalse**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcE724C2C7F8598586BC2AE84E232C2A4B(Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmPrimitiveObjectType_t, Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILIsTrue**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcFFB2CBC90C25CF40C1EC0ADEF943DD21(UINT32, Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILJump**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc2A6EFECEEC08A414F708C9237A23820A(UINT32, Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILJumpIfFalse**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcFA7E1E2E0DFF33CDC7B49FE9A2BF2A22(UINT32, Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILJumpIfTrue**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcBB0D564A3653A0A30F1FC72C203C9C15(UINT32, Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILLoad**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc52F772C3D63AAE4A52633DD19BFDC964(UINT32, Microsoft::VisualStudio::Debugger::DkmReadMemoryFlags_t, Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILMemoryRead**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcDA48987D0C3B6A7E18E3AC29CAAD314D(Microsoft::VisualStudio::Debugger::DkmReadMemoryFlags_t, UINT16, UINT32, Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILMemoryStringRead**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc61C52246DE45479B72BA6997F2B2A8F1(Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILMemoryWrite**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc401CC9B272AC84D4FD02EB44812606BA(Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmPrimitiveObjectType_t, Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILMultiply**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc45F2C6048794F68C28A16C1614F4F4EA(Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILNop**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcFD4EE301C59FC0351D8CF4431CBC623B(UINT32, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<BYTE>*, Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILParameterValue**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcCE37C359ECDC6F99185E4B406EE8ABCC(UINT32, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<BYTE>*, bool, Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILParameterValue**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc9DF1C12E7E667FAA07405E2EB93A3FA5(Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILParameterValue*>*, Microsoft::VisualStudio::Debugger::Evaluation::Group::DkmILParameterValueCollection**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc1DC79D92A0938AE9690076CE9323DAC7(Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILPop**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcE4F5DD31DD2BC1EDC34C6E1135328142(Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<BYTE>*, Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILPushConstant**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc58B9915C02C6BE805485E625EBF9C530(CV_HREG_e, Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILRegisterRead**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcDCC91AD8A2E048D1EA602989BF72949C(CV_HREG_e, Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILRegisterWrite**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcF5C9FC936A5A04CE6DF00B7345A7E8CA(Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmPrimitiveObjectType_t, Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILRemainder**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcF3C1D5377032837C2404235250E0B451(Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILReturnTop**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcD8B6F020C004300F488AA5F72045BC59(UINT32, Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILSave**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc256DC5FA8167A7B12392751E76AD665A(Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILSetBytesRegion**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcB74FE600C741C9E0EA9A5EB02EC32244(Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmPrimitiveObjectType_t, Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILSubtract**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcDC178BD53797D38351843A49AAE130A1(Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILFailureReason_t, Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILThrow**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcDDCD8B82D3B57686F096172A6C076243(Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILTlsGetValue**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc3E44E2254CE4725B5E4A486A9B526329(Microsoft::VisualStudio::Debugger::Evaluation::DkmInspectionSession*, Microsoft::VisualStudio::Debugger::DkmRuntimeInstance*, Microsoft::VisualStudio::Debugger::DkmThread*, UINT32, Microsoft::VisualStudio::Debugger::Evaluation::DkmEvaluationFlags_t, Microsoft::VisualStudio::Debugger::Evaluation::DkmFuncEvalFlags_t, UINT32, Microsoft::VisualStudio::Debugger::Evaluation::DkmLanguage*, Microsoft::VisualStudio::Debugger::Evaluation::DkmRawReturnValue*, Microsoft::VisualStudio::Debugger::Evaluation::DkmInspectionContext**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc1B8F796B6C622B33C8D151185C0D2B9C(Microsoft::VisualStudio::Debugger::Evaluation::DkmInspectionSession*, Microsoft::VisualStudio::Debugger::DkmRuntimeInstance*, Microsoft::VisualStudio::Debugger::DkmThread*, UINT32, Microsoft::VisualStudio::Debugger::Evaluation::DkmEvaluationFlags_t, Microsoft::VisualStudio::Debugger::Evaluation::DkmFuncEvalFlags_t, UINT32, Microsoft::VisualStudio::Debugger::Evaluation::DkmLanguage*, Microsoft::VisualStudio::Debugger::Evaluation::DkmRawReturnValue*, Microsoft::VisualStudio::Debugger::Evaluation::DkmCompiledVisualizationData*, Microsoft::VisualStudio::Debugger::Evaluation::DkmCompiledVisualizationDataPriority_t, Microsoft::VisualStudio::Debugger::Evaluation::DkmInspectionContext**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc1BB47B2873705FF468D77E2EB1CE6D18(Microsoft::VisualStudio::Debugger::Evaluation::DkmInspectionSession*, Microsoft::VisualStudio::Debugger::DkmRuntimeInstance*, Microsoft::VisualStudio::Debugger::DkmThread*, UINT32, Microsoft::VisualStudio::Debugger::Evaluation::DkmEvaluationFlags_t, Microsoft::VisualStudio::Debugger::Evaluation::DkmFuncEvalFlags_t, UINT32, Microsoft::VisualStudio::Debugger::Evaluation::DkmLanguage*, Microsoft::VisualStudio::Debugger::Evaluation::DkmRawReturnValue*, Microsoft::VisualStudio::Debugger::Evaluation::DkmCompiledVisualizationData*, Microsoft::VisualStudio::Debugger::Evaluation::DkmCompiledVisualizationDataPriority_t, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<Microsoft::VisualStudio::Debugger::Evaluation::DkmRawReturnValueContainer*>*, Microsoft::VisualStudio::Debugger::Evaluation::DkmInspectionContext**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc086780F7AB96BE98E973B6DADFEEC905(Microsoft::VisualStudio::Debugger::Evaluation::DkmInspectionContext*, Microsoft::VisualStudio::Debugger::DkmWorkList*, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<UINT64>*, Microsoft::VisualStudio::Debugger::CallStack::DkmStackWalkFrame*, Microsoft::VisualStudio::Debugger::Evaluation::DkmLanguageExpression*, Microsoft::VisualStudio::Debugger::IDkmCompletionRoutine<Microsoft::VisualStudio::Debugger::Evaluation::Group::DkmEvaluateExpressionOnThreadsAsyncResult>*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcF7531579429F4DBD3A2C1DEED15F6A9B(Microsoft::VisualStudio::Debugger::Evaluation::DkmInspectionContext*, Microsoft::VisualStudio::Debugger::DkmWorkList*, Microsoft::VisualStudio::Debugger::Evaluation::DkmLanguageExpression*, Microsoft::VisualStudio::Debugger::CallStack::DkmStackWalkFrame*, Microsoft::VisualStudio::Debugger::IDkmCompletionRoutine<Microsoft::VisualStudio::Debugger::Evaluation::DkmEvaluateExpressionAsyncResult>*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc22DAB17B5E419C4DFC5198EFBCADBC18(Microsoft::VisualStudio::Debugger::Evaluation::DkmInspectionContext*, Microsoft::VisualStudio::Debugger::DkmWorkList*, Microsoft::VisualStudio::Debugger::CallStack::DkmStackWalkFrame*, Microsoft::VisualStudio::Debugger::IDkmCompletionRoutine<Microsoft::VisualStudio::Debugger::Evaluation::DkmGetFrameLocalsAsyncResult>*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcCEB972D13FE445A9D304AD753C757552(Microsoft::VisualStudio::Debugger::Evaluation::DkmInspectionContext*, Microsoft::VisualStudio::Debugger::DkmWorkList*, Microsoft::VisualStudio::Debugger::CallStack::DkmStackWalkFrame*, Microsoft::VisualStudio::Debugger::IDkmCompletionRoutine<Microsoft::VisualStudio::Debugger::Evaluation::DkmGetFrameArgumentsAsyncResult>*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc44DBDEA6AB474E8EB67B5F2348EDCC20(Microsoft::VisualStudio::Debugger::Evaluation::DkmInspectionContext*, Microsoft::VisualStudio::Debugger::DkmWorkList*, Microsoft::VisualStudio::Debugger::CallStack::DkmStackWalkFrame*, Microsoft::VisualStudio::Debugger::Evaluation::DkmVariableInfoFlags_t, Microsoft::VisualStudio::Debugger::IDkmCompletionRoutine<Microsoft::VisualStudio::Debugger::Evaluation::DkmGetFrameNameAsyncResult>*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc281BD02CCE55B2A58FC2C8301699BF33(Microsoft::VisualStudio::Debugger::Evaluation::DkmInspectionContext*, Microsoft::VisualStudio::Debugger::DkmWorkList*, Microsoft::VisualStudio::Debugger::CallStack::DkmStackWalkFrame*, Microsoft::VisualStudio::Debugger::IDkmCompletionRoutine<Microsoft::VisualStudio::Debugger::Evaluation::DkmGetFrameReturnTypeAsyncResult>*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc8100E1C553B1AE153B3AEF9DAE275F33(Microsoft::VisualStudio::Debugger::Evaluation::DkmInspectionContext*, Microsoft::VisualStudio::Debugger::DkmWorkList*, Microsoft::VisualStudio::Debugger::CallStack::DkmStackWalkFrame*, Microsoft::VisualStudio::Debugger::Evaluation::DkmRawReturnValue*, Microsoft::VisualStudio::Debugger::IDkmCompletionRoutine<Microsoft::VisualStudio::Debugger::Evaluation::DkmEvaluateReturnValueAsyncResult>*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc92260B87C04ECE6862D88F7A45EECD13(Microsoft::VisualStudio::Debugger::Evaluation::DkmInspectionContext*, Microsoft::VisualStudio::Debugger::Clr::DkmClrInstructionAddress*, bool, Microsoft::VisualStudio::Debugger::Evaluation::ClrCompilation::DkmCompiledClrLocalsQuery**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc0343604ED036A20BFD02BE7C9A4CB730(Microsoft::VisualStudio::Debugger::Evaluation::DkmInspectionContext*, Microsoft::VisualStudio::Debugger::Clr::DkmClrType*, Microsoft::VisualStudio::Debugger::Evaluation::ClrCompilation::DkmClrCustomTypeInfo*, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<Microsoft::VisualStudio::Debugger::DkmString*>*, Microsoft::VisualStudio::Debugger::DkmString**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc8BFD65439118D33CF7BD0C4D95F940EE(Microsoft::VisualStudio::Debugger::Evaluation::DkmInspectionContext*, Microsoft::VisualStudio::Debugger::DkmWorkList*, Microsoft::VisualStudio::Debugger::CallStack::DkmStackWalkFrame*, Microsoft::VisualStudio::Debugger::Evaluation::DkmRawReturnValueContainer*, Microsoft::VisualStudio::Debugger::IDkmCompletionRoutine<Microsoft::VisualStudio::Debugger::Evaluation::DkmEvaluateReturnValueAsyncResult2>*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc2DCEF64A20FA074BCCA5B25B25800DEC(Microsoft::VisualStudio::Debugger::Evaluation::DkmInspectionSession*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc094F295F322424992BB5E795A7035884(Microsoft::VisualStudio::Debugger::DkmProcess*, const Microsoft::VisualStudio::Debugger::DkmDataItem&, Microsoft::VisualStudio::Debugger::Evaluation::DkmInspectionSession**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc2A390C1D1F33EDBD1ACC2F03C450252B(Microsoft::VisualStudio::Debugger::Evaluation::DkmInspectionSession*, UINT32, Microsoft::VisualStudio::Debugger::Evaluation::DkmRawReturnValueContainer**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcB6994295ABE30C2D9DEEF34C72334641(Microsoft::VisualStudio::Debugger::Evaluation::DkmInspectionSession*, Microsoft::VisualStudio::Debugger::DkmArray<Microsoft::VisualStudio::Debugger::Evaluation::DkmRawReturnValueContainer*>*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc2EA0223CA2C28FD2A44B1ABE5EAA38E6(Microsoft::VisualStudio::Debugger::DefaultPort::DkmAppPackageId*, Microsoft::VisualStudio::Debugger::DkmString*, Microsoft::VisualStudio::Debugger::DkmString*, Microsoft::VisualStudio::Debugger::DkmString*, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<Microsoft::VisualStudio::Debugger::DefaultPort::DkmInstalledApplicationInfo*>*, Microsoft::VisualStudio::Debugger::DefaultPort::DkmInstalledAppPackageInfo**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc5C4A41F2572CF238937F847AC2A3B828(Microsoft::VisualStudio::Debugger::DkmString*, Microsoft::VisualStudio::Debugger::DkmString*, Microsoft::VisualStudio::Debugger::DkmString*, Microsoft::VisualStudio::Debugger::DkmString*, Microsoft::VisualStudio::Debugger::DkmString*, Microsoft::VisualStudio::Debugger::DkmString*, const GUID&, Microsoft::VisualStudio::Debugger::DefaultPort::DkmInstalledApplicationInfo**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc2063EA8A5827C04D2BF6A7BA85E27556(Microsoft::VisualStudio::Debugger::DkmInstructionAddress*, Microsoft::VisualStudio::Debugger::Symbols::DkmInstructionSymbol**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc94A165B2D7D457C800C0044AEE4DF1CB(Microsoft::VisualStudio::Debugger::DkmInstructionAddress*, Microsoft::VisualStudio::Debugger::DkmInstructionAddress*, INT32*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcCAA57817DCAB36FA6857F059CC28E22C(Microsoft::VisualStudio::Debugger::DkmInstructionAddress*, Microsoft::VisualStudio::Debugger::DkmInstructionAddress*, bool*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc52D25C4E1682ABDE2CA361EA4457EC20(Microsoft::VisualStudio::Debugger::DkmInstructionAddress*, Microsoft::VisualStudio::Debugger::DkmArray<UINT64>*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcACB1ED9131E740FA3BE29B6308FECCB2(Microsoft::VisualStudio::Debugger::DkmInstructionAddress*, Microsoft::VisualStudio::Debugger::DkmWorkList*, Microsoft::VisualStudio::Debugger::IDkmCompletionRoutine<Microsoft::VisualStudio::Debugger::DkmGetCurrentCPUAddressAsyncResult>*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc9B7FAC38CDD9E0656EF668FB4B062428(Microsoft::VisualStudio::Debugger::DkmInstructionAddress*, Microsoft::VisualStudio::Debugger::DkmWorkList*, Microsoft::VisualStudio::Debugger::IDkmCompletionRoutine<Microsoft::VisualStudio::Debugger::Symbols::DkmIsUserCodeAsyncResult>*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcAC852ACB3B15D4C2B177E7AA9ED66C3F(Microsoft::VisualStudio::Debugger::Symbols::DkmInstructionSymbol*, Microsoft::VisualStudio::Debugger::DkmModuleInstance*, Microsoft::VisualStudio::Debugger::DkmInstructionAddress**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc31D347AE67B44CCB5C5B5025DAC7D49F(Microsoft::VisualStudio::Debugger::Symbols::DkmInstructionSymbol*, Microsoft::VisualStudio::Debugger::DkmInstructionAddress*, Microsoft::VisualStudio::Debugger::Symbols::DkmInstructionSymbol*, Microsoft::VisualStudio::Debugger::GPU::DkmGPUAddressType_t*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc862FD79FBD0E048B914012C907E6262E(Microsoft::VisualStudio::Debugger::Symbols::DkmInstructionSymbol*, Microsoft::VisualStudio::Debugger::DkmArray<Microsoft::VisualStudio::Debugger::Symbols::DkmSteppingRange>*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcBDD11793EA51E5D4A4A47BB5D6AF1606(Microsoft::VisualStudio::Debugger::Symbols::DkmInstructionSymbol*, Microsoft::VisualStudio::Debugger::Evaluation::DkmInspectionSession*, Microsoft::VisualStudio::Debugger::Symbols::DkmSourcePosition**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcC8D8FC52CDB2195F51CF25F6E35EF5FB(Microsoft::VisualStudio::Debugger::Symbols::DkmInstructionSymbol*, Microsoft::VisualStudio::Debugger::DkmWorkList*, Microsoft::VisualStudio::Debugger::Evaluation::DkmInspectionSession*, Microsoft::VisualStudio::Debugger::IDkmCompletionRoutine<Microsoft::VisualStudio::Debugger::Symbols::DkmGetUserCodeSourcePositionCallbackAsyncResult>*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc11B96E95076AEBD19435335693648C9F(Microsoft::VisualStudio::Debugger::Symbols::DkmInstructionSymbol*, Microsoft::VisualStudio::Debugger::Evaluation::DkmInspectionSession*, Microsoft::VisualStudio::Debugger::DkmString**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc25C283D1FA9B4F1F3979BA9CA8917013(Microsoft::VisualStudio::Debugger::Symbols::DkmInstructionSymbol*, Microsoft::VisualStudio::Debugger::Evaluation::DkmInspectionSession*, Microsoft::VisualStudio::Debugger::Evaluation::DkmCompilerId*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcA273139AC02E5BE47E4FAD7C165037C1(Microsoft::VisualStudio::Debugger::Symbols::DkmInstructionSymbol*, Microsoft::VisualStudio::Debugger::DkmWorkList*, Microsoft::VisualStudio::Debugger::Evaluation::DkmInspectionSession*, Microsoft::VisualStudio::Debugger::DkmInstructionAddress*, Microsoft::VisualStudio::Debugger::IDkmCompletionRoutine<Microsoft::VisualStudio::Debugger::Symbols::DkmIsHiddenCodeAsyncResult>*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcE3287B6AD1874438A4638A94F83D8907(Microsoft::VisualStudio::Debugger::Symbols::DkmInstructionSymbol*, Microsoft::VisualStudio::Debugger::Symbols::DkmSteppingRangeBoundary_t, bool, Microsoft::VisualStudio::Debugger::DkmArray<Microsoft::VisualStudio::Debugger::Symbols::DkmSteppingRange>*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc23E28172B8ED4C1CF1065854ACDA6236(Microsoft::VisualStudio::Debugger::Symbols::DkmInstructionSymbol*, bool*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcEECEDA2F659A9B7F31A4E9CEBAF928D5(Microsoft::VisualStudio::Debugger::Symbols::DkmInstructionSymbol*, Microsoft::VisualStudio::Debugger::DkmWorkList*, Microsoft::VisualStudio::Debugger::IDkmCompletionRoutine<Microsoft::VisualStudio::Debugger::Symbols::DkmHasLineInfoAsyncResult>*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc312C43C3EBD40AA19100FC0BE9A909AB(Microsoft::VisualStudio::Debugger::Symbols::DkmInstructionSymbol*, Microsoft::VisualStudio::Debugger::Symbols::DkmSteppingRange*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc74625D16DFFBC0BBB0B76F58AC775415(Microsoft::VisualStudio::Debugger::Symbols::DkmInstructionSymbol*, Microsoft::VisualStudio::Debugger::Symbols::DkmSourcePositionFlags_t, Microsoft::VisualStudio::Debugger::Evaluation::DkmInspectionSession*, bool*, Microsoft::VisualStudio::Debugger::Symbols::DkmSourcePosition**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcF1DC26DBD878FEE1EC011A3321EF806F(Microsoft::VisualStudio::Debugger::Symbols::DkmInstructionSymbol*, Microsoft::VisualStudio::Debugger::DkmWorkList*, Microsoft::VisualStudio::Debugger::Symbols::DkmSourcePositionFlags_t, Microsoft::VisualStudio::Debugger::Evaluation::DkmInspectionSession*, Microsoft::VisualStudio::Debugger::IDkmCompletionRoutine<Microsoft::VisualStudio::Debugger::Symbols::DkmGetSourcePositionAsyncResult>*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc93764ECF9C2251D624F78B0CE24C436C(Microsoft::VisualStudio::Debugger::Symbols::DkmInstructionSymbol*, Microsoft::VisualStudio::Debugger::Symbols::DkmSourcePositionFlags_t, Microsoft::VisualStudio::Debugger::Evaluation::DkmInspectionSession*, bool*, Microsoft::VisualStudio::Debugger::Symbols::DkmSourcePosition**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc04DEBA8C7D7338ACBE9E489F5CDDEEC3(Microsoft::VisualStudio::Debugger::Symbols::DkmInstructionSymbol*, Microsoft::VisualStudio::Debugger::DkmWorkList*, Microsoft::VisualStudio::Debugger::Symbols::DkmSourcePositionFlags_t, Microsoft::VisualStudio::Debugger::Evaluation::DkmInspectionSession*, Microsoft::VisualStudio::Debugger::IDkmCompletionRoutine<Microsoft::VisualStudio::Debugger::Symbols::DkmGetSourcePositionCallbackAsyncResult>*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc9EBFFE4FF0C0B8719F419B9AA576BCFB(Microsoft::VisualStudio::Debugger::Symbols::DkmInstructionSymbol*, Microsoft::VisualStudio::Debugger::Symbols::DkmSourcePositionFlags_t, Microsoft::VisualStudio::Debugger::Symbols::DkmSourcePosition**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc456FB60B9E4993FCB92B225C95A1B152(Microsoft::VisualStudio::Debugger::DkmString*, const Microsoft::VisualStudio::Debugger::Evaluation::DkmCompilerId&, Microsoft::VisualStudio::Debugger::Evaluation::DkmLanguage**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc59530E264B592B0BFF5FDCD149513A30(Microsoft::VisualStudio::Debugger::Evaluation::DkmLanguage*, Microsoft::VisualStudio::Debugger::DkmArray<Microsoft::VisualStudio::Debugger::DkmLanguageRegistrySetting*>*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcF1D4F60E91C176CB2494DD14B47089A1(Microsoft::VisualStudio::Debugger::Evaluation::DkmLanguage*, Microsoft::VisualStudio::Debugger::DkmWorkList*, Microsoft::VisualStudio::Debugger::IDkmCompletionRoutine<Microsoft::VisualStudio::Debugger::Evaluation::DkmGetLanguageSettingsAsyncResult>*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc4B24038B5804A260021A129904C9BBC6(Microsoft::VisualStudio::Debugger::Evaluation::DkmLanguage*, Microsoft::VisualStudio::Debugger::DkmString*, Microsoft::VisualStudio::Debugger::DkmString**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcD69DC66A57C38CA4CAB503AEA3C31D11(Microsoft::VisualStudio::Debugger::Evaluation::DkmLanguageExpression*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc8CE02648478ABDF8A3F6F73CE84429FA(Microsoft::VisualStudio::Debugger::Evaluation::DkmLanguage*, Microsoft::VisualStudio::Debugger::Evaluation::DkmEvaluationFlags_t, Microsoft::VisualStudio::Debugger::DkmString*, const Microsoft::VisualStudio::Debugger::DkmDataItem&, Microsoft::VisualStudio::Debugger::Evaluation::DkmLanguageExpression**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcB3BE8CF198DBF082F2F19BE994CAC4C5(Microsoft::VisualStudio::Debugger::Evaluation::DkmLanguageExpression*, Microsoft::VisualStudio::Debugger::Clr::DkmClrInstructionAddress*, Microsoft::VisualStudio::Debugger::Evaluation::DkmInspectionContext*, Microsoft::VisualStudio::Debugger::DkmString**, Microsoft::VisualStudio::Debugger::Evaluation::ClrCompilation::DkmCompiledClrInspectionQuery**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc454BD0C84C668A0A125BCB6475524F31(Microsoft::VisualStudio::Debugger::Evaluation::DkmLanguageExpression*, Microsoft::VisualStudio::Debugger::Clr::DkmClrInstructionAddress*, Microsoft::VisualStudio::Debugger::Evaluation::DkmEvaluationResult*, Microsoft::VisualStudio::Debugger::DkmString**, Microsoft::VisualStudio::Debugger::Evaluation::ClrCompilation::DkmCompiledClrInspectionQuery**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcC5676EEB270E5D63EEDBBA79A6A10809(Microsoft::VisualStudio::Debugger::Evaluation::DkmLanguageExpression*, Microsoft::VisualStudio::Debugger::Clr::DkmClrModuleInstance*, UINT32, Microsoft::VisualStudio::Debugger::DkmString**, Microsoft::VisualStudio::Debugger::Evaluation::ClrCompilation::DkmCompiledClrInspectionQuery**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcF14399E29BCD6CF68684B4E4FACCE08B(Microsoft::VisualStudio::Debugger::Evaluation::DkmLanguageExpression*, Microsoft::VisualStudio::Debugger::Clr::DkmClrModuleInstance*, UINT32, Microsoft::VisualStudio::Debugger::DkmString**, Microsoft::VisualStudio::Debugger::Evaluation::ClrCompilation::DkmCompiledClrInspectionQuery**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcD2487F1CCF357A31DF51A101750E2793(Microsoft::VisualStudio::Debugger::Evaluation::DkmLanguageExpression*, Microsoft::VisualStudio::Debugger::DkmWorkList*, Microsoft::VisualStudio::Debugger::Clr::DkmClrModuleInstance*, UINT32, Microsoft::VisualStudio::Debugger::IDkmCompletionRoutine<Microsoft::VisualStudio::Debugger::Evaluation::DkmCompileDisplayAttributeInternalAsyncResult>*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc425C8315F654ADA55907101C9C65A89A(Microsoft::VisualStudio::Debugger::Evaluation::DkmLanguage*, Microsoft::VisualStudio::Debugger::DkmInstructionAddress*, Microsoft::VisualStudio::Debugger::Evaluation::DkmLanguageInstructionAddress**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc9EACD04F3FD1CA479AF6A3CE86B9E9FA(Microsoft::VisualStudio::Debugger::Evaluation::DkmLanguageInstructionAddress*, Microsoft::VisualStudio::Debugger::Evaluation::DkmLanguageExpression*, Microsoft::VisualStudio::Debugger::Evaluation::DkmFailedEvaluationResult**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc4A691C7F7E4EA945A06F4071763491F1(Microsoft::VisualStudio::Debugger::Evaluation::DkmLanguageInstructionAddress*, Microsoft::VisualStudio::Debugger::Breakpoints::DkmBreakpointCondition*, Microsoft::VisualStudio::Debugger::Evaluation::DkmCompiledInspectionQuery**, Microsoft::VisualStudio::Debugger::DkmString**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc02B8A45DC663391C88C64FF8F16423AE(Microsoft::VisualStudio::Debugger::Evaluation::DkmLanguageInstructionAddress*, Microsoft::VisualStudio::Debugger::Evaluation::DkmVariableInfoFlags_t, Microsoft::VisualStudio::Debugger::DkmString**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc6217600D01C4D2ECBE61829AFD936139(Microsoft::VisualStudio::Debugger::Evaluation::DkmLanguageInstructionAddress*, Microsoft::VisualStudio::Debugger::Stepping::DkmLanguageStepIntoFlags_t*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc68AD630132C16798EB187E26E4B8E18B(Microsoft::VisualStudio::Debugger::DkmString*, Microsoft::VisualStudio::Debugger::DkmVariant*, Microsoft::VisualStudio::Debugger::DkmLanguageRegistrySetting**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW int STDMETHODCALLTYPE Proc19F3BC72A701F59F6D869826B65D2C66(const Microsoft::VisualStudio::Debugger::Symbols::DkmMD5HashValue&, const Microsoft::VisualStudio::Debugger::Symbols::DkmMD5HashValue&);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc5291958220F6BA230E62F74538F8E025(const Microsoft::VisualStudio::Debugger::Symbols::DkmModuleId&, Microsoft::VisualStudio::Debugger::Symbols::DkmModule**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc8CBFCEEC88661ADC3F294DFCA4AF14BD(Microsoft::VisualStudio::Debugger::DkmArray<Microsoft::VisualStudio::Debugger::Symbols::DkmModule*>*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcD60BA609E5572E71FE7454972F0CC2FE(const Microsoft::VisualStudio::Debugger::Symbols::DkmModuleId&, Microsoft::VisualStudio::Debugger::DkmString*, const Microsoft::VisualStudio::Debugger::Evaluation::DkmCompilerId&, Microsoft::VisualStudio::Debugger::DefaultPort::DkmTransportConnection*, const Microsoft::VisualStudio::Debugger::DkmDataItem&, Microsoft::VisualStudio::Debugger::Symbols::DkmModule**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc1893989E63FB4502D761835AA167574F(Microsoft::VisualStudio::Debugger::Symbols::DkmModule*, Microsoft::VisualStudio::Debugger::DkmArray<Microsoft::VisualStudio::Debugger::Script::DkmScriptDocument*>*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc787E6277F93875EC906A2F61947281D1(Microsoft::VisualStudio::Debugger::Symbols::DkmModule*, const Microsoft::VisualStudio::Debugger::Clr::DkmClrMethodId&, Microsoft::VisualStudio::Debugger::DkmArray<Microsoft::VisualStudio::Debugger::Clr::DkmClrMethodScopeData>*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc0F050A725D2A1A68D6AEA249072A74CA(Microsoft::VisualStudio::Debugger::Symbols::DkmModule*, Microsoft::VisualStudio::Debugger::DkmWorkList*, const Microsoft::VisualStudio::Debugger::Clr::DkmClrMethodId&, Microsoft::VisualStudio::Debugger::IDkmCompletionRoutine<Microsoft::VisualStudio::Debugger::Symbols::DkmGetMethodSymbolStoreDataAsyncResult>*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcBBBD87DA3F9E7D240B27461DD59C7F82(Microsoft::VisualStudio::Debugger::Symbols::DkmModule*, Microsoft::VisualStudio::Debugger::Clr::DkmClrMethodId*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcAB14A3D49AB97EEE5634A0BE1114A8DB(Microsoft::VisualStudio::Debugger::Symbols::DkmModule*, const Microsoft::VisualStudio::Debugger::Clr::DkmClrMethodId&, UINT32*, Microsoft::VisualStudio::Debugger::DkmArray<Microsoft::VisualStudio::Debugger::Clr::DkmClrMethodScopeData>*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcFA4AE503D69BFA42C4969ADBDC1209A3(Microsoft::VisualStudio::Debugger::Symbols::DkmModule*, Microsoft::VisualStudio::Debugger::DkmWorkList*, const Microsoft::VisualStudio::Debugger::Clr::DkmClrMethodId&, Microsoft::VisualStudio::Debugger::IDkmCompletionRoutine<Microsoft::VisualStudio::Debugger::Symbols::DkmGetMethodSymbolStoreDataPreRemapAsyncResult>*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcD01D70ACAE8430CBB07B5F422017B9D6(Microsoft::VisualStudio::Debugger::Symbols::DkmModule*, UINT32, bool, Microsoft::VisualStudio::Debugger::DkmString*, Microsoft::VisualStudio::Debugger::DkmArray<BYTE>*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcA0F5CAEEAAB4BB662F0A035412F7BBC6(Microsoft::VisualStudio::Debugger::Symbols::DkmModule*, Microsoft::VisualStudio::Debugger::DkmWorkList*, UINT32, bool, Microsoft::VisualStudio::Debugger::DkmString*, Microsoft::VisualStudio::Debugger::IDkmCompletionRoutine<Microsoft::VisualStudio::Debugger::Symbols::DkmGetTokenSymbolStoreAttributeAsyncResult>*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcD04C7DFC744864F9E28B48FDE7FC2E93(Microsoft::VisualStudio::Debugger::Symbols::DkmModule*, UINT32, UINT32, UINT32*, UINT32*, UINT32*, UINT32*, UINT32*, UINT32*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc1FA09A66CFC6C30956FDF9F38B06E31F(Microsoft::VisualStudio::Debugger::Symbols::DkmModule*, Microsoft::VisualStudio::Debugger::DkmString**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc09E6E2514FF654881B54EB0150C7AC32(Microsoft::VisualStudio::Debugger::Symbols::DkmModule*, UINT32, UINT32, UINT32*, UINT32*, UINT32*, UINT32*, UINT32*, UINT32*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc8C41A92D8B47ABE0375B9D7756FD489D(Microsoft::VisualStudio::Debugger::Symbols::DkmModule*, UINT32, UINT32, bool*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc5F33BB9A16D050DC6A11F8D02254B011(Microsoft::VisualStudio::Debugger::Symbols::DkmModule*, CV_HREG_e, UINT32, UINT32, UINT32, UINT32, UINT32, UINT32, UINT32, UINT32, UINT64*, bool*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc9DF311E58282BDB725263E4F8096A4C5(Microsoft::VisualStudio::Debugger::Symbols::DkmModule*, UINT64, CV_HREG_e, UINT32, UINT32, UINT32, UINT32, UINT32, UINT32, UINT32);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc4621B3FD8E354DF3C09CD7AF4EFA6890(Microsoft::VisualStudio::Debugger::Symbols::DkmModule*, UINT32*, UINT32*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc5134BC888343F0CBDC3CFF37F53CE11F(Microsoft::VisualStudio::Debugger::Symbols::DkmModule*, UINT32, UINT32*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc101685421B67B01CA3E0DB5E650B022E(Microsoft::VisualStudio::Debugger::Symbols::DkmModule*, Microsoft::VisualStudio::Debugger::DkmArray<Microsoft::VisualStudio::Debugger::DkmModuleInstance*>*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcE94B97BDA30ADC68B86021B4E04E88B9(Microsoft::VisualStudio::Debugger::Symbols::DkmModule*, Microsoft::VisualStudio::Debugger::DkmString*, UINT32, Microsoft::VisualStudio::Debugger::DkmString**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcB78DCC1D97D2784074F1B8AD23A79A8D(Microsoft::VisualStudio::Debugger::Symbols::DkmModule*, Microsoft::VisualStudio::Debugger::DkmString*, Microsoft::VisualStudio::Debugger::Native::DkmNativeInstructionSymbol**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc6F7D7F50E471D11AD110BF84C52571CC(Microsoft::VisualStudio::Debugger::Symbols::DkmModule*, Microsoft::VisualStudio::Debugger::DkmModuleInstance*, Microsoft::VisualStudio::Debugger::DkmArray<BYTE>*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcCCBBBEED8A02B87E7A41F8504E31545E(Microsoft::VisualStudio::Debugger::Symbols::DkmModule*, Microsoft::VisualStudio::Debugger::Symbols::DkmSourceFileId*, Microsoft::VisualStudio::Debugger::DkmArray<Microsoft::VisualStudio::Debugger::Symbols::DkmResolvedDocument*>*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc203BC1170806E54DBAAF1B3530F58C16(Microsoft::VisualStudio::Debugger::Symbols::DkmModule*, Microsoft::VisualStudio::Debugger::DkmWorkList*, Microsoft::VisualStudio::Debugger::Symbols::DkmSourceFileId*, Microsoft::VisualStudio::Debugger::IDkmCompletionRoutine<Microsoft::VisualStudio::Debugger::Symbols::DkmFindDocumentsAsyncResult>*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc63D01FE35215A6F186CDAAF3981ECB78(Microsoft::VisualStudio::Debugger::Symbols::DkmModule*, Microsoft::VisualStudio::Debugger::DkmString**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcD1DA8568A04474B5C880F261EDF65D23(Microsoft::VisualStudio::Debugger::Symbols::DkmModule*, Microsoft::VisualStudio::Debugger::DkmArray<Microsoft::VisualStudio::Debugger::Symbols::DkmInstructionSymbol*>*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcB3AE544A716277EBD21AB3A79E73A97D(Microsoft::VisualStudio::Debugger::Symbols::DkmModule*, Microsoft::VisualStudio::Debugger::DkmString*, Microsoft::VisualStudio::Debugger::DkmArray<Microsoft::VisualStudio::Debugger::Symbols::DkmRVASizePair>*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc8BFB1F00FB320ADA9A2FD47EB5E00505(Microsoft::VisualStudio::Debugger::Symbols::DkmModule*, Microsoft::VisualStudio::Debugger::DkmWorkList*, Microsoft::VisualStudio::Debugger::DkmString*, Microsoft::VisualStudio::Debugger::IDkmCompletionRoutine<Microsoft::VisualStudio::Debugger::Symbols::DkmGetFunctionInfoAsyncResult>*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcF1B19E03C0D1B1CB1DFED383F9D9A51C(Microsoft::VisualStudio::Debugger::Symbols::DkmModule*, const GUID&, IUnknown**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW int STDMETHODCALLTYPE Proc1B02BC6A77ED80B4C26F62A6EA215225(const Microsoft::VisualStudio::Debugger::Symbols::DkmModuleId&, const Microsoft::VisualStudio::Debugger::Symbols::DkmModuleId&);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Get645AD40C25493913B4F735C441506A16(Microsoft::VisualStudio::Debugger::DkmModuleInstance*, Microsoft::VisualStudio::Debugger::Symbols::DkmModule**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcEC7B013CEB23AA93633EDBA7FAB549B1(Microsoft::VisualStudio::Debugger::DkmModuleInstance*, bool);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcA2068CD9D703B7D4CE4B42E82A5C761E(Microsoft::VisualStudio::Debugger::DkmModuleInstance*, UINT64, UINT32, bool, Microsoft::VisualStudio::Debugger::DkmArray<BYTE>*, bool*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc07E9A8763D0D6AD6ACDBED6ED0AFEC7A(Microsoft::VisualStudio::Debugger::DkmModuleInstance*, UINT64*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc5CE38E6CF8E905E0A2FDD562AE2B9F6F(Microsoft::VisualStudio::Debugger::DkmModuleInstance*, UINT64, UINT64*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc00D734DD81ACDC01605A9CFD79A152DD(Microsoft::VisualStudio::Debugger::DkmModuleInstance*, Microsoft::VisualStudio::Debugger::Symbols::DkmModule*, bool);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcA2A87FA9B2EABE057C973454C4D0E0FE(Microsoft::VisualStudio::Debugger::DkmModuleInstance*, Microsoft::VisualStudio::Debugger::Symbols::DkmModule*, bool);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc5A1A29171D03FC392A4795717141E0C3(Microsoft::VisualStudio::Debugger::DkmModuleInstance*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc1880B774E3CEB4FFE43F3E5FFFFFC505(Microsoft::VisualStudio::Debugger::DkmModuleInstance*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc4B179835811F44DCE0F243F176717948(Microsoft::VisualStudio::Debugger::DkmModuleInstance*, bool*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc0B9652121F6BC866281A1E15F8B76330(Microsoft::VisualStudio::Debugger::DkmModuleInstance*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc34893D26C250199161E3A453FFEEF918(Microsoft::VisualStudio::Debugger::DkmModuleInstance*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcE57162D15B9C4A9B50CAF4AF489C894F(Microsoft::VisualStudio::Debugger::DkmModuleInstance*, bool, Microsoft::VisualStudio::Debugger::DkmString**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcC2B6CE7C926FEA8B7BB1737D6705C84C(Microsoft::VisualStudio::Debugger::DkmModuleInstance*, Microsoft::VisualStudio::Debugger::DkmString**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc5411B0DDBEF94775850CBFCCE24FDAA0(Microsoft::VisualStudio::Debugger::DkmModuleInstance*, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<BYTE>**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc1DF3FBE6FE204B1CB87244F8FE368C24(Microsoft::VisualStudio::Debugger::DkmModuleInstance*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc7C740EFAED2FCAE33007EF4EB2BCA3CF(Microsoft::VisualStudio::Debugger::DkmModuleInstance*, Microsoft::VisualStudio::Debugger::Symbols::DkmModule*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc3FCE740432071F95E811C82C437CB8D0(Microsoft::VisualStudio::Debugger::DkmModuleInstance*, Microsoft::VisualStudio::Debugger::DkmString*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcF386FCA16584C1EAE2CEB33B55A36BA3(Microsoft::VisualStudio::Debugger::DkmModuleInstance*, bool*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc52D5288CF84A94E56C713A4E2F5B6947(Microsoft::VisualStudio::Debugger::DkmModuleInstance*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcA1906536FCD2F44CD6AADD9DF63D8C47(Microsoft::VisualStudio::Debugger::DkmModuleInstance*, bool*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcA4A76835B9CD64AE968BA52BC84263FB(Microsoft::VisualStudio::Debugger::DkmModuleInstance*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc2717980A0CDDDFF0805419095281221C(Microsoft::VisualStudio::Debugger::DkmString*, Microsoft::VisualStudio::Debugger::DkmString*, UINT32, UINT32, UINT32, UINT32, UINT32, Microsoft::VisualStudio::Debugger::DkmModuleVersion**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcDC7ED1E90FA2A6178BEA83BB0A11B501(Microsoft::VisualStudio::Debugger::CallStack::DkmMonitorStackWalkContext*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcA29A9B6A00CD4E346ACD54992947A817(Microsoft::VisualStudio::Debugger::DkmRuntimeInstance*, Microsoft::VisualStudio::Debugger::DkmThread*, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<BYTE>*, const Microsoft::VisualStudio::Debugger::DkmDataItem&, Microsoft::VisualStudio::Debugger::CallStack::DkmMonitorStackWalkContext**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc2D82CAC96183DD7B6D1DF3394318FC27(Microsoft::VisualStudio::Debugger::CallStack::DkmMonitorStackWalkContext*, Microsoft::VisualStudio::Debugger::CallStack::DkmFrameRegisters*, UINT32);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc8A1248C3A4D0B316E04BDEB5C39F281A(Microsoft::VisualStudio::Debugger::CallStack::DkmMonitorStackWalkContext*, Microsoft::VisualStudio::Debugger::CallStack::DkmFrameRegisters*, UINT32);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc35BF8659E4F78CFC4EDCF9F8C35DCF25(Microsoft::VisualStudio::Debugger::CallStack::DkmMonitorStackWalkContext*, Microsoft::VisualStudio::Debugger::CallStack::DkmMonitorStackWalkResult*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW void STDMETHODCALLTYPE ProcF077EF6B9A532BB38F440A3E41457FEE(Microsoft::VisualStudio::Debugger::CallStack::DkmMonitorStackWalkResult*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc3CC4BB810E58E0616B44FC6441DB2E43(Microsoft::VisualStudio::Debugger::Native::DkmNativeAddressType_t, Microsoft::VisualStudio::Debugger::Native::DkmNativeAddressStepType_t, UINT32, Microsoft::VisualStudio::Debugger::Native::DkmNativeAddressMetadata**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc1EA107D7E0BFF457B5E6A661C838536A(Microsoft::VisualStudio::Debugger::Native::DkmNativeRuntimeInstance*, Microsoft::VisualStudio::Debugger::Native::DkmNativeModuleInstance*, UINT32, const Microsoft::VisualStudio::Debugger::DkmInstructionAddress::CPUInstruction*, Microsoft::VisualStudio::Debugger::Native::DkmNativeInstructionAddress**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc918993F014B90FB01D72E7053BB1AAF2(Microsoft::VisualStudio::Debugger::Native::DkmNativeInstructionAddress*, Microsoft::VisualStudio::Debugger::DkmString**, INT32*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc60E84CC95C998F0AD7E7E519F0209668(Microsoft::VisualStudio::Debugger::Native::DkmNativeInstructionAddress*, Microsoft::VisualStudio::Debugger::DkmWorkList*, Microsoft::VisualStudio::Debugger::IDkmCompletionRoutine<Microsoft::VisualStudio::Debugger::Native::DkmFindNearestExportAsyncResult>*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc44EADD160F31BE6B3796FA9A467F646C(Microsoft::VisualStudio::Debugger::Native::DkmNativeInstructionAddress*, const Microsoft::VisualStudio::Debugger::DkmArray<Microsoft::VisualStudio::Debugger::Symbols::DkmSteppingRange>&, Microsoft::VisualStudio::Debugger::DkmArray<Microsoft::VisualStudio::Debugger::Stepping::DkmNativeSteppingCallSite*>*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc62D0A91244300EC2F3874A30E936DF26(Microsoft::VisualStudio::Debugger::Symbols::DkmModule*, UINT32, Microsoft::VisualStudio::Debugger::Native::DkmNativeInstructionSymbol**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcA5DB4FF28172AC8EE337B4F616F0D8FC(Microsoft::VisualStudio::Debugger::Native::DkmNativeInstructionSymbol*, Microsoft::VisualStudio::Debugger::DkmInstructionAddress*, Microsoft::VisualStudio::Debugger::Native::DkmNativeAddressMetadata**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc20C5AC2C29FFB6772842DB423E85767C(Microsoft::VisualStudio::Debugger::Native::DkmNativeInstructionSymbol*, Microsoft::VisualStudio::Debugger::DkmModuleInstance*, Microsoft::VisualStudio::Debugger::DkmInstructionAddress*, Microsoft::VisualStudio::Debugger::Symbols::DkmSteppingRangeBoundary_t, bool, Microsoft::VisualStudio::Debugger::DkmArray<Microsoft::VisualStudio::Debugger::Symbols::DkmSteppingRange>*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc08CD058CAA9E5478B87D9248545A2D2E(Microsoft::VisualStudio::Debugger::Native::DkmNativeInstructionSymbol*, Microsoft::VisualStudio::Debugger::DkmModuleInstance*, Microsoft::VisualStudio::Debugger::DkmInstructionAddress*, Microsoft::VisualStudio::Debugger::Native::DkmNativeAddressMetadata**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcB8D112804ACF0EF98486C2DBE47F5860(Microsoft::VisualStudio::Debugger::DkmString*, Microsoft::VisualStudio::Debugger::DkmString*, UINT64, Microsoft::VisualStudio::Debugger::DkmModuleVersion*, Microsoft::VisualStudio::Debugger::Symbols::DkmSymbolFileId*, Microsoft::VisualStudio::Debugger::DkmModuleFlags_t, Microsoft::VisualStudio::Debugger::DkmModuleMemoryLayout_t, UINT32, Microsoft::VisualStudio::Debugger::DkmString*, Microsoft::VisualStudio::Debugger::Native::DkmNativeRuntimeInstance*, UINT64, UINT32, Microsoft::VisualStudio::Debugger::Clr::DkmClrHeaderStatus_t, bool, Microsoft::VisualStudio::Debugger::Symbols::DkmModule*, const Microsoft::VisualStudio::Debugger::DkmModuleInstance::MinidumpInfo*, const Microsoft::VisualStudio::Debugger::DkmDataItem&, Microsoft::VisualStudio::Debugger::Native::DkmNativeModuleInstance**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc7C33005073B197E468D344B6CC30046F(Microsoft::VisualStudio::Debugger::Native::DkmNativeModuleInstance*, UINT64, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<BYTE>**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc88303C178160F6B7A48F74A2AE8D50B5(Microsoft::VisualStudio::Debugger::Native::DkmNativeModuleInstance*, Microsoft::VisualStudio::Debugger::DkmString*, bool, Microsoft::VisualStudio::Debugger::Native::DkmNativeInstructionAddress**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc80A9F462958D3BF363A4E3F18DB01E46(Microsoft::VisualStudio::Debugger::Native::DkmNativeModuleInstance*, Microsoft::VisualStudio::Debugger::DkmWorkList*, Microsoft::VisualStudio::Debugger::DkmString*, bool, Microsoft::VisualStudio::Debugger::IDkmCompletionRoutine<Microsoft::VisualStudio::Debugger::Native::DkmFindExportNameAsyncResult>*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcC6565F2B8739BF2909221336A3BBE9C6(Microsoft::VisualStudio::Debugger::DkmInstructionAddress*, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<Microsoft::VisualStudio::Debugger::Evaluation::DkmNativeReturnValueRegister*>*, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<BYTE>*, Microsoft::VisualStudio::Debugger::Evaluation::DkmNativeRawReturnValue**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc12B8AEBDE8DC06ECC146022EFDF43BA0(CV_HREG_e, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<BYTE>*, Microsoft::VisualStudio::Debugger::Evaluation::DkmNativeReturnValueRegister**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc0C813EFC4A612A8F0E0975C93D9CA8B2(Microsoft::VisualStudio::Debugger::DkmProcess*, const Microsoft::VisualStudio::Debugger::DkmRuntimeInstanceId&, const Microsoft::VisualStudio::Debugger::DkmDataItem&, Microsoft::VisualStudio::Debugger::Native::DkmNativeRuntimeInstance**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcACB567FCFFFF620887A60A7FEDA08D1F(Microsoft::VisualStudio::Debugger::DkmProcess*, const Microsoft::VisualStudio::Debugger::DkmRuntimeInstanceId&, Microsoft::VisualStudio::Debugger::DkmRuntimeCapabilities_t, Microsoft::VisualStudio::Debugger::DkmRuntimeInstance*, const Microsoft::VisualStudio::Debugger::DkmDataItem&, Microsoft::VisualStudio::Debugger::Native::DkmNativeRuntimeInstance**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc32F748045CAE5D710346099F66C76CBF(Microsoft::VisualStudio::Debugger::Native::DkmNativeRuntimeInstance*, UINT64, Microsoft::VisualStudio::Debugger::Native::DkmNativeModuleInstance**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcFD045CFE2611847953C966E4D4891465(Microsoft::VisualStudio::Debugger::Native::DkmNativeRuntimeInstance*, Microsoft::VisualStudio::Debugger::DkmArray<Microsoft::VisualStudio::Debugger::Native::DkmNativeModuleInstance*>*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcD01245BBCCF50A985F33D7F2B376C6A3(Microsoft::VisualStudio::Debugger::Native::DkmNativeRuntimeInstance*, const Microsoft::VisualStudio::Debugger::DkmArray<Microsoft::VisualStudio::Debugger::Native::DkmNativeInstructionAddress*>&, const Microsoft::VisualStudio::Debugger::DkmArray<UINT32>&, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<Microsoft::VisualStudio::Debugger::DkmString*>**, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<Microsoft::VisualStudio::Debugger::DkmString*>**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcECA60A812FB3EBE489041C773FE06A85(Microsoft::VisualStudio::Debugger::Native::DkmNativeRuntimeInstance*, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<Microsoft::VisualStudio::Debugger::DkmString*>**, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<Microsoft::VisualStudio::Debugger::DkmString*>**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc9712D292D3F561C85D575D1D1A169743(Microsoft::VisualStudio::Debugger::Native::DkmNativeInstructionAddress*, Microsoft::VisualStudio::Debugger::Native::DkmNativeInstructionAddress*, Microsoft::VisualStudio::Debugger::Native::DkmNativeInstructionAddress*, Microsoft::VisualStudio::Debugger::Stepping::DkmNativeSteppingCallSite**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcFD1ECC0384614A7BB087DDC735CC263F(const GUID&, const GUID&, UINT32, Microsoft::VisualStudio::Debugger::DkmString*, Microsoft::VisualStudio::Debugger::Symbols::DkmPdbFileId**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcF0887F8CD77331C223C58112B02B3D06(const GUID&, const Microsoft::VisualStudio::Debugger::Evaluation::DkmCompilerId&, Microsoft::VisualStudio::Debugger::DkmThread*, bool, Microsoft::VisualStudio::Debugger::DkmInstructionAddress*, const Microsoft::VisualStudio::Debugger::DkmDataItem&, Microsoft::VisualStudio::Debugger::Breakpoints::DkmPendingAddressBreakpoint**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc60332A18F85A4FFB428E5704BCDD2A1E(Microsoft::VisualStudio::Debugger::DkmProcess*, const GUID&, const Microsoft::VisualStudio::Debugger::Evaluation::DkmCompilerId&, Microsoft::VisualStudio::Debugger::DkmThread*, bool, Microsoft::VisualStudio::Debugger::DkmString*, Microsoft::VisualStudio::Debugger::DkmString*, Microsoft::VisualStudio::Debugger::DkmString*, const Microsoft::VisualStudio::Debugger::DkmDataItem&, Microsoft::VisualStudio::Debugger::Breakpoints::DkmPendingAddressNameBreakpoint**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc4921BEC0D30D1765A57ECFF2126DBB4B(Microsoft::VisualStudio::Debugger::Breakpoints::DkmPendingBreakpoint*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcD1322FBC5A4F53CD71D904A9129D140F(Microsoft::VisualStudio::Debugger::Breakpoints::DkmPendingBreakpoint*, Microsoft::VisualStudio::Debugger::DkmArray<Microsoft::VisualStudio::Debugger::Breakpoints::DkmBoundBreakpoint*>*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcA128E99A1AEAC21ACBFA950EE3F3B480(Microsoft::VisualStudio::Debugger::Breakpoints::DkmPendingBreakpoint*, Microsoft::VisualStudio::Debugger::DkmWorkList*, Microsoft::VisualStudio::Debugger::IDkmCompletionRoutine<Microsoft::VisualStudio::Debugger::Breakpoints::DkmEnablePendingBreakpointAsyncResult>*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc3AA44FB37FBBCFFA6FBBE1CA72E86896(Microsoft::VisualStudio::Debugger::Breakpoints::DkmPendingBreakpoint*, Microsoft::VisualStudio::Debugger::DkmWorkList*, Microsoft::VisualStudio::Debugger::IDkmCompletionRoutine<Microsoft::VisualStudio::Debugger::Breakpoints::DkmDisablePendingBreakpointAsyncResult>*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcEFEC79D1BCD21D1131F213381B99DD64(Microsoft::VisualStudio::Debugger::Breakpoints::DkmPendingBreakpoint*, Microsoft::VisualStudio::Debugger::DkmWorkList*, Microsoft::VisualStudio::Debugger::IDkmCompletionRoutine<Microsoft::VisualStudio::Debugger::Breakpoints::DkmEnrollPendingBreakpointAsyncResult>*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc477ABB8F3A0820484777E4374E219075(Microsoft::VisualStudio::Debugger::Breakpoints::DkmPendingBreakpoint*, Microsoft::VisualStudio::Debugger::DkmWorkList*, Microsoft::VisualStudio::Debugger::Breakpoints::DkmBreakpointCondition*, Microsoft::VisualStudio::Debugger::IDkmCompletionRoutine<Microsoft::VisualStudio::Debugger::Breakpoints::DkmSetPendingBreakpointConditionAsyncResult>*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc292FF758655DE22ECB36F4C74707AA8A(Microsoft::VisualStudio::Debugger::Breakpoints::DkmPendingBreakpoint*, Microsoft::VisualStudio::Debugger::DkmWorkList*, Microsoft::VisualStudio::Debugger::Breakpoints::DkmBreakpointHitCountCondition*, Microsoft::VisualStudio::Debugger::IDkmCompletionRoutine<Microsoft::VisualStudio::Debugger::Breakpoints::DkmSetPendingBreakpointHitCountConditionAsyncResult>*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcB460D8699FACB2F98617CEE663F430B5(Microsoft::VisualStudio::Debugger::Breakpoints::DkmPendingBreakpoint*, const Microsoft::VisualStudio::Debugger::DkmArray<Microsoft::VisualStudio::Debugger::Breakpoints::DkmBoundBreakpoint*>&);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcA9A34CABE5D34924B96CEC8E5546A656(Microsoft::VisualStudio::Debugger::Breakpoints::DkmPendingBreakpoint*, const Microsoft::VisualStudio::Debugger::DkmArray<Microsoft::VisualStudio::Debugger::Breakpoints::DkmBoundBreakpoint*>&, Microsoft::VisualStudio::Debugger::Breakpoints::DkmBreakpointUnboundReason_t);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc99CA4912ED11CCD3CA63F744165160AB(Microsoft::VisualStudio::Debugger::Breakpoints::DkmPendingBreakpoint*, Microsoft::VisualStudio::Debugger::Breakpoints::DkmBreakpointMessageLevel_t, Microsoft::VisualStudio::Debugger::DkmString*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc8ECC658EC2242BE249FD192CBE25E53F(Microsoft::VisualStudio::Debugger::DkmProcess*, const GUID&, const Microsoft::VisualStudio::Debugger::Evaluation::DkmCompilerId&, Microsoft::VisualStudio::Debugger::DkmThread*, bool, Microsoft::VisualStudio::Debugger::DkmString*, UINT32, const Microsoft::VisualStudio::Debugger::DkmDataItem&, Microsoft::VisualStudio::Debugger::Breakpoints::DkmPendingDataBreakpoint**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc6053B28C3096673FC90D26445A76528D(Microsoft::VisualStudio::Debugger::DkmProcess*, const GUID&, const Microsoft::VisualStudio::Debugger::Evaluation::DkmCompilerId&, Microsoft::VisualStudio::Debugger::DkmThread*, bool, const Microsoft::VisualStudio::Debugger::DkmDataItem&, Microsoft::VisualStudio::Debugger::Breakpoints::DkmPendingFileLineBreakpoint**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc9B0261EA0FE6234EFD936CB4480EA78D(Microsoft::VisualStudio::Debugger::Breakpoints::DkmPendingFileLineBreakpoint*, Microsoft::VisualStudio::Debugger::Symbols::DkmSourcePosition**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcF9D4693132F4DAF29D2D657F564DEF25(Microsoft::VisualStudio::Debugger::Breakpoints::DkmPendingFileLineBreakpoint*, Microsoft::VisualStudio::Debugger::DkmString**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcE56F511514FFDB6E7EBB991014B63565(Microsoft::VisualStudio::Debugger::DkmProcess*, const GUID&, const Microsoft::VisualStudio::Debugger::Evaluation::DkmCompilerId&, Microsoft::VisualStudio::Debugger::DkmThread*, bool, Microsoft::VisualStudio::Debugger::DkmString*, Microsoft::VisualStudio::Debugger::DkmString*, UINT32, const Microsoft::VisualStudio::Debugger::DkmDataItem&, Microsoft::VisualStudio::Debugger::Breakpoints::DkmPendingFunctionBreakpoint**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcC2C38CE8A50D042DEED2E1DBADC5CB25(UINT64, Microsoft::VisualStudio::Debugger::Evaluation::DkmPointerValueHome**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc3878B0A51524BC8FD74356AF6390338C(const GUID&, Microsoft::VisualStudio::Debugger::DkmProcess**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc33E7E6971423BF9A85008A3E9CFD7DC9(Microsoft::VisualStudio::Debugger::DkmArray<Microsoft::VisualStudio::Debugger::DkmProcess*>*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcC475EB6F33F01CF8E23EBF14281DC9D5(Microsoft::VisualStudio::Debugger::DefaultPort::DkmTransportConnection*, Microsoft::VisualStudio::Debugger::DkmString*, const GUID&, Microsoft::VisualStudio::Debugger::Start::DkmStartMethod_t, Microsoft::VisualStudio::Debugger::DkmEngineSettings*, Microsoft::VisualStudio::Debugger::Start::DkmDebugLaunchSettings*, Microsoft::VisualStudio::Debugger::DefaultPort::DkmSystemInformation*, const GUID&, bool, const Microsoft::VisualStudio::Debugger::DkmProcess::Live*, const Microsoft::VisualStudio::Debugger::DkmDataItem&, Microsoft::VisualStudio::Debugger::DkmProcess**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc106265AC3459BC4D58F9E120E7890A5B(Microsoft::VisualStudio::Debugger::DefaultPort::DkmTransportConnection*, Microsoft::VisualStudio::Debugger::DkmString*, const GUID&, Microsoft::VisualStudio::Debugger::Start::DkmStartMethod_t, Microsoft::VisualStudio::Debugger::DkmEngineSettings*, Microsoft::VisualStudio::Debugger::Start::DkmDebugLaunchSettings*, Microsoft::VisualStudio::Debugger::DefaultPort::DkmSystemInformation*, const GUID&, bool, bool, const Microsoft::VisualStudio::Debugger::DkmProcess::Live*, const Microsoft::VisualStudio::Debugger::DkmDataItem&, Microsoft::VisualStudio::Debugger::DkmProcess**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcC36364A347A1331856E21EB8986BAE70(Microsoft::VisualStudio::Debugger::DkmProcess*, Microsoft::VisualStudio::Debugger::DkmArray<Microsoft::VisualStudio::Debugger::DkmThread*>*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc271368D023C6928C09CB19546C3F1AD1(Microsoft::VisualStudio::Debugger::DkmProcess*, UINT32, Microsoft::VisualStudio::Debugger::DkmThread**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcED5672D2B090E000D7A7F7AD376C8B29(Microsoft::VisualStudio::Debugger::DkmProcess*, Microsoft::VisualStudio::Debugger::DkmAsyncBreakStatus_t, Microsoft::VisualStudio::Debugger::DkmThread*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc4A0E15FDF157B102C15D0945524E44EA(Microsoft::VisualStudio::Debugger::DkmProcess*, Microsoft::VisualStudio::Debugger::DkmArray<Microsoft::VisualStudio::Debugger::Breakpoints::DkmPendingBreakpoint*>*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcE26FC60E9788891FD620E40D02F8214A(Microsoft::VisualStudio::Debugger::DkmProcess*, const Microsoft::VisualStudio::Debugger::DkmRuntimeInstanceId&, Microsoft::VisualStudio::Debugger::DkmRuntimeInstance**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc6A4CB9E6ACE0329D50B59CB473BB5DA6(Microsoft::VisualStudio::Debugger::DkmProcess*, Microsoft::VisualStudio::Debugger::DkmArray<Microsoft::VisualStudio::Debugger::DkmRuntimeInstance*>*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc83904421FD75D950D0C529A5A96F888B(Microsoft::VisualStudio::Debugger::DkmProcess*, Microsoft::VisualStudio::Debugger::DkmArray<Microsoft::VisualStudio::Debugger::GPU::DkmGPUComputeKernel*>*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcFE2313088C600310FB7FB38145E2E44A(Microsoft::VisualStudio::Debugger::DkmProcess*, Microsoft::VisualStudio::Debugger::DkmArray<Microsoft::VisualStudio::Debugger::FunctionResolution::DkmRuntimeFunctionResolutionRequest*>*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcDF334C7812DE5779F127659C7CD0F4FC(Microsoft::VisualStudio::Debugger::DkmProcess*, Microsoft::VisualStudio::Debugger::DkmThread*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc5A54344DA99A8E8110ED35DAA5DA2324(Microsoft::VisualStudio::Debugger::DkmProcess*, UINT64, Microsoft::VisualStudio::Debugger::DkmInstructionAddress**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcF4FA5D54D06ED8FB9E7DEB680FC83C0D(Microsoft::VisualStudio::Debugger::DkmProcess*, UINT64, Microsoft::VisualStudio::Debugger::Native::DkmNativeModuleInstance**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc8A6D7EC2A52F26AD397C691D3330A926(Microsoft::VisualStudio::Debugger::DkmProcess*, UINT64, bool, Microsoft::VisualStudio::Debugger::Native::DkmNativeModuleInstance**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcAF31D72F6E65E289D17CCB5D3D2F418F(Microsoft::VisualStudio::Debugger::DkmProcess*, bool);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc1BA75E1240F3CFD277658D59B4759BAB(Microsoft::VisualStudio::Debugger::DkmProcess*, Microsoft::VisualStudio::Debugger::DkmString*, Microsoft::VisualStudio::Debugger::DkmString*, Microsoft::VisualStudio::Debugger::DkmString*, UINT32, UINT32, Microsoft::VisualStudio::Debugger::DkmString**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc1BFA716C410EE92B5D9550D310574100(Microsoft::VisualStudio::Debugger::DkmProcess*, Microsoft::VisualStudio::Debugger::DkmInstructionAddress*, UINT32, Microsoft::VisualStudio::Debugger::DkmArray<Microsoft::VisualStudio::Debugger::Disassembly::DkmDisassembledInstruction*>*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc418F9EE0619D1B155F4CBF61E05C3742(Microsoft::VisualStudio::Debugger::DkmProcess*, Microsoft::VisualStudio::Debugger::DkmInstructionAddress*, INT32, Microsoft::VisualStudio::Debugger::DkmInstructionAddress**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc78457549C84AD5A4D3E96DDC28B4A91D(Microsoft::VisualStudio::Debugger::DkmProcess*, Microsoft::VisualStudio::Debugger::DkmDumpType_t, Microsoft::VisualStudio::Debugger::DkmString*, Microsoft::VisualStudio::Debugger::DkmThread*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc9FB80C6A3DB27E2C52259C3282AE46F7(Microsoft::VisualStudio::Debugger::DkmProcess*, const GUID&, Microsoft::VisualStudio::Debugger::Exceptions::DkmExceptionTrigger*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc433805FB32119EF9F52D897E3DB167CC(Microsoft::VisualStudio::Debugger::DkmProcess*, Microsoft::VisualStudio::Debugger::DkmWorkList*, const GUID&, Microsoft::VisualStudio::Debugger::Exceptions::DkmExceptionTrigger*, Microsoft::VisualStudio::Debugger::IDkmCompletionRoutine<Microsoft::VisualStudio::Debugger::Exceptions::DkmAddExceptionTriggerAsyncResult>*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcD2F3BF5A81EA26B2F9702DE5AA7F854E(Microsoft::VisualStudio::Debugger::DkmProcess*, const GUID&);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc94A9989CD07F6E368BE9234F2C761007(Microsoft::VisualStudio::Debugger::DkmProcess*, UINT64, UINT64*, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<BYTE>**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc2A48A9D77297CAE270C2A2DBC52F163B(Microsoft::VisualStudio::Debugger::DkmProcess*, Microsoft::VisualStudio::Debugger::GPU::DkmGPUBreakpointBehaviorFlags_t*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc221A1C16A0CA91E399F361A5B5A38AC9(Microsoft::VisualStudio::Debugger::DkmProcess*, UINT32, bool);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc8D47871CB4A49A7D7E9DB77822948CFD(Microsoft::VisualStudio::Debugger::DkmProcess*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc9D6623C601DB3190377A91A37C7419B0(Microsoft::VisualStudio::Debugger::DkmProcess*, Microsoft::VisualStudio::Debugger::DkmWorkList*, UINT64, Microsoft::VisualStudio::Debugger::IDkmCompletionRoutine<Microsoft::VisualStudio::Debugger::DkmGetInstructionAddressAsyncResult>*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcBBC3412E622A85C7A9C9A2B97362ACC4(Microsoft::VisualStudio::Debugger::DkmProcess*, UINT64, const Microsoft::VisualStudio::Debugger::DkmArray<BYTE>&);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc6B1CD2F016C6DF558BBBB8943EC462EA(Microsoft::VisualStudio::Debugger::DkmProcess*, UINT64, const Microsoft::VisualStudio::Debugger::DkmArray<BYTE>&);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc43F8B1A71560988CDA93783A20518F4C(Microsoft::VisualStudio::Debugger::DkmProcess*, UINT64, Microsoft::VisualStudio::Debugger::DkmReadMemoryFlags_t, void*, UINT32, UINT32*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcFB08A1C7BD77B71CAE548E8932D320E1(Microsoft::VisualStudio::Debugger::DkmProcess*, UINT64, Microsoft::VisualStudio::Debugger::DkmReadMemoryFlags_t, UINT16, UINT32, Microsoft::VisualStudio::Debugger::DkmArray<BYTE>*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcCB54C33EFFC65296BF4C0F6267CAF6B9(Microsoft::VisualStudio::Debugger::DkmProcess*, UINT64, const Microsoft::VisualStudio::Debugger::DkmArray<BYTE>&);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc6918CAE6B208EA57C2B5EFC585308EA4(Microsoft::VisualStudio::Debugger::DkmProcess*, UINT64, const Microsoft::VisualStudio::Debugger::DkmArray<BYTE>&);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc264596E3D714E689ED29EB416C0EDB59(Microsoft::VisualStudio::Debugger::DkmProcess*, UINT32*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc535260FC7FAE6E6D8632B4D1639CFB53(Microsoft::VisualStudio::Debugger::DkmProcess*, UINT64*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc4013D302AF1F5E1D81F7B9F13E7BE15C(Microsoft::VisualStudio::Debugger::DkmProcess*, UINT64);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc9FA203E127EE0B8B16CF94D1DBF8F7E5(Microsoft::VisualStudio::Debugger::DkmProcess*, Microsoft::VisualStudio::Debugger::Native::DkmNativeRuntimeInstance**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc6CE4E58CC03DB77D9C770472F95BCF46(Microsoft::VisualStudio::Debugger::DkmProcess*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc47D4E3D46CE7EA40D78544A4E2F2CCCB(Microsoft::VisualStudio::Debugger::DkmProcess*, UINT32);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc7AB53941FD46A190C2C1AA3D528041D9(Microsoft::VisualStudio::Debugger::DkmProcess*, bool);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcD53F280F1F4958974C7D9C5765C56D3D(Microsoft::VisualStudio::Debugger::DkmProcess*, Microsoft::VisualStudio::Debugger::DkmStoppingEventProcessingNextAction_t*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc4DD206531745B166ED6A848124817007(Microsoft::VisualStudio::Debugger::DkmProcess*, Microsoft::VisualStudio::Debugger::Evaluation::DkmFuncEvalFlags_t);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcEC0AAA177C50B8CBA6F8BDF561155D7D(Microsoft::VisualStudio::Debugger::DkmProcess*, bool*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcFC48FDC6FDEA04D6E5196CF1CBEEE2E4(Microsoft::VisualStudio::Debugger::DkmProcess*, Microsoft::VisualStudio::Debugger::DkmArray<Microsoft::VisualStudio::Debugger::DkmThread*>*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcA863A9CAB9B57E2180E37E0162F20CE1(Microsoft::VisualStudio::Debugger::DkmProcess*, UINT64, UINT32, UINT32, UINT32, UINT64*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc4C097F77E57173F0A64E1BC1D0723263(Microsoft::VisualStudio::Debugger::DkmProcess*, UINT64, UINT32, UINT32);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc38B421E6EE7506792532303AF2226FCE(Microsoft::VisualStudio::Debugger::DkmProcess*, UINT64, void*, UINT32);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc9DE0E3BEAA03DD17B309B44950EB2366(Microsoft::VisualStudio::Debugger::DkmProcess*, UINT64, const Microsoft::VisualStudio::Debugger::DkmArray<BYTE>&);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc1045230454C0D39659EA1D5AD3413E7E(Microsoft::VisualStudio::Debugger::DkmProcess*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc353AC2FCF8655B4292847535571BE6DA(Microsoft::VisualStudio::Debugger::DkmProcess*, UINT32);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc912C6A5D8C8520F4EE9D8D805F709792(Microsoft::VisualStudio::Debugger::DkmProcess*, Microsoft::VisualStudio::Debugger::DkmString*, Microsoft::VisualStudio::Debugger::DkmString*, Microsoft::VisualStudio::Debugger::DkmString*, UINT32, UINT32, Microsoft::VisualStudio::Debugger::DkmString**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc0F286FA438BB0A3E8BE280B348C50768(Microsoft::VisualStudio::Debugger::DkmProcess*, Microsoft::VisualStudio::Debugger::DkmString**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc4BCA75CF3D92FD0EA881A7C0933E56F6(Microsoft::VisualStudio::Debugger::DkmProcess*, bool*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc2C3E4F93686B031E62765DCF2E354C55(Microsoft::VisualStudio::Debugger::DkmProcess*, Microsoft::VisualStudio::Debugger::DkmArray<Microsoft::VisualStudio::Debugger::Exceptions::DkmStowedExceptionInformation*>*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc11AE8BE85B54FCBEC61658A6EC5669AE(Microsoft::VisualStudio::Debugger::DkmProcess*, Microsoft::VisualStudio::Debugger::Exceptions::DkmStowedExceptionInformation**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc74C5490FBA85CA138364F8B0304B5527(Microsoft::VisualStudio::Debugger::DkmProcess*, Microsoft::VisualStudio::Debugger::Exceptions::DkmStowedExceptionInformation**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcF0490F8C71F1B2038D9EFFE562E9CF9B(Microsoft::VisualStudio::Debugger::DkmProcess*, Microsoft::VisualStudio::Debugger::DkmThread*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc3F1D247E5CBE9876F22B1D94330B371C(Microsoft::VisualStudio::Debugger::DkmProcess*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc444AC9BCFD60B3815B326D50A57FB1A3(Microsoft::VisualStudio::Debugger::DkmProcess*, HRESULT);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcF9282C86885E264678A6962758BB80A6(Microsoft::VisualStudio::Debugger::DkmProcess*, const GUID&, Microsoft::VisualStudio::Debugger::Exceptions::DkmExceptionTrigger*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc9F4AAC0BCB8074D0750AA7E25A7605D6(Microsoft::VisualStudio::Debugger::DkmProcess*, Microsoft::VisualStudio::Debugger::DkmWorkList*, const GUID&, Microsoft::VisualStudio::Debugger::Exceptions::DkmExceptionTrigger*, Microsoft::VisualStudio::Debugger::IDkmCompletionRoutine<Microsoft::VisualStudio::Debugger::Exceptions::DkmRemoveExceptionTriggerAsyncResult>*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcDE09D55133C268C263EACD3C416BF51B(Microsoft::VisualStudio::Debugger::DkmProcess*, Microsoft::VisualStudio::Debugger::DkmWorkList*, Microsoft::VisualStudio::Debugger::IDkmCompletionRoutine<Microsoft::VisualStudio::Debugger::DkmPerformanceCountersAsyncResult>*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc95205A6BC436A6D493CD550A588C10F8(Microsoft::VisualStudio::Debugger::DefaultPort::DkmTransportConnection*, Microsoft::VisualStudio::Debugger::DkmString*, UINT32, const GUID&, Microsoft::VisualStudio::Debugger::Start::DkmStartMethod_t, const GUID&, Microsoft::VisualStudio::Debugger::DkmEngineSettings*, Microsoft::VisualStudio::Debugger::Start::DkmDebugLaunchSettings*, Microsoft::VisualStudio::Debugger::Start::DkmProcessAttachRequest**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcEED23EBC51D0283776E53E11AC6B53AD(Microsoft::VisualStudio::Debugger::DefaultPort::DkmTransportConnection*, Microsoft::VisualStudio::Debugger::DkmString*, UINT32, const GUID&, Microsoft::VisualStudio::Debugger::Start::DkmStartMethod_t, const GUID&, Microsoft::VisualStudio::Debugger::DkmEngineSettings*, Microsoft::VisualStudio::Debugger::Start::DkmDebugLaunchSettings*, UINT64, Microsoft::VisualStudio::Debugger::Start::DkmProcessAttachRequest**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc609FC4C1EFA5159E8A99CB48C4A049B6(Microsoft::VisualStudio::Debugger::Start::DkmProcessAttachRequest*, Microsoft::VisualStudio::Debugger::DkmProcess**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcF505EE31F3B51D5736BBC626A76BFA18(Microsoft::VisualStudio::Debugger::Start::DkmProcessLaunchEnvironmentFilterList*, UINT32, Microsoft::VisualStudio::Debugger::Start::DkmDebugLaunchSettings*, Microsoft::VisualStudio::Debugger::Start::DkmProcessLaunchEnvironmentFilterScenario_t, Microsoft::VisualStudio::Debugger::DkmString**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc7E7DA05F4F334A3C130300B9DE219574(Microsoft::VisualStudio::Debugger::Start::DkmProcessLaunchEnvironmentFilterList**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc133D28FFA03AD3445985EA795062324F(Microsoft::VisualStudio::Debugger::Start::DkmProcessLaunchRequest*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcCE60681703B6B3BE0727ACD155F1F4B0(Microsoft::VisualStudio::Debugger::DkmString*, Microsoft::VisualStudio::Debugger::DkmString*, Microsoft::VisualStudio::Debugger::DkmString*, Microsoft::VisualStudio::Debugger::DkmString*, Microsoft::VisualStudio::Debugger::Start::DkmProcessStartupInfo*, Microsoft::VisualStudio::Debugger::Start::DkmProcessLaunchModeFlags_t, UINT32, Microsoft::VisualStudio::Debugger::DefaultPort::DkmTransportConnection*, Microsoft::VisualStudio::Debugger::DkmEngineSettings*, Microsoft::VisualStudio::Debugger::Start::DkmDebugLaunchSettings*, const Microsoft::VisualStudio::Debugger::DkmDataItem&, Microsoft::VisualStudio::Debugger::Start::DkmProcessLaunchRequest**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc626F2CDEB514881451E5BC89AD48ABC9(Microsoft::VisualStudio::Debugger::DkmString*, Microsoft::VisualStudio::Debugger::DkmString*, Microsoft::VisualStudio::Debugger::DkmString*, Microsoft::VisualStudio::Debugger::DkmString*, Microsoft::VisualStudio::Debugger::Start::DkmProcessStartupInfo*, Microsoft::VisualStudio::Debugger::Start::DkmProcessLaunchModeFlags_t, UINT32, Microsoft::VisualStudio::Debugger::DefaultPort::DkmTransportConnection*, Microsoft::VisualStudio::Debugger::DkmEngineSettings*, Microsoft::VisualStudio::Debugger::Start::DkmDebugLaunchSettings*, Microsoft::VisualStudio::Debugger::Start::DkmProcessLaunchFlags_t, const Microsoft::VisualStudio::Debugger::DkmDataItem&, Microsoft::VisualStudio::Debugger::Start::DkmProcessLaunchRequest**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcEE04EDDA44575ACCE2D895843CC5E455(Microsoft::VisualStudio::Debugger::Start::DkmProcessLaunchRequest*, UINT32, Microsoft::VisualStudio::Debugger::Start::DkmLaunchedProcessInfo*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc92D5E0C5D4EAF1F319BEA651257EFED6(Microsoft::VisualStudio::Debugger::Start::DkmProcessLaunchRequest*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcB93000BE4745096FE67A3B4F7FC0E930(Microsoft::VisualStudio::Debugger::Start::DkmProcessLaunchRequest*, Microsoft::VisualStudio::Debugger::Start::DkmLaunchedProcessInfo*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc048095810FEB921258184BC243942C8C(Microsoft::VisualStudio::Debugger::Start::DkmProcessLaunchRequest*, const GUID&, Microsoft::VisualStudio::Debugger::DkmProcess**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcA8FADDCF3708A1A38F469A40A28BA3B8(Microsoft::VisualStudio::Debugger::DkmString*, Microsoft::VisualStudio::Debugger::DkmString*, UINT32, UINT32, UINT32, UINT32, UINT32, UINT32, UINT32, UINT32, UINT16, UINT64, UINT64, UINT64, Microsoft::VisualStudio::Debugger::Start::DkmProcessStartupInfo**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc5E7FD8F8CCFD4B162EAF3C29B5240CD8(UINT32, Microsoft::VisualStudio::Debugger::Evaluation::DkmSuccessEvaluationResult*, const Microsoft::VisualStudio::Debugger::DkmDataItem&, Microsoft::VisualStudio::Debugger::Internal::DkmPropertyProxy**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcAC74F0017B56DBED5A20E546C72C4091(Microsoft::VisualStudio::Debugger::Internal::DkmPropertyProxy*, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<BYTE>**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcD00A582A8E46FA8DA5A6390AC691465D(Microsoft::VisualStudio::Debugger::Internal::DkmPropertyProxy*, Microsoft::VisualStudio::Debugger::DkmString**, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<BYTE>**, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<BYTE>**, Microsoft::VisualStudio::Debugger::DkmString**, UINT32*, bool*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcC17D73FF4688C3A6F221FDC45D39BEFA(Microsoft::VisualStudio::Debugger::Internal::DkmPropertyProxy*, const Microsoft::VisualStudio::Debugger::DkmArray<BYTE>&, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<BYTE>**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc24A65EB99D5591E0DD35D8B55E0614F8(Microsoft::VisualStudio::Debugger::Internal::DkmPropertyProxy*, Microsoft::VisualStudio::Debugger::DkmString*, UINT32, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<BYTE>**, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<BYTE>**, Microsoft::VisualStudio::Debugger::DkmString**, UINT32*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc53BD85DE362C9852CF729B63A0D58D8B(Microsoft::VisualStudio::Debugger::Internal::DkmPropertyProxy*, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<BYTE>**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc7E66F613557B51733EA6A6D6A87087D7(Microsoft::VisualStudio::Debugger::Internal::DkmPropertyProxy*, const Microsoft::VisualStudio::Debugger::DkmArray<BYTE>&, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<BYTE>**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc302B29EB2B5017008BE1DC136F1ED5EE(Microsoft::VisualStudio::Debugger::DkmString*, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<GUID>*, Microsoft::VisualStudio::Debugger::DefaultPort::DkmPublishedProgramInfo**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc2DB31E954D2ED062F8C66B849EE60429(Microsoft::VisualStudio::Debugger::Symbols::DkmResolvedDocument*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc4E2ECDABAF53878BC2CB86BB0CA5DE92(Microsoft::VisualStudio::Debugger::Symbols::DkmModule*, Microsoft::VisualStudio::Debugger::DkmString*, Microsoft::VisualStudio::Debugger::Script::DkmScriptDocument*, Microsoft::VisualStudio::Debugger::Symbols::DkmDocumentMatchStrength_t, Microsoft::VisualStudio::Debugger::Symbols::DkmResolvedDocumentWarning_t, bool, const Microsoft::VisualStudio::Debugger::DkmDataItem&, Microsoft::VisualStudio::Debugger::Symbols::DkmResolvedDocument**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc1A9C348A582748AB15065E17A667A486(Microsoft::VisualStudio::Debugger::Symbols::DkmResolvedDocument*, const Microsoft::VisualStudio::Debugger::Symbols::DkmTextSpan&, Microsoft::VisualStudio::Debugger::DkmString*, Microsoft::VisualStudio::Debugger::DkmArray<Microsoft::VisualStudio::Debugger::Symbols::DkmInstructionSymbol*>*, Microsoft::VisualStudio::Debugger::DkmArray<Microsoft::VisualStudio::Debugger::Symbols::DkmSourcePosition*>*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcB9407B9EAA35C920D32759FE968A25CA(Microsoft::VisualStudio::Debugger::Symbols::DkmResolvedDocument*, Microsoft::VisualStudio::Debugger::DkmWorkList*, const Microsoft::VisualStudio::Debugger::Symbols::DkmTextSpan&, Microsoft::VisualStudio::Debugger::DkmString*, Microsoft::VisualStudio::Debugger::IDkmCompletionRoutine<Microsoft::VisualStudio::Debugger::Symbols::DkmFindSymbolsAsyncResult>*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc00BCCC33F43438DB686C5A05BE34F2E9(Microsoft::VisualStudio::Debugger::Symbols::DkmModule*, Microsoft::VisualStudio::Debugger::DkmString*, Microsoft::VisualStudio::Debugger::Script::DkmScriptDocument*, Microsoft::VisualStudio::Debugger::Symbols::DkmDocumentMatchStrength_t, Microsoft::VisualStudio::Debugger::Symbols::DkmResolvedDocumentWarning_t, bool, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<Microsoft::VisualStudio::Debugger::Script::DkmScriptBlockMappingInfo*>*, const Microsoft::VisualStudio::Debugger::DkmDataItem&, Microsoft::VisualStudio::Debugger::Symbols::DkmResolvedMappedDocument**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcE236B855866DB4A74880D6FEA3185901(Microsoft::VisualStudio::Debugger::Evaluation::DkmInspectionContext*, const GUID&, const GUID&, Microsoft::VisualStudio::Debugger::CallStack::DkmStackWalkFrame*, Microsoft::VisualStudio::Debugger::Evaluation::DkmExpressionValueHome*, Microsoft::VisualStudio::Debugger::Symbols::DkmModule*, Microsoft::VisualStudio::Debugger::DkmString*, Microsoft::VisualStudio::Debugger::DkmString*, Microsoft::VisualStudio::Debugger::Evaluation::DkmRootVisualizedExpressionFlags_t, UINT32, const Microsoft::VisualStudio::Debugger::DkmDataItem&, Microsoft::VisualStudio::Debugger::Evaluation::DkmRootVisualizedExpression**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc8FA048E453B8822275B07A0A9A0BF6F0(Microsoft::VisualStudio::Debugger::Evaluation::DkmInspectionContext*, const GUID&, const GUID&, Microsoft::VisualStudio::Debugger::CallStack::DkmStackWalkFrame*, Microsoft::VisualStudio::Debugger::Evaluation::DkmExpressionValueHome*, Microsoft::VisualStudio::Debugger::Symbols::DkmModule*, Microsoft::VisualStudio::Debugger::DkmString*, Microsoft::VisualStudio::Debugger::DkmString*, Microsoft::VisualStudio::Debugger::Evaluation::DkmRootVisualizedExpressionFlags_t, UINT32, Microsoft::VisualStudio::Debugger::DkmString*, const Microsoft::VisualStudio::Debugger::DkmDataItem&, Microsoft::VisualStudio::Debugger::Evaluation::DkmRootVisualizedExpression**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc37D73B0F874CC8F77777D40219EDB14A(UINT32, UINT64, UINT32, Microsoft::VisualStudio::Debugger::DkmString*, Microsoft::VisualStudio::Debugger::DkmString*, Microsoft::VisualStudio::Debugger::DkmString*, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<Microsoft::VisualStudio::Debugger::DkmString*>*, Microsoft::VisualStudio::Debugger::DkmString*, Microsoft::VisualStudio::Debugger::DkmString*, Microsoft::VisualStudio::Debugger::DkmString*, UINT32, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<Microsoft::VisualStudio::Debugger::DefaultPort::DkmPublishedProgramInfo*>*, Microsoft::VisualStudio::Debugger::DefaultPort::DkmRunningProcessFlags_t, UINT16, Microsoft::VisualStudio::Debugger::DefaultPort::DkmAppPackageId*, Microsoft::VisualStudio::Debugger::DefaultPort::DkmRunningProcessInfo**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc7729A748D025D8D1D27D5F70D2E2971C(Microsoft::VisualStudio::Debugger::Breakpoints::DkmRuntimeBreakpoint*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcFC9C6DD35B19AD87E29CF388843DEF42(Microsoft::VisualStudio::Debugger::Breakpoints::DkmRuntimeBreakpoint*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc0245E3B12859026D7920DFF4858DF38F(Microsoft::VisualStudio::Debugger::Breakpoints::DkmRuntimeBreakpoint*, Microsoft::VisualStudio::Debugger::DkmWorkList*, Microsoft::VisualStudio::Debugger::IDkmCompletionRoutine<Microsoft::VisualStudio::Debugger::Breakpoints::DkmSetCompiledConditionPendingAsyncResult>*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcE46325D07FF9ECFA31F70280E1A0DD0F(Microsoft::VisualStudio::Debugger::Breakpoints::DkmRuntimeBreakpoint*, Microsoft::VisualStudio::Debugger::Breakpoints::DkmBreakpointCondition*, Microsoft::VisualStudio::Debugger::DkmString**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcA19DF47DA04A1D5C32B02E7F4032BED7(Microsoft::VisualStudio::Debugger::Breakpoints::DkmRuntimeBreakpoint*, Microsoft::VisualStudio::Debugger::DkmWorkList*, Microsoft::VisualStudio::Debugger::Breakpoints::DkmBreakpointCondition*, Microsoft::VisualStudio::Debugger::IDkmCompletionRoutine<Microsoft::VisualStudio::Debugger::Breakpoints::DkmSetEvaluationConditionAsyncResult>*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcF4A3B764CCDEFECC871133DFB3DABD74(Microsoft::VisualStudio::Debugger::Breakpoints::DkmRuntimeBreakpoint*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc99E8152F458A4714289FF221F4100D2F(Microsoft::VisualStudio::Debugger::Breakpoints::DkmRuntimeBreakpoint*, Microsoft::VisualStudio::Debugger::DkmWorkList*, Microsoft::VisualStudio::Debugger::IDkmCompletionRoutine<Microsoft::VisualStudio::Debugger::Breakpoints::DkmClearRuntimeBreakpointConditionsAsyncResult>*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc1E9AD8DA5F656684C0C7A9CBFACB19A3(Microsoft::VisualStudio::Debugger::Breakpoints::DkmRuntimeBreakpoint*, Microsoft::VisualStudio::Debugger::Breakpoints::DkmBreakpointHitCountCondition*, UINT32);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc2F391C137BC1096F8C013BDECD30B957(Microsoft::VisualStudio::Debugger::Breakpoints::DkmRuntimeBreakpoint*, Microsoft::VisualStudio::Debugger::DkmWorkList*, Microsoft::VisualStudio::Debugger::Breakpoints::DkmBreakpointHitCountCondition*, UINT32, Microsoft::VisualStudio::Debugger::IDkmCompletionRoutine<Microsoft::VisualStudio::Debugger::Breakpoints::DkmSetRuntimeBreakpointHitCountConditionAsyncResult>*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcF9E386AD9771E9F2C3058D5834F64CB5(Microsoft::VisualStudio::Debugger::Breakpoints::DkmRuntimeBreakpoint*, Microsoft::VisualStudio::Debugger::Breakpoints::DkmBreakpointHitCountCondition*, UINT32*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc8F395CEE476179C6FEBC6905D21E7A85(Microsoft::VisualStudio::Debugger::Breakpoints::DkmRuntimeBreakpoint*, Microsoft::VisualStudio::Debugger::DkmWorkList*, Microsoft::VisualStudio::Debugger::Breakpoints::DkmBreakpointHitCountCondition*, Microsoft::VisualStudio::Debugger::IDkmCompletionRoutine<Microsoft::VisualStudio::Debugger::Breakpoints::DkmClearRuntimeBreakpointHitCountConditionAsyncResult>*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc2933A0DFA7612550A1AF4A41C1E9C15F(Microsoft::VisualStudio::Debugger::Breakpoints::DkmRuntimeBreakpoint*, UINT32*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc4C9A3BE3A5112A28D0AF6CA87F562C70(Microsoft::VisualStudio::Debugger::Breakpoints::DkmRuntimeBreakpoint*, Microsoft::VisualStudio::Debugger::DkmWorkList*, Microsoft::VisualStudio::Debugger::IDkmCompletionRoutine<Microsoft::VisualStudio::Debugger::Breakpoints::DkmGetRuntimeBreakpointHitCountConditionAsyncResult>*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc41499D88B1F6924ECF29547583D8DD95(Microsoft::VisualStudio::Debugger::Breakpoints::DkmRuntimeBreakpoint*, Microsoft::VisualStudio::Debugger::DkmInstructionAddress*, Microsoft::VisualStudio::Debugger::Breakpoints::DkmBreakpointConditionOperator_t*, Microsoft::VisualStudio::Debugger::Evaluation::DkmCompiledInspectionQuery**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcE8EF7EF6768418441FE22C86348944FC(Microsoft::VisualStudio::Debugger::Breakpoints::DkmRuntimeBreakpoint*, Microsoft::VisualStudio::Debugger::DkmString*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc39CF936CBBD422C18149B4C96CF48257(Microsoft::VisualStudio::Debugger::Breakpoints::DkmRuntimeBreakpoint*, Microsoft::VisualStudio::Debugger::DkmThread*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcA6288D90C3F6D3DECB145E59C1E2E0BE(Microsoft::VisualStudio::Debugger::Breakpoints::DkmRuntimeBreakpoint*, Microsoft::VisualStudio::Debugger::DkmWorkList*, Microsoft::VisualStudio::Debugger::DkmThread*, Microsoft::VisualStudio::Debugger::IDkmCompletionRoutine<Microsoft::VisualStudio::Debugger::Breakpoints::DkmRequestBreakpointEventOnModifiedThreadAsyncResult>*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc93E2EB641A58D187BC71A1FD19D779A4(Microsoft::VisualStudio::Debugger::Breakpoints::DkmRuntimeBreakpoint*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc9893B43ADE803E4FF563307C23A5DE77(Microsoft::VisualStudio::Debugger::Breakpoints::DkmRuntimeBreakpoint*, Microsoft::VisualStudio::Debugger::DkmWorkList*, Microsoft::VisualStudio::Debugger::IDkmCompletionRoutine<Microsoft::VisualStudio::Debugger::Breakpoints::DkmEnableRuntimeBreakpointAsyncResult>*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcFFE7BBBBC1EC94B9CB3791B48190C3C2(Microsoft::VisualStudio::Debugger::Breakpoints::DkmRuntimeBreakpoint*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcAB4964C8D77D3256EFE0D6A44501C685(Microsoft::VisualStudio::Debugger::Breakpoints::DkmRuntimeBreakpoint*, Microsoft::VisualStudio::Debugger::DkmWorkList*, Microsoft::VisualStudio::Debugger::IDkmCompletionRoutine<Microsoft::VisualStudio::Debugger::Breakpoints::DkmTestRuntimeBreakpointAsyncResult>*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc37D0CD0D0909DE69E045690F177B6ED0(Microsoft::VisualStudio::Debugger::Breakpoints::DkmRuntimeBreakpoint*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc7F86958C6499B678D002E26D8724C3E4(Microsoft::VisualStudio::Debugger::Breakpoints::DkmRuntimeBreakpoint*, Microsoft::VisualStudio::Debugger::DkmWorkList*, Microsoft::VisualStudio::Debugger::IDkmCompletionRoutine<Microsoft::VisualStudio::Debugger::Breakpoints::DkmDisableRuntimeBreakpointAsyncResult>*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc11942CA3E32D2CC5E71549580B4EEE2F(Microsoft::VisualStudio::Debugger::Breakpoints::DkmRuntimeBreakpoint*, Microsoft::VisualStudio::Debugger::DkmThread*, bool);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcA744AE7AD70089B93C050396189C0E6D(Microsoft::VisualStudio::Debugger::Breakpoints::DkmRuntimeBreakpoint*, Microsoft::VisualStudio::Debugger::DkmThread*, Microsoft::VisualStudio::Debugger::DkmThread**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc654E5E6C9B16E21E572DC1F61E81FC11(Microsoft::VisualStudio::Debugger::Breakpoints::DkmRuntimeBreakpoint*, Microsoft::VisualStudio::Debugger::DkmWorkList*, Microsoft::VisualStudio::Debugger::DkmThread*, Microsoft::VisualStudio::Debugger::IDkmCompletionRoutine<Microsoft::VisualStudio::Debugger::Breakpoints::DkmEvaluateConditionAndSelectThreadAsyncResult>*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcE1E4C9C8AACD6229ECEA07922F384831(Microsoft::VisualStudio::Debugger::Breakpoints::DkmRuntimeBreakpoint*, Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILFailureReason_t);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc1CB7AA5C0E18E7C2533CABD78EF033B3(Microsoft::VisualStudio::Debugger::FunctionResolution::DkmRuntimeFunctionResolutionRequest*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc02F5B636B11CFD1F31E0C794EE4631B8(Microsoft::VisualStudio::Debugger::DkmProcess*, const Microsoft::VisualStudio::Debugger::Evaluation::DkmCompilerId&, Microsoft::VisualStudio::Debugger::DkmString*, UINT32, Microsoft::VisualStudio::Debugger::DkmString*, Microsoft::VisualStudio::Debugger::FunctionResolution::DkmAddressSearchFlags_t, const Microsoft::VisualStudio::Debugger::DkmDataItem&, Microsoft::VisualStudio::Debugger::FunctionResolution::DkmRuntimeFunctionResolutionRequest**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcDF15402D0A339E45CC2A57DB2F63EBE3(Microsoft::VisualStudio::Debugger::FunctionResolution::DkmRuntimeFunctionResolutionRequest*, Microsoft::VisualStudio::Debugger::DkmWorkList*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcB7DF07C7E259E057345053EA721F2BCE(Microsoft::VisualStudio::Debugger::FunctionResolution::DkmRuntimeFunctionResolutionRequest*, Microsoft::VisualStudio::Debugger::DkmInstructionAddress*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc4C6C4F1118EF07A4E19E8D544DBDEEA0(Microsoft::VisualStudio::Debugger::FunctionResolution::DkmRuntimeFunctionResolutionRequest*, Microsoft::VisualStudio::Debugger::DkmWorkList*, Microsoft::VisualStudio::Debugger::DkmInstructionAddress*, Microsoft::VisualStudio::Debugger::IDkmCompletionRoutine<Microsoft::VisualStudio::Debugger::FunctionResolution::DkmOnFunctionResolvedAsyncResult>*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc10A22778D523D607BD6C09729AD0F35E(Microsoft::VisualStudio::Debugger::FunctionResolution::DkmRuntimeFunctionResolutionRequest*, Microsoft::VisualStudio::Debugger::Breakpoints::DkmBreakpointMessageLevel_t, Microsoft::VisualStudio::Debugger::DkmString*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcC1543CFD5ACC8E9540123E1C97C081EC(Microsoft::VisualStudio::Debugger::FunctionResolution::DkmRuntimeFunctionResolutionRequest*, Microsoft::VisualStudio::Debugger::DkmWorkList*, Microsoft::VisualStudio::Debugger::Breakpoints::DkmBreakpointMessageLevel_t, Microsoft::VisualStudio::Debugger::DkmString*, Microsoft::VisualStudio::Debugger::IDkmCompletionRoutine<Microsoft::VisualStudio::Debugger::FunctionResolution::DkmOnResolverMessageAsyncResult>*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc473E9833342ED425C288649015CC324B(Microsoft::VisualStudio::Debugger::DkmRuntimeInstance*, const GUID&, Microsoft::VisualStudio::Debugger::DkmThread*, UINT64, Microsoft::VisualStudio::Debugger::Breakpoints::DkmDataAccessStopMask_t, UINT32, const Microsoft::VisualStudio::Debugger::DkmDataItem&, Microsoft::VisualStudio::Debugger::Breakpoints::DkmRuntimeHardwareDataBreakpoint**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc0E8B280F47F46C4B2A2734040F7FA707(Microsoft::VisualStudio::Debugger::DkmRuntimeInstance*, Microsoft::VisualStudio::Debugger::DkmArray<Microsoft::VisualStudio::Debugger::Script::DkmScriptDocumentTreeNode*>*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc245EB5834F220A1C282AA6E2B457151C(Microsoft::VisualStudio::Debugger::DkmRuntimeInstance*, Microsoft::VisualStudio::Debugger::DkmArray<Microsoft::VisualStudio::Debugger::DkmModuleInstance*>*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc9E83BEF15E45216D9E571931B801FC8F(Microsoft::VisualStudio::Debugger::DkmRuntimeInstance*, Microsoft::VisualStudio::Debugger::DkmArray<Microsoft::VisualStudio::Debugger::ParallelTasks::DkmTaskProvider*>*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcF47641A9B4F4EF84594FF51457BD43AD(Microsoft::VisualStudio::Debugger::DkmRuntimeInstance*, UINT64, Microsoft::VisualStudio::Debugger::DkmInstructionAddress**, bool*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcDDA5249C91A40BC1C63ABF57EE417F35(Microsoft::VisualStudio::Debugger::DkmRuntimeInstance*, Microsoft::VisualStudio::Debugger::DkmWorkList*, UINT64, Microsoft::VisualStudio::Debugger::IDkmCompletionRoutine<Microsoft::VisualStudio::Debugger::DkmResolveCPUInstructionAddressAsyncResult>*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc10463036625AB2B5AAA7F05509328531(Microsoft::VisualStudio::Debugger::DkmRuntimeInstance*, Microsoft::VisualStudio::Debugger::DkmString*, Microsoft::VisualStudio::Debugger::DkmArray<Microsoft::VisualStudio::Debugger::DkmModuleInstance*>*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc49AB6C5E8A36B60EA1D587680080E9ED(Microsoft::VisualStudio::Debugger::DkmRuntimeInstance*, Microsoft::VisualStudio::Debugger::CallStack::DkmStackWalkFrame*, CV_HREG_e, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<BYTE>*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc003CEB61065326C60432436C71B15AF3(Microsoft::VisualStudio::Debugger::DkmRuntimeInstance*, Microsoft::VisualStudio::Debugger::Stepping::DkmStepper*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcFF2EBEF240F6308F4BC2649DFFAED7C9(Microsoft::VisualStudio::Debugger::DkmRuntimeInstance*, Microsoft::VisualStudio::Debugger::Stepping::DkmStepper*, Microsoft::VisualStudio::Debugger::Stepping::DkmStepArbitrationReason_t, bool*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc803C37AF1E9AECCD4C7CAE2B2785162A(Microsoft::VisualStudio::Debugger::DkmRuntimeInstance*, Microsoft::VisualStudio::Debugger::Stepping::DkmStepper*, Microsoft::VisualStudio::Debugger::Stepping::DkmStepArbitrationReason_t);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcC0CB9DB875E57138C93DFCE332C3D32C(Microsoft::VisualStudio::Debugger::DkmRuntimeInstance*, Microsoft::VisualStudio::Debugger::Stepping::DkmStepper*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcAA61459CFDC30CEC49DA6E3BBD21802C(Microsoft::VisualStudio::Debugger::DkmRuntimeInstance*, Microsoft::VisualStudio::Debugger::Stepping::DkmStepper*, Microsoft::VisualStudio::Debugger::Stepping::DkmStepArbitrationReason_t, Microsoft::VisualStudio::Debugger::DkmRuntimeInstance*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc6C79DBE9F40FE80E961282947D988039(Microsoft::VisualStudio::Debugger::DkmRuntimeInstance*, Microsoft::VisualStudio::Debugger::Stepping::DkmStepper*, Microsoft::VisualStudio::Debugger::Stepping::DkmStepArbitrationReason_t, Microsoft::VisualStudio::Debugger::DkmRuntimeInstance*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcF0247C5D3632A8B6B5A018211C1D2410(Microsoft::VisualStudio::Debugger::DkmRuntimeInstance*, Microsoft::VisualStudio::Debugger::Stepping::DkmStepper*, Microsoft::VisualStudio::Debugger::Stepping::DkmStepArbitrationReason_t, Microsoft::VisualStudio::Debugger::DkmRuntimeInstance*, bool*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc17820A171C58275B4CB2469D9614049B(Microsoft::VisualStudio::Debugger::DkmRuntimeInstance*, Microsoft::VisualStudio::Debugger::Stepping::DkmStepper*, bool, Microsoft::VisualStudio::Debugger::Stepping::DkmStepArbitrationReason_t, Microsoft::VisualStudio::Debugger::DkmRuntimeInstance*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc2344FF3BDFEDB69A0DC72C3155B8F61B(Microsoft::VisualStudio::Debugger::DkmRuntimeInstance*, Microsoft::VisualStudio::Debugger::Stepping::DkmStepper*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcB0B79064BF97FA5726711951AECE4E77(Microsoft::VisualStudio::Debugger::DkmRuntimeInstance*, Microsoft::VisualStudio::Debugger::DkmWorkList*, Microsoft::VisualStudio::Debugger::DkmThread*, Microsoft::VisualStudio::Debugger::IDkmCompletionRoutine<Microsoft::VisualStudio::Debugger::ThreadProperties::DkmGetThreadDisplayPropertiesAsyncResult>*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc2EA1B4DEDF4599B865E8E1A2E5718E86(Microsoft::VisualStudio::Debugger::DkmRuntimeInstance*, Microsoft::VisualStudio::Debugger::DkmThread*, Microsoft::VisualStudio::Debugger::DkmString**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcA73EB0668CACF4528C6378839C71F455(Microsoft::VisualStudio::Debugger::DkmRuntimeInstance*, Microsoft::VisualStudio::Debugger::DkmWorkList*, Microsoft::VisualStudio::Debugger::DkmThread*, Microsoft::VisualStudio::Debugger::IDkmCompletionRoutine<Microsoft::VisualStudio::Debugger::ThreadProperties::DkmGetThreadNameAsyncResult>*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcCA285C60E7286A27F6D525028789BEB1(Microsoft::VisualStudio::Debugger::DkmRuntimeInstance*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcB94CF78451EDBCA915BAFD75C300EF35(Microsoft::VisualStudio::Debugger::DkmRuntimeInstance*, Microsoft::VisualStudio::Debugger::DkmArray<Microsoft::VisualStudio::Debugger::Clr::DkmManagedHeapSampler*>*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcA4A36CF75EB42A472782FD7825A58C9D(Microsoft::VisualStudio::Debugger::DkmRuntimeInstance*, Microsoft::VisualStudio::Debugger::DkmArray<Microsoft::VisualStudio::Debugger::Clr::DkmManagedHeapWalker*>*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc1DF54DB322921281DE98E82C2A0D2D12(Microsoft::VisualStudio::Debugger::DkmRuntimeInstance*, ICorDebugFrame*, UINT32, UINT32, Microsoft::VisualStudio::Debugger::DkmArray<Microsoft::VisualStudio::Debugger::Stepping::DkmSteppingCodePath*>*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcA67728A0C5C3D3B4EACB1F1C598A20D7(Microsoft::VisualStudio::Debugger::DkmRuntimeInstance*, Microsoft::VisualStudio::Debugger::DkmInstructionAddress*, UINT32, Microsoft::VisualStudio::Debugger::DkmArray<Microsoft::VisualStudio::Debugger::Disassembly::DkmDisassembledInstruction*>*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc147D5B957653AEED0BF962688F3879AE(Microsoft::VisualStudio::Debugger::DkmRuntimeInstance*, Microsoft::VisualStudio::Debugger::DkmInstructionAddress*, INT32, Microsoft::VisualStudio::Debugger::DkmInstructionAddress**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc698471DF4195CB1B70826EC3715C2DF8(Microsoft::VisualStudio::Debugger::DkmRuntimeInstance*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW int STDMETHODCALLTYPE ProcE97BC9882851F8E9E5A3179B48A6A534(const Microsoft::VisualStudio::Debugger::DkmRuntimeInstanceId&, const Microsoft::VisualStudio::Debugger::DkmRuntimeInstanceId&);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcCB83857C81F60315EF70D865BF0E4B1A(const GUID&, Microsoft::VisualStudio::Debugger::DkmThread*, Microsoft::VisualStudio::Debugger::DkmInstructionAddress*, bool, const Microsoft::VisualStudio::Debugger::DkmDataItem&, Microsoft::VisualStudio::Debugger::Breakpoints::DkmRuntimeInstructionBreakpoint**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcE485A2033078735C920AC84BD6F97736(Microsoft::VisualStudio::Debugger::Breakpoints::DkmRuntimeInstructionBreakpoint*, Microsoft::VisualStudio::Debugger::Evaluation::DkmCompiledInspectionQuery*, Microsoft::VisualStudio::Debugger::Breakpoints::DkmBreakpointConditionOperator_t);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc7AF36FD7B7E0B4CE88AC133EBE2CA062(Microsoft::VisualStudio::Debugger::Breakpoints::DkmRuntimeInstructionBreakpoint*, Microsoft::VisualStudio::Debugger::DkmWorkList*, Microsoft::VisualStudio::Debugger::Evaluation::DkmCompiledInspectionQuery*, Microsoft::VisualStudio::Debugger::Breakpoints::DkmBreakpointConditionOperator_t, Microsoft::VisualStudio::Debugger::IDkmCompletionRoutine<Microsoft::VisualStudio::Debugger::Breakpoints::DkmSetCompiledConditionAsyncResult>*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcB7BFDF6A5DD40400B07E77E9E74DD0ED(Microsoft::VisualStudio::Debugger::Breakpoints::DkmRuntimeInstructionBreakpoint*, Microsoft::VisualStudio::Debugger::Evaluation::DkmCompiledInspectionQuery*, Microsoft::VisualStudio::Debugger::Breakpoints::DkmBreakpointConditionOperator_t);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc3ABAEA10372ACE2485C57CA038BBC209(Microsoft::VisualStudio::Debugger::Breakpoints::DkmRuntimeInstructionBreakpoint*, Microsoft::VisualStudio::Debugger::DkmWorkList*, Microsoft::VisualStudio::Debugger::Evaluation::DkmCompiledInspectionQuery*, Microsoft::VisualStudio::Debugger::Breakpoints::DkmBreakpointConditionOperator_t, Microsoft::VisualStudio::Debugger::IDkmCompletionRoutine<Microsoft::VisualStudio::Debugger::Breakpoints::DkmTryPushConditionToTargetDeviceAsyncResult>*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc720EFC94A30F2FDA0A06EC4DDEA4C417(Microsoft::VisualStudio::Debugger::Breakpoints::DkmRuntimeInstructionBreakpoint*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc79B572DB628856A7B5E44CCD638AF7DC(Microsoft::VisualStudio::Debugger::Breakpoints::DkmRuntimeInstructionBreakpoint*, Microsoft::VisualStudio::Debugger::DkmWorkList*, Microsoft::VisualStudio::Debugger::IDkmCompletionRoutine<Microsoft::VisualStudio::Debugger::Breakpoints::DkmTryClearConditionOnTargetDeviceAsyncResult>*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW int STDMETHODCALLTYPE Proc3DE111A28EFA51314B6DEABFD2A12DB2(const Microsoft::VisualStudio::Debugger::Symbols::DkmSHA1HashValue&, const Microsoft::VisualStudio::Debugger::Symbols::DkmSHA1HashValue&);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc50B5D8DA1C11FB7B3B25AF5A65A55FB0(Microsoft::VisualStudio::Debugger::DkmString*, const Microsoft::VisualStudio::Debugger::Symbols::DkmTextSpan&, Microsoft::VisualStudio::Debugger::Script::DkmScriptBlockMappingInfo**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE GetC5849E9833F5F36297EB088EC664A234(Microsoft::VisualStudio::Debugger::Script::DkmScriptDocument*, Microsoft::VisualStudio::Debugger::Script::DkmScriptSourceProjectItem**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcEA0F13D8EBAAD5C57D07D7CA0ADFBE54(Microsoft::VisualStudio::Debugger::DkmRuntimeInstance*, Microsoft::VisualStudio::Debugger::Script::DkmScriptDocumentTreeNode*, Microsoft::VisualStudio::Debugger::DkmString*, Microsoft::VisualStudio::Debugger::Symbols::DkmModule*, Microsoft::VisualStudio::Debugger::DkmString*, Microsoft::VisualStudio::Debugger::DkmString*, Microsoft::VisualStudio::Debugger::Script::DkmScriptDocumentFlags_t, Microsoft::VisualStudio::Debugger::Script::DkmScriptSourceProjectItem*, const Microsoft::VisualStudio::Debugger::DkmDataItem&, Microsoft::VisualStudio::Debugger::Script::DkmScriptDocument**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcA673B7F58C93640EC322B5C0A2E63F79(Microsoft::VisualStudio::Debugger::DkmRuntimeInstance*, Microsoft::VisualStudio::Debugger::Script::DkmScriptDocumentTreeNode*, Microsoft::VisualStudio::Debugger::DkmString*, Microsoft::VisualStudio::Debugger::Symbols::DkmModule*, Microsoft::VisualStudio::Debugger::DkmString*, Microsoft::VisualStudio::Debugger::DkmString*, Microsoft::VisualStudio::Debugger::Script::DkmScriptDocumentFlags_t, Microsoft::VisualStudio::Debugger::Script::DkmScriptDocumentContentType_t, Microsoft::VisualStudio::Debugger::Script::DkmScriptEmbeddedDocumentKind_t, Microsoft::VisualStudio::Debugger::Script::DkmScriptSourceProjectItem*, Microsoft::VisualStudio::Debugger::Script::DkmScriptDocumentJmcState_t, const Microsoft::VisualStudio::Debugger::DkmDataItem&, Microsoft::VisualStudio::Debugger::Script::DkmScriptDocument**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc605D280FE9838181FA3A4A2B68F0F82B(Microsoft::VisualStudio::Debugger::Script::DkmScriptDocument*, bool, Microsoft::VisualStudio::Debugger::DkmString**, Microsoft::VisualStudio::Debugger::DkmArray<UINT32>*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcB907C0A7AFABDB032781F0EB78062FA2(Microsoft::VisualStudio::Debugger::Script::DkmScriptDocument*, bool);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc3070F6337FAFE9328B926573E08C6350(Microsoft::VisualStudio::Debugger::Script::DkmScriptDocument*, Microsoft::VisualStudio::Debugger::Symbols::DkmSourceFileId*, Microsoft::VisualStudio::Debugger::Symbols::DkmResolvedDocument**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcDEE08F4607BF904380CD375869159CAA(Microsoft::VisualStudio::Debugger::Script::DkmScriptDocument*, bool);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc2E0CDF0E0AEBB33AA8AE4C476F46A6E1(Microsoft::VisualStudio::Debugger::Script::DkmScriptDocument*, Microsoft::VisualStudio::Debugger::DkmWorkList*, bool, Microsoft::VisualStudio::Debugger::IDkmCompletionRoutine<Microsoft::VisualStudio::Debugger::Script::DkmSetRaiseSymbolEventsAsyncResult>*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc6C9638A955AE91EA6325FFD14E45E14C(Microsoft::VisualStudio::Debugger::Script::DkmScriptDocument*, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<Microsoft::VisualStudio::Debugger::Script::DkmScriptBlockMappingInfo*>**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcE2EA22D316F3FD9C3A1E03841E45F509(Microsoft::VisualStudio::Debugger::Script::DkmScriptDocument*, const Microsoft::VisualStudio::Debugger::Symbols::DkmTextSpan&, Microsoft::VisualStudio::Debugger::DkmString*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc28927B0EE826B95D2F3582541114A6FB(Microsoft::VisualStudio::Debugger::Script::DkmScriptDocument*, const Microsoft::VisualStudio::Debugger::Symbols::DkmTextSpan&, UINT32);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc6110C67BD847D8134C925AC608E254E1(Microsoft::VisualStudio::Debugger::Script::DkmScriptDocument*, Microsoft::VisualStudio::Debugger::Script::DkmScriptDocumentJmcState_t);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc1AE37B2274C1C965566B6B7955EABD47(Microsoft::VisualStudio::Debugger::DkmRuntimeInstance*, Microsoft::VisualStudio::Debugger::Script::DkmScriptDocumentTreeNode*, Microsoft::VisualStudio::Debugger::DkmString*, const Microsoft::VisualStudio::Debugger::DkmDataItem&, Microsoft::VisualStudio::Debugger::Script::DkmScriptDocumentTreeNode**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc14A934ACD96B407ADFD71AE6C2B5C520(Microsoft::VisualStudio::Debugger::Script::DkmScriptDocumentTreeNode*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcF1A9A362454701895C74085D767B0A84(Microsoft::VisualStudio::Debugger::DkmModuleInstance*, Microsoft::VisualStudio::Debugger::Script::DkmScriptRuntimeInstance*, Microsoft::VisualStudio::Debugger::Script::DkmScriptDocument*, UINT32, UINT32, UINT32, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<BYTE>*, const Microsoft::VisualStudio::Debugger::DkmInstructionAddress::CPUInstruction*, Microsoft::VisualStudio::Debugger::Script::DkmScriptInstructionAddress**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcB0BD63F2B9661E923F8200970F45D067(Microsoft::VisualStudio::Debugger::Symbols::DkmModule*, const GUID&, Microsoft::VisualStudio::Debugger::Script::DkmScriptDocument*, UINT32, UINT32, UINT32, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<BYTE>*, Microsoft::VisualStudio::Debugger::Script::DkmScriptInstructionSymbol**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc35C553500D44E1B4057B6A4FA0819122(Microsoft::VisualStudio::Debugger::Script::DkmScriptInstructionSymbol*, Microsoft::VisualStudio::Debugger::Script::DkmScriptInstructionSymbol*, bool, Microsoft::VisualStudio::Debugger::Script::DkmScriptSymbolNextSteppingAction_t*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc470676CA7F49CBA39017F29721BF5721(Microsoft::VisualStudio::Debugger::DkmProcess*, const Microsoft::VisualStudio::Debugger::DkmRuntimeInstanceId&, UINT32, const Microsoft::VisualStudio::Debugger::DkmDataItem&, Microsoft::VisualStudio::Debugger::Script::DkmScriptRuntimeInstance**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcB33C67B27C7D54EBA23E2C2FB33D4DBC(Microsoft::VisualStudio::Debugger::DkmProcess*, const Microsoft::VisualStudio::Debugger::DkmRuntimeInstanceId&, Microsoft::VisualStudio::Debugger::DkmRuntimeCapabilities_t, Microsoft::VisualStudio::Debugger::DkmRuntimeInstance*, UINT32, const Microsoft::VisualStudio::Debugger::DkmDataItem&, Microsoft::VisualStudio::Debugger::Script::DkmScriptRuntimeInstance**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcCAE8512E35EA05E7C9580B90ACA14D37(Microsoft::VisualStudio::Debugger::DkmProcess*, const Microsoft::VisualStudio::Debugger::DkmRuntimeInstanceId&, Microsoft::VisualStudio::Debugger::DkmRuntimeCapabilities_t, Microsoft::VisualStudio::Debugger::DkmRuntimeInstance*, UINT32, bool, UINT64, const Microsoft::VisualStudio::Debugger::DkmDataItem&, Microsoft::VisualStudio::Debugger::Script::DkmScriptRuntimeInstance**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc7BC07BA209278B7749391B532A06C4B1(Microsoft::VisualStudio::Debugger::Script::DkmScriptRuntimeInstance*, IRemoteDebugApplication**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc69A328E0ADD079DF0ACFF13D910911C8(Microsoft::VisualStudio::Debugger::Script::DkmScriptRuntimeInstance*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc128384C8203A27AA4CD3890344DFF576(Microsoft::VisualStudio::Debugger::Script::DkmScriptRuntimeInstance*, Microsoft::VisualStudio::Debugger::DkmWorkList*, Microsoft::VisualStudio::Debugger::DkmString*, UINT32, Microsoft::VisualStudio::Debugger::DkmString*, Microsoft::VisualStudio::Debugger::Script::DkmScriptInstructionAddress*, Microsoft::VisualStudio::Debugger::Symbols::DkmSourcePosition*, Microsoft::VisualStudio::Debugger::IDkmCompletionRoutine<Microsoft::VisualStudio::Debugger::Script::DkmOnScriptCriticalErrorAsyncResult>*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcAEDE145089DD531D49D8D3AFC3277A6C(Microsoft::VisualStudio::Debugger::Script::DkmScriptRuntimeInstance*, const Microsoft::VisualStudio::Debugger::DkmArray<Microsoft::VisualStudio::Debugger::Script::DkmScriptDocument*>&);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc2F17F66CDE0E78674E5011F343327F56(Microsoft::VisualStudio::Debugger::DkmString*, bool, Microsoft::VisualStudio::Debugger::Script::DkmScriptSourceProjectItem**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc8C8881FB7D3648D13E24DE5A80DD1F83(const GUID&, Microsoft::VisualStudio::Debugger::DkmThread*, Microsoft::VisualStudio::Debugger::Stepping::DkmSingleStepRequest**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcADBB6CC055D2BD215B9891EC59C55284(Microsoft::VisualStudio::Debugger::Stepping::DkmSingleStepRequest*, Microsoft::VisualStudio::Debugger::DkmThread*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc5C34DFAF0E3CA60C3523472E5C911930(Microsoft::VisualStudio::Debugger::Stepping::DkmSingleStepRequest*, const Microsoft::VisualStudio::Debugger::DkmArray<UINT64>&);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc39295C4B4207546A5413781780E09C01(Microsoft::VisualStudio::Debugger::Stepping::DkmSingleStepRequest*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcAE64E2E60E05EDDB9DBF80F18CB6B1D1(Microsoft::VisualStudio::Debugger::Stepping::DkmSingleStepRequest*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcE5290FEE5BE393C4CBEFDBC334154102(Microsoft::VisualStudio::Debugger::Stepping::DkmSingleStepRequest*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc96B2A0869281F2E9E1E8FB63DDDC012B(Microsoft::VisualStudio::Debugger::Stepping::DkmSingleStepRequest*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc8CB20AF3128815B290295CECB4F778C2(Microsoft::VisualStudio::Debugger::DkmString*, Microsoft::VisualStudio::Debugger::Script::DkmScriptDocument*, const Microsoft::VisualStudio::Debugger::Symbols::DkmSourceFileId::MD5Hash*, const Microsoft::VisualStudio::Debugger::Symbols::DkmSourceFileId::SHA1Hash*, Microsoft::VisualStudio::Debugger::Symbols::DkmSourceFileId**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcC7F5C260E52A1B26A2C10C0D8BF7787C(Microsoft::VisualStudio::Debugger::Symbols::DkmSourceFileId*, const Microsoft::VisualStudio::Debugger::Symbols::DkmTextSpan&, Microsoft::VisualStudio::Debugger::Symbols::DkmSourcePosition**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcFFE6AA7C220F41C1F306FAAC721E5E76(Microsoft::VisualStudio::Debugger::CallStack::DkmStackContext*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcDEEC88626A3FA552218C1327D95542B1(Microsoft::VisualStudio::Debugger::Evaluation::DkmInspectionSession*, Microsoft::VisualStudio::Debugger::DkmThread*, Microsoft::VisualStudio::Debugger::CallStack::DkmCallStackFilterOptions_t, const Microsoft::VisualStudio::Debugger::CallStack::DkmFrameFormatOptions&, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<BYTE>*, const Microsoft::VisualStudio::Debugger::DkmDataItem&, Microsoft::VisualStudio::Debugger::CallStack::DkmStackContext**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc25F3629003D01C15D2C699A63D201EAD(Microsoft::VisualStudio::Debugger::Evaluation::DkmInspectionSession*, Microsoft::VisualStudio::Debugger::DkmThread*, Microsoft::VisualStudio::Debugger::CallStack::DkmCallStackFilterOptions_t, const Microsoft::VisualStudio::Debugger::CallStack::DkmFrameFormatOptions&, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<BYTE>*, Microsoft::VisualStudio::Debugger::CallStack::DkmAsyncStackWalkContext*, Microsoft::VisualStudio::Debugger::CallStack::DkmStackWalkOperation_t, const Microsoft::VisualStudio::Debugger::DkmDataItem&, Microsoft::VisualStudio::Debugger::CallStack::DkmStackContext**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcC523C229635B2E14B58D880FD561BD8B(Microsoft::VisualStudio::Debugger::CallStack::DkmStackContext*, Microsoft::VisualStudio::Debugger::DkmWorkList*, UINT32, Microsoft::VisualStudio::Debugger::IDkmCompletionRoutine<Microsoft::VisualStudio::Debugger::CallStack::DkmGetNextFramesAsyncResult>*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc28D1273D015808E5A637BACE1F82718C(Microsoft::VisualStudio::Debugger::CallStack::DkmStackWalkFrame*, const Microsoft::VisualStudio::Debugger::CallStack::DkmFrameFormatOptions&, const Microsoft::VisualStudio::Debugger::Evaluation::DkmCompilerId&, Microsoft::VisualStudio::Debugger::DkmString*, Microsoft::VisualStudio::Debugger::DkmString*, Microsoft::VisualStudio::Debugger::Symbols::DkmSourcePosition*, Microsoft::VisualStudio::Debugger::CallStack::DkmStackFrame**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc4C1B28C21F3C11BDC1687B7F3D78B840(Microsoft::VisualStudio::Debugger::CallStack::DkmStackFrame*, Microsoft::VisualStudio::Debugger::DkmInstructionAddress*, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<Microsoft::VisualStudio::Debugger::Disassembly::DkmEffectiveAddress>**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc7F3F889DF5BFA8C78C8D53CD3D56516D(Microsoft::VisualStudio::Debugger::DkmThread*, const Microsoft::VisualStudio::Debugger::CallStack::DkmStackMemoryRange&, const Microsoft::VisualStudio::Debugger::Symbols::DkmMD5HashValue&, const Microsoft::VisualStudio::Debugger::Symbols::DkmMD5HashValue&, Microsoft::VisualStudio::Debugger::CallStack::DkmStackHash**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW int STDMETHODCALLTYPE Proc9828B496783EE3A4837AA6A8CB8EA07F(const Microsoft::VisualStudio::Debugger::CallStack::DkmStackMemoryRange&, const Microsoft::VisualStudio::Debugger::CallStack::DkmStackMemoryRange&);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc0F86415E78B3D06F5C59926FF40D2E0A(Microsoft::VisualStudio::Debugger::CallStack::DkmStackWalkContext*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcA34DFAA73EBF7F9AFDC8E6C494472623(Microsoft::VisualStudio::Debugger::DkmThread*, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<BYTE>*, const Microsoft::VisualStudio::Debugger::DkmDataItem&, Microsoft::VisualStudio::Debugger::CallStack::DkmStackWalkContext**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcC5D26383F8A6987AA14E7F72D5BAB969(Microsoft::VisualStudio::Debugger::CallStack::DkmStackWalkContext*, const GUID&, Microsoft::VisualStudio::Debugger::CallStack::DkmSymbolStackWalkContext**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc565FEFF060E22589D7A3DA86DBF0C5A9(Microsoft::VisualStudio::Debugger::CallStack::DkmStackWalkContext*, Microsoft::VisualStudio::Debugger::CallStack::DkmFrameRegisters*, UINT32, UINT64, Microsoft::VisualStudio::Debugger::DkmArray<Microsoft::VisualStudio::Debugger::CallStack::DkmStackWalkFrame*>*, Microsoft::VisualStudio::Debugger::CallStack::DkmFrameRegisters**, bool*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcD8298F6AEBCFE639A5277E7C6B4C291E(Microsoft::VisualStudio::Debugger::CallStack::DkmStackWalkContext*, Microsoft::VisualStudio::Debugger::DkmWorkList*, Microsoft::VisualStudio::Debugger::CallStack::DkmFrameRegisters*, UINT32, UINT64, Microsoft::VisualStudio::Debugger::IDkmCompletionRoutine<Microsoft::VisualStudio::Debugger::CallStack::DkmHeuristicWalkFramesAsyncResult>*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc919F289A3BBDF586B90161CC0F85674B(Microsoft::VisualStudio::Debugger::CallStack::DkmStackWalkContext*, UINT32, UINT32, Microsoft::VisualStudio::Debugger::CallStack::DkmStackHash*, Microsoft::VisualStudio::Debugger::DkmArray<Microsoft::VisualStudio::Debugger::CallStack::DkmStackWalkFrame*>*, bool*, Microsoft::VisualStudio::Debugger::CallStack::DkmStackHash**, Microsoft::VisualStudio::Debugger::CallStack::DkmStackWalkContext**, bool*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc582931453CE802630963C16E4C3CE31C(Microsoft::VisualStudio::Debugger::CallStack::DkmStackWalkContext*, Microsoft::VisualStudio::Debugger::DkmWorkList*, UINT32, UINT32, Microsoft::VisualStudio::Debugger::CallStack::DkmStackHash*, Microsoft::VisualStudio::Debugger::IDkmCompletionRoutine<Microsoft::VisualStudio::Debugger::CallStack::DkmRuntimeWalkNextFramesAndCheckCacheAsyncResult>*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcD6F5490DFB1533AA47E6BFB583FACB52(Microsoft::VisualStudio::Debugger::CallStack::DkmStackWalkContext*, UINT32, Microsoft::VisualStudio::Debugger::DkmArray<Microsoft::VisualStudio::Debugger::CallStack::DkmStackWalkFrame*>*, bool*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcD7B60D34DF9743384ECC91AAED076C34(Microsoft::VisualStudio::Debugger::CallStack::DkmStackWalkContext*, Microsoft::VisualStudio::Debugger::DkmWorkList*, UINT32, Microsoft::VisualStudio::Debugger::IDkmCompletionRoutine<Microsoft::VisualStudio::Debugger::CallStack::DkmRuntimeWalkNextFramesAsyncResult>*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcA0BA43B79BBE61B6ED073DE327837C99(Microsoft::VisualStudio::Debugger::DkmThread*, Microsoft::VisualStudio::Debugger::DkmInstructionAddress*, UINT64, UINT32, Microsoft::VisualStudio::Debugger::CallStack::DkmStackWalkFrameFlags_t, Microsoft::VisualStudio::Debugger::DkmString*, Microsoft::VisualStudio::Debugger::CallStack::DkmFrameRegisters*, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<Microsoft::VisualStudio::Debugger::CallStack::DkmStackWalkFrameAnnotation*>*, Microsoft::VisualStudio::Debugger::CallStack::DkmStackWalkFrame**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc279D105745DA281D3F61B6DCF5411056(Microsoft::VisualStudio::Debugger::DkmThread*, Microsoft::VisualStudio::Debugger::DkmInstructionAddress*, UINT64, UINT32, Microsoft::VisualStudio::Debugger::CallStack::DkmStackWalkFrameFlags_t, Microsoft::VisualStudio::Debugger::DkmString*, Microsoft::VisualStudio::Debugger::CallStack::DkmFrameRegisters*, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<Microsoft::VisualStudio::Debugger::CallStack::DkmStackWalkFrameAnnotation*>*, Microsoft::VisualStudio::Debugger::DkmModuleInstance*, Microsoft::VisualStudio::Debugger::CallStack::DkmAsyncStackWalkContext*, Microsoft::VisualStudio::Debugger::CallStack::DkmStackWalkFrameData*, Microsoft::VisualStudio::Debugger::CallStack::DkmStackWalkFrame**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc4E67D055D6D2E433A2852293B6E54BA1(Microsoft::VisualStudio::Debugger::CallStack::DkmStackWalkFrame*, Microsoft::VisualStudio::Debugger::DkmInstructionAddress*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc1630B1D062AC4FA4C48876B44B526781(Microsoft::VisualStudio::Debugger::CallStack::DkmStackWalkFrame*, Microsoft::VisualStudio::Debugger::Exceptions::DkmExceptionInterceptActionFlags_t, UINT64*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcB774E248DFD633FF0DB4E742857915BF(Microsoft::VisualStudio::Debugger::CallStack::DkmStackWalkFrame*, Microsoft::VisualStudio::Debugger::DkmInstructionAddress**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcA21A0DDB349EAED3F11615E3530AE002(Microsoft::VisualStudio::Debugger::CallStack::DkmStackWalkFrame*, Microsoft::VisualStudio::Debugger::DkmInstructionAddress*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcB4069C4360C0041F560E048681EFCB5E(Microsoft::VisualStudio::Debugger::CallStack::DkmStackWalkFrame*, Microsoft::VisualStudio::Debugger::DkmInstructionAddress*, UINT32*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcD6009FD4D2BFA6D9143568A4A20A299E(Microsoft::VisualStudio::Debugger::CallStack::DkmStackWalkFrame*, Microsoft::VisualStudio::Debugger::Evaluation::DkmInspectionSession*, const Microsoft::VisualStudio::Debugger::CallStack::DkmFrameFormatOptions&, Microsoft::VisualStudio::Debugger::CallStack::DkmStackFrame**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc0EE400E922AE4C51108614E9BA744DBA(Microsoft::VisualStudio::Debugger::CallStack::DkmStackWalkFrame*, Microsoft::VisualStudio::Debugger::Symbols::DkmInstructionSymbol**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc08B4418EC0C18825B12F3E72299F915C(Microsoft::VisualStudio::Debugger::CallStack::DkmStackWalkFrame*, Microsoft::VisualStudio::Debugger::Evaluation::DkmInspectionSession*, const GUID&, IUnknown**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc44D0BCBEFEC7D375AC47BA3B8004849F(Microsoft::VisualStudio::Debugger::CallStack::DkmStackWalkFrame*, Microsoft::VisualStudio::Debugger::Evaluation::DkmInspectionSession*, bool*, bool*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc534F96B0D6ADB61962316301422644F4(Microsoft::VisualStudio::Debugger::CallStack::DkmStackWalkFrame*, Microsoft::VisualStudio::Debugger::DkmArray<Microsoft::VisualStudio::Debugger::DkmString*>*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc44405EED9324011A0B6E9A64D1EAF513(Microsoft::VisualStudio::Debugger::CallStack::DkmStackWalkFrame*, Microsoft::VisualStudio::Debugger::DkmWorkList*, Microsoft::VisualStudio::Debugger::IDkmCompletionRoutine<Microsoft::VisualStudio::Debugger::CallStack::DkmGetClrGenericParametersAsyncResult>*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc6094CA2A993E3F9848322098956FD3F5(const GUID&, UINT64, Microsoft::VisualStudio::Debugger::CallStack::DkmStackWalkFrameAnnotation**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcDD11033D3489012566EDD562BBE02571(Microsoft::VisualStudio::Debugger::DefaultPort::DkmStandardRemoteTransportConnection*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc46A6B17E652C2B421E2B2F3B3E34CD21(Microsoft::VisualStudio::Debugger::Stepping::DkmStepper*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc614B3EA5586AF72A6005519B6F6C9C50(Microsoft::VisualStudio::Debugger::DkmThread*, Microsoft::VisualStudio::Debugger::DkmInstructionAddress*, UINT64, Microsoft::VisualStudio::Debugger::Stepping::DkmStepKind_t, Microsoft::VisualStudio::Debugger::Stepping::DkmStepUnit_t, const GUID&, Microsoft::VisualStudio::Debugger::Stepping::DkmSteppingCodePath*, Microsoft::VisualStudio::Debugger::Stepping::DkmStepper*, const Microsoft::VisualStudio::Debugger::DkmDataItem&, Microsoft::VisualStudio::Debugger::Stepping::DkmStepper**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcC1A3683E892B091686163189B43D1000(Microsoft::VisualStudio::Debugger::DkmThread*, Microsoft::VisualStudio::Debugger::DkmInstructionAddress*, UINT64, Microsoft::VisualStudio::Debugger::Stepping::DkmStepKind_t, Microsoft::VisualStudio::Debugger::Stepping::DkmStepUnit_t, const GUID&, Microsoft::VisualStudio::Debugger::Stepping::DkmSteppingCodePath*, Microsoft::VisualStudio::Debugger::Stepping::DkmStepper*, bool, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<Microsoft::VisualStudio::Debugger::Stepping::DkmSteppingCodePath*>*, Microsoft::VisualStudio::Debugger::DkmString*, const Microsoft::VisualStudio::Debugger::DkmDataItem&, Microsoft::VisualStudio::Debugger::Stepping::DkmStepper**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc969AFD652C52B34DFBA58A08419D9038(Microsoft::VisualStudio::Debugger::Stepping::DkmStepper*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc7B97F0FF86BD2E2D682B864DFF17E77F(Microsoft::VisualStudio::Debugger::Stepping::DkmStepper*, bool);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc63E53E7C4821AF09FA0624C5CADC370F(Microsoft::VisualStudio::Debugger::Stepping::DkmStepper*, Microsoft::VisualStudio::Debugger::DkmRuntimeInstance*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcE7A61A9F049FF2D74FDA1483C449EB9F(Microsoft::VisualStudio::Debugger::Stepping::DkmStepper*, Microsoft::VisualStudio::Debugger::DkmRuntimeInstance**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc8A5F09971F6A17F44FEF05D97B445AFD(Microsoft::VisualStudio::Debugger::Stepping::DkmStepper*, Microsoft::VisualStudio::Debugger::Stepping::DkmStepArbitrationReason_t, Microsoft::VisualStudio::Debugger::DkmRuntimeInstance*, bool*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc154EECF6D0808A631400840CD20CE9A7(Microsoft::VisualStudio::Debugger::Stepping::DkmStepper*, bool, Microsoft::VisualStudio::Debugger::Stepping::DkmStepArbitrationReason_t, Microsoft::VisualStudio::Debugger::DkmRuntimeInstance*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc2C4711ACA8448D643F9553C50E310375(Microsoft::VisualStudio::Debugger::Stepping::DkmStepper*, Microsoft::VisualStudio::Debugger::Stepping::DkmStepArbitrationReason_t, Microsoft::VisualStudio::Debugger::DkmRuntimeInstance*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc75944E1AEDA5BD6E213831B42B08C09F(Microsoft::VisualStudio::Debugger::Stepping::DkmStepper*, Microsoft::VisualStudio::Debugger::Stepping::DkmStepArbitrationReason_t, Microsoft::VisualStudio::Debugger::DkmRuntimeInstance*, Microsoft::VisualStudio::Debugger::DkmThread*, Microsoft::VisualStudio::Debugger::DkmInstructionAddress*, Microsoft::VisualStudio::Debugger::Stepping::DkmStepper**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcC1E64E1BAA30DE49027A7DBE4849ED6D(Microsoft::VisualStudio::Debugger::Stepping::DkmStepper*, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<Microsoft::VisualStudio::Debugger::Evaluation::DkmRawReturnValue*>*, bool);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc23A5971C1BF1E602DEE5AB4BEFB31342(Microsoft::VisualStudio::Debugger::Stepping::DkmStepper*, Microsoft::VisualStudio::Debugger::DkmThread*, bool);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc687EB6BCECC901CC320D6678FDA635CC(Microsoft::VisualStudio::Debugger::Stepping::DkmStepper*, bool);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcE3FC472EC679C1DE3AB9FFAD538956CA(Microsoft::VisualStudio::Debugger::Stepping::DkmStepper*, bool*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc9E2248E24ABD99A8B1E10B4450E75955(Microsoft::VisualStudio::Debugger::DkmString*, UINT32, UINT32, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<BYTE>*, Microsoft::VisualStudio::Debugger::Stepping::DkmSteppingCodePath**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcB8F55C2292C5362692D5A78BF5A1E049(Microsoft::VisualStudio::Debugger::Symbols::DkmInstructionSymbol*, Microsoft::VisualStudio::Debugger::DkmInstructionAddress*, Microsoft::VisualStudio::Debugger::Evaluation::DkmLanguage*, Microsoft::VisualStudio::Debugger::Stepping::DkmSteppingCodePathSource**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc0339C3F8A834349475BA153214394E66(Microsoft::VisualStudio::Debugger::Stepping::DkmSteppingCodePathSource*, Microsoft::VisualStudio::Debugger::CallStack::DkmStackWalkFrame*, Microsoft::VisualStudio::Debugger::Stepping::DkmStepUnit_t, Microsoft::VisualStudio::Debugger::DkmArray<Microsoft::VisualStudio::Debugger::Stepping::DkmSteppingCodePath*>*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc0BB87DD0FEF959F7D6EBC724EA4C6B07(Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<UINT64>*, HRESULT, Microsoft::VisualStudio::Debugger::DkmString*, Microsoft::VisualStudio::Debugger::DkmString*, Microsoft::VisualStudio::Debugger::DkmRuntimeInstance*, Microsoft::VisualStudio::Debugger::Evaluation::DkmEvaluationResultFlags_t, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<Microsoft::VisualStudio::Debugger::DkmString*>*, Microsoft::VisualStudio::Debugger::DkmString*, Microsoft::VisualStudio::Debugger::Evaluation::DkmEvaluationResultCategory_t, Microsoft::VisualStudio::Debugger::Evaluation::DkmEvaluationResultAccessType_t, Microsoft::VisualStudio::Debugger::Evaluation::DkmEvaluationResultStorageType_t, Microsoft::VisualStudio::Debugger::Evaluation::DkmEvaluationResultTypeModifierFlags_t, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<Microsoft::VisualStudio::Debugger::Evaluation::DkmCustomUIVisualizerInfo*>*, const Microsoft::VisualStudio::Debugger::DkmDataItem&, Microsoft::VisualStudio::Debugger::Evaluation::Group::DkmSuccessContextGroupEvaluationResult**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc42A2B316A229EB6E25BB276960D29FB9(Microsoft::VisualStudio::Debugger::Evaluation::DkmInspectionContext*, Microsoft::VisualStudio::Debugger::CallStack::DkmStackWalkFrame*, Microsoft::VisualStudio::Debugger::DkmString*, Microsoft::VisualStudio::Debugger::DkmString*, Microsoft::VisualStudio::Debugger::Evaluation::DkmEvaluationResultFlags_t, Microsoft::VisualStudio::Debugger::DkmString*, Microsoft::VisualStudio::Debugger::DkmString*, Microsoft::VisualStudio::Debugger::DkmString*, Microsoft::VisualStudio::Debugger::Evaluation::DkmEvaluationResultCategory_t, Microsoft::VisualStudio::Debugger::Evaluation::DkmEvaluationResultAccessType_t, Microsoft::VisualStudio::Debugger::Evaluation::DkmEvaluationResultStorageType_t, Microsoft::VisualStudio::Debugger::Evaluation::DkmEvaluationResultTypeModifierFlags_t, Microsoft::VisualStudio::Debugger::Evaluation::DkmDataAddress*, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<Microsoft::VisualStudio::Debugger::Evaluation::DkmCustomUIVisualizerInfo*>*, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<Microsoft::VisualStudio::Debugger::DkmModuleInstance*>*, const Microsoft::VisualStudio::Debugger::DkmDataItem&, Microsoft::VisualStudio::Debugger::Evaluation::DkmSuccessEvaluationResult**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcBF4F55B3075F1581F65EC9A0DA3B90DB(Microsoft::VisualStudio::Debugger::Evaluation::DkmSuccessEvaluationResult*, UINT32, Microsoft::VisualStudio::Debugger::DkmString**, Microsoft::VisualStudio::Debugger::DkmString**, Microsoft::VisualStudio::Debugger::DkmString**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcAE0E37DAE591F76FAA05D9A44DBD9606(Microsoft::VisualStudio::Debugger::Evaluation::DkmSuccessEvaluationResult*, bool*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcF10EC243109F3B64DF8A48E7F1023A39(Microsoft::VisualStudio::Debugger::Evaluation::DkmSuccessEvaluationResult*, Microsoft::VisualStudio::Debugger::DkmString*, Microsoft::VisualStudio::Debugger::DkmString**, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<BYTE>**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc037F7F6CB3C9C69C5DA87653781BB97D(Microsoft::VisualStudio::Debugger::Evaluation::DkmSuccessEvaluationResult*, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<BYTE>**, Microsoft::VisualStudio::Debugger::DkmString**, Microsoft::VisualStudio::Debugger::DkmString**, Microsoft::VisualStudio::Debugger::DkmString**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc52E095AB0C83B4CC11E33B364EBE8CC3(Microsoft::VisualStudio::Debugger::Evaluation::DkmSuccessEvaluationResult*, const Microsoft::VisualStudio::Debugger::DkmArray<BYTE>&, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<BYTE>**, Microsoft::VisualStudio::Debugger::DkmString**, Microsoft::VisualStudio::Debugger::DkmString**, Microsoft::VisualStudio::Debugger::DkmString**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc12D6FA921255A7F58679B0276D7AC79B(Microsoft::VisualStudio::Debugger::Evaluation::DkmSuccessEvaluationResult*, const Microsoft::VisualStudio::Debugger::DkmArray<BYTE>&, Microsoft::VisualStudio::Debugger::DkmString**, Microsoft::VisualStudio::Debugger::DkmString**, Microsoft::VisualStudio::Debugger::DkmString**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcE46C1A3CC6F29F0A20ED6C5F80FD2289(Microsoft::VisualStudio::Debugger::Evaluation::DkmSuccessEvaluationResult*, Microsoft::VisualStudio::Debugger::Evaluation::ClrCompilation::DkmClrValue**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc3932AEFE94C36823D1A160EFA97E3F11(Microsoft::VisualStudio::Debugger::DkmProcess*, Microsoft::VisualStudio::Debugger::Symbols::DkmModule*, Microsoft::VisualStudio::Debugger::Evaluation::DkmLanguage*, Microsoft::VisualStudio::Debugger::DkmString*, UINT32, Microsoft::VisualStudio::Debugger::DkmString*, Microsoft::VisualStudio::Debugger::FunctionResolution::DkmAddressSearchFlags_t, Microsoft::VisualStudio::Debugger::FunctionResolution::DkmSymbolFunctionResolutionRequest**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc5AFC8CFC0FF188C22A757EFC938F0AB2(Microsoft::VisualStudio::Debugger::FunctionResolution::DkmSymbolFunctionResolutionRequest*, Microsoft::VisualStudio::Debugger::DkmArray<Microsoft::VisualStudio::Debugger::Symbols::DkmInstructionSymbol*>*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcBDF0D5748E83AE15E24B5B1687A335C2(Microsoft::VisualStudio::Debugger::CallStack::DkmSymbolStackWalkContext*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcA2953E3BF3583689D4AA360B2A068724(Microsoft::VisualStudio::Debugger::CallStack::DkmStackWalkContext*, const GUID&, const Microsoft::VisualStudio::Debugger::DkmDataItem&, Microsoft::VisualStudio::Debugger::CallStack::DkmSymbolStackWalkContext**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc11DEBCF91819AB5C7D511F5CC8132865(Microsoft::VisualStudio::Debugger::CallStack::DkmSymbolStackWalkContext*, Microsoft::VisualStudio::Debugger::CallStack::DkmFrameRegisters*, UINT32);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc8EA48BC824C9B98D3446CD1284310781(Microsoft::VisualStudio::Debugger::CallStack::DkmSymbolStackWalkContext*, Microsoft::VisualStudio::Debugger::CallStack::DkmFrameRegisters*, UINT32, Microsoft::VisualStudio::Debugger::DkmInstructionAddress*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcE53FE4708620D30C1080556AF0FFBE3F(Microsoft::VisualStudio::Debugger::CallStack::DkmSymbolStackWalkContext*, Microsoft::VisualStudio::Debugger::CallStack::DkmFrameRegisters**, Microsoft::VisualStudio::Debugger::CallStack::DkmStackWalkFrame**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc35DBD0B3A9C4D65B34C9C9DC38DEEA7A(UINT16, UINT32, UINT32, UINT16, Microsoft::VisualStudio::Debugger::DefaultPort::DkmSystemInformationFlags_t, Microsoft::VisualStudio::Debugger::DefaultPort::DkmProcessorFeatures_t, Microsoft::VisualStudio::Debugger::DefaultPort::DkmSystemInformation**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcBB4C4C507C3D48982BF5C6EA6D711C9C(UINT16, UINT32, UINT32, UINT16, Microsoft::VisualStudio::Debugger::DefaultPort::DkmSystemInformationFlags_t, Microsoft::VisualStudio::Debugger::DefaultPort::DkmProcessorFeatures_t, MINIDUMP_TYPE, Microsoft::VisualStudio::Debugger::DkmString*, Microsoft::VisualStudio::Debugger::DkmString*, Microsoft::VisualStudio::Debugger::DefaultPort::DkmSystemInformation**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc6A78429E482A38FE4E0A0B929B65F919(UINT16, UINT32, UINT32, UINT16, Microsoft::VisualStudio::Debugger::DefaultPort::DkmSystemInformationFlags_t, Microsoft::VisualStudio::Debugger::DefaultPort::DkmProcessorFeatures_t, MINIDUMP_TYPE, Microsoft::VisualStudio::Debugger::DkmString*, Microsoft::VisualStudio::Debugger::DkmString*, Microsoft::VisualStudio::Debugger::DefaultPort::DkmDeviceInfo*, Microsoft::VisualStudio::Debugger::DefaultPort::DkmSystemInformation**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcE195EB82A3658BBE184BF772FE70EE44(Microsoft::VisualStudio::Debugger::ParallelTasks::DkmTask*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc3BC141B0950632BBEDF0F3A329B42598(Microsoft::VisualStudio::Debugger::ParallelTasks::DkmTaskProvider*, Microsoft::VisualStudio::Debugger::DkmThread*, UINT64, UINT64, const Microsoft::VisualStudio::Debugger::ParallelTasks::DkmTaskStackSegment&, const Microsoft::VisualStudio::Debugger::DkmDataItem&, Microsoft::VisualStudio::Debugger::ParallelTasks::DkmTask**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcF67FD0F8724B847483F082B115F61994(Microsoft::VisualStudio::Debugger::ParallelTasks::DkmTaskProvider*, Microsoft::VisualStudio::Debugger::DkmThread*, UINT64, UINT64, const Microsoft::VisualStudio::Debugger::ParallelTasks::DkmTaskStackSegment&, Microsoft::VisualStudio::Debugger::ParallelTasks::DkmTaskReturnStatus_t, double, double, double, const Microsoft::VisualStudio::Debugger::DkmDataItem&, Microsoft::VisualStudio::Debugger::ParallelTasks::DkmTask**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc6F163AC98BAF7B488B85A75616791C9F(Microsoft::VisualStudio::Debugger::ParallelTasks::DkmTask*, Microsoft::VisualStudio::Debugger::DkmArray<Microsoft::VisualStudio::Debugger::ParallelTasks::DkmTask*>*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc678BC032D274C3D145554F7DA4BCF98C(Microsoft::VisualStudio::Debugger::ParallelTasks::DkmTask*, UINT32, UINT32, Microsoft::VisualStudio::Debugger::ParallelTasks::DkmTaskProperties*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcEAFDA659BBC3E7B5DECD28D58939CC40(Microsoft::VisualStudio::Debugger::ParallelTasks::DkmTask*, Microsoft::VisualStudio::Debugger::DkmArray<Microsoft::VisualStudio::Debugger::ParallelTasks::DkmTaskSynchronizationObject*>*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW void STDMETHODCALLTYPE ProcA07FAFB63F4649DD290A721E8EFE4162(Microsoft::VisualStudio::Debugger::ParallelTasks::DkmTaskProperties*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc21FB0093543B45F8828E79D9EEF3AA3A(Microsoft::VisualStudio::Debugger::ParallelTasks::DkmTaskProvider*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcCCE97B15762479275D3FB2967C597CCB(const GUID&, Microsoft::VisualStudio::Debugger::DkmString*, Microsoft::VisualStudio::Debugger::DkmRuntimeInstance*, const Microsoft::VisualStudio::Debugger::DkmDataItem&, Microsoft::VisualStudio::Debugger::ParallelTasks::DkmTaskProvider**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcF5AF3CCABE57E88CB0B16B900C3902FB(const GUID&, Microsoft::VisualStudio::Debugger::DkmString*, Microsoft::VisualStudio::Debugger::DkmRuntimeInstance*, Microsoft::VisualStudio::Debugger::ParallelTasks::DkmTaskProviderCapabilityFlags_t, const Microsoft::VisualStudio::Debugger::DkmDataItem&, Microsoft::VisualStudio::Debugger::ParallelTasks::DkmTaskProvider**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc62E124921D164B7AECA13D786603EC06(Microsoft::VisualStudio::Debugger::ParallelTasks::DkmTaskProvider*, UINT64, Microsoft::VisualStudio::Debugger::ParallelTasks::DkmTask**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcCDD4E8C991BEBFAC2D35C0F765297B11(Microsoft::VisualStudio::Debugger::ParallelTasks::DkmTaskProvider*, bool, UINT32, UINT32*, Microsoft::VisualStudio::Debugger::DkmArray<Microsoft::VisualStudio::Debugger::ParallelTasks::DkmTask*>*, UINT32*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc1C52C73B1F05AD5D701CFE684EFF003B(Microsoft::VisualStudio::Debugger::ParallelTasks::DkmTaskProvider*, Microsoft::VisualStudio::Debugger::DkmArray<Microsoft::VisualStudio::Debugger::DkmString*>*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcF54418460BC26AF2C3429E967BAEDB56(Microsoft::VisualStudio::Debugger::ParallelTasks::DkmTaskSynchronizationObject*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcA598DC6767B6B5E321EA1C7E6742268C(Microsoft::VisualStudio::Debugger::ParallelTasks::DkmTask*, Microsoft::VisualStudio::Debugger::DkmThread*, Microsoft::VisualStudio::Debugger::DkmString*, Microsoft::VisualStudio::Debugger::DkmString*, Microsoft::VisualStudio::Debugger::DkmString*, UINT32, UINT32, const Microsoft::VisualStudio::Debugger::DkmDataItem&, Microsoft::VisualStudio::Debugger::ParallelTasks::DkmTaskSynchronizationObject**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW int STDMETHODCALLTYPE Proc94CE83C176C18E080657DE893B3FB7D1(const Microsoft::VisualStudio::Debugger::Symbols::DkmTextSpan&, const Microsoft::VisualStudio::Debugger::Symbols::DkmTextSpan&);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc660872E9B1A72FBC89EE136ED9490954(Microsoft::VisualStudio::Debugger::DkmProcess*, UINT64, UINT64, bool, const Microsoft::VisualStudio::Debugger::DkmThread::System*, const Microsoft::VisualStudio::Debugger::DkmDataItem&, Microsoft::VisualStudio::Debugger::DkmThread**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc32245DDCC51A1CA87768FB26C135C6CF(Microsoft::VisualStudio::Debugger::DkmThread*, Microsoft::VisualStudio::Debugger::DkmArray<Microsoft::VisualStudio::Debugger::Stepping::DkmStepper*>*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc9EC9594DE9AD4721F7CA1A6661474411(Microsoft::VisualStudio::Debugger::DkmThread*, Microsoft::VisualStudio::Debugger::DkmInstructionAddress*, bool);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc21018EEF594F640991F4C8723510500B(Microsoft::VisualStudio::Debugger::DkmThread*, Microsoft::VisualStudio::Debugger::Evaluation::DkmFuncEvalFlags_t);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcCC77495B04753F1B0085CAF63BCF1679(Microsoft::VisualStudio::Debugger::DkmThread*, UINT32);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcC85E3C661A3F69393C3308D5AA724031(Microsoft::VisualStudio::Debugger::DkmThread*, Microsoft::VisualStudio::Debugger::DkmArray<Microsoft::VisualStudio::Debugger::CallStack::DkmUnwoundRegister*>*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcDA2C88FCD29A13D41642E51A73A0C5F3(Microsoft::VisualStudio::Debugger::DkmThread*, CV_HREG_e, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<BYTE>*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcCFC90B74E86F409E42174D75C612ECC1(Microsoft::VisualStudio::Debugger::DkmThread*, const Microsoft::VisualStudio::Debugger::DkmArray<Microsoft::VisualStudio::Debugger::CallStack::DkmUnwoundRegister*>&, UINT32, Microsoft::VisualStudio::Debugger::CallStack::DkmFrameRegisters**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc1F8112701DC8FD65384408A8F7AC2688(Microsoft::VisualStudio::Debugger::DkmThread*, INT32*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc32E9F18F7EC761620221F110A2CE057F(Microsoft::VisualStudio::Debugger::DkmThread*, Microsoft::VisualStudio::Debugger::DkmWorkList*, Microsoft::VisualStudio::Debugger::IDkmCompletionRoutine<Microsoft::VisualStudio::Debugger::ThreadProperties::DkmGetManagedThreadPropertiesAsyncResult>*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc8877C3D70304E8D4D8932D1B95A128BC(Microsoft::VisualStudio::Debugger::DkmThread*, Microsoft::VisualStudio::Debugger::DkmRuntimeInstance*, Microsoft::VisualStudio::Debugger::CallStack::DkmStackWalkFrame**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc13E806B9B3C4319EF36A2D0160C5F358(Microsoft::VisualStudio::Debugger::DkmThread*, UINT64*, UINT64*, UINT64*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcF5A59EE47B626A7A0FF46B584F2CF13F(Microsoft::VisualStudio::Debugger::DkmThread*, Microsoft::VisualStudio::Debugger::CallStack::DkmStackWalkFrame**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc764B89CAFFE718355031F1555E23D68B(Microsoft::VisualStudio::Debugger::DkmThread*, const Microsoft::VisualStudio::Debugger::DkmArray<Microsoft::VisualStudio::Debugger::CallStack::DkmUnwoundRegister*>&, Microsoft::VisualStudio::Debugger::CallStack::DkmFrameRegisters**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcE07A59DADEB847529B1EDACF190F9622(Microsoft::VisualStudio::Debugger::DkmThread*, const Microsoft::VisualStudio::Debugger::DkmArray<BYTE>&, const Microsoft::VisualStudio::Debugger::DkmArray<Microsoft::VisualStudio::Debugger::CallStack::DkmUnwoundRegister*>&, const Microsoft::VisualStudio::Debugger::DkmArray<Microsoft::VisualStudio::Debugger::CallStack::DkmUnwoundRegister*>&, Microsoft::VisualStudio::Debugger::CallStack::DkmFrameRegisters**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc0960E067C6E6CE7EBFEEDBBDFE1D27A8(Microsoft::VisualStudio::Debugger::DkmThread*, bool*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc82FF1FA4E1EEAE6244230B42302688EF(Microsoft::VisualStudio::Debugger::DkmThread*, Microsoft::VisualStudio::Debugger::Evaluation::DkmFuncEvalFlags_t, bool*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcF525CDEB2CCDEEF6A83975AAF4A2818E(Microsoft::VisualStudio::Debugger::DkmThread*, Microsoft::VisualStudio::Debugger::Evaluation::DkmFuncEvalFlags_t);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcEBB9C20B7D84DC94119D75E52F0311D0(Microsoft::VisualStudio::Debugger::DkmThread*, bool, bool*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcE7E936BAFB8A03BADC8D5E852E215D5F(Microsoft::VisualStudio::Debugger::DkmThread*, Microsoft::VisualStudio::Debugger::DkmFuncEvalMode_t*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc47057DDC632AD45CEC7B2F19D7C55FC5(Microsoft::VisualStudio::Debugger::DkmThread*, const Microsoft::VisualStudio::Debugger::DkmArray<BYTE>&);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc6C71BAFC0CA8B6BB34725A9DB87FBDAC(Microsoft::VisualStudio::Debugger::DkmThread*, UINT32, void*, UINT32);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc4560E9791A28974C03DBB766B0923E3F(Microsoft::VisualStudio::Debugger::DkmThread*, Microsoft::VisualStudio::Debugger::DkmWorkList*, Microsoft::VisualStudio::Debugger::IDkmCompletionRoutine<Microsoft::VisualStudio::Debugger::CallStack::DkmGetCurrentLocationAsyncResult>*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcBF51E4F2615C39213EB93E638D855420(Microsoft::VisualStudio::Debugger::DkmThread*, Microsoft::VisualStudio::Debugger::CallStack::DkmStackMemoryRange*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc8B5D381DB7DEAB34963D4ED0B1F13B59(Microsoft::VisualStudio::Debugger::DkmThread*, bool, UINT32*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc0CD674D84CB44BC00252F10D501563F9(Microsoft::VisualStudio::Debugger::DkmThread*, bool, UINT32*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcD1CE80C145D86692B21A5385E307B03C(Microsoft::VisualStudio::Debugger::DkmThread*, bool, UINT32*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc43848E55BF00ABC986124109B62D5595(Microsoft::VisualStudio::Debugger::DkmThread*, UINT32*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc73F92C73F402A0645B5F0E13E132A009(Microsoft::VisualStudio::Debugger::DkmThread*, UINT32, UINT64*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc2953901DB8E2A56A7761ADC76A4C51C9(Microsoft::VisualStudio::Debugger::DkmThread*, UINT32, UINT64);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcCB686005B0C45325B528A4AB178C8DDA(Microsoft::VisualStudio::Debugger::DkmThread*, INT32*, UINT64*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc85E5BDCC65DBFBFD46BD72850AB5598D(Microsoft::VisualStudio::Debugger::DkmThread*, Microsoft::VisualStudio::Debugger::DkmWorkList*, Microsoft::VisualStudio::Debugger::IDkmCompletionRoutine<Microsoft::VisualStudio::Debugger::ThreadProperties::DkmGetVolatilePropertiesAsyncResult>*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc72D8789037B29D9BE4656FCAB8B158C1(Microsoft::VisualStudio::Debugger::DkmThread*, Microsoft::VisualStudio::Debugger::ThreadProperties::DkmVolatileThreadFlags_t*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcE025EC0D8596C9875C1203A22839D44C(Microsoft::VisualStudio::Debugger::DkmThread*, Microsoft::VisualStudio::Debugger::DkmWorkList*, Microsoft::VisualStudio::Debugger::IDkmCompletionRoutine<Microsoft::VisualStudio::Debugger::ThreadProperties::DkmGetVolatileFlagsAsyncResult>*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc28873A94D65410FCC0056B9C83596DD0(Microsoft::VisualStudio::Debugger::DkmThread*, UINT64);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcCEC10D8029BB7FE6392177BA9943EDE1(Microsoft::VisualStudio::Debugger::DkmThread*, UINT32);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcA889D7143B7FAC827A4BAE8265E8FB6A(Microsoft::VisualStudio::Debugger::DkmThread*, UINT64*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcFECA898F562A1BE8B44B5148E9227073(Microsoft::VisualStudio::Debugger::DkmThread*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcE6D433576CE0AC1C21EE4E98D3422D5A(Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILEvaluationResult*>*, Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILFailureReason_t, Microsoft::VisualStudio::Debugger::Evaluation::Group::DkmThreadEvaluationResultCollection**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcAB7E84604904D5C915B4A266F97F80F5(const GUID&, Microsoft::VisualStudio::Debugger::DefaultPort::DkmTransportConnection**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc2C8F3653A7BDEAB26FDAC5E12529D820(Microsoft::VisualStudio::Debugger::DkmArray<Microsoft::VisualStudio::Debugger::DefaultPort::DkmTransportConnection*>*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcF8399B27892C4BBF5D648783DCDCBA5A(Microsoft::VisualStudio::Debugger::DefaultPort::DkmTransportConnection*, const GUID&, Microsoft::VisualStudio::Debugger::DkmProcess**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcC071CA11E0A11A2E283015A2F9433338(Microsoft::VisualStudio::Debugger::DefaultPort::DkmTransportConnection*, Microsoft::VisualStudio::Debugger::DkmArray<Microsoft::VisualStudio::Debugger::DkmProcess*>*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcD6035EBBD17B0D0141A839FB20A8A90F(Microsoft::VisualStudio::Debugger::DefaultPort::DkmTransportConnection*, UINT32, Microsoft::VisualStudio::Debugger::DkmProcess**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcDB0050730FB328F4C9D7C1BB448007A9(Microsoft::VisualStudio::Debugger::DefaultPort::DkmTransportConnection*, Microsoft::VisualStudio::Debugger::DkmArray<Microsoft::VisualStudio::Debugger::DkmProcess*>*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcC43FD22B022A5A6DDF7F66F3A86E698F(Microsoft::VisualStudio::Debugger::DefaultPort::DkmTransportConnection*, Microsoft::VisualStudio::Debugger::DkmArray<Microsoft::VisualStudio::Debugger::Start::DkmProcessLaunchRequest*>*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcA792859DA394A6CB2C2E468A8805621E(Microsoft::VisualStudio::Debugger::DefaultPort::DkmTransportConnection*, Microsoft::VisualStudio::Debugger::DkmWorkList*, Microsoft::VisualStudio::Debugger::DefaultPort::DkmPackagedAppPlatform_t, Microsoft::VisualStudio::Debugger::DkmString*, bool, Microsoft::VisualStudio::Debugger::IDkmCompletionRoutine<Microsoft::VisualStudio::Debugger::Start::DkmActivateAppPackageAsyncResult>*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcDE7401ACE2C30C377F9CBF611BDF4337(Microsoft::VisualStudio::Debugger::DefaultPort::DkmTransportConnection*, Microsoft::VisualStudio::Debugger::DkmWorkList*, Microsoft::VisualStudio::Debugger::DefaultPort::DkmAppPackageId*, UINT32, Microsoft::VisualStudio::Debugger::IDkmCompletionRoutine<Microsoft::VisualStudio::Debugger::DefaultPort::DkmSuspendAppPackageAsyncResult>*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcD2B975D78F12643226D0BB33B75EAD13(Microsoft::VisualStudio::Debugger::DefaultPort::DkmTransportConnection*, Microsoft::VisualStudio::Debugger::DefaultPort::DkmAppPackageId*, UINT32);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcB34EA264F4F8FECA9A9F132A25DCD7D8(Microsoft::VisualStudio::Debugger::DefaultPort::DkmTransportConnection*, Microsoft::VisualStudio::Debugger::DkmWorkList*, Microsoft::VisualStudio::Debugger::DefaultPort::DkmAppPackageId*, UINT32, Microsoft::VisualStudio::Debugger::IDkmCompletionRoutine<Microsoft::VisualStudio::Debugger::DefaultPort::DkmShutDownAppPackageAsyncResult>*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcD10A03178A61DDA50CE791FE7A50CE1A(Microsoft::VisualStudio::Debugger::DefaultPort::DkmTransportConnection*, Microsoft::VisualStudio::Debugger::DefaultPort::DkmAppPackageId*, Microsoft::VisualStudio::Debugger::DkmString**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcFE6C80165E565AC3EC08B717C8E51C9E(Microsoft::VisualStudio::Debugger::DefaultPort::DkmTransportConnection*, Microsoft::VisualStudio::Debugger::DefaultPort::DkmAppPackageId*, UINT32, Microsoft::VisualStudio::Debugger::DefaultPort::DkmPackageExecutionState_t*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcF45761B62AD6B1092A2DF893E962C810(Microsoft::VisualStudio::Debugger::DefaultPort::DkmTransportConnection*, Microsoft::VisualStudio::Debugger::DkmWorkList*, Microsoft::VisualStudio::Debugger::DefaultPort::DkmAppPackageId*, UINT32, Microsoft::VisualStudio::Debugger::IDkmCompletionRoutine<Microsoft::VisualStudio::Debugger::DefaultPort::DkmEnumerateBackgroundTasksAsyncResult>*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc30FEC696C9945D2B0417493F60C0A048(Microsoft::VisualStudio::Debugger::DefaultPort::DkmTransportConnection*, Microsoft::VisualStudio::Debugger::DkmWorkList*, Microsoft::VisualStudio::Debugger::DefaultPort::DkmAppPackageId*, UINT32, const GUID&, Microsoft::VisualStudio::Debugger::IDkmCompletionRoutine<Microsoft::VisualStudio::Debugger::DefaultPort::DkmActivateBackgroundTaskAsyncResult>*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc98A6A894DD93626ADCA0978BCE953839(Microsoft::VisualStudio::Debugger::DefaultPort::DkmTransportConnection*, Microsoft::VisualStudio::Debugger::DkmArray<Microsoft::VisualStudio::Debugger::DefaultPort::DkmInstalledAppPackageInfo*>*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcDDD014885B12C65BD78508D907B44AD7(Microsoft::VisualStudio::Debugger::DefaultPort::DkmTransportConnection*, Microsoft::VisualStudio::Debugger::DkmString*, Microsoft::VisualStudio::Debugger::DkmString*, bool);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc3652ACA5E5318812E35FB3CA4438BE02(Microsoft::VisualStudio::Debugger::DefaultPort::DkmTransportConnection*, Microsoft::VisualStudio::Debugger::DkmString*, Microsoft::VisualStudio::Debugger::DkmString*, bool);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcD5CB3FCA82CC14A00D5F13D7E222756B(Microsoft::VisualStudio::Debugger::DefaultPort::DkmTransportConnection*, Microsoft::VisualStudio::Debugger::DkmWorkList*, Microsoft::VisualStudio::Debugger::DkmString*, Microsoft::VisualStudio::Debugger::DkmString*, bool, Microsoft::VisualStudio::Debugger::IDkmCompletionRoutine<Microsoft::VisualStudio::Debugger::DefaultPort::DkmDownloadFileAsyncResult>*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcB8D5E627A1202BFABE708EACCB652FBB(Microsoft::VisualStudio::Debugger::DefaultPort::DkmTransportConnection*, Microsoft::VisualStudio::Debugger::DkmString*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc215DD9BC078CB88CF23C40B8C2910BE3(Microsoft::VisualStudio::Debugger::DefaultPort::DkmTransportConnection*, Microsoft::VisualStudio::Debugger::DkmString**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc97FB9A3F5C72B5CCF8B0B70D68A04767(Microsoft::VisualStudio::Debugger::DefaultPort::DkmTransportConnection*, Microsoft::VisualStudio::Debugger::DkmString*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc42B2E39E095C8CC924104C96D815A87F(Microsoft::VisualStudio::Debugger::DefaultPort::DkmTransportConnection*, Microsoft::VisualStudio::Debugger::DkmString*, bool);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcBA58E5F29495587EE83647ED4B7CA047(Microsoft::VisualStudio::Debugger::DefaultPort::DkmTransportConnection*, Microsoft::VisualStudio::Debugger::DkmString*, Microsoft::VisualStudio::Debugger::DkmString*, bool, Microsoft::VisualStudio::Debugger::DkmArray<Microsoft::VisualStudio::Debugger::DefaultPort::DkmFileInfo*>*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc78D9244B76EA8F1DE4E149D466A3067E(Microsoft::VisualStudio::Debugger::DefaultPort::DkmTransportConnection*, bool, Microsoft::VisualStudio::Debugger::DefaultPort::DkmRunningProcessInfoPropertyMask_t, Microsoft::VisualStudio::Debugger::DkmArray<Microsoft::VisualStudio::Debugger::DefaultPort::DkmRunningProcessInfo*>*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc39246E41B82608CB696343435CB621CC(Microsoft::VisualStudio::Debugger::DefaultPort::DkmTransportConnection*, UINT32, UINT64, bool, Microsoft::VisualStudio::Debugger::DefaultPort::DkmRunningProcessInfoPropertyMask_t, Microsoft::VisualStudio::Debugger::DefaultPort::DkmRunningProcessInfo**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc865805A776E7741A6D402D348F5B10C8(Microsoft::VisualStudio::Debugger::DefaultPort::DkmTransportConnection*, UINT32, UINT64, UINT32);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc2C5C54E587F4180B257B172F561B9D86(Microsoft::VisualStudio::Debugger::DefaultPort::DkmTransportConnection*, bool, Microsoft::VisualStudio::Debugger::DefaultPort::DkmSystemInformation**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc64B5767554228566D9C77062DA22744E(Microsoft::VisualStudio::Debugger::DefaultPort::DkmTransportConnection*, Microsoft::VisualStudio::Debugger::DkmString*, Microsoft::VisualStudio::Debugger::DkmString**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc0869184C622FC2631C3092D1F9F56171(Microsoft::VisualStudio::Debugger::DefaultPort::DkmTransportConnection*, Microsoft::VisualStudio::Debugger::DkmString*, bool*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc8B8D1408689D364C99D8A5AEA2A33BF9(Microsoft::VisualStudio::Debugger::DefaultPort::DkmTransportConnection*, Microsoft::VisualStudio::Debugger::DkmString**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc455ECE81CE1CDD87D2DA5494FE7B4B03(Microsoft::VisualStudio::Debugger::DefaultPort::DkmTransportConnection*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcC5753DD54FFBAD601A042910A22F7508(Microsoft::VisualStudio::Debugger::DefaultPort::DkmTransportConnection*, Microsoft::VisualStudio::Debugger::DkmString*, Microsoft::VisualStudio::Debugger::DefaultPort::DkmPackagedAppPlatform_t, HRESULT*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc2F051284F979333EE60A5318711A2C6B(Microsoft::VisualStudio::Debugger::DefaultPort::DkmTransportConnection*, Microsoft::VisualStudio::Debugger::DefaultPort::DkmAppPackageId*, UINT32);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc60DB9E894042BDA745E19DFFE7A836B3(Microsoft::VisualStudio::Debugger::DefaultPort::DkmTransportConnection*, Microsoft::VisualStudio::Debugger::DkmWorkList*, Microsoft::VisualStudio::Debugger::DefaultPort::DkmPackagedAppPlatform_t, Microsoft::VisualStudio::Debugger::DkmString*, bool, UINT32, Microsoft::VisualStudio::Debugger::IDkmCompletionRoutine<Microsoft::VisualStudio::Debugger::Start::DkmActivateAppPackageAsyncResult>*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc18A5450F8560919A30800EE0FE7D9ECB(Microsoft::VisualStudio::Debugger::DefaultPort::DkmTransportConnection*, Microsoft::VisualStudio::Debugger::DkmWorkList*, Microsoft::VisualStudio::Debugger::DkmString*, bool, Microsoft::VisualStudio::Debugger::IDkmCompletionRoutine<Microsoft::VisualStudio::Debugger::Start::DkmActivateAppPackageAsyncResult>*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc8EDE4866600ED1B4F51326202AD7B614(Microsoft::VisualStudio::Debugger::DkmRuntimeInstance*, const Microsoft::VisualStudio::Debugger::DkmInstructionAddress::CPUInstruction*, Microsoft::VisualStudio::Debugger::DkmUnknownInstructionAddress**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc466368E9818C5AAA5A91F1B4871168C3(CV_HREG_e, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<BYTE>*, Microsoft::VisualStudio::Debugger::CallStack::DkmUnwoundRegister**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcFDD9B7914B7C22033996520394B90F8A(Microsoft::VisualStudio::Debugger::DefaultPort::DkmTransportConnection*, Microsoft::VisualStudio::Debugger::DkmProcess*, Microsoft::VisualStudio::Debugger::DkmUserMessageOutputKind_t, Microsoft::VisualStudio::Debugger::DkmString*, UINT32, HRESULT, Microsoft::VisualStudio::Debugger::DkmUserMessage**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc99B99125827B46ADC3E97549DA4EA4DF(Microsoft::VisualStudio::Debugger::DefaultPort::DkmTransportConnection*, Microsoft::VisualStudio::Debugger::DkmProcess*, Microsoft::VisualStudio::Debugger::DkmUserMessageOutputKind_t, Microsoft::VisualStudio::Debugger::DkmString*, UINT32, HRESULT, UINT64, Microsoft::VisualStudio::Debugger::DkmUserMessage**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcBA1057B67974B1DAE7A677E1B7156D48(Microsoft::VisualStudio::Debugger::DkmUserMessage*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcA3E4FFDD239F6E8EB98DECB7AD2660ED(Microsoft::VisualStudio::Debugger::DkmUserMessage*, UINT32*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc724F9A5CAEC412BD5A71787991347219(Microsoft::VisualStudio::Debugger::DkmUserMessage*, Microsoft::VisualStudio::Debugger::DkmWorkList*, Microsoft::VisualStudio::Debugger::IDkmCompletionRoutine<Microsoft::VisualStudio::Debugger::DkmDisplayUserMessagePromptAsyncResult>*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc37A7A04E658357DDF89FD94C01950EDE(Microsoft::VisualStudio::Debugger::Evaluation::DkmVisualizedExpression*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc775646EA9C2CEA81FE5E83FA6B154C80(Microsoft::VisualStudio::Debugger::Evaluation::DkmVisualizedExpression*, Microsoft::VisualStudio::Debugger::Evaluation::DkmEvaluationResult**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc2EAA5EF1A1F3D78893EF5BF262A09FF1(Microsoft::VisualStudio::Debugger::Evaluation::DkmVisualizedExpression*, bool*, Microsoft::VisualStudio::Debugger::Evaluation::DkmEvaluationResult**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc16C97186D55550648ABE74675D33BF50(Microsoft::VisualStudio::Debugger::Evaluation::DkmVisualizedExpression*, UINT32, Microsoft::VisualStudio::Debugger::Evaluation::DkmInspectionContext*, Microsoft::VisualStudio::Debugger::DkmArray<Microsoft::VisualStudio::Debugger::Evaluation::DkmChildVisualizedExpression*>*, Microsoft::VisualStudio::Debugger::Evaluation::DkmEvaluationResultEnumContext**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc0A069DACDF37E06B697F148BFAE76960(Microsoft::VisualStudio::Debugger::Evaluation::DkmVisualizedExpression*, Microsoft::VisualStudio::Debugger::Evaluation::DkmEvaluationResultEnumContext*, UINT32, UINT32, Microsoft::VisualStudio::Debugger::DkmArray<Microsoft::VisualStudio::Debugger::Evaluation::DkmChildVisualizedExpression*>*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcEC64BFA42F296CC9011D7887E9AA821E(Microsoft::VisualStudio::Debugger::Evaluation::DkmVisualizedExpression*, Microsoft::VisualStudio::Debugger::DkmString*, UINT32, Microsoft::VisualStudio::Debugger::DkmString**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc2DAB6617600220DC44DEB7DBC7D87FA6(Microsoft::VisualStudio::Debugger::Evaluation::DkmVisualizedExpression*, Microsoft::VisualStudio::Debugger::DkmString**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcA236F77AF12387A7771096B443CA3FC7(Microsoft::VisualStudio::Debugger::Evaluation::DkmVisualizedExpression*, const GUID&, IUnknown**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc7138B8A8F36654C2D04C9FD6EB1981F5(Microsoft::VisualStudio::Debugger::Evaluation::DkmVisualizedExpression*, Microsoft::VisualStudio::Debugger::Evaluation::DkmInspectionContext*, Microsoft::VisualStudio::Debugger::Evaluation::DkmLanguageExpression*, Microsoft::VisualStudio::Debugger::CallStack::DkmStackWalkFrame*, Microsoft::VisualStudio::Debugger::Evaluation::DkmEvaluationResult**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcE7CC624DFD52EBFD7D8D4328B80F7B8B(Microsoft::VisualStudio::Debugger::Evaluation::DkmVisualizedExpression*, INT32, Microsoft::VisualStudio::Debugger::DkmString**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcCC231CEFF16CBD971CC342AC73007747(Microsoft::VisualStudio::Debugger::Evaluation::DkmVisualizedExpression*, Microsoft::VisualStudio::Debugger::Evaluation::DkmEvaluationResult*, UINT32, Microsoft::VisualStudio::Debugger::Evaluation::DkmInspectionContext*, Microsoft::VisualStudio::Debugger::DkmArray<Microsoft::VisualStudio::Debugger::Evaluation::DkmEvaluationResult*>*, Microsoft::VisualStudio::Debugger::Evaluation::DkmEvaluationResultEnumContext**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcE50B12FF94F4FB40DEF8945C53BB3691(Microsoft::VisualStudio::Debugger::Evaluation::DkmVisualizedExpression*, Microsoft::VisualStudio::Debugger::Evaluation::DkmEvaluationResultEnumContext*, UINT32, UINT32, Microsoft::VisualStudio::Debugger::DkmArray<Microsoft::VisualStudio::Debugger::Evaluation::DkmEvaluationResult*>*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc7EEBF387B7C2B848675D0F50E63E9996(Microsoft::VisualStudio::Debugger::Evaluation::DkmVisualizedExpression*, Microsoft::VisualStudio::Debugger::Evaluation::DkmEvaluationResult*, Microsoft::VisualStudio::Debugger::DkmString*, UINT32, Microsoft::VisualStudio::Debugger::DkmString**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcAED1622BD40E6A09C5DE0FE3F1603171(Microsoft::VisualStudio::Debugger::Evaluation::DkmVisualizedExpression*, Microsoft::VisualStudio::Debugger::Evaluation::DkmEvaluationResult*, Microsoft::VisualStudio::Debugger::DkmString**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc83735219E8CC0CD40DBBF6F68C286948(Microsoft::VisualStudio::Debugger::DkmRuntimeInstance*, Microsoft::VisualStudio::Debugger::DkmThread*, Microsoft::VisualStudio::Debugger::DkmInstructionAddress*, UINT32, Microsoft::VisualStudio::Debugger::Exceptions::DkmExceptionProcessingStage_t, UINT32, UINT64, UINT64, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<UINT64>*, Microsoft::VisualStudio::Debugger::Native::DkmWin32ExceptionInformation**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc0820CA92D0247DC5DF701F1C1ECEA7DF(Microsoft::VisualStudio::Debugger::Evaluation::DkmInspectionSession*, const GUID&, Microsoft::VisualStudio::Debugger::CallStack::DkmStackWalkFrame*, Microsoft::VisualStudio::Debugger::CallStack::DkmStackWalkFrame*, Microsoft::VisualStudio::Debugger::Evaluation::DkmSuccessEvaluationResult*, Microsoft::VisualStudio::Debugger::ParallelTasks::DkmTask*, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<Microsoft::VisualStudio::Debugger::Evaluation::DkmSuccessEvaluationResult*>*, Microsoft::VisualStudio::Debugger::DkmRuntimeInstance*, const Microsoft::VisualStudio::Debugger::DkmDataItem&, Microsoft::VisualStudio::Debugger::CallStack::DkmAsyncStackWalkContext**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc86FDCE2F5D7CA7AEEFDCA32E39728044(Microsoft::VisualStudio::Debugger::CallStack::DkmAsyncStackWalkContext*, Microsoft::VisualStudio::Debugger::DkmWorkList*, Microsoft::VisualStudio::Debugger::DkmThread*, Microsoft::VisualStudio::Debugger::IDkmCompletionRoutine<Microsoft::VisualStudio::Debugger::CallStack::DkmGetTaskCreationStackAsyncResult>*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc4CE2773DE0FDDAF90435E6FDFCFAAAED(Microsoft::VisualStudio::Debugger::CallStack::DkmAsyncStackWalkContext*, Microsoft::VisualStudio::Debugger::DkmWorkList*, Microsoft::VisualStudio::Debugger::DkmThread*, Microsoft::VisualStudio::Debugger::IDkmCompletionRoutine<Microsoft::VisualStudio::Debugger::CallStack::DkmGetTaskContinuationFramesAsyncResult>*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc1C7E85CB433B74A1BE139D8B40E53768(Microsoft::VisualStudio::Debugger::CallStack::DkmAsyncStackWalkContext*, Microsoft::VisualStudio::Debugger::DkmWorkList*, Microsoft::VisualStudio::Debugger::DkmThread*, Microsoft::VisualStudio::Debugger::IDkmCompletionRoutine<Microsoft::VisualStudio::Debugger::CallStack::DkmGetAsyncCallStackAsyncResult>*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc7A6C7A0227D6BD610F97D032767448A8(Microsoft::VisualStudio::Debugger::DkmThread*, UINT64, UINT64, Microsoft::VisualStudio::Debugger::DkmInstructionAddress*, UINT32, Microsoft::VisualStudio::Debugger::DkmString*, Microsoft::VisualStudio::Debugger::Clr::DkmClrCaughtExceptionInformation**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcAB099C958E2B4BDC4A6A8969DF728294(Microsoft::VisualStudio::Debugger::Clr::DkmClrCaughtExceptionInformation*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc75FF43FC6B24BBA9BCB13405C170E6F2(Microsoft::VisualStudio::Debugger::Clr::NativeCompilation::DkmClrNcContainerModuleInstance*, UINT32, Microsoft::VisualStudio::Debugger::Clr::NativeCompilation::DkmClrNcModuleInstance**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc07F31C87616869864CBF6033F37DAAB9(Microsoft::VisualStudio::Debugger::Clr::NativeCompilation::DkmClrNcContainerModuleInstance*, Microsoft::VisualStudio::Debugger::DkmArray<Microsoft::VisualStudio::Debugger::Clr::NativeCompilation::DkmClrNcModuleInstance*>*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcD535CEE9B7C2831AB2793C7873F721C8(Microsoft::VisualStudio::Debugger::Clr::NativeCompilation::DkmClrNcContainerModuleInstance*, UINT32, UINT32, Microsoft::VisualStudio::Debugger::DkmArray<BYTE>*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcB9BAA2DA346F0AF91423145A3413CA27(Microsoft::VisualStudio::Debugger::Clr::NativeCompilation::DkmClrNcContainerModuleInstance*, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<BYTE>*, Microsoft::VisualStudio::Debugger::DkmArray<Microsoft::VisualStudio::Debugger::Clr::NativeCompilation::DkmClrNcInstanceFieldSymbol*>*, UINT32*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc719588163E7E4FA81DEDFC45467F9A5D(Microsoft::VisualStudio::Debugger::Clr::NativeCompilation::DkmClrNcContainerModuleInstance*, Microsoft::VisualStudio::Debugger::DkmArray<BYTE>*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc8D74EF2700984C5AE6DB6F9891E5AFEB(Microsoft::VisualStudio::Debugger::Clr::NativeCompilation::DkmClrNcContainerModuleInstance*, Microsoft::VisualStudio::Debugger::DkmWorkList*, UINT32, Microsoft::VisualStudio::Debugger::IDkmCompletionRoutine<Microsoft::VisualStudio::Debugger::Clr::NativeCompilation::DkmCreateInstructionAddressFromRvaAsyncResult>*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc0CF9D0EC7EF8995BD39E312B58463B27(Microsoft::VisualStudio::Debugger::DkmString*, UINT32, UINT32, Microsoft::VisualStudio::Debugger::Clr::NativeCompilation::DkmClrNcInstanceFieldSymbol**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc9B089C79F9336B6ABA00EF766311F77F(const Microsoft::VisualStudio::Debugger::Clr::DkmClrMethodId&, UINT32, UINT32, Microsoft::VisualStudio::Debugger::Clr::NativeCompilation::DkmClrNcRuntimeInstance*, Microsoft::VisualStudio::Debugger::Clr::NativeCompilation::DkmClrNcModuleInstance*, Microsoft::VisualStudio::Debugger::Clr::NativeCompilation::DkmClrNcContainerModuleInstance*, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<BYTE>*, const Microsoft::VisualStudio::Debugger::DkmInstructionAddress::CPUInstruction*, Microsoft::VisualStudio::Debugger::Clr::NativeCompilation::DkmClrNcInstructionAddress**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc249AAF78F1239055957393B3DC7BE289(Microsoft::VisualStudio::Debugger::Symbols::DkmModule*, const Microsoft::VisualStudio::Debugger::Clr::DkmClrMethodId&, UINT32, UINT32, UINT32, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<BYTE>*, Microsoft::VisualStudio::Debugger::Clr::NativeCompilation::DkmClrNcInstructionSymbol**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcFD92FC444A902CC21FC67149BB551442(Microsoft::VisualStudio::Debugger::Clr::NativeCompilation::DkmClrNcModuleInstance*, Microsoft::VisualStudio::Debugger::DkmWorkList*, const Microsoft::VisualStudio::Debugger::Clr::DkmClrMethodId&, UINT32, Microsoft::VisualStudio::Debugger::IDkmCompletionRoutine<Microsoft::VisualStudio::Debugger::Clr::NativeCompilation::DkmCreateInstructionAddressesFromILAddressAsyncResult>*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcC6E2961BDBDC1A9CA97272FF4B74A350(Microsoft::VisualStudio::Debugger::DkmProcess*, const Microsoft::VisualStudio::Debugger::DkmRuntimeInstanceId&, Microsoft::VisualStudio::Debugger::DkmRuntimeCapabilities_t, Microsoft::VisualStudio::Debugger::DkmRuntimeInstance*, Microsoft::VisualStudio::Debugger::DkmString*, const Microsoft::VisualStudio::Debugger::DkmDataItem&, Microsoft::VisualStudio::Debugger::Clr::NativeCompilation::DkmClrNcRuntimeInstance**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcEDF0FCE8A74B5D0C131F7752E8991D3D(Microsoft::VisualStudio::Debugger::Clr::DkmClrModuleInstance*, UINT32, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<Microsoft::VisualStudio::Debugger::Clr::DkmClrType*>*, Microsoft::VisualStudio::Debugger::Clr::DkmClrType**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc52C1C31C0DF8AA33BE89FC83CE9BEA43(Microsoft::VisualStudio::Debugger::Clr::DkmClrModuleInstance*, UINT32, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<Microsoft::VisualStudio::Debugger::Clr::DkmClrType*>*, Microsoft::VisualStudio::Debugger::Clr::DkmClrType*, UINT32, UINT32, const GUID&, Microsoft::VisualStudio::Debugger::Clr::DkmClrType**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc8538455986C021ACA81FB03C2A62E0A6(Microsoft::VisualStudio::Debugger::Clr::DkmClrType*, Microsoft::VisualStudio::Debugger::DkmString*, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<Microsoft::VisualStudio::Debugger::Clr::DkmClrType*>*, Microsoft::VisualStudio::Debugger::Clr::DkmClrMethodId*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc1904FE3D3F1FF1F186B011743A677EA1(Microsoft::VisualStudio::Debugger::Clr::DkmClrType*, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<Microsoft::VisualStudio::Debugger::Evaluation::ClrCompilation::DkmClrEvalAttribute*>**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc323D69516EBA1BCDC37105AA207724E0(Microsoft::VisualStudio::Debugger::Evaluation::DkmCompiledVisualizationData*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcFA215BDCF150EB6AB9820C4A27727AC2(Microsoft::VisualStudio::Debugger::Evaluation::DkmLanguage*, Microsoft::VisualStudio::Debugger::Evaluation::DkmInspectionSession*, const Microsoft::VisualStudio::Debugger::DkmDataItem&, Microsoft::VisualStudio::Debugger::Evaluation::DkmCompiledVisualizationData**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcA39016543127594E0FEB0444CDC3DF07(Microsoft::VisualStudio::Debugger::Evaluation::DkmCompiledVisualizationData*, const Microsoft::VisualStudio::Debugger::DkmArray<Microsoft::VisualStudio::Debugger::DkmString*>&);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc9EB16C97D0F941B559CA036DF7F4341E(Microsoft::VisualStudio::Debugger::Clr::DkmClrRuntimeInstance*, Microsoft::VisualStudio::Debugger::DkmVariant*, Microsoft::VisualStudio::Debugger::Clr::DkmILInterpreterPrimitiveValue**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc16C7D428BB76D469DE0C081CC2EB0A62(Microsoft::VisualStudio::Debugger::Clr::DkmClrRuntimeInstance*, ICorDebugHandleValue*, Microsoft::VisualStudio::Debugger::Clr::DkmILInterpreterReferenceValue**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc1061F6811AA7AD0D33CC213D93488771(Microsoft::VisualStudio::Debugger::Evaluation::DkmInspectionContext*, Microsoft::VisualStudio::Debugger::CallStack::DkmStackWalkFrame*, Microsoft::VisualStudio::Debugger::DkmString*, Microsoft::VisualStudio::Debugger::DkmString*, Microsoft::VisualStudio::Debugger::DkmString*, Microsoft::VisualStudio::Debugger::Evaluation::DkmLanguage*, Microsoft::VisualStudio::Debugger::DkmRuntimeInstance*, const Microsoft::VisualStudio::Debugger::DkmDataItem&, Microsoft::VisualStudio::Debugger::Evaluation::DkmIntermediateEvaluationResult**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW void STDMETHODCALLTYPE Proc0C053A2A86820E43F81FB08DAC8CE244(Microsoft::VisualStudio::Debugger::Clr::DkmManagedHeapRootInfo*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc94B18169AB0EDFAE1D81988AA6E03752(Microsoft::VisualStudio::Debugger::Clr::DkmManagedHeapSampler*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcD924583F9543AD80E04AE68B28A15BDE(Microsoft::VisualStudio::Debugger::DkmRuntimeInstance*, const Microsoft::VisualStudio::Debugger::DkmDataItem&, Microsoft::VisualStudio::Debugger::Clr::DkmManagedHeapSampler**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcCC7C33549F96E9BFCC53D8D4796C4789(Microsoft::VisualStudio::Debugger::Clr::DkmManagedHeapSampler*, UINT32, bool);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc3A6D0DF639ECB96F5A8FCD3BFF85AE11(Microsoft::VisualStudio::Debugger::Clr::DkmManagedHeapSampler*, UINT32, UINT32*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcE8071A89F43A788EBFEBB41CBC4489AA(Microsoft::VisualStudio::Debugger::Clr::DkmManagedHeapSampler*, UINT32, UINT32*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcBBB2B6145A59219AFF600BAA441C73A8(Microsoft::VisualStudio::Debugger::Clr::DkmManagedHeapSampler*, UINT32, UINT32*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcE7DE701BDD91AE12A722F8CC317D19BC(Microsoft::VisualStudio::Debugger::Clr::DkmManagedHeapSampler*, UINT32, Microsoft::VisualStudio::Debugger::DkmArray<BYTE>*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcFFE0C8AF37E73BF497ECBCABECEEA17A(Microsoft::VisualStudio::Debugger::Clr::DkmManagedHeapSampler*, Microsoft::VisualStudio::Debugger::DkmArray<Microsoft::VisualStudio::Debugger::Clr::DkmManagedHeapTypeInfo>*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcD96B04D45E8105CE11F115D9F742F71C(Microsoft::VisualStudio::Debugger::Clr::DkmManagedHeapSampler*, Microsoft::VisualStudio::Debugger::DkmArray<Microsoft::VisualStudio::Debugger::Clr::DkmManagedHeapRootInfo>*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW void STDMETHODCALLTYPE ProcBEDC326A3D66F01DD50255E127A47AEA(Microsoft::VisualStudio::Debugger::Clr::DkmManagedHeapTypeInfo*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc79FC2AA34BD6D341512F69F8135965C1(Microsoft::VisualStudio::Debugger::Clr::DkmManagedHeapWalker*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc01ED18A9A87787ECBAFD76CA6F41C042(Microsoft::VisualStudio::Debugger::DkmRuntimeInstance*, const Microsoft::VisualStudio::Debugger::DkmDataItem&, Microsoft::VisualStudio::Debugger::Clr::DkmManagedHeapWalker**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcB3C9F5EA2C9BFB8EB3DB4F9E5D8BB6DE(Microsoft::VisualStudio::Debugger::Clr::DkmManagedHeapWalker*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcE18D30D305F175DD1817B8F658179FD9(Microsoft::VisualStudio::Debugger::Clr::DkmManagedHeapWalker*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc797764A0BAC725C4193977B374A1E5A4(Microsoft::VisualStudio::Debugger::Clr::DkmManagedHeapWalker*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc39D50FE942130684A08B74A259BEAAD4(Microsoft::VisualStudio::Debugger::Clr::DkmManagedHeapWalker*, UINT32, Microsoft::VisualStudio::Debugger::DkmArray<Microsoft::VisualStudio::Debugger::Clr::DkmManagedHeapObjectInfo>*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc089C4F654C8E15E4AE89DDF3A1A857B2(Microsoft::VisualStudio::Debugger::Clr::DkmManagedHeapWalker*, UINT32, Microsoft::VisualStudio::Debugger::DkmArray<Microsoft::VisualStudio::Debugger::Clr::DkmManagedObjectReferenceInfo>*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcBDA1C4B8B62A848BDDA4ED914C3950B5(Microsoft::VisualStudio::Debugger::Clr::DkmManagedHeapWalker*, UINT32, Microsoft::VisualStudio::Debugger::DkmArray<Microsoft::VisualStudio::Debugger::Clr::DkmManagedHeapRootInfo>*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcDDC4469B03A149435C884CD60D958A3E(Microsoft::VisualStudio::Debugger::Clr::DkmManagedHeapWalker*, const Microsoft::VisualStudio::Debugger::DkmArray<Microsoft::VisualStudio::Debugger::Clr::DkmManagedTypeId>&, Microsoft::VisualStudio::Debugger::DkmArray<Microsoft::VisualStudio::Debugger::DkmString*>*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc0789C5EB42EE609273BB5E426139B584(Microsoft::VisualStudio::Debugger::Clr::DkmManagedHeapWalker*, Microsoft::VisualStudio::Debugger::DkmArray<Microsoft::VisualStudio::Debugger::Clr::DkmManagedHeapSegmentInfo>*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcF307798AFAEC3339F0F539394CF897AD(Microsoft::VisualStudio::Debugger::DkmThread*, Microsoft::VisualStudio::Debugger::CallStack::DkmStackWalkFrameFlags_t, const Microsoft::VisualStudio::Debugger::Clr::DkmClrMethodId&, Microsoft::VisualStudio::Debugger::Clr::DkmClrModuleInstance*, UINT32, Microsoft::VisualStudio::Debugger::CallStack::DkmAsyncStackWalkContext*, Microsoft::VisualStudio::Debugger::CallStack::DkmStackWalkFrameData*, Microsoft::VisualStudio::Debugger::Clr::DkmManagedReturnStackFrame**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc3190D0E445D2FE7421CF79FA67C8F250(Microsoft::VisualStudio::Debugger::DkmThread*, Microsoft::VisualStudio::Debugger::DkmRuntimeInstance*, Microsoft::VisualStudio::Debugger::Clr::DkmClrInstructionAddress*, Microsoft::VisualStudio::Debugger::DkmString*, Microsoft::VisualStudio::Debugger::DkmString*, Microsoft::VisualStudio::Debugger::Clr::DkmManagedReturnValueContext**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc978E4E1F1C2A124CCD52C37CE7B3FE2F(Microsoft::VisualStudio::Debugger::Clr::DkmManagedReturnValueContext*, Microsoft::VisualStudio::Debugger::Clr::DkmManagedReturnValueInfo**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcD87D1398C6DB7E1C5819A7AEF3065005(ICorDebugType*, UINT32, UINT32, UINT64, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<BYTE>*, Microsoft::VisualStudio::Debugger::Clr::DkmManagedReturnValueCopy**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcD5CA6002328EC4403BAE43C674FC3C77(ICorDebugType*, ICorDebugValue*, Microsoft::VisualStudio::Debugger::Clr::DkmManagedReturnValueReference**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW void STDMETHODCALLTYPE Proc1E701FEAF4CA56487DDB8AD758EC4739(Microsoft::VisualStudio::Debugger::ParallelTasks::DkmManagedTaskInfo*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW int STDMETHODCALLTYPE Proc0ACB29B8C23F835357243E566EC6301C(const Microsoft::VisualStudio::Debugger::Clr::DkmManagedTypeId&, const Microsoft::VisualStudio::Debugger::Clr::DkmManagedTypeId&);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc8D47D19688BAF506460B4626D5B8D8EF(Microsoft::VisualStudio::Debugger::DkmInstructionAddress*, Microsoft::VisualStudio::Debugger::Clr::DkmManagedReturnValueContext*, Microsoft::VisualStudio::Debugger::Evaluation::DkmRawManagedReturnValue**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc4BD013B67BCF30535C934FEC828B0D2F(Microsoft::VisualStudio::Debugger::DkmString*, UINT32, Microsoft::VisualStudio::Debugger::DkmRegistryTweak**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc096C4143603B1A366F404656A77DF808(Microsoft::VisualStudio::Debugger::Evaluation::DkmInspectionSession*, Microsoft::VisualStudio::Debugger::DkmThread*, Microsoft::VisualStudio::Debugger::CallStack::DkmCallStackFilterOptions_t, const Microsoft::VisualStudio::Debugger::CallStack::DkmFrameFormatOptions&, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<BYTE>*, Microsoft::VisualStudio::Debugger::CallStack::DkmAsyncStackWalkContext*, Microsoft::VisualStudio::Debugger::CallStack::DkmStackWalkOperation_t, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<Microsoft::VisualStudio::Debugger::DkmInstructionAddress*>*, const Microsoft::VisualStudio::Debugger::DkmDataItem&, Microsoft::VisualStudio::Debugger::CallStack::DkmStackTraceContext**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc75D8E6CFCFD2990F41F14B42601A66B9(Microsoft::VisualStudio::Debugger::Evaluation::DkmInspectionSession*, const Microsoft::VisualStudio::Debugger::DkmDataItem&, Microsoft::VisualStudio::Debugger::CallStack::DkmStackWalkFrameData**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc5EC0E1ADE23A70FE021DAD12CAFFC595(Microsoft::VisualStudio::Debugger::DkmProcess*, const GUID&, Microsoft::VisualStudio::Debugger::Start::DkmLoadCompleteEventDeferral**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc1F9658A9DD9C06D2D908C3ACB74E7E37(Microsoft::VisualStudio::Debugger::Start::DkmLoadCompleteEventDeferral*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcD463863E27EBF9AED0D4A4E73EC97E94(Microsoft::VisualStudio::Debugger::Start::DkmLoadCompleteEventDeferral*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc3249D3C9EA46E0FD18272AB7760482C4(HRESULT, UINT32, Microsoft::VisualStudio::Debugger::DkmString*, UINT64, UINT32, UINT32, UINT64, const Microsoft::VisualStudio::Debugger::Exceptions::DkmStowedExceptionInformation::NestedException*, Microsoft::VisualStudio::Debugger::Exceptions::DkmStowedExceptionInformation**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcF1B1DA50551A6B51735C9A51AA4CEAE4(Microsoft::VisualStudio::Debugger::Clr::DkmClrAliasKind_t, Microsoft::VisualStudio::Debugger::DkmString*, Microsoft::VisualStudio::Debugger::DkmString*, Microsoft::VisualStudio::Debugger::DkmString*, const GUID&, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<BYTE>*, Microsoft::VisualStudio::Debugger::Clr::DkmClrAlias**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcF0E5919982A4F1DB7B9372D231C26F61(const GUID&, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<BYTE>*, Microsoft::VisualStudio::Debugger::Evaluation::ClrCompilation::DkmClrCustomTypeInfo**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc8D1736155FDC81F1E58139DE347B7E41(Microsoft::VisualStudio::Debugger::Clr::DkmClrType*, Microsoft::VisualStudio::Debugger::DkmString*, Microsoft::VisualStudio::Debugger::Evaluation::ClrCompilation::DkmClrDebuggerBrowsableAttributeState_t, Microsoft::VisualStudio::Debugger::Evaluation::ClrCompilation::DkmClrDebuggerBrowsableAttribute**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcB14B5FE34DBC117808112FEC057E8D54(Microsoft::VisualStudio::Debugger::Clr::DkmClrType*, Microsoft::VisualStudio::Debugger::DkmString*, Microsoft::VisualStudio::Debugger::DkmString*, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<BYTE>*, Microsoft::VisualStudio::Debugger::DkmString*, Microsoft::VisualStudio::Debugger::DkmString*, Microsoft::VisualStudio::Debugger::DkmString*, Microsoft::VisualStudio::Debugger::Evaluation::ClrCompilation::DkmClrDebuggerDisplayAttribute**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcB145D365DC91297B6CB026CB1B5BC3DD(Microsoft::VisualStudio::Debugger::Clr::DkmClrType*, Microsoft::VisualStudio::Debugger::DkmString*, Microsoft::VisualStudio::Debugger::Clr::DkmClrType*, Microsoft::VisualStudio::Debugger::Evaluation::ClrCompilation::DkmClrDebuggerTypeProxyAttribute**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc39A1A14313605335F7629F87A8D822EA(Microsoft::VisualStudio::Debugger::Clr::DkmClrType*, Microsoft::VisualStudio::Debugger::DkmString*, Microsoft::VisualStudio::Debugger::DkmString*, Microsoft::VisualStudio::Debugger::DkmString*, Microsoft::VisualStudio::Debugger::Evaluation::DkmClrCustomVisualizerAssemblyLocation_t, Microsoft::VisualStudio::Debugger::DkmString*, Microsoft::VisualStudio::Debugger::DkmString*, Microsoft::VisualStudio::Debugger::DkmString*, Microsoft::VisualStudio::Debugger::Evaluation::ClrCompilation::DkmClrDebuggerVisualizerAttribute**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc14A0AAE890048630D46A2E955241D0CF(Microsoft::VisualStudio::Debugger::DkmString*, Microsoft::VisualStudio::Debugger::DkmString*, Microsoft::VisualStudio::Debugger::DkmString*, Microsoft::VisualStudio::Debugger::Evaluation::ClrCompilation::DkmClrCompilationResultFlags_t, Microsoft::VisualStudio::Debugger::Evaluation::DkmEvaluationResultCategory_t, Microsoft::VisualStudio::Debugger::Evaluation::ClrCompilation::DkmClrCustomTypeInfo*, Microsoft::VisualStudio::Debugger::Evaluation::ClrCompilation::DkmClrLocalVariableInfo**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcA210DBF525D74CF809345A94627A2672(Microsoft::VisualStudio::Debugger::Evaluation::ClrCompilation::DkmClrValue*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc2021ABFAEFCB327E6372E6E40E399D27(Microsoft::VisualStudio::Debugger::Evaluation::DkmInspectionSession*, Microsoft::VisualStudio::Debugger::Evaluation::DkmLanguage*, Microsoft::VisualStudio::Debugger::Clr::DkmClrType*, Microsoft::VisualStudio::Debugger::Evaluation::DkmEvaluationResultCategory_t, Microsoft::VisualStudio::Debugger::Evaluation::DkmEvaluationResultAccessType_t, Microsoft::VisualStudio::Debugger::Evaluation::DkmEvaluationResultStorageType_t, Microsoft::VisualStudio::Debugger::Evaluation::DkmEvaluationResultTypeModifierFlags_t, bool, Microsoft::VisualStudio::Debugger::DkmVariant*, Microsoft::VisualStudio::Debugger::CallStack::DkmStackWalkFrame*, Microsoft::VisualStudio::Debugger::Evaluation::DkmEvaluationResultFlags_t, Microsoft::VisualStudio::Debugger::Evaluation::DkmClrValueFlags_t, UINT64, Microsoft::VisualStudio::Debugger::Evaluation::DkmDataAddress*, Microsoft::VisualStudio::Debugger::DkmString*, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<UINT32>*, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<UINT32>*, const Microsoft::VisualStudio::Debugger::DkmDataItem&, Microsoft::VisualStudio::Debugger::Evaluation::ClrCompilation::DkmClrValue**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc6C4DE7505B979C71E3E02EB952475CC3(Microsoft::VisualStudio::Debugger::Evaluation::ClrCompilation::DkmClrValue*, Microsoft::VisualStudio::Debugger::Evaluation::DkmInspectionContext*, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<Microsoft::VisualStudio::Debugger::DkmString*>*, Microsoft::VisualStudio::Debugger::DkmString**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc890C63B33FF2E68F5B265D7634690B8F(Microsoft::VisualStudio::Debugger::Evaluation::ClrCompilation::DkmClrValue*, Microsoft::VisualStudio::Debugger::Evaluation::DkmInspectionContext*, bool*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcBF98F87C306590B3E18C3BA27F89ADD2(Microsoft::VisualStudio::Debugger::Evaluation::ClrCompilation::DkmClrValue*, Microsoft::VisualStudio::Debugger::Evaluation::DkmInspectionContext*, Microsoft::VisualStudio::Debugger::DkmString**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcAFCF06128BDFB93D5DF0C0F44D50448F(Microsoft::VisualStudio::Debugger::Evaluation::ClrCompilation::DkmClrValue*, Microsoft::VisualStudio::Debugger::DkmWorkList*, Microsoft::VisualStudio::Debugger::Clr::DkmClrType*, Microsoft::VisualStudio::Debugger::Evaluation::ClrCompilation::DkmClrCustomTypeInfo*, Microsoft::VisualStudio::Debugger::Evaluation::DkmInspectionContext*, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<Microsoft::VisualStudio::Debugger::DkmString*>*, Microsoft::VisualStudio::Debugger::DkmString*, Microsoft::VisualStudio::Debugger::DkmString*, Microsoft::VisualStudio::Debugger::IDkmCompletionRoutine<Microsoft::VisualStudio::Debugger::Evaluation::ClrCompilation::DkmEvaluationAsyncResult>*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc3AF35B63B30CFA5A1D212BEE27AC26D5(Microsoft::VisualStudio::Debugger::Evaluation::ClrCompilation::DkmClrValue*, Microsoft::VisualStudio::Debugger::Evaluation::DkmInspectionContext*, Microsoft::VisualStudio::Debugger::DkmString**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc400088C369C8C66604FDFF13B813C730(Microsoft::VisualStudio::Debugger::Evaluation::ClrCompilation::DkmClrValue*, Microsoft::VisualStudio::Debugger::DkmWorkList*, Microsoft::VisualStudio::Debugger::Evaluation::DkmInspectionContext*, Microsoft::VisualStudio::Debugger::Clr::DkmClrType*, Microsoft::VisualStudio::Debugger::DkmString*, Microsoft::VisualStudio::Debugger::IDkmCompletionRoutine<Microsoft::VisualStudio::Debugger::Evaluation::ClrCompilation::DkmEvaluateDebuggerDisplayStringAsyncResult>*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc91C4EC61807E297F57957A40CAB27100(Microsoft::VisualStudio::Debugger::Evaluation::ClrCompilation::DkmClrValue*, Microsoft::VisualStudio::Debugger::Evaluation::DkmInspectionContext*, Microsoft::VisualStudio::Debugger::Clr::DkmClrType*, Microsoft::VisualStudio::Debugger::Evaluation::ClrCompilation::DkmClrValue**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc22EEA4C695BED5B20A3D86A0C0082B66(Microsoft::VisualStudio::Debugger::Evaluation::ClrCompilation::DkmClrValue*, Microsoft::VisualStudio::Debugger::Evaluation::DkmInspectionContext*, Microsoft::VisualStudio::Debugger::Clr::DkmClrType*, Microsoft::VisualStudio::Debugger::Evaluation::ClrCompilation::DkmClrValue**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc456DE515A7AD07EAA1EC0FF44DC197A8(Microsoft::VisualStudio::Debugger::Evaluation::ClrCompilation::DkmClrValue*, Microsoft::VisualStudio::Debugger::Evaluation::DkmInspectionContext*, Microsoft::VisualStudio::Debugger::Evaluation::ClrCompilation::DkmClrValue**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc6243C5A4A929D860DA0B917987F9D8AA(Microsoft::VisualStudio::Debugger::Evaluation::ClrCompilation::DkmClrValue*, Microsoft::VisualStudio::Debugger::DkmString*, UINT32, Microsoft::VisualStudio::Debugger::DkmString*, Microsoft::VisualStudio::Debugger::Evaluation::DkmInspectionContext*, Microsoft::VisualStudio::Debugger::Evaluation::ClrCompilation::DkmClrValue**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcA590A504A81E76260F0F8227960A9E01(Microsoft::VisualStudio::Debugger::Evaluation::ClrCompilation::DkmClrValue*, const Microsoft::VisualStudio::Debugger::DkmArray<UINT32>&, Microsoft::VisualStudio::Debugger::Evaluation::DkmInspectionContext*, Microsoft::VisualStudio::Debugger::Evaluation::ClrCompilation::DkmClrValue**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc90CD4ED530C25300CB93AB8F04C67D8E(Microsoft::VisualStudio::Debugger::Evaluation::ClrCompilation::DkmClrValue*, Microsoft::VisualStudio::Debugger::Evaluation::DkmInspectionContext*, Microsoft::VisualStudio::Debugger::Evaluation::ClrCompilation::DkmClrValue**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc74D790147FCAC34024A1CD668561842F(Microsoft::VisualStudio::Debugger::DkmRuntimeInstance*, Microsoft::VisualStudio::Debugger::Evaluation::DkmCustomDataContainer*, const Microsoft::VisualStudio::Debugger::Evaluation::DkmCompilerId&, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<BYTE>*, Microsoft::VisualStudio::Debugger::DkmString*, Microsoft::VisualStudio::Debugger::DkmString*, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<Microsoft::VisualStudio::Debugger::DkmString*>*, Microsoft::VisualStudio::Debugger::Evaluation::ClrCompilation::DkmClrCompilationResultFlags_t, Microsoft::VisualStudio::Debugger::Evaluation::DkmEvaluationResultCategory_t, Microsoft::VisualStudio::Debugger::Evaluation::DkmEvaluationResultAccessType_t, Microsoft::VisualStudio::Debugger::Evaluation::DkmEvaluationResultStorageType_t, Microsoft::VisualStudio::Debugger::Evaluation::DkmEvaluationResultTypeModifierFlags_t, Microsoft::VisualStudio::Debugger::Evaluation::ClrCompilation::DkmClrCustomTypeInfo*, Microsoft::VisualStudio::Debugger::Evaluation::ClrCompilation::DkmCompiledClrInspectionQuery**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc2CB7A3C8059AAC75AF28E0B1E84A9917(Microsoft::VisualStudio::Debugger::Evaluation::ClrCompilation::DkmCompiledClrInspectionQuery*, Microsoft::VisualStudio::Debugger::DkmWorkList*, Microsoft::VisualStudio::Debugger::Evaluation::DkmInspectionContext*, Microsoft::VisualStudio::Debugger::Evaluation::DkmILContext*, Microsoft::VisualStudio::Debugger::DkmString*, Microsoft::VisualStudio::Debugger::IDkmCompletionRoutine<Microsoft::VisualStudio::Debugger::Evaluation::ClrCompilation::DkmExecuteClrInspectionQueryAsyncResult>*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc4DD91DB37653F5E07597467950976083(Microsoft::VisualStudio::Debugger::DkmRuntimeInstance*, Microsoft::VisualStudio::Debugger::Evaluation::DkmCustomDataContainer*, const Microsoft::VisualStudio::Debugger::Evaluation::DkmCompilerId&, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<BYTE>*, Microsoft::VisualStudio::Debugger::DkmString*, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<Microsoft::VisualStudio::Debugger::Evaluation::ClrCompilation::DkmClrLocalVariableInfo*>*, Microsoft::VisualStudio::Debugger::Evaluation::ClrCompilation::DkmCompiledClrLocalsQuery**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc005392F2C0BF0145335ECA55C374B2A2(Microsoft::VisualStudio::Debugger::Evaluation::ClrCompilation::DkmCompiledClrLocalsQuery*, Microsoft::VisualStudio::Debugger::DkmWorkList*, Microsoft::VisualStudio::Debugger::Evaluation::DkmInspectionContext*, Microsoft::VisualStudio::Debugger::Evaluation::DkmILContext*, UINT32, UINT32, Microsoft::VisualStudio::Debugger::IDkmCompletionRoutine<Microsoft::VisualStudio::Debugger::Evaluation::ClrCompilation::DkmGetLocalValuesAsyncResult>*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc571451A6697E1B721711E9473EF39285(Microsoft::VisualStudio::Debugger::Evaluation::DkmCustomDataContainer*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcFDC6780AC8E93F157C9371DF0C755468(Microsoft::VisualStudio::Debugger::DkmProcess*, const Microsoft::VisualStudio::Debugger::DkmDataItem&, Microsoft::VisualStudio::Debugger::Evaluation::DkmCustomDataContainer**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcCA7B631362F38C18B5D8C2D9CE4FE491(UINT32, UINT64, Microsoft::VisualStudio::Debugger::DkmProcess*, Microsoft::VisualStudio::Debugger::DkmString*, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<GUID>*, Microsoft::VisualStudio::Debugger::Start::DkmDebugProcessRequestFlags_t, Microsoft::VisualStudio::Debugger::Start::DkmDebugProcessRequest**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc43CF0BC35847CC7DAA444A86904AAF19(Microsoft::VisualStudio::Debugger::Start::DkmDebugProcessRequest*, Microsoft::VisualStudio::Debugger::DkmWorkList*, Microsoft::VisualStudio::Debugger::IDkmCompletionRoutine<Microsoft::VisualStudio::Debugger::Start::DkmDebugProcessRequestAsyncResult>*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc082C271A47113D797444C427094AAEDF(Microsoft::VisualStudio::Debugger::DkmString*, Microsoft::VisualStudio::Debugger::DkmString*, Microsoft::VisualStudio::Debugger::DkmString*, Microsoft::VisualStudio::Debugger::DefaultPort::DkmDeviceInfo**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc4B7457AF46268ED8D57C1BFC79F8BC79(Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILCheckTimeout**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc5022149BA7EB46392DCD117CA2FEF386(Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILExtractBytesPopArguments**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcFBD8048E323DAC88D7FF8393F688ED91(UINT32, UINT32, Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILPushLocalVariablePseudoAddress**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcB6D7212BE816425F674E88BD06E78AE0(UINT64, UINT32, UINT32, Microsoft::VisualStudio::Debugger::DkmString*, Microsoft::VisualStudio::Debugger::ParallelTasks::DkmJsAsyncStackFrame**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcA362BD15F58DE8F2A1F626F0A7DBA97E(Microsoft::VisualStudio::Debugger::DkmString*, Microsoft::VisualStudio::Debugger::DkmVariant*, Microsoft::VisualStudio::Debugger::Telemetry::DkmNameValuePair**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcB5B3FB396ABDFD2A6B8D805FDC61EE50(UINT32, UINT64, UINT64, UINT64, UINT64, UINT64, UINT64, UINT64, Microsoft::VisualStudio::Debugger::DkmPerformanceCounters**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcF54928607EEFC725D831257A3CC72386(UINT64, Microsoft::VisualStudio::Debugger::DkmProcessExecutionCounters**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc199972430544F641DFC1A35754AF1EC0(Microsoft::VisualStudio::Debugger::DefaultPort::DkmTransportConnection*, Microsoft::VisualStudio::Debugger::Start::DkmDebugLaunchSettings*, Microsoft::VisualStudio::Debugger::DkmString*, Microsoft::VisualStudio::Debugger::DefaultPort::DkmAppPackageId*, Microsoft::VisualStudio::Debugger::Start::DkmProcessLaunchFlags_t, Microsoft::VisualStudio::Debugger::Start::DkmProcessLaunchEnvironmentFilterInputData**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcD9DC7CF02117F80BE2495AB906AC64B0(Microsoft::VisualStudio::Debugger::Start::DkmProcessLaunchEnvironmentFilterList140*, UINT32, Microsoft::VisualStudio::Debugger::Start::DkmProcessLaunchEnvironmentFilterInputData*, Microsoft::VisualStudio::Debugger::DkmString**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc0C211680A7F9624327EDD6ED30FD1C19(Microsoft::VisualStudio::Debugger::Start::DkmProcessLaunchEnvironmentFilterList140**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc7E505E32958900398D69C6DFB3CC8958(Microsoft::VisualStudio::Debugger::Evaluation::DkmInspectionSession*, UINT32, Microsoft::VisualStudio::Debugger::Evaluation::DkmRawReturnValue*, const Microsoft::VisualStudio::Debugger::DkmDataItem&, Microsoft::VisualStudio::Debugger::Evaluation::DkmRawReturnValueContainer**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Proc460DDFA12EC13DA36A7F58D811507AD7(Microsoft::VisualStudio::Debugger::DkmString*, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<Microsoft::VisualStudio::Debugger::Telemetry::DkmNameValuePair*>*, Microsoft::VisualStudio::Debugger::DkmProcess*, Microsoft::VisualStudio::Debugger::Telemetry::DkmTelemetryEvent**);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcC7B5FDEAB2F8AA4877A954A64B765D38(Microsoft::VisualStudio::Debugger::Telemetry::DkmTelemetryEvent*);
extern "C" __declspec(dllimport) DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE ProcAE0CE43A914209353DDCF288F1A32E1A(Microsoft::VisualStudio::Debugger::Telemetry::DkmTelemetryEvent*, Microsoft::VisualStudio::Debugger::DkmWorkList*, Microsoft::VisualStudio::Debugger::IDkmCompletionRoutine<Microsoft::VisualStudio::Debugger::Telemetry::DkmPostAsyncResult>*);

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmComponentManager::InitializeThread(_In_ REFGUID guidComponentId)
{
    return ProcDkmInitializeThread(guidComponentId, NULL);
}
inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmComponentManager::UninitializeThread(_In_ REFGUID guidComponentId)
{
    return ProcDkmUninitializeThread(guidComponentId);
}
inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmComponentManager::GetCurrentComponentId(_Out_ GUID* pComponentId)
{
    return ProcDkmGetCurrentComponentId(pComponentId);
}
inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmComponentManager::AllowComponentReentrancy()
{
    return ProcDkmAllowComponentReentrancy();
}
inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmComponentManager::DisableComponentReentrancy()
{
    return ProcDkmDisableComponentReentrancy();
}
inline DECLSPEC_NOTHROW bool STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmComponentManager::IsApiVersionSupported(_In_ DkmApiVersion_t apiVersion)
{
    return ProcDkmIsApiVersionSupported(apiVersion);
}
inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmComponentManager::FindComponentHandle(
    _In_ REFGUID componentInfo,
    _Deref_out_ DkmComponentHandle* pComponentHandle
    )
{
    return ProcDkmFindComponentHandle(componentInfo, pComponentHandle);
}
inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmComponentManager::PushComponentTransition(
    _In_ DkmComponentHandle ComponentHandle
    )
{
    return ProcDkmPushComponentTransition(ComponentHandle);
}
inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmComponentManager::PopComponentTransition(
    _In_ DkmComponentHandle ComponentHandle
    )
{
    return ProcDkmPopComponentTransition(ComponentHandle);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmComponentManager::InitializeThreadByHandle(
    _In_ DkmComponentHandle ComponentHandle
    )
{
    return ProcDkmInitializeThreadByHandle(ComponentHandle);
}
inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmComponentManager::UninitializeThreadByHandle(
    _In_ DkmComponentHandle ComponentHandle
    )
{
    return ProcDkmUninitializeThreadByHandle(ComponentHandle);
}

inline DECLSPEC_NOTHROW UINT64 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmEventDescriptor::GetTimeStamp()
{
    ATLASSERT(DkmComponentManager::IsApiVersionSupported(DkmApiVersion::VS14RTM) || !"Invalid usage detected. Process will crash or bogus data will be returned");
    return ProcDkmGetCurrentEventTimeStamp();
}


inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmDataContainer::SetDataItem(_In_ DkmDataCreationDisposition_t CreationDisposition, _In_ const DkmDataItem& item)
{
    return ProcDkmDataContainerSet(this, CreationDisposition, item);
}
inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmDataContainer::GetDataItem(_In_ REFGUID guidDataId, _Deref_out_ IUnknown** ppObject)
{
    return ProcDkmDataContainerGet(this, guidDataId, ppObject);
}
inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmDataContainer::RemoveDataItem(_In_ REFGUID guidDataId)
{
    return ProcDkmDataContainerRemove(this, guidDataId);
}
inline DECLSPEC_NOTHROW bool STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmDataContainer::IsUnloaded()
{
    const DkmDispatcherObjectFlags_t mask = (DkmDispatcherObjectFlags::ObjectAlive | DkmDispatcherObjectFlags::ObjectUnloaded);
    return (m_ObjectFlags & mask) != DkmDispatcherObjectFlags::ObjectAlive;
}
#ifndef NO_DATA_CONTAINER_TEMPLATES
template <class T>
inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmDataContainer::GetDataItem(_Deref_out_ T** ppObject)
{
    IUnknown* pObject = NULL;
    HRESULT hr = GetDataItem(__uuidof(T), &pObject);
    *ppObject = static_cast<T*>(pObject);
    return hr;
}
template <class T>
inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmDataContainer::RemoveDataItem()
{
    return ProcDkmDataContainerRemove(this, __uuidof(T));
}
#endif
inline const Microsoft::VisualStudio::Debugger::DkmDataItem& STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmDataItem::Null()
{
    C_ASSERT(sizeof(DkmDataItem) % sizeof(size_t) == 0);
    static const size_t null_value[sizeof(DkmDataItem)/sizeof(size_t)] = {0};

    return *reinterpret_cast<const DkmDataItem*>(&null_value[0]);
}
inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmAllocBytes(
    _In_ size_t bytes,
    _Out_bytecap_(bytes) void** ppMemory
    )
{
    return ProcDkmAlloc(bytes, ppMemory);
}

inline DECLSPEC_NOTHROW void STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmFreeMemory(
    _Post_ptr_invalid_ void* pMemory
    )
{
    ProcDkmFree(pMemory);
}

inline DECLSPEC_NOTHROW void STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmReleaseInterface(
    _In_opt_ IUnknown* pObject
    )
{
    ProcDkmReleaseInterface(pObject);
}

template <class T>
DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmAllocArray(
    _In_ size_t elements,
    _Out_ Microsoft::VisualStudio::Debugger::DkmArray<T>* pArray
    )
{
    HRESULT hr;

    pArray->Members = NULL;
    pArray->Length = 0;

    if (elements == 0)
    {
        return S_OK;
    }

    if (elements > MAXDWORD / sizeof(T))
    {
        return E_OUTOFMEMORY;
    }

    hr = DkmAllocBytes(elements * sizeof(T), (void**)&pArray->Members);
    if (FAILED(hr))
    {
        return hr;
    }

    pArray->Length = (DWORD)elements;
    return S_OK;
}

template <class T>
DECLSPEC_NOTHROW void STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmReleaseElement(
    T& element
    )
{
    // The non-specialized version of DkmReleaseElement assumes that element is
    // an interface pointer. This header file defines many specialized versions of this
    // function to handle all the other types in this header file. This template is not
    // designed to be used with types defined outside of this header file.
    DkmReleaseInterface(element);
}

template <class T>
DECLSPEC_NOTHROW void STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmFreeArray(
    _In_ const DkmArray<T>& Array
    )
{
    for (DWORD c = 0; c < Array.Length; c++)
    {
        DkmReleaseElement(Array.Members[c]);
    }

    if (Array.Members != NULL)
    {
        DkmFreeMemory(Array.Members);
    }
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmWorkList::Create(_In_opt_ IDkmWorkListCompletionRoutine* pCompletionRoutine, _Deref_out_ DkmWorkList** ppCreatedObject)
{
    return ProcDkmWorkListCreate(pCompletionRoutine, ppCreatedObject);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmWorkList::QueryIsCurrentInstanceCanceled()
{
    return ProcDkmWorkListQueryIsCurrentInstanceCanceled();
}

inline DECLSPEC_NOTHROW bool STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmWorkList::IsCanceled()
{
    return (this->m_Flags & DkmWorkListFlags::Canceled) != DkmWorkListFlags::None;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmWorkList::BeginExecution()
{
    return ProcDkmWorkListBeginExecution(this);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmWorkList::Execute()
{
    return ProcDkmWorkListExecute(this);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmWorkList::Cancel()
{
    return ProcDkmWorkListCancel(this);
}

#pragma warning(push)
#pragma warning(disable:6387) // disable 'return value might be 0' warning when return fields
#pragma warning(disable:6385) // disable 'invalid data access' warning for static_casts

inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DefaultPort::DkmPackagedAppPlatform_t STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DefaultPort::DkmAppPackageId::AppPlatform()
{
    return this->m_AppPlatform;
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmString* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DefaultPort::DkmAppPackageId::FullName()
{
    return this->m_pFullName;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DefaultPort::DkmAppPackageId::Create(Microsoft::VisualStudio::Debugger::DefaultPort::DkmPackagedAppPlatform_t AppPlatform, Microsoft::VisualStudio::Debugger::DkmString* pFullName, Microsoft::VisualStudio::Debugger::DefaultPort::DkmAppPackageId** ppCreatedObject)
{
    return Proc1E8D5F0C922FF9B67FDDD80B2ED6503B(AppPlatform, pFullName, ppCreatedObject);
}

inline DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::CallStack::DkmArmFrameRegisters::Pc()
{
    return this->m_Pc;
}

inline DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::CallStack::DkmArmFrameRegisters::Sp()
{
    return this->m_Sp;
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::Breakpoints::DkmPendingBreakpoint* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Breakpoints::DkmBoundBreakpoint::PendingBreakpoint()
{
    return this->m_pPendingBreakpoint;
}

inline DECLSPEC_NOTHROW const GUID& STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Breakpoints::DkmBoundBreakpoint::UniqueId()
{
    return this->m_UniqueId;
}

_Ret_opt_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::Breakpoints::DkmRuntimeBreakpoint* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Breakpoints::DkmBoundBreakpoint::Target()
{
    return this->m_pTarget;
}

_Ret_opt_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::Symbols::DkmSourcePosition* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Breakpoints::DkmBoundBreakpoint::SourcePosition()
{
    return this->m_pSourcePosition;
}

inline DECLSPEC_NOTHROW const GUID& STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Breakpoints::DkmBoundBreakpoint::SourceId()
{
    return this->m_pPendingBreakpoint->SourceId();
}

inline DECLSPEC_NOTHROW const Microsoft::VisualStudio::Debugger::Evaluation::DkmCompilerId& STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Breakpoints::DkmBoundBreakpoint::CompilerId()
{
    return this->m_pPendingBreakpoint->CompilerId();
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmProcess* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Breakpoints::DkmBoundBreakpoint::Process()
{
    return this->m_pPendingBreakpoint->Process();
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Breakpoints::DkmBoundBreakpoint::Close()
{
    return ProcEDC75945D166F34184CD05BE77F99EE5(this);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Breakpoints::DkmBoundBreakpoint::Create(Microsoft::VisualStudio::Debugger::Breakpoints::DkmPendingBreakpoint* pPendingBreakpoint, Microsoft::VisualStudio::Debugger::Breakpoints::DkmRuntimeBreakpoint* pTarget, Microsoft::VisualStudio::Debugger::Symbols::DkmSourcePosition* pSourcePosition, const Microsoft::VisualStudio::Debugger::DkmDataItem& DataItem, Microsoft::VisualStudio::Debugger::Breakpoints::DkmBoundBreakpoint** ppCreatedObject)
{
    return ProcCAF4269E8986B80CE0D8D9E03E81B4D3(pPendingBreakpoint, pTarget, pSourcePosition, DataItem, ppCreatedObject);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Breakpoints::DkmBoundBreakpoint::OnHit(Microsoft::VisualStudio::Debugger::DkmThread* pThread, bool HasException)
{
    return Proc220C93F26AF511DF6CEB8F7ED67347FD(this, pThread, HasException);
}

#ifndef EXCLUDE_IDE_ONLY_APIS
inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Breakpoints::DkmBoundBreakpoint::Enable(Microsoft::VisualStudio::Debugger::DkmWorkList* pWorkList, Microsoft::VisualStudio::Debugger::IDkmCompletionRoutine<Microsoft::VisualStudio::Debugger::Breakpoints::DkmEnableBoundBreakpointAsyncResult>* pCompletionRoutine)
{
    return Proc8CB5A7081B1ECE9D3867EC558F028B01(this, pWorkList, pCompletionRoutine);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Breakpoints::DkmBoundBreakpoint::Disable(Microsoft::VisualStudio::Debugger::DkmWorkList* pWorkList, Microsoft::VisualStudio::Debugger::IDkmCompletionRoutine<Microsoft::VisualStudio::Debugger::Breakpoints::DkmDisableBoundBreakpointAsyncResult>* pCompletionRoutine)
{
    return ProcC8789CC74E265D785FAC9687BCA58590(this, pWorkList, pCompletionRoutine);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Breakpoints::DkmBoundBreakpoint::IsEnabled(bool* pResult)
{
    return ProcF294D5B58C198B7ACF2AF61B645BFE5E(this, pResult);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Breakpoints::DkmBoundBreakpoint::SetCondition(Microsoft::VisualStudio::Debugger::Breakpoints::DkmBreakpointCondition* pCondition)
{
    return ProcD12950265C8C561E2385E7B1918F3B8B(this, pCondition);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Breakpoints::DkmBoundBreakpoint::SetHitCountCondition(Microsoft::VisualStudio::Debugger::Breakpoints::DkmBreakpointHitCountCondition* pCondition)
{
    return Proc10B0816A10DF6638455B6A097A890E3A(this, pCondition);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Breakpoints::DkmBoundBreakpoint::SetHitCountValue(UINT32 NewValue)
{
    return ProcDFB5690535A81F9A14E31EEFC96C6363(this, NewValue);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Breakpoints::DkmBoundBreakpoint::GetHitCountValue(Microsoft::VisualStudio::Debugger::DkmWorkList* pWorkList, Microsoft::VisualStudio::Debugger::IDkmCompletionRoutine<Microsoft::VisualStudio::Debugger::Breakpoints::DkmGetBoundBreakpointHitCountValueAsyncResult>* pCompletionRoutine)
{
    return ProcB6A0881929281E26ADD0F69F08CB7E3B(this, pWorkList, pCompletionRoutine);
}
#endif // #ifndef EXCLUDE_IDE_ONLY_APIS

inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::Breakpoints::DkmBreakpointConditionOperator_t STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Breakpoints::DkmBreakpointCondition::Operator()
{
    return this->m_Operator;
}

inline DECLSPEC_NOTHROW const Microsoft::VisualStudio::Debugger::Evaluation::DkmCompilerId& STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Breakpoints::DkmBreakpointCondition::CompilerId()
{
    return this->m_CompilerId;
}

inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::Evaluation::DkmEvaluationFlags_t STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Breakpoints::DkmBreakpointCondition::CompilationFlags()
{
    return this->m_CompilationFlags;
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmString* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Breakpoints::DkmBreakpointCondition::Text()
{
    return this->m_pText;
}

inline DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Breakpoints::DkmBreakpointCondition::Timeout()
{
    return this->m_Timeout;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Breakpoints::DkmBreakpointCondition::Create(Microsoft::VisualStudio::Debugger::Breakpoints::DkmBreakpointConditionOperator_t Operator, const Microsoft::VisualStudio::Debugger::Evaluation::DkmCompilerId& CompilerId, Microsoft::VisualStudio::Debugger::Evaluation::DkmEvaluationFlags_t CompilationFlags, Microsoft::VisualStudio::Debugger::DkmString* pText, UINT32 Timeout, Microsoft::VisualStudio::Debugger::Breakpoints::DkmBreakpointCondition** ppCreatedObject)
{
    return ProcDBD59238A6D89616EAEA09CCF81580D0(Operator, CompilerId, CompilationFlags, pText, Timeout, ppCreatedObject);
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<Microsoft::VisualStudio::Debugger::DkmString*>* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Breakpoints::DkmBreakpointFileUpdateNotification::FilePaths()
{
    return this->m_pFilePaths;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Breakpoints::DkmBreakpointFileUpdateNotification::Create(Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<Microsoft::VisualStudio::Debugger::DkmString*>* pFilePaths, Microsoft::VisualStudio::Debugger::Breakpoints::DkmBreakpointFileUpdateNotification** ppCreatedObject)
{
    return Proc06959BB0D92CB78ACC5BB9232D136227(pFilePaths, ppCreatedObject);
}

#ifndef EXCLUDE_IDE_ONLY_APIS
inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Breakpoints::DkmBreakpointFileUpdateNotification::Send(Microsoft::VisualStudio::Debugger::DkmWorkList* pWorkList)
{
    return Proc15ECE005CF581C5BE953A8E33738CF90(this, pWorkList);
}
#endif // #ifndef EXCLUDE_IDE_ONLY_APIS

inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::Breakpoints::DkmBreakpointHitCountConditionOperator_t STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Breakpoints::DkmBreakpointHitCountCondition::Operator()
{
    return this->m_Operator;
}

inline DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Breakpoints::DkmBreakpointHitCountCondition::Operand()
{
    return this->m_Operand;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Breakpoints::DkmBreakpointHitCountCondition::Create(Microsoft::VisualStudio::Debugger::Breakpoints::DkmBreakpointHitCountConditionOperator_t Operator, UINT32 Operand, Microsoft::VisualStudio::Debugger::Breakpoints::DkmBreakpointHitCountCondition** ppCreatedObject)
{
    return Proc897268949AF157149CA77541A54929EF(Operator, Operand, ppCreatedObject);
}

#ifndef EXCLUDE_IDE_ONLY_APIS
inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::CallStack::DkmCallStackFilterList::FilterNextFrame(UINT32 ImplementationIndex, Microsoft::VisualStudio::Debugger::CallStack::DkmStackContext* pStackContext, Microsoft::VisualStudio::Debugger::CallStack::DkmStackWalkFrame* pInput, Microsoft::VisualStudio::Debugger::DkmArray<Microsoft::VisualStudio::Debugger::CallStack::DkmStackWalkFrame*>* pResult)
{
    return Proc95D0D3C69B29592470F0BAE106585FD5(this, ImplementationIndex, pStackContext, pInput, pResult);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::CallStack::DkmCallStackFilterList::Create(Microsoft::VisualStudio::Debugger::CallStack::DkmCallStackFilterList** ppCreatedObject)
{
    return Proc8CD293451372A9D9382BD97F8B7920A6(ppCreatedObject);
}
#endif // #ifndef EXCLUDE_IDE_ONLY_APIS
_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::Evaluation::DkmEvaluationResult* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmChildVisualizedExpression::EvaluationResult()
{
    return this->m_pEvaluationResult;
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::Evaluation::DkmVisualizedExpression* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmChildVisualizedExpression::Parent()
{
    return this->m_pParent;
}

inline DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmChildVisualizedExpression::Index()
{
    return this->m_Index;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmChildVisualizedExpression::Create(Microsoft::VisualStudio::Debugger::Evaluation::DkmInspectionContext* pInspectionContext, const GUID& VisualizerId, const GUID& SourceId, Microsoft::VisualStudio::Debugger::CallStack::DkmStackWalkFrame* pStackFrame, Microsoft::VisualStudio::Debugger::Evaluation::DkmExpressionValueHome* pValueHome, Microsoft::VisualStudio::Debugger::Evaluation::DkmEvaluationResult* pEvaluationResult, Microsoft::VisualStudio::Debugger::Evaluation::DkmVisualizedExpression* pParent, UINT32 Index, const Microsoft::VisualStudio::Debugger::DkmDataItem& DataItem, Microsoft::VisualStudio::Debugger::Evaluation::DkmChildVisualizedExpression** ppCreatedObject)
{
    return Proc7076BF819350B9FA03C236373E15B497(pInspectionContext, VisualizerId, SourceId, pStackFrame, pValueHome, pEvaluationResult, pParent, Index, DataItem, ppCreatedObject);
}

inline DECLSPEC_NOTHROW const GUID& STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::DkmClrAppDomain::UniqueId()
{
    return this->m_UniqueId;
}

inline DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::DkmClrAppDomain::Id()
{
    return this->m_Id;
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::Clr::DkmClrRuntimeInstance* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::DkmClrAppDomain::RuntimeInstance()
{
    return this->m_pRuntimeInstance;
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmProcess* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::DkmClrAppDomain::Process()
{
    return this->m_pRuntimeInstance->Process();
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::DkmClrAppDomain::GetName(_Deref_out_ Microsoft::VisualStudio::Debugger::DkmString** ppValue)
{
    return GetEE6D45A22822D04D9205C8DEAAD59330(this, ppValue);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::DkmClrAppDomain::Close()
{
    return Proc547EB931F10F0693AD8703D28E7D7E56(this);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::DkmClrAppDomain::Create(UINT32 Id, Microsoft::VisualStudio::Debugger::Clr::DkmClrRuntimeInstance* pRuntimeInstance, Microsoft::VisualStudio::Debugger::DkmString* pName, const Microsoft::VisualStudio::Debugger::DkmDataItem& DataItem, Microsoft::VisualStudio::Debugger::Clr::DkmClrAppDomain** ppCreatedObject)
{
    return Proc04C30C6994A0A82EB150AF86435B3156(Id, pRuntimeInstance, pName, DataItem, ppCreatedObject);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::DkmClrAppDomain::FindClrModuleInstance(const GUID& Mvid, Microsoft::VisualStudio::Debugger::Clr::DkmClrModuleInstance** ppClrModuleInstance)
{
    return Proc433E97E57EED993B1935CE0F8FCDFBC9(this, Mvid, ppClrModuleInstance);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::DkmClrAppDomain::GetClrModuleInstances(Microsoft::VisualStudio::Debugger::DkmArray<Microsoft::VisualStudio::Debugger::Clr::DkmClrModuleInstance*>* pClrModuleInstances)
{
    return ProcA3074544DDDC4B69C83EE3A63BB51CC0(this, pClrModuleInstances);
}

#ifndef EXCLUDE_MONITOR_ONLY_APIS
inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::DkmClrAppDomain::GetCorObject(ICorDebugAppDomain** ppCorAppDomain)
{
    return Proc29ECFBE77883E77E9949C40B2DDD0D24(this, ppCorAppDomain);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::DkmClrAppDomain::GetManagedRuntimeModule(Microsoft::VisualStudio::Debugger::Clr::DkmClrModuleInstance** ppRuntimeModule)
{
    return Proc1A0826709868B99EFD98472E97E97AA8(this, ppRuntimeModule);
}
#endif // #ifndef EXCLUDE_MONITOR_ONLY_APIS

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::DkmClrAppDomain::GetMetaDataBytesPtr(Microsoft::VisualStudio::Debugger::DkmString* pAssemblyName, UINT32* pSize, LPCVOID* pMetaDataPtr)
{
    return Proc956DC35526BAB8F0F7566B0A7A687DB9(this, pAssemblyName, pSize, pMetaDataPtr);
}

#ifndef EXCLUDE_IDE_ONLY_APIS
inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::DkmClrAppDomain::GetMetaDataBytes(Microsoft::VisualStudio::Debugger::DkmString* pAssemblyName, GUID* pMvid, Microsoft::VisualStudio::Debugger::DkmArray<BYTE>* pMetaData)
{
    return Proc1EC7EADF185F4D6340751CB2DDFA761B(this, pAssemblyName, pMvid, pMetaData);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::DkmClrAppDomain::ResolveMvidByAssemblyName(Microsoft::VisualStudio::Debugger::DkmString* pAssemblyName, GUID* pMvid)
{
    return ProcEA3353C032D68329DA4409146C8B241F(this, pAssemblyName, pMvid);
}
#endif // #ifndef EXCLUDE_IDE_ONLY_APIS

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmString* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::DkmClrExceptionInformation::Name()
{
    return static_cast<Microsoft::VisualStudio::Debugger::DkmString*>(DkmExceptionInformation::Name());
}

_Ret_opt_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::Clr::DkmClrInstructionAddress* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::DkmClrExceptionInformation::InstructionAddress()
{
    return static_cast<Microsoft::VisualStudio::Debugger::Clr::DkmClrInstructionAddress*>(DkmExceptionInformation::InstructionAddress());
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::DkmClrExceptionInformation::Create(Microsoft::VisualStudio::Debugger::DkmRuntimeInstance* pRuntimeInstance, Microsoft::VisualStudio::Debugger::DkmThread* pThread, Microsoft::VisualStudio::Debugger::Exceptions::DkmExceptionProcessingStage_t ProcessingStage, Microsoft::VisualStudio::Debugger::DkmString* pName, Microsoft::VisualStudio::Debugger::Clr::DkmClrInstructionAddress* pInstructionAddress, Microsoft::VisualStudio::Debugger::Clr::DkmClrExceptionInformation** ppCreatedObject)
{
    return Proc46C70E124C967BA573D28ABE0C365815(pRuntimeInstance, pThread, ProcessingStage, pName, pInstructionAddress, ppCreatedObject);
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::Clr::DkmClrRuntimeInstance* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::DkmClrInstructionAddress::RuntimeInstance()
{
    return static_cast<Microsoft::VisualStudio::Debugger::Clr::DkmClrRuntimeInstance*>(DkmInstructionAddress::RuntimeInstance());
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::Clr::DkmClrModuleInstance* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::DkmClrInstructionAddress::ModuleInstance()
{
    return static_cast<Microsoft::VisualStudio::Debugger::Clr::DkmClrModuleInstance*>(DkmInstructionAddress::ModuleInstance());
}

inline DECLSPEC_NOTHROW const Microsoft::VisualStudio::Debugger::Clr::DkmClrMethodId& STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::DkmClrInstructionAddress::MethodId()
{
    return this->m_MethodId;
}

inline DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::DkmClrInstructionAddress::NativeOffset()
{
    return this->m_NativeOffset;
}

inline DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::DkmClrInstructionAddress::ILOffset()
{
    return this->m_ILOffset;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::DkmClrInstructionAddress::Create(Microsoft::VisualStudio::Debugger::Clr::DkmClrRuntimeInstance* pRuntimeInstance, Microsoft::VisualStudio::Debugger::Clr::DkmClrModuleInstance* pModuleInstance, const Microsoft::VisualStudio::Debugger::Clr::DkmClrMethodId& MethodId, UINT32 NativeOffset, UINT32 ILOffset, const Microsoft::VisualStudio::Debugger::DkmInstructionAddress::CPUInstruction* pCPUInstruction, Microsoft::VisualStudio::Debugger::Clr::DkmClrInstructionAddress** ppCreatedObject)
{
    return Proc86E901A98609A3892236B80CC83BC545(pRuntimeInstance, pModuleInstance, MethodId, NativeOffset, ILOffset, pCPUInstruction, ppCreatedObject);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::DkmClrInstructionAddress::GetNonUserCodeMetadataFlags(Microsoft::VisualStudio::Debugger::Clr::DkmNonUserCodeFlags_t* pNonUserCodeFlags)
{
    return ProcCA87389EB16C25D55399B86CC7697716(this, pNonUserCodeFlags);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::DkmClrInstructionAddress::GetNativeCodeMap(Microsoft::VisualStudio::Debugger::CallStack::DkmStackWalkFrame* pStackFrame, Microsoft::VisualStudio::Debugger::DkmArray<Microsoft::VisualStudio::Debugger::Clr::DkmClrNativeCodeMapEntry>* pMap)
{
    return Proc68D78BE71363649843A328B368564247(this, pStackFrame, pMap);
}

#ifndef EXCLUDE_MONITOR_ONLY_APIS
inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::DkmClrInstructionAddress::GetCorFunction(ICorDebugFunction** ppCorFunction)
{
    return Proc9514CD34D91549CCC50F8A227CDD1ACD(this, ppCorFunction);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::DkmClrInstructionAddress::IsUserCodeWithoutCheckingLineInfo(bool* pUserCode)
{
    return Proc04CC599737BBF61C58A0FFFE1C870BEE(this, pUserCode);
}
#endif // #ifndef EXCLUDE_MONITOR_ONLY_APIS

inline DECLSPEC_NOTHROW const Microsoft::VisualStudio::Debugger::Clr::DkmClrMethodId& STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::DkmClrInstructionSymbol::MethodId()
{
    return this->m_MethodId;
}

inline DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::DkmClrInstructionSymbol::ILOffset()
{
    return this->m_ILOffset;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::DkmClrInstructionSymbol::Create(Microsoft::VisualStudio::Debugger::Symbols::DkmModule* pModule, const Microsoft::VisualStudio::Debugger::Clr::DkmClrMethodId& MethodId, UINT32 ILOffset, Microsoft::VisualStudio::Debugger::Clr::DkmClrInstructionSymbol** ppCreatedObject)
{
    return ProcCE0EAB9E1275E364CAA5CDF5BF2BF219(pModule, MethodId, ILOffset, ppCreatedObject);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::DkmClrInstructionSymbol::GetAsyncMethodLocation(Microsoft::VisualStudio::Debugger::Clr::DkmClrAsyncMethodLocation_t* pAsyncLocation)
{
    return Proc49AD48ADCB8A261A843D2BA12C9F32C5(this, pAsyncLocation);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::DkmClrInstructionSymbol::GetAsyncMethodLocation(Microsoft::VisualStudio::Debugger::DkmWorkList* pWorkList, Microsoft::VisualStudio::Debugger::IDkmCompletionRoutine<Microsoft::VisualStudio::Debugger::Clr::DkmGetAsyncMethodLocationAsyncResult>* pCompletionRoutine)
{
    return Proc27CEF809C4A5195C4D6661A549F86174(this, pWorkList, pCompletionRoutine);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::DkmClrInstructionSymbol::GetAllAwaitExpressionInfoForStatement(Microsoft::VisualStudio::Debugger::DkmArray<Microsoft::VisualStudio::Debugger::Clr::DkmClrAwaitExpressionInfo>* pAsyncExpressionInfo)
{
    return Proc55C9EB068F3F789821C74F5AA300C95A(this, pAsyncExpressionInfo);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::DkmClrInstructionSymbol::GetAllAwaitExpressionInfoForStatement(Microsoft::VisualStudio::Debugger::DkmWorkList* pWorkList, Microsoft::VisualStudio::Debugger::IDkmCompletionRoutine<Microsoft::VisualStudio::Debugger::Clr::DkmGetAllAwaitExpressionInfoForStatementAsyncResult>* pCompletionRoutine)
{
    return ProcA4C73DE4731C0DDF331ED2FDB8844E4D(this, pWorkList, pCompletionRoutine);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::DkmClrInstructionSymbol::GetAsyncMethodCatchHandlerILOffset(bool* pHasCatchHandlerILOffset, UINT32* pCatchHandlerILOffset)
{
    return ProcE4BE46E4F2212642D86BC4DCBC0F16DE(this, pHasCatchHandlerILOffset, pCatchHandlerILOffset);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::DkmClrInstructionSymbol::GetNextAwaitExpressionInfo(Microsoft::VisualStudio::Debugger::Clr::DkmClrAwaitExpressionInfo* pAwaitExpressionInfo)
{
    return Proc0AB3766D13B1A2E65AADEEF04F334E90(this, pAwaitExpressionInfo);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::DkmClrInstructionSymbol::GetNextAwaitExpressionInfo(Microsoft::VisualStudio::Debugger::DkmWorkList* pWorkList, Microsoft::VisualStudio::Debugger::IDkmCompletionRoutine<Microsoft::VisualStudio::Debugger::Clr::DkmGetNextAwaitExpressionInfoAsyncResult>* pCompletionRoutine)
{
    return Proc73D36C87372025D0A2C8F5A4D47D55B8(this, pWorkList, pCompletionRoutine);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::DkmClrInstructionSymbol::GetAsyncKickoffMethod(UINT32* pKickoffMethodToken)
{
    return ProcA02F1303E8DBAEECF20626244D70D1FE(this, pKickoffMethodToken);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::DkmClrInstructionSymbol::GetAsyncKickoffMethod(Microsoft::VisualStudio::Debugger::DkmWorkList* pWorkList, Microsoft::VisualStudio::Debugger::IDkmCompletionRoutine<Microsoft::VisualStudio::Debugger::Clr::DkmGetAsyncKickoffMethodAsyncResult>* pCompletionRoutine)
{
    return Proc98766C6DD35ADF90EA215031CEB4FDCB(this, pWorkList, pCompletionRoutine);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::DkmClrInstructionSymbol::GetMethodLocalSymbols(Microsoft::VisualStudio::Debugger::DkmArray<Microsoft::VisualStudio::Debugger::Clr::DkmClrMethodScopeData>* pScopes)
{
    return ProcA933649E990648AA1B06DB796A61472B(this, pScopes);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::DkmClrInstructionSymbol::GetMethodLocalSymbols(Microsoft::VisualStudio::Debugger::DkmWorkList* pWorkList, Microsoft::VisualStudio::Debugger::IDkmCompletionRoutine<Microsoft::VisualStudio::Debugger::Clr::DkmGetMethodLocalSymbolsAsyncResult>* pCompletionRoutine)
{
    return Proc54648C4626062C911464BDF85C437D99(this, pWorkList, pCompletionRoutine);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::DkmClrInstructionSymbol::GetMethodSymbolStoreAttribute(Microsoft::VisualStudio::Debugger::DkmString* pAttributeName, Microsoft::VisualStudio::Debugger::DkmArray<BYTE>* pData)
{
    return Proc0FEE6D1828309260C0A02D36CE0D615B(this, pAttributeName, pData);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::DkmClrInstructionSymbol::GetMethodSymbolStoreAttribute(Microsoft::VisualStudio::Debugger::DkmWorkList* pWorkList, Microsoft::VisualStudio::Debugger::DkmString* pAttributeName, Microsoft::VisualStudio::Debugger::IDkmCompletionRoutine<Microsoft::VisualStudio::Debugger::Clr::DkmGetMethodSymbolStoreAttributeAsyncResult>* pCompletionRoutine)
{
    return ProcB66B51DF3FDA3AB6DBF96A21F58208D6(this, pWorkList, pAttributeName, pCompletionRoutine);
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::Symbols::DkmModule* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::DkmClrLocalConstant::Module()
{
    return this->m_pModule;
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmString* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::DkmClrLocalConstant::Name()
{
    return this->m_pName;
}

_Ret_opt_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmVariant* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::DkmClrLocalConstant::Value()
{
    return this->m_pValue;
}

_Ret_opt_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<BYTE>* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::DkmClrLocalConstant::AdditionalData()
{
    return this->m_pAdditionalData;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::DkmClrLocalConstant::Create(Microsoft::VisualStudio::Debugger::Symbols::DkmModule* pModule, Microsoft::VisualStudio::Debugger::DkmString* pName, Microsoft::VisualStudio::Debugger::DkmVariant* pValue, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<BYTE>* pAdditionalData, Microsoft::VisualStudio::Debugger::Clr::DkmClrLocalConstant** ppCreatedObject)
{
    return Proc149EE765B2389BDD6C5B91E33BDBE963(pModule, pName, pValue, pAdditionalData, ppCreatedObject);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::DkmClrLocalConstant::GetSignature(Microsoft::VisualStudio::Debugger::DkmArray<BYTE>* pSignature)
{
    return Proc69943C1ACC9E2BF01923C60E0ADABD4A(this, pSignature);
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::Symbols::DkmModule* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::DkmClrLocalVariable::Module()
{
    return this->m_pModule;
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmString* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::DkmClrLocalVariable::Name()
{
    return this->m_pName;
}

inline DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::DkmClrLocalVariable::Attributes()
{
    return this->m_Attributes;
}

inline DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::DkmClrLocalVariable::Slot()
{
    return this->m_Slot;
}

_Ret_opt_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<BYTE>* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::DkmClrLocalVariable::AdditionalData()
{
    return this->m_pAdditionalData;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::DkmClrLocalVariable::Create(Microsoft::VisualStudio::Debugger::Symbols::DkmModule* pModule, Microsoft::VisualStudio::Debugger::DkmString* pName, UINT32 Attributes, UINT32 Slot, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<BYTE>* pAdditionalData, Microsoft::VisualStudio::Debugger::Clr::DkmClrLocalVariable** ppCreatedObject)
{
    return ProcC58244BD2C547AB8EB3BF80233F4021A(pModule, pName, Attributes, Slot, pAdditionalData, ppCreatedObject);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::DkmClrLocalVariable::GetSignature(Microsoft::VisualStudio::Debugger::DkmArray<BYTE>* pSignature)
{
    return Proc65A467389235866CD2C6B92C00AE6D2A(this, pSignature);
}

inline DECLSPEC_NOTHROW int STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::DkmClrMethodId::CompareTo(const Microsoft::VisualStudio::Debugger::Clr::DkmClrMethodId& other) const
{
    return Proc876A5E63BBBE04526596CB8A99A5E9E0(*this, other);
}

inline DECLSPEC_NOTHROW void STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::DkmClrMethodScopeData::Release(Microsoft::VisualStudio::Debugger::Clr::DkmClrMethodScopeData* pItem)
{
    return ProcC0378E1124166D86890CA327620CB640(pItem);
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::Clr::DkmClrRuntimeInstance* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::DkmClrModuleInstance::RuntimeInstance()
{
    return static_cast<Microsoft::VisualStudio::Debugger::Clr::DkmClrRuntimeInstance*>(DkmModuleInstance::RuntimeInstance());
}

inline DECLSPEC_NOTHROW const GUID& STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::DkmClrModuleInstance::Mvid()
{
    return this->m_Mvid;
}

inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::Clr::DkmClrModuleFlags_t STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::DkmClrModuleInstance::ClrFlags()
{
    return this->m_ClrFlags;
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::Clr::DkmClrAppDomain* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::DkmClrModuleInstance::AppDomain()
{
    return this->m_pAppDomain;
}

inline DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::DkmClrModuleInstance::ILImageSize()
{
    // This method was introduced after the initial version of the API. The caller is
    // responsible for taking steps to ensure that this method is not called when running
    // against earlier versions of vsdebugeng.dll.
    ATLASSERT(DkmComponentManager::IsApiVersionSupported(DkmApiVersion::VS12RTM) || !"Invalid usage detected. Process will crash or bogus data will be returned");
    return this->m__pExtendedData->ILImageSize;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::DkmClrModuleInstance::Create(Microsoft::VisualStudio::Debugger::DkmString* pName, Microsoft::VisualStudio::Debugger::DkmString* pFullName, UINT64 TimeDateStamp, Microsoft::VisualStudio::Debugger::DkmModuleVersion* pVersion, Microsoft::VisualStudio::Debugger::Symbols::DkmSymbolFileId* pSymbolFileId, Microsoft::VisualStudio::Debugger::DkmModuleFlags_t Flags, Microsoft::VisualStudio::Debugger::DkmModuleMemoryLayout_t MemoryLayout, UINT64 BaseAddress, UINT32 LoadOrder, UINT32 Size, Microsoft::VisualStudio::Debugger::DkmString* pLoadContext, Microsoft::VisualStudio::Debugger::Clr::DkmClrRuntimeInstance* pRuntimeInstance, const GUID& Mvid, Microsoft::VisualStudio::Debugger::Clr::DkmClrModuleFlags_t ClrFlags, Microsoft::VisualStudio::Debugger::Clr::DkmClrAppDomain* pAppDomain, bool IsDisabled, Microsoft::VisualStudio::Debugger::Symbols::DkmModule* pModule, const Microsoft::VisualStudio::Debugger::DkmModuleInstance::MinidumpInfo* pMinidumpInfo, const Microsoft::VisualStudio::Debugger::DkmDataItem& DataItem, Microsoft::VisualStudio::Debugger::Clr::DkmClrModuleInstance** ppCreatedObject)
{
    return ProcA9BDAC6B67EE4CBC82EDEA2AB8AA48EF(pName, pFullName, TimeDateStamp, pVersion, pSymbolFileId, Flags, MemoryLayout, BaseAddress, LoadOrder, Size, pLoadContext, pRuntimeInstance, Mvid, ClrFlags, pAppDomain, IsDisabled, pModule, pMinidumpInfo, DataItem, ppCreatedObject);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::DkmClrModuleInstance::Create(Microsoft::VisualStudio::Debugger::DkmString* pName, Microsoft::VisualStudio::Debugger::DkmString* pFullName, UINT64 TimeDateStamp, Microsoft::VisualStudio::Debugger::DkmModuleVersion* pVersion, Microsoft::VisualStudio::Debugger::Symbols::DkmSymbolFileId* pSymbolFileId, Microsoft::VisualStudio::Debugger::DkmModuleFlags_t Flags, Microsoft::VisualStudio::Debugger::DkmModuleMemoryLayout_t MemoryLayout, UINT64 BaseAddress, UINT32 LoadOrder, UINT32 Size, Microsoft::VisualStudio::Debugger::DkmString* pLoadContext, Microsoft::VisualStudio::Debugger::Clr::DkmClrRuntimeInstance* pRuntimeInstance, const GUID& Mvid, Microsoft::VisualStudio::Debugger::Clr::DkmClrModuleFlags_t ClrFlags, Microsoft::VisualStudio::Debugger::Clr::DkmClrAppDomain* pAppDomain, UINT32 ILImageSize, bool IsDisabled, Microsoft::VisualStudio::Debugger::Symbols::DkmModule* pModule, const Microsoft::VisualStudio::Debugger::DkmModuleInstance::MinidumpInfo* pMinidumpInfo, const Microsoft::VisualStudio::Debugger::DkmDataItem& DataItem, Microsoft::VisualStudio::Debugger::Clr::DkmClrModuleInstance** ppCreatedObject)
{
    return ProcAEA58B7861C86E08A55546A1C4D0ACAD(pName, pFullName, TimeDateStamp, pVersion, pSymbolFileId, Flags, MemoryLayout, BaseAddress, LoadOrder, Size, pLoadContext, pRuntimeInstance, Mvid, ClrFlags, pAppDomain, ILImageSize, IsDisabled, pModule, pMinidumpInfo, DataItem, ppCreatedObject);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::DkmClrModuleInstance::GetMetaDataImport(IUnknown** ppMetaData)
{
    return ProcF4BC786AEBAC294EE9C4C0BB1B0F56A7(this, ppMetaData);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::DkmClrModuleInstance::GetMetaDataBytes(Microsoft::VisualStudio::Debugger::DkmArray<BYTE>* pMetaData)
{
    return Proc423E0CAAC5C839003AD794CCD62FA0AC(this, pMetaData);
}

#ifndef EXCLUDE_MONITOR_ONLY_APIS
inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::DkmClrModuleInstance::GetCorObject(ICorDebugModule** ppCorModule)
{
    return Proc007981F40FEA39E044F4D8CF4A9AC416(this, ppCorModule);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::DkmClrModuleInstance::ResolveTypeName(Microsoft::VisualStudio::Debugger::DkmString* pTypeName, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<Microsoft::VisualStudio::Debugger::Clr::DkmClrType*>* pGenericParameters, Microsoft::VisualStudio::Debugger::Clr::DkmClrType** ppResult)
{
    return ProcCFC27B46EBDEFADA1E91D0A90B77634C(this, pTypeName, pGenericParameters, ppResult);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::DkmClrModuleInstance::InterpretManagedMethod(const Microsoft::VisualStudio::Debugger::Clr::DkmClrMethodId& Method, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<Microsoft::VisualStudio::Debugger::Clr::DkmClrType*>* pGenericTypeParameters, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<Microsoft::VisualStudio::Debugger::Clr::DkmClrType*>* pGenericMethodParameters, Microsoft::VisualStudio::Debugger::Clr::DkmILInterpreterValue* pThisParameter, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<Microsoft::VisualStudio::Debugger::Clr::DkmILInterpreterValue*>* pParameters, UINT32 MaxInstructionCount, Microsoft::VisualStudio::Debugger::Clr::DkmILInterpreterOptions_t Options, Microsoft::VisualStudio::Debugger::Clr::DkmILInterpreterValue** ppReturnValue, Microsoft::VisualStudio::Debugger::DkmString** ppExceptionType)
{
    return ProcC2A7595A78323D9ED538F97DF8858518(this, Method, pGenericTypeParameters, pGenericMethodParameters, pThisParameter, pParameters, MaxInstructionCount, Options, ppReturnValue, ppExceptionType);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::DkmClrModuleInstance::GetMetadataStatus(Microsoft::VisualStudio::Debugger::Clr::DkmMetadataStatus_t* pMetadataStatus)
{
    return ProcBA9A7ADBEAC8F47A27529954272992A2(this, pMetadataStatus);
}
#endif // #ifndef EXCLUDE_MONITOR_ONLY_APIS

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::DkmClrModuleInstance::GetMetaDataBytesPtr(UINT32* pSize, LPCVOID* pMetaDataPtr)
{
    return Proc21CE24614A03FAC406FB8A39D7D56627(this, pSize, pMetaDataPtr);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::DkmClrModuleInstance::GetLocalSignatureToken(UINT32 MethodToken, UINT32* pLocalSignatureToken)
{
    return ProcF2D46E24A8C073A9344BD0846AEF9CA1(this, MethodToken, pLocalSignatureToken);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::DkmClrModuleInstance::GetMethodTokens(Microsoft::VisualStudio::Debugger::DkmString* pClassName, Microsoft::VisualStudio::Debugger::DkmString* pMethodName, Microsoft::VisualStudio::Debugger::DkmArray<UINT32>* pTokens)
{
    return Proc7BA9C35CB6604944814CAD70CD48C7AD(this, pClassName, pMethodName, pTokens);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::DkmClrModuleInstance::GetMethodTokens(Microsoft::VisualStudio::Debugger::DkmWorkList* pWorkList, Microsoft::VisualStudio::Debugger::DkmString* pClassName, Microsoft::VisualStudio::Debugger::DkmString* pMethodName, Microsoft::VisualStudio::Debugger::IDkmCompletionRoutine<Microsoft::VisualStudio::Debugger::Clr::DkmGetMethodTokensAsyncResult>* pCompletionRoutine)
{
    return Proc0CDF6394547B1FFF45B26226166278EC(this, pWorkList, pClassName, pMethodName, pCompletionRoutine);
}

_Ret_opt_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmString* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::DkmClrRuntimeInstance::CORSystemDirectory()
{
    return this->m_pCORSystemDirectory;
}

_Ret_opt_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmString* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::DkmClrRuntimeInstance::RuntimeVersion()
{
    return this->m_pRuntimeVersion;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::DkmClrRuntimeInstance::Create(Microsoft::VisualStudio::Debugger::DkmProcess* pProcess, const Microsoft::VisualStudio::Debugger::DkmRuntimeInstanceId& Id, Microsoft::VisualStudio::Debugger::DkmString* pCORSystemDirectory, Microsoft::VisualStudio::Debugger::DkmString* pRuntimeVersion, const Microsoft::VisualStudio::Debugger::DkmDataItem& DataItem, Microsoft::VisualStudio::Debugger::Clr::DkmClrRuntimeInstance** ppCreatedObject)
{
    return ProcA5B161350506D3C0213719EA3CA946C7(pProcess, Id, pCORSystemDirectory, pRuntimeVersion, DataItem, ppCreatedObject);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::DkmClrRuntimeInstance::Create(Microsoft::VisualStudio::Debugger::DkmProcess* pProcess, const Microsoft::VisualStudio::Debugger::DkmRuntimeInstanceId& Id, Microsoft::VisualStudio::Debugger::DkmRuntimeCapabilities_t Capabilities, Microsoft::VisualStudio::Debugger::DkmRuntimeInstance* pParentRuntime, Microsoft::VisualStudio::Debugger::DkmString* pCORSystemDirectory, Microsoft::VisualStudio::Debugger::DkmString* pRuntimeVersion, const Microsoft::VisualStudio::Debugger::DkmDataItem& DataItem, Microsoft::VisualStudio::Debugger::Clr::DkmClrRuntimeInstance** ppCreatedObject)
{
    return ProcA8484D0DF6D845608CC611EB2C6E61F9(pProcess, Id, Capabilities, pParentRuntime, pCORSystemDirectory, pRuntimeVersion, DataItem, ppCreatedObject);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::DkmClrRuntimeInstance::FindAppDomain(UINT32 Id, Microsoft::VisualStudio::Debugger::Clr::DkmClrAppDomain** ppAppDomain)
{
    return Proc494202493BBFB43009A6715156984C4D(this, Id, ppAppDomain);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::DkmClrRuntimeInstance::GetAppDomains(Microsoft::VisualStudio::Debugger::DkmArray<Microsoft::VisualStudio::Debugger::Clr::DkmClrAppDomain*>* pAppDomains)
{
    return Proc30CD194706F2789B39BDA5888D5809D6(this, pAppDomains);
}

#ifndef EXCLUDE_MONITOR_ONLY_APIS
inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::DkmClrRuntimeInstance::FindClrModuleInstance(ICorDebugModule* pCorModule, Microsoft::VisualStudio::Debugger::Clr::DkmClrModuleInstance** ppResult)
{
    return Proc81F4DF12CD2E79C82CFA7D02F085DE1D(this, pCorModule, ppResult);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::DkmClrRuntimeInstance::GetCorThread(Microsoft::VisualStudio::Debugger::DkmThread* pThread, ICorDebugThread** ppCorThread)
{
    return Proc7AC8F22DCEDC5109A8CFCCDB1698A28C(this, pThread, ppCorThread);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::DkmClrRuntimeInstance::GetCorProcess(ICorDebugProcess** ppCorProcess)
{
    return Proc4F2ACCA282DF893ACD2710806F488982(this, ppCorProcess);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::DkmClrRuntimeInstance::PrepareForFuncEvalQuickAbort(Microsoft::VisualStudio::Debugger::DkmThread* pThread, bool* pSkipLoad, UINT64* pMemoryAddress)
{
    return Proc47E089E532D16825286594316453806D(this, pThread, pSkipLoad, pMemoryAddress);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::DkmClrRuntimeInstance::OnFuncEvalQuickAbortDllLoaded(Microsoft::VisualStudio::Debugger::DkmThread* pThread, bool Result)
{
    return Proc0132C3722F8DEFF0E84DABDD6B5DCCBA(this, pThread, Result);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::DkmClrRuntimeInstance::ContinueForFuncEval(Microsoft::VisualStudio::Debugger::DkmThread* pThread, ICorDebugEval* pCorEval, Microsoft::VisualStudio::Debugger::Evaluation::DkmFuncEvalFlags_t FuncEvalFlags, UINT32 Timeout, Microsoft::VisualStudio::Debugger::DkmString* pEvaluationString, HRESULT* pResult)
{
    return ProcA58F0A1DAF5C4DEA3A4923BA8F90EF34(this, pThread, pCorEval, FuncEvalFlags, Timeout, pEvaluationString, pResult);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::DkmClrRuntimeInstance::CanDoFuncEval(Microsoft::VisualStudio::Debugger::DkmThread* pThread, HRESULT* pResult)
{
    return Proc4C53A066D18791671CC9C01BFA0C6D8D(this, pThread, pResult);
}
#endif // #ifndef EXCLUDE_MONITOR_ONLY_APIS

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::DkmClrRuntimeInstance::GetAliases(Microsoft::VisualStudio::Debugger::Evaluation::DkmInspectionContext* pInspectionContext, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<Microsoft::VisualStudio::Debugger::Clr::DkmClrAlias*>** ppResult)
{
    return Proc7FA2ACD6DAD998180F54B053E883C4E7(this, pInspectionContext, ppResult);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::DkmClrRuntimeInstance::GetIntrinsicAssemblyMetaDataBytesPtr(UINT32* pSize, LPCVOID* pMetaDataPtr)
{
    return Proc0AAAE1549C1585A26F4F8EE8C9257B0E(this, pSize, pMetaDataPtr);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::DkmClrRuntimeInstance::GetCorFrame(Microsoft::VisualStudio::Debugger::DkmThread* pThread, UINT64 FrameBase, const GUID& InterfaceID, IUnknown** ppFrameInterface)
{
    return Proc401508E48EF424452285528230DAFD68(this, pThread, FrameBase, InterfaceID, ppFrameInterface);
}

inline DECLSPEC_NOTHROW void STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Symbols::DkmCodeViewCompilerId::Release(Microsoft::VisualStudio::Debugger::Symbols::DkmCodeViewCompilerId* pItem)
{
    return ProcC3CB7743B5DBB83116E9365BACFA6AF3(pItem);
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<BYTE>* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmCompiledCustomInspectionQuery::Instructions()
{
    return this->m_pInstructions;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmCompiledCustomInspectionQuery::Create(Microsoft::VisualStudio::Debugger::DkmRuntimeInstance* pRuntimeInstance, const GUID& QueryKind, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<BYTE>* pInstructions, Microsoft::VisualStudio::Debugger::Evaluation::DkmCompiledCustomInspectionQuery** ppCreatedObject)
{
    return Proc0C158E97206654F945E7158521D7796B(pRuntimeInstance, QueryKind, pInstructions, ppCreatedObject);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmCompiledCustomInspectionQuery::Create(Microsoft::VisualStudio::Debugger::DkmRuntimeInstance* pRuntimeInstance, const GUID& QueryKind, Microsoft::VisualStudio::Debugger::Evaluation::DkmCustomDataContainer* pDataContainer, const Microsoft::VisualStudio::Debugger::Evaluation::DkmCompilerId& LanguageId, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<BYTE>* pInstructions, Microsoft::VisualStudio::Debugger::Evaluation::DkmCompiledCustomInspectionQuery** ppCreatedObject)
{
    return ProcF163E94993A30EF0B0CE551E602CAB26(pRuntimeInstance, QueryKind, pDataContainer, LanguageId, pInstructions, ppCreatedObject);
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILInstruction*>* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmCompiledILInspectionQuery::Instructions()
{
    return this->m_pInstructions;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmCompiledILInspectionQuery::Create(Microsoft::VisualStudio::Debugger::DkmRuntimeInstance* pRuntimeInstance, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILInstruction*>* pInstructions, Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmCompiledILInspectionQuery** ppCreatedObject)
{
    return ProcB0E7C63F4B37AB192D3B02A003BD771F(pRuntimeInstance, pInstructions, ppCreatedObject);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmCompiledILInspectionQuery::Create(Microsoft::VisualStudio::Debugger::DkmRuntimeInstance* pRuntimeInstance, Microsoft::VisualStudio::Debugger::Evaluation::DkmCustomDataContainer* pDataContainer, const Microsoft::VisualStudio::Debugger::Evaluation::DkmCompilerId& LanguageId, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILInstruction*>* pInstructions, Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmCompiledILInspectionQuery** ppCreatedObject)
{
    return Proc15E2FB5FD78B7B4EFDEAE0EBD5FEC28A(pRuntimeInstance, pDataContainer, LanguageId, pInstructions, ppCreatedObject);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmCompiledILInspectionQuery::ExecuteQueryOnThreads(Microsoft::VisualStudio::Debugger::Evaluation::DkmILContext* pILContext, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<UINT64>* pThreads, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<Microsoft::VisualStudio::Debugger::Evaluation::Group::DkmILParameterValueCollection*>* pParameters, Microsoft::VisualStudio::Debugger::Evaluation::Group::DkmContextGroupEvaluationILResult** ppResult)
{
    return Proc52A14AC059F0DEB8A5DD37CE238BCAA4(this, pILContext, pThreads, pParameters, ppResult);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmCompiledILInspectionQuery::ExecuteQueryOnThreads(Microsoft::VisualStudio::Debugger::DkmWorkList* pWorkList, Microsoft::VisualStudio::Debugger::Evaluation::DkmILContext* pILContext, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<UINT64>* pThreads, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<Microsoft::VisualStudio::Debugger::Evaluation::Group::DkmILParameterValueCollection*>* pParameters, Microsoft::VisualStudio::Debugger::IDkmCompletionRoutine<Microsoft::VisualStudio::Debugger::Evaluation::Group::DkmExecuteQueryOnThreadsAsyncResult>* pCompletionRoutine)
{
    return Proc99FA7DE19BFA48E79B8C772F04C5C0F7(this, pWorkList, pILContext, pThreads, pParameters, pCompletionRoutine);
}

inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::Evaluation::DkmCompiledInspectionQuery::Tag_t STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmCompiledInspectionQuery::TagValue()
{
    return this->m_TagValue;
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmRuntimeInstance* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmCompiledInspectionQuery::RuntimeInstance()
{
    return this->m_pRuntimeInstance;
}

inline DECLSPEC_NOTHROW const GUID& STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmCompiledInspectionQuery::QueryKind()
{
    return this->m_QueryKind;
}

_Ret_opt_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::Evaluation::DkmCustomDataContainer* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmCompiledInspectionQuery::DataContainer()
{
    // This method was introduced after the initial version of the API. The caller is
    // responsible for taking steps to ensure that this method is not called when running
    // against earlier versions of vsdebugeng.dll.
    ATLASSERT(DkmComponentManager::IsApiVersionSupported(DkmApiVersion::VS14RTM) || !"Invalid usage detected. Process will crash or bogus data will be returned");
    return this->m__pExtendedData->pDataContainer;
}

inline DECLSPEC_NOTHROW const Microsoft::VisualStudio::Debugger::Evaluation::DkmCompilerId& STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmCompiledInspectionQuery::LanguageId()
{
    // This method was introduced after the initial version of the API. The caller is
    // responsible for taking steps to ensure that this method is not called when running
    // against earlier versions of vsdebugeng.dll.
    ATLASSERT(DkmComponentManager::IsApiVersionSupported(DkmApiVersion::VS14RTM) || !"Invalid usage detected. Process will crash or bogus data will be returned");
    return this->m__pExtendedData->LanguageId;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmCompiledInspectionQuery::Execute(Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILParameterValue*>* pParameters, Microsoft::VisualStudio::Debugger::Evaluation::DkmILContext* pILContext, UINT32 Timeout, Microsoft::VisualStudio::Debugger::Evaluation::DkmFuncEvalFlags_t FuncEvalFlags, Microsoft::VisualStudio::Debugger::DkmArray<Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILEvaluationResult*>* pResults, Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILFailureReason_t* pFailureReason)
{
    return Proc830BF1EC32B2D50A6F454C73132E8D95(this, pParameters, pILContext, Timeout, FuncEvalFlags, pResults, pFailureReason);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmCompiledInspectionQuery::Execute(Microsoft::VisualStudio::Debugger::DkmWorkList* pWorkList, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILParameterValue*>* pParameters, Microsoft::VisualStudio::Debugger::Evaluation::DkmILContext* pILContext, UINT32 Timeout, Microsoft::VisualStudio::Debugger::Evaluation::DkmFuncEvalFlags_t FuncEvalFlags, Microsoft::VisualStudio::Debugger::IDkmCompletionRoutine<Microsoft::VisualStudio::Debugger::Evaluation::DkmExecuteQueryAsyncResult>* pCompletionRoutine)
{
    return ProcDAC5F1C0332F717B7A78BCF000B235F3(this, pWorkList, pParameters, pILContext, Timeout, FuncEvalFlags, pCompletionRoutine);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmCompiledInspectionQuery::Close()
{
    return ProcFB899FA0AA542ED4551771DA143A14EC(this);
}

#ifndef EXCLUDE_IDE_ONLY_APIS
inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmCompiledInspectionQuery::ResolveILFailureReason(Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILFailureReason_t ErrorCode, Microsoft::VisualStudio::Debugger::DkmString** ppErrorMessage)
{
    return Proc8EE5D07204FC6772B1A9B4184A9B15A8(this, ErrorCode, ppErrorMessage);
}
#endif // #ifndef EXCLUDE_IDE_ONLY_APIS

inline DECLSPEC_NOTHROW int STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmCompilerId::CompareTo(const Microsoft::VisualStudio::Debugger::Evaluation::DkmCompilerId& other) const
{
    return Proc558180C0AA1756192A5B4EECD2C72DAE(*this, other);
}

inline DECLSPEC_NOTHROW void STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::GPU::DkmComputeProperty::Release(Microsoft::VisualStudio::Debugger::GPU::DkmComputeProperty* pItem)
{
    return Proc2CC5FE15ED9552B8D71D8052FAB0ABA3(pItem);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::Group::DkmContextGroupEvaluationILResult::EvaluationResults()
{
    return this->m_EvaluationResults;
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<Microsoft::VisualStudio::Debugger::Evaluation::Group::DkmThreadEvaluationResultCollection*>* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::Group::DkmContextGroupEvaluationILResult::ResultData()
{
    return this->m_pResultData;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::Group::DkmContextGroupEvaluationILResult::Create(HRESULT EvaluationResults, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<Microsoft::VisualStudio::Debugger::Evaluation::Group::DkmThreadEvaluationResultCollection*>* pResultData, Microsoft::VisualStudio::Debugger::Evaluation::Group::DkmContextGroupEvaluationILResult** ppCreatedObject)
{
    return ProcD1951845DC0A598B7D01BE514C5C6242(EvaluationResults, pResultData, ppCreatedObject);
}

inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::Evaluation::Group::DkmContextGroupEvaluationResult::Tag_t STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::Group::DkmContextGroupEvaluationResult::TagValue()
{
    return this->m_TagValue;
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<UINT64>* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::Group::DkmContextGroupEvaluationResult::ThreadIds()
{
    return this->m_pThreadIds;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::Group::DkmContextGroupEvaluationResult::EvaluationResults()
{
    return this->m_EvaluationResults;
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmString* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::Group::DkmContextGroupEvaluationResult::Name()
{
    return this->m_pName;
}

_Ret_opt_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmString* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::Group::DkmContextGroupEvaluationResult::FullName()
{
    return this->m_pFullName;
}

inline DECLSPEC_NOTHROW const GUID& STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::Group::DkmContextGroupEvaluationResult::UniqueId()
{
    return this->m_UniqueId;
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmRuntimeInstance* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::Group::DkmContextGroupEvaluationResult::RuntimeInstance()
{
    return this->m_pRuntimeInstance;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::Group::DkmContextGroupEvaluationResult::Close()
{
    return Proc99CFA8EC6ABD1D93AFE145CA709A7FBD(this);
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmString* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Native::DkmCppExceptionInformation::Name()
{
    return static_cast<Microsoft::VisualStudio::Debugger::DkmString*>(DkmExceptionInformation::Name());
}

inline DECLSPEC_NOTHROW UINT64 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Native::DkmCppExceptionInformation::ExceptionObjectPointer()
{
    return this->m_ExceptionObjectPointer;
}

inline DECLSPEC_NOTHROW UINT64 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Native::DkmCppExceptionInformation::Address()
{
    return this->m_Address;
}

_Ret_opt_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::Native::DkmCppWinRTExceptionInformation* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Native::DkmCppExceptionInformation::WinRTExceptionInfo()
{
    return this->m_pWinRTExceptionInfo;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Native::DkmCppExceptionInformation::Create(Microsoft::VisualStudio::Debugger::DkmRuntimeInstance* pRuntimeInstance, Microsoft::VisualStudio::Debugger::DkmThread* pThread, Microsoft::VisualStudio::Debugger::DkmInstructionAddress* pInstructionAddress, Microsoft::VisualStudio::Debugger::Exceptions::DkmExceptionProcessingStage_t ProcessingStage, Microsoft::VisualStudio::Debugger::Exceptions::DkmExceptionInformation* pImplementationException, Microsoft::VisualStudio::Debugger::DkmString* pName, UINT64 ExceptionObjectPointer, UINT64 Address, Microsoft::VisualStudio::Debugger::Native::DkmCppWinRTExceptionInformation* pWinRTExceptionInfo, Microsoft::VisualStudio::Debugger::Native::DkmCppExceptionInformation** ppCreatedObject)
{
    return ProcA53162B525391FF931A42627F7AAD6A9(pRuntimeInstance, pThread, pInstructionAddress, ProcessingStage, pImplementationException, pName, ExceptionObjectPointer, Address, pWinRTExceptionInfo, ppCreatedObject);
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmString* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Native::DkmCppWinRTExceptionInformation::Description()
{
    return this->m_pDescription;
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmString* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Native::DkmCppWinRTExceptionInformation::RestrictedDescription()
{
    return this->m_pRestrictedDescription;
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmString* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Native::DkmCppWinRTExceptionInformation::RestrictedReference()
{
    return this->m_pRestrictedReference;
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmString* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Native::DkmCppWinRTExceptionInformation::RestrictedCapabilitySid()
{
    return this->m_pRestrictedCapabilitySid;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Native::DkmCppWinRTExceptionInformation::ExceptionHR()
{
    return this->m_ExceptionHR;
}

inline DECLSPEC_NOTHROW UINT64 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Native::DkmCppWinRTExceptionInformation::ErrorInfoAddress()
{
    // This method was introduced after the initial version of the API. The caller is
    // responsible for taking steps to ensure that this method is not called when running
    // against earlier versions of vsdebugeng.dll.
    ATLASSERT(DkmComponentManager::IsApiVersionSupported(DkmApiVersion::VS12RTM) || !"Invalid usage detected. Process will crash or bogus data will be returned");
    return this->m__pExtendedData->ErrorInfoAddress;
}

_Ret_opt_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<Microsoft::VisualStudio::Debugger::DkmInstructionAddress*>* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Native::DkmCppWinRTExceptionInformation::CapturedStack()
{
    // This method was introduced after the initial version of the API. The caller is
    // responsible for taking steps to ensure that this method is not called when running
    // against earlier versions of vsdebugeng.dll.
    ATLASSERT(DkmComponentManager::IsApiVersionSupported(DkmApiVersion::VS12RTM) || !"Invalid usage detected. Process will crash or bogus data will be returned");
    return this->m__pExtendedData->pCapturedStack;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Native::DkmCppWinRTExceptionInformation::Create(Microsoft::VisualStudio::Debugger::DkmString* pDescription, Microsoft::VisualStudio::Debugger::DkmString* pRestrictedDescription, Microsoft::VisualStudio::Debugger::DkmString* pRestrictedReference, Microsoft::VisualStudio::Debugger::DkmString* pRestrictedCapabilitySid, HRESULT ExceptionHR, Microsoft::VisualStudio::Debugger::Native::DkmCppWinRTExceptionInformation** ppCreatedObject)
{
    return Proc6DFAC5682AB3B324F2B704053BEE6004(pDescription, pRestrictedDescription, pRestrictedReference, pRestrictedCapabilitySid, ExceptionHR, ppCreatedObject);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Native::DkmCppWinRTExceptionInformation::Create(Microsoft::VisualStudio::Debugger::DkmString* pDescription, Microsoft::VisualStudio::Debugger::DkmString* pRestrictedDescription, Microsoft::VisualStudio::Debugger::DkmString* pRestrictedReference, Microsoft::VisualStudio::Debugger::DkmString* pRestrictedCapabilitySid, HRESULT ExceptionHR, UINT64 ErrorInfoAddress, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<Microsoft::VisualStudio::Debugger::DkmInstructionAddress*>* pCapturedStack, Microsoft::VisualStudio::Debugger::Native::DkmCppWinRTExceptionInformation** ppCreatedObject)
{
    return Proc424C754CDDD2CF45A942C20EED3CC893(pDescription, pRestrictedDescription, pRestrictedReference, pRestrictedCapabilitySid, ExceptionHR, ErrorInfoAddress, pCapturedStack, ppCreatedObject);
}

_Ret_opt_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<BYTE>* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::CustomRuntimes::DkmCustomExceptionInformation::AdditionalInformation()
{
    return this->m_pAdditionalInformation;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::CustomRuntimes::DkmCustomExceptionInformation::Create(Microsoft::VisualStudio::Debugger::DkmRuntimeInstance* pRuntimeInstance, const GUID& ExceptionCategory, Microsoft::VisualStudio::Debugger::DkmThread* pThread, Microsoft::VisualStudio::Debugger::DkmInstructionAddress* pInstructionAddress, Microsoft::VisualStudio::Debugger::DkmString* pName, UINT32 Code, Microsoft::VisualStudio::Debugger::Exceptions::DkmExceptionProcessingStage_t ProcessingStage, Microsoft::VisualStudio::Debugger::Exceptions::DkmExceptionInformation* pImplementationException, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<BYTE>* pAdditionalInformation, Microsoft::VisualStudio::Debugger::CustomRuntimes::DkmCustomExceptionInformation** ppCreatedObject)
{
    return Proc0293D2889DE6E0C14B909BC2A4CE0670(pRuntimeInstance, ExceptionCategory, pThread, pInstructionAddress, pName, Code, ProcessingStage, pImplementationException, pAdditionalInformation, ppCreatedObject);
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::CustomRuntimes::DkmCustomModuleInstance* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::CustomRuntimes::DkmCustomInstructionAddress::ModuleInstance()
{
    return static_cast<Microsoft::VisualStudio::Debugger::CustomRuntimes::DkmCustomModuleInstance*>(DkmInstructionAddress::ModuleInstance());
}

_Ret_opt_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<BYTE>* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::CustomRuntimes::DkmCustomInstructionAddress::EntityId()
{
    return this->m_pEntityId;
}

inline DECLSPEC_NOTHROW UINT64 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::CustomRuntimes::DkmCustomInstructionAddress::Offset()
{
    return this->m_Offset;
}

_Ret_opt_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<BYTE>* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::CustomRuntimes::DkmCustomInstructionAddress::AdditionalData()
{
    return this->m_pAdditionalData;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::CustomRuntimes::DkmCustomInstructionAddress::Create(Microsoft::VisualStudio::Debugger::DkmRuntimeInstance* pRuntimeInstance, Microsoft::VisualStudio::Debugger::CustomRuntimes::DkmCustomModuleInstance* pModuleInstance, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<BYTE>* pEntityId, UINT64 Offset, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<BYTE>* pAdditionalData, const Microsoft::VisualStudio::Debugger::DkmInstructionAddress::CPUInstruction* pCPUInstruction, Microsoft::VisualStudio::Debugger::CustomRuntimes::DkmCustomInstructionAddress** ppCreatedObject)
{
    return ProcE315DFDB6AEB76AA580E27B52F91F5AF(pRuntimeInstance, pModuleInstance, pEntityId, Offset, pAdditionalData, pCPUInstruction, ppCreatedObject);
}

_Ret_opt_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<BYTE>* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::CustomRuntimes::DkmCustomInstructionSymbol::EntityId()
{
    return this->m_pEntityId;
}

inline DECLSPEC_NOTHROW UINT64 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::CustomRuntimes::DkmCustomInstructionSymbol::Offset()
{
    return this->m_Offset;
}

_Ret_opt_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<BYTE>* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::CustomRuntimes::DkmCustomInstructionSymbol::AdditionalData()
{
    return this->m_pAdditionalData;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::CustomRuntimes::DkmCustomInstructionSymbol::Create(Microsoft::VisualStudio::Debugger::Symbols::DkmModule* pModule, const GUID& RuntimeType, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<BYTE>* pEntityId, UINT64 Offset, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<BYTE>* pAdditionalData, Microsoft::VisualStudio::Debugger::CustomRuntimes::DkmCustomInstructionSymbol** ppCreatedObject)
{
    return Proc166F47D8BD25C8CC59B1502B3F4A5DDB(pModule, RuntimeType, pEntityId, Offset, pAdditionalData, ppCreatedObject);
}

_Ret_opt_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DefaultPort::DkmTransportConnection* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmCustomMessage::Connection()
{
    return this->m_pConnection;
}

_Ret_opt_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmProcess* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmCustomMessage::Process()
{
    return this->m_pProcess;
}

inline DECLSPEC_NOTHROW const GUID& STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmCustomMessage::SourceId()
{
    return this->m_SourceId;
}

inline DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmCustomMessage::MessageCode()
{
    return this->m_MessageCode;
}

_Ret_opt_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmVariant* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmCustomMessage::Parameter1()
{
    return this->m_pParameter1;
}

_Ret_opt_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmVariant* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmCustomMessage::Parameter2()
{
    return this->m_pParameter2;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmCustomMessage::Create(Microsoft::VisualStudio::Debugger::DefaultPort::DkmTransportConnection* pConnection, Microsoft::VisualStudio::Debugger::DkmProcess* pProcess, const GUID& SourceId, UINT32 MessageCode, Microsoft::VisualStudio::Debugger::DkmVariant* pParameter1, Microsoft::VisualStudio::Debugger::DkmVariant* pParameter2, Microsoft::VisualStudio::Debugger::DkmCustomMessage** ppCreatedObject)
{
    return Proc6D698C640DFDABA88B6B6A8B78565B1C(pConnection, pProcess, SourceId, MessageCode, pParameter1, pParameter2, ppCreatedObject);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmCustomMessage::OnCustomStop(Microsoft::VisualStudio::Debugger::DkmThread* pThread, const GUID& VsService)
{
    return Proc5C808A6463557CF774E01775628F0DCA(this, pThread, VsService);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmCustomMessage::SendHigher(Microsoft::VisualStudio::Debugger::DkmCustomMessage** ppReplyMessage)
{
    return Proc1BAFA69EABAF1980E4618AC80AEECB47(this, ppReplyMessage);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmCustomMessage::SendLower(Microsoft::VisualStudio::Debugger::DkmCustomMessage** ppReplyMessage)
{
    return ProcA035DEDBF7F91EB78B75DE7CDEB4644C(this, ppReplyMessage);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmCustomMessage::SendLower(Microsoft::VisualStudio::Debugger::DkmWorkList* pWorkList, Microsoft::VisualStudio::Debugger::IDkmCompletionRoutine<Microsoft::VisualStudio::Debugger::DkmSendLowerAsyncResult>* pCompletionRoutine)
{
    return Proc73CBBC77F9E0A5C530459780952936FE(this, pWorkList, pCompletionRoutine);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmCustomMessage::SendToVsService(const GUID& VsService, bool IsBlocking)
{
    return Proc387497D446792B6386776489669D2D7B(this, VsService, IsBlocking);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::CustomRuntimes::DkmCustomModuleInstance::Create(Microsoft::VisualStudio::Debugger::DkmString* pName, Microsoft::VisualStudio::Debugger::DkmString* pFullName, UINT64 TimeDateStamp, Microsoft::VisualStudio::Debugger::DkmRuntimeInstance* pRuntimeInstance, Microsoft::VisualStudio::Debugger::DkmModuleVersion* pVersion, Microsoft::VisualStudio::Debugger::Symbols::DkmSymbolFileId* pSymbolFileId, Microsoft::VisualStudio::Debugger::DkmModuleFlags_t Flags, Microsoft::VisualStudio::Debugger::DkmModuleMemoryLayout_t MemoryLayout, UINT64 BaseAddress, UINT32 LoadOrder, UINT32 Size, Microsoft::VisualStudio::Debugger::DkmString* pLoadContext, bool IsDisabled, Microsoft::VisualStudio::Debugger::Symbols::DkmModule* pModule, const Microsoft::VisualStudio::Debugger::DkmModuleInstance::MinidumpInfo* pMinidumpInfo, const Microsoft::VisualStudio::Debugger::DkmDataItem& DataItem, Microsoft::VisualStudio::Debugger::CustomRuntimes::DkmCustomModuleInstance** ppCreatedObject)
{
    return ProcCCE122D321D1AFDE76D7CACE58F839C7(pName, pFullName, TimeDateStamp, pRuntimeInstance, pVersion, pSymbolFileId, Flags, MemoryLayout, BaseAddress, LoadOrder, Size, pLoadContext, IsDisabled, pModule, pMinidumpInfo, DataItem, ppCreatedObject);
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<BYTE>* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmCustomRawReturnValue::Value()
{
    return this->m_pValue;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmCustomRawReturnValue::Create(Microsoft::VisualStudio::Debugger::DkmInstructionAddress* pReturnFrom, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<BYTE>* pValue, Microsoft::VisualStudio::Debugger::Evaluation::DkmCustomRawReturnValue** ppCreatedObject)
{
    return Proc3C62BEDE7059A6F82EF5950D9B08F212(pReturnFrom, pValue, ppCreatedObject);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::CustomRuntimes::DkmCustomRuntimeInstance::Create(Microsoft::VisualStudio::Debugger::DkmProcess* pProcess, const Microsoft::VisualStudio::Debugger::DkmRuntimeInstanceId& Id, const Microsoft::VisualStudio::Debugger::DkmDataItem& DataItem, Microsoft::VisualStudio::Debugger::CustomRuntimes::DkmCustomRuntimeInstance** ppCreatedObject)
{
    return Proc0F93893A27AD0F7C9A3E108C73ABCEF6(pProcess, Id, DataItem, ppCreatedObject);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::CustomRuntimes::DkmCustomRuntimeInstance::Create(Microsoft::VisualStudio::Debugger::DkmProcess* pProcess, const Microsoft::VisualStudio::Debugger::DkmRuntimeInstanceId& Id, Microsoft::VisualStudio::Debugger::DkmRuntimeCapabilities_t Capabilities, Microsoft::VisualStudio::Debugger::DkmRuntimeInstance* pParentRuntime, const Microsoft::VisualStudio::Debugger::DkmDataItem& DataItem, Microsoft::VisualStudio::Debugger::CustomRuntimes::DkmCustomRuntimeInstance** ppCreatedObject)
{
    return Proc1A4BA89C2192C5ED79E0F488CA118164(pProcess, Id, Capabilities, pParentRuntime, DataItem, ppCreatedObject);
}

inline DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Symbols::DkmCustomSymbolFileId::Type()
{
    return this->m_Type;
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<BYTE>* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Symbols::DkmCustomSymbolFileId::Data()
{
    return this->m_pData;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Symbols::DkmCustomSymbolFileId::Create(const GUID& SymbolProviderId, UINT32 Type, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<BYTE>* pData, Microsoft::VisualStudio::Debugger::Symbols::DkmCustomSymbolFileId** ppCreatedObject)
{
    return Proc439EB6AA207DB70F8ED3430FFCAB70A6(SymbolProviderId, Type, pData, ppCreatedObject);
}

inline DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmCustomUIVisualizerInfo::Id()
{
    return this->m_Id;
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmString* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmCustomUIVisualizerInfo::MenuName()
{
    return this->m_pMenuName;
}

_Ret_opt_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmString* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmCustomUIVisualizerInfo::Description()
{
    return this->m_pDescription;
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmString* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmCustomUIVisualizerInfo::Metric()
{
    return this->m_pMetric;
}

_Ret_opt_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmString* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmCustomUIVisualizerInfo::UISideVisualizerTypeName()
{
    // This method was introduced after the initial version of the API. The caller is
    // responsible for taking steps to ensure that this method is not called when running
    // against earlier versions of vsdebugeng.dll.
    ATLASSERT(DkmComponentManager::IsApiVersionSupported(DkmApiVersion::VS14RTM) || !"Invalid usage detected. Process will crash or bogus data will be returned");
    return this->m__pExtendedData->pUISideVisualizerTypeName;
}

_Ret_opt_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmString* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmCustomUIVisualizerInfo::UISideVisualizerAssemblyName()
{
    // This method was introduced after the initial version of the API. The caller is
    // responsible for taking steps to ensure that this method is not called when running
    // against earlier versions of vsdebugeng.dll.
    ATLASSERT(DkmComponentManager::IsApiVersionSupported(DkmApiVersion::VS14RTM) || !"Invalid usage detected. Process will crash or bogus data will be returned");
    return this->m__pExtendedData->pUISideVisualizerAssemblyName;
}

inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::Evaluation::DkmClrCustomVisualizerAssemblyLocation_t STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmCustomUIVisualizerInfo::UISideVisualizerAssemblyLocation()
{
    // This method was introduced after the initial version of the API. The caller is
    // responsible for taking steps to ensure that this method is not called when running
    // against earlier versions of vsdebugeng.dll.
    ATLASSERT(DkmComponentManager::IsApiVersionSupported(DkmApiVersion::VS14RTM) || !"Invalid usage detected. Process will crash or bogus data will be returned");
    return this->m__pExtendedData->UISideVisualizerAssemblyLocation;
}

_Ret_opt_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmString* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmCustomUIVisualizerInfo::DebuggeeSideVisualizerTypeName()
{
    // This method was introduced after the initial version of the API. The caller is
    // responsible for taking steps to ensure that this method is not called when running
    // against earlier versions of vsdebugeng.dll.
    ATLASSERT(DkmComponentManager::IsApiVersionSupported(DkmApiVersion::VS14RTM) || !"Invalid usage detected. Process will crash or bogus data will be returned");
    return this->m__pExtendedData->pDebuggeeSideVisualizerTypeName;
}

_Ret_opt_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmString* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmCustomUIVisualizerInfo::DebuggeeSideVisualizerAssemblyName()
{
    // This method was introduced after the initial version of the API. The caller is
    // responsible for taking steps to ensure that this method is not called when running
    // against earlier versions of vsdebugeng.dll.
    ATLASSERT(DkmComponentManager::IsApiVersionSupported(DkmApiVersion::VS14RTM) || !"Invalid usage detected. Process will crash or bogus data will be returned");
    return this->m__pExtendedData->pDebuggeeSideVisualizerAssemblyName;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmCustomUIVisualizerInfo::Create(UINT32 Id, Microsoft::VisualStudio::Debugger::DkmString* pMenuName, Microsoft::VisualStudio::Debugger::DkmString* pDescription, Microsoft::VisualStudio::Debugger::DkmString* pMetric, Microsoft::VisualStudio::Debugger::Evaluation::DkmCustomUIVisualizerInfo** ppCreatedObject)
{
    return ProcA9F782A3E84B2CDB9646FDCE26477F26(Id, pMenuName, pDescription, pMetric, ppCreatedObject);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmCustomUIVisualizerInfo::Create(UINT32 Id, Microsoft::VisualStudio::Debugger::DkmString* pMenuName, Microsoft::VisualStudio::Debugger::DkmString* pDescription, Microsoft::VisualStudio::Debugger::DkmString* pMetric, Microsoft::VisualStudio::Debugger::DkmString* pUISideVisualizerTypeName, Microsoft::VisualStudio::Debugger::DkmString* pUISideVisualizerAssemblyName, Microsoft::VisualStudio::Debugger::Evaluation::DkmClrCustomVisualizerAssemblyLocation_t UISideVisualizerAssemblyLocation, Microsoft::VisualStudio::Debugger::DkmString* pDebuggeeSideVisualizerTypeName, Microsoft::VisualStudio::Debugger::DkmString* pDebuggeeSideVisualizerAssemblyName, Microsoft::VisualStudio::Debugger::Evaluation::DkmCustomUIVisualizerInfo** ppCreatedObject)
{
    return ProcB483EE2298133236098B18BE15BBBC8C(Id, pMenuName, pDescription, pMetric, pUISideVisualizerTypeName, pUISideVisualizerAssemblyName, UISideVisualizerAssemblyLocation, pDebuggeeSideVisualizerTypeName, pDebuggeeSideVisualizerAssemblyName, ppCreatedObject);
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmRuntimeInstance* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmDataAddress::RuntimeInstance()
{
    return this->m_pRuntimeInstance;
}

inline DECLSPEC_NOTHROW UINT64 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmDataAddress::Value()
{
    return this->m_Value;
}

_Ret_opt_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmInstructionAddress* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmDataAddress::InstructionAddress()
{
    return this->m_pInstructionAddress;
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmProcess* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmDataAddress::Process()
{
    return this->m_pRuntimeInstance->Process();
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmDataAddress::Create(Microsoft::VisualStudio::Debugger::DkmRuntimeInstance* pRuntimeInstance, UINT64 Value, Microsoft::VisualStudio::Debugger::DkmInstructionAddress* pInstructionAddress, Microsoft::VisualStudio::Debugger::Evaluation::DkmDataAddress** ppCreatedObject)
{
    return Proc76C4E68C18BC734895D4A803EED86642(pRuntimeInstance, Value, pInstructionAddress, ppCreatedObject);
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmString* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Start::DkmDebugLaunchSettings::OptionsString()
{
    return this->m_pOptionsString;
}

_Ret_opt_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<GUID>* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Start::DkmDebugLaunchSettings::EngineFilter()
{
    return this->m_pEngineFilter;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Start::DkmDebugLaunchSettings::Create(Microsoft::VisualStudio::Debugger::DkmString* pOptionsString, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<GUID>* pEngineFilter, Microsoft::VisualStudio::Debugger::Start::DkmDebugLaunchSettings** ppCreatedObject)
{
    return ProcD1BDFF0E74198F9E97B1200C099D36B2(pOptionsString, pEngineFilter, ppCreatedObject);
}

#ifndef EXCLUDE_MONITOR_ONLY_APIS
inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Start::DkmDebugLaunchSettings::GetGPUAdditionalEnvironmentVariables(Microsoft::VisualStudio::Debugger::Start::DkmProcessLaunchEnvironmentFilterScenario_t Scenario, Microsoft::VisualStudio::Debugger::DkmString** ppAdditionalEnvironmentBlock)
{
    return Proc3B2F13165414C4F66EE876593C947FF7(this, Scenario, ppAdditionalEnvironmentBlock);
}
#endif // #ifndef EXCLUDE_MONITOR_ONLY_APIS

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Start::DkmDebugLaunchSettings::IsNativeCodeSupported(Microsoft::VisualStudio::Debugger::DkmEngineSettings* pEngineSettings, bool* pNativeCodeSupported)
{
    return Proc1770D48A2E0076C5FD8CC68B89308134(this, pEngineSettings, pNativeCodeSupported);
}

inline DECLSPEC_NOTHROW const GUID& STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DefaultPort::DkmDeploymentCommand::UniqueId()
{
    return this->m_UniqueId;
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DefaultPort::DkmTransportConnection* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DefaultPort::DkmDeploymentCommand::Connection()
{
    return this->m_pConnection;
}

inline DECLSPEC_NOTHROW const GUID& STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DefaultPort::DkmDeploymentCommand::SourceId()
{
    return this->m_SourceId;
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmString* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DefaultPort::DkmDeploymentCommand::RemoteExecutable()
{
    return this->m_pRemoteExecutable;
}

_Ret_opt_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmString* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DefaultPort::DkmDeploymentCommand::Arguments()
{
    return this->m_pArguments;
}

_Ret_opt_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmString* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DefaultPort::DkmDeploymentCommand::CurrentDirectory()
{
    return this->m_pCurrentDirectory;
}

inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DefaultPort::DkmDeploymentCommandFlags_t STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DefaultPort::DkmDeploymentCommand::Flags()
{
    return this->m_Flags;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DefaultPort::DkmDeploymentCommand::Close()
{
    return Proc55CE06AE749FE4FDB97CE54A455619A3(this);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DefaultPort::DkmDeploymentCommand::Create(Microsoft::VisualStudio::Debugger::DefaultPort::DkmTransportConnection* pConnection, const GUID& SourceId, Microsoft::VisualStudio::Debugger::DkmString* pRemoteExecutable, Microsoft::VisualStudio::Debugger::DkmString* pArguments, Microsoft::VisualStudio::Debugger::DkmString* pCurrentDirectory, Microsoft::VisualStudio::Debugger::DefaultPort::DkmDeploymentCommandFlags_t Flags, const Microsoft::VisualStudio::Debugger::DkmDataItem& DataItem, Microsoft::VisualStudio::Debugger::DefaultPort::DkmDeploymentCommand** ppCreatedObject)
{
    return Proc8FCA18285F43AB559217B26B94231774(pConnection, SourceId, pRemoteExecutable, pArguments, pCurrentDirectory, Flags, DataItem, ppCreatedObject);
}

#ifndef EXCLUDE_MONITOR_ONLY_APIS
inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DefaultPort::DkmDeploymentCommand::OnProcessExit(UINT32 ExitCode)
{
    return Proc533B990E9F9B15A54DDC4E3E1D2E1078(this, ExitCode);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DefaultPort::DkmDeploymentCommand::OnStdOut(Microsoft::VisualStudio::Debugger::DkmString* pText)
{
    return ProcCE2CA685D8412F7CDB1945E19E677AEA(this, pText);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DefaultPort::DkmDeploymentCommand::OnStdErr(Microsoft::VisualStudio::Debugger::DkmString* pText)
{
    return ProcA8DA7BD7B83089DE1427BED550F265FD(this, pText);
}
#endif // #ifndef EXCLUDE_MONITOR_ONLY_APIS

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DefaultPort::DkmDeploymentCommand::Start()
{
    return Proc72A6761FCC1029893756B99ADC6B9E6C(this);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DefaultPort::DkmDeploymentCommand::Abort()
{
    return Proc86DE7C8070519AEDC00A37E1FA5E127C(this);
}

#ifndef EXCLUDE_IDE_ONLY_APIS
_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmProcess* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Disassembly::DkmDisassembledInstruction::Process()
{
    return this->m_pProcess;
}

inline DECLSPEC_NOTHROW UINT64 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Disassembly::DkmDisassembledInstruction::InstructionPointer()
{
    return this->m_InstructionPointer;
}

inline DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Disassembly::DkmDisassembledInstruction::InstructionLength()
{
    return this->m_InstructionLength;
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmString* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Disassembly::DkmDisassembledInstruction::Address()
{
    return this->m_pAddress;
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmString* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Disassembly::DkmDisassembledInstruction::AddressOffset()
{
    return this->m_pAddressOffset;
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmString* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Disassembly::DkmDisassembledInstruction::CodeBytes()
{
    return this->m_pCodeBytes;
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmString* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Disassembly::DkmDisassembledInstruction::RawOpcode()
{
    return this->m_pRawOpcode;
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmString* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Disassembly::DkmDisassembledInstruction::RawOperands()
{
    return this->m_pRawOperands;
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmString* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Disassembly::DkmDisassembledInstruction::FormattedOpcode()
{
    return this->m_pFormattedOpcode;
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmString* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Disassembly::DkmDisassembledInstruction::FormattedOperands()
{
    return this->m_pFormattedOperands;
}

_Ret_opt_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmString* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Disassembly::DkmDisassembledInstruction::Symbol()
{
    return this->m_pSymbol;
}

_Ret_opt_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::Symbols::DkmSourcePosition* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Disassembly::DkmDisassembledInstruction::DocumentPosition()
{
    return this->m_pDocumentPosition;
}

inline DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Disassembly::DkmDisassembledInstruction::ByteOffset()
{
    return this->m_ByteOffset;
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<CV_HREG_e>* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Disassembly::DkmDisassembledInstruction::RegisterOperands()
{
    return this->m_pRegisterOperands;
}

inline DECLSPEC_NOTHROW bool STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Disassembly::DkmDisassembledInstruction::ValidInstruction()
{
    return this->m_ValidInstruction;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Disassembly::DkmDisassembledInstruction::Create(Microsoft::VisualStudio::Debugger::DkmProcess* pProcess, UINT64 InstructionPointer, UINT32 InstructionLength, Microsoft::VisualStudio::Debugger::DkmString* pAddress, Microsoft::VisualStudio::Debugger::DkmString* pAddressOffset, Microsoft::VisualStudio::Debugger::DkmString* pCodeBytes, Microsoft::VisualStudio::Debugger::DkmString* pRawOpcode, Microsoft::VisualStudio::Debugger::DkmString* pRawOperands, Microsoft::VisualStudio::Debugger::DkmString* pFormattedOpcode, Microsoft::VisualStudio::Debugger::DkmString* pFormattedOperands, Microsoft::VisualStudio::Debugger::DkmString* pSymbol, Microsoft::VisualStudio::Debugger::Symbols::DkmSourcePosition* pDocumentPosition, UINT32 ByteOffset, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<CV_HREG_e>* pRegisterOperands, bool ValidInstruction, Microsoft::VisualStudio::Debugger::Disassembly::DkmDisassembledInstruction** ppCreatedObject)
{
    return Proc3416010C84D4A08CE249F39B46310F4B(pProcess, InstructionPointer, InstructionLength, pAddress, pAddressOffset, pCodeBytes, pRawOpcode, pRawOperands, pFormattedOpcode, pFormattedOperands, pSymbol, pDocumentPosition, ByteOffset, pRegisterOperands, ValidInstruction, ppCreatedObject);
}
#endif // #ifndef EXCLUDE_IDE_ONLY_APIS

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Symbols::DkmDynamicSymbolFileId::Create(const GUID& SymbolProviderId, Microsoft::VisualStudio::Debugger::Symbols::DkmDynamicSymbolFileId** ppCreatedObject)
{
    return Proc2CDF0821065EEEAF4BF0768BBC714CF9(SymbolProviderId, ppCreatedObject);
}

inline DECLSPEC_NOTHROW const GUID& STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Internal::DkmEELocalObject::UniqueId()
{
    return this->m_UniqueId;
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmProcess* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Internal::DkmEELocalObject::Process()
{
    return this->m_pProcess;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Internal::DkmEELocalObject::Create(Microsoft::VisualStudio::Debugger::DkmProcess* pProcess, const Microsoft::VisualStudio::Debugger::DkmDataItem& DataItem, Microsoft::VisualStudio::Debugger::Internal::DkmEELocalObject** ppCreatedObject)
{
    return Proc0AD4448F733B3969810D3200D16F7571(pProcess, DataItem, ppCreatedObject);
}

#ifndef EXCLUDE_MONITOR_ONLY_APIS
inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Internal::DkmEELocalObject::InitCache()
{
    return Proc212CD04490F098DD69043824CE41E472(this);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Internal::DkmEELocalObject::GetTargetClass(Microsoft::VisualStudio::Debugger::DkmString* pName, UINT32 AssemblyCookie, UINT32* pCookie, UINT32* pValueAttributeCount, UINT32* pViewerAttributeCount, UINT32* pVisualizerAttributeCount)
{
    return Proc5CB574B305F260A0A4DC51E163157D25(this, pName, AssemblyCookie, pCookie, pValueAttributeCount, pViewerAttributeCount, pVisualizerAttributeCount);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Internal::DkmEELocalObject::GetTargetAssembly(Microsoft::VisualStudio::Debugger::DkmString* pName, UINT32* pCookie)
{
    return Proc19D6B8616421D55B78D376D6CD3A5C5D(this, pName, pCookie);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Internal::DkmEELocalObject::GetAssembly(UINT32 AssemblyCookie, UINT32 Flags, UINT32* pFlagsOut, Microsoft::VisualStudio::Debugger::DkmString** ppName, Microsoft::VisualStudio::Debugger::DkmArray<BYTE>* pAssemblyBytes, Microsoft::VisualStudio::Debugger::DkmArray<BYTE>* pPdbBytes)
{
    return Proc71288BA136E46AD8363AFD5AA013391E(this, AssemblyCookie, Flags, pFlagsOut, ppName, pAssemblyBytes, pPdbBytes);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Internal::DkmEELocalObject::GetHostAssembly(UINT32 Flags, Microsoft::VisualStudio::Debugger::DkmArray<BYTE>* pAssemblyBytes, Microsoft::VisualStudio::Debugger::DkmArray<BYTE>* pPdbBytes)
{
    return ProcD089BFE2A48AC9E0A8F4B1DDDC4A9F71(this, Flags, pAssemblyBytes, pPdbBytes);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Internal::DkmEELocalObject::GetValueAttributeProps(UINT32 ClassCookie, UINT32 Ordinal, Microsoft::VisualStudio::Debugger::DkmString** ppTargetedAssembly, UINT32* pAssemblyLocation, Microsoft::VisualStudio::Debugger::DkmString** ppName, Microsoft::VisualStudio::Debugger::DkmString** ppValue, Microsoft::VisualStudio::Debugger::DkmString** ppType)
{
    return ProcB619FA0B30165B806D34B9DE6755888B(this, ClassCookie, Ordinal, ppTargetedAssembly, pAssemblyLocation, ppName, ppValue, ppType);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Internal::DkmEELocalObject::GetViewerAttributeProps(UINT32 ClassCookie, UINT32 Ordinal, Microsoft::VisualStudio::Debugger::DkmString** ppTargetedAssembly, UINT32* pAssemblyLocation, Microsoft::VisualStudio::Debugger::DkmString** ppClassName, UINT32* pClassAssemblyLocation)
{
    return ProcFD5E0390E2DDF834E43AC2E8528EFDE3(this, ClassCookie, Ordinal, ppTargetedAssembly, pAssemblyLocation, ppClassName, pClassAssemblyLocation);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Internal::DkmEELocalObject::GetVisualizerAttributeProps(UINT32 ClassCookie, UINT32 Ordinal, Microsoft::VisualStudio::Debugger::DkmString** ppTargetedAssembly, UINT32* pAssemblyLocation, Microsoft::VisualStudio::Debugger::DkmString** ppDisplayClassName, UINT32* pDisplayClassAssemblyLocation, Microsoft::VisualStudio::Debugger::DkmString** ppProxyClassName, UINT32* pProxyClassAssemblyLocation, Microsoft::VisualStudio::Debugger::DkmString** ppDescription, UINT32* pType)
{
    return Proc94B68F827E58FE88F3FA8771B9D09337(this, ClassCookie, Ordinal, ppTargetedAssembly, pAssemblyLocation, ppDisplayClassName, pDisplayClassAssemblyLocation, ppProxyClassName, pProxyClassAssemblyLocation, ppDescription, pType);
}
#endif // #ifndef EXCLUDE_MONITOR_ONLY_APIS

inline DECLSPEC_NOTHROW const GUID& STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmEngineSettings::EngineId()
{
    return this->m_EngineId;
}

inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmEngineFlags_t STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmEngineSettings::Flags()
{
    return this->m_Flags;
}

inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::Clr::DkmClrDebuggingServicesId_t STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmEngineSettings::ClrDebuggingServicesId()
{
    return this->m_ClrDebuggingServicesId;
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<Microsoft::VisualStudio::Debugger::Evaluation::DkmLanguage*>* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmEngineSettings::Languages()
{
    return this->m_pLanguages;
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<Microsoft::VisualStudio::Debugger::Symbols::DkmImageDebugDirectoryFormat>* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmEngineSettings::ImageDebugDirectoryFormats()
{
    return this->m_pImageDebugDirectoryFormats;
}

inline DECLSPEC_NOTHROW bool STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmEngineSettings::EnableFuncEvalQuickAbort()
{
    return this->m_EnableFuncEvalQuickAbort;
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<Microsoft::VisualStudio::Debugger::DkmString*>* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmEngineSettings::FuncEvalQuickAbortExcludeList()
{
    return this->m_pFuncEvalQuickAbortExcludeList;
}

inline DECLSPEC_NOTHROW bool STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmEngineSettings::EnableAsyncDebugging()
{
    return this->m_EnableAsyncDebugging;
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<Microsoft::VisualStudio::Debugger::DkmString*>* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmEngineSettings::RemoteClrPdbNamePatterns()
{
    return this->m_pRemoteClrPdbNamePatterns;
}

inline DECLSPEC_NOTHROW const GUID& STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmEngineSettings::BaseDebugMonitorId()
{
    return this->m_BaseDebugMonitorId;
}

inline DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmEngineSettings::MaxCallStackFrames()
{
    // This method was introduced after the initial version of the API. The caller is
    // responsible for taking steps to ensure that this method is not called when running
    // against earlier versions of vsdebugeng.dll.
    ATLASSERT(DkmComponentManager::IsApiVersionSupported(DkmApiVersion::VS12RTM) || !"Invalid usage detected. Process will crash or bogus data will be returned");
    return this->m__pExtendedData->MaxCallStackFrames;
}

inline DECLSPEC_NOTHROW bool STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmEngineSettings::IsEditAndContinue()
{
    // This method was introduced after the initial version of the API. The caller is
    // responsible for taking steps to ensure that this method is not called when running
    // against earlier versions of vsdebugeng.dll.
    ATLASSERT(DkmComponentManager::IsApiVersionSupported(DkmApiVersion::VS12RTM) || !"Invalid usage detected. Process will crash or bogus data will be returned");
    return this->m__pExtendedData->IsEditAndContinue;
}

inline DECLSPEC_NOTHROW bool STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmEngineSettings::ValidateFilesForMinidumps()
{
    // This method was introduced after the initial version of the API. The caller is
    // responsible for taking steps to ensure that this method is not called when running
    // against earlier versions of vsdebugeng.dll.
    ATLASSERT(DkmComponentManager::IsApiVersionSupported(DkmApiVersion::VS12RTM) || !"Invalid usage detected. Process will crash or bogus data will be returned");
    return this->m__pExtendedData->ValidateFilesForMinidumps;
}

_Ret_opt_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<Microsoft::VisualStudio::Debugger::DkmRegistryTweak*>* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmEngineSettings::RegistryTweaks()
{
    // This method was introduced after the initial version of the API. The caller is
    // responsible for taking steps to ensure that this method is not called when running
    // against earlier versions of vsdebugeng.dll.
    ATLASSERT(DkmComponentManager::IsApiVersionSupported(DkmApiVersion::VS12RTM) || !"Invalid usage detected. Process will crash or bogus data will be returned");
    return this->m__pExtendedData->pRegistryTweaks;
}

inline DECLSPEC_NOTHROW bool STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmEngineSettings::IsJustMyCodeEnabled()
{
    return this->m_IsJustMyCodeEnabled;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmEngineSettings::GetSymbolPaths(_Deref_out_ Microsoft::VisualStudio::Debugger::Symbols::DkmEngineSymbolSettings** ppValue)
{
    return Get250481482FAEDAA4BBEBC807B24DD715(this, ppValue);
}

inline DECLSPEC_NOTHROW bool STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmEngineSettings::IsSuppressOptimizationsEnabled()
{
    return this->m_IsSuppressOptimizationsEnabled;
}

inline DECLSPEC_NOTHROW bool STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmEngineSettings::IsStepOverPropertiesAndOperatorsEnabled()
{
    return this->m_IsStepOverPropertiesAndOperatorsEnabled;
}

inline DECLSPEC_NOTHROW bool STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmEngineSettings::IsNativeExportsEnabled()
{
    return this->m_IsNativeExportsEnabled;
}

inline DECLSPEC_NOTHROW bool STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmEngineSettings::IsGpuRaceHazardsAllowSameSettingEnabled()
{
    return this->m_IsGpuRaceHazardsAllowSameSettingEnabled;
}

inline DECLSPEC_NOTHROW bool STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmEngineSettings::RequireFullTrustForSourceServer()
{
    return this->m_RequireFullTrustForSourceServer;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmEngineSettings::GetTraceSettings(_Deref_out_opt_ Microsoft::VisualStudio::Debugger::DkmString** ppValue)
{
    return Get5A5033115F5D59291645BEAAE598F0BD(this, ppValue);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmEngineSettings::FindSettings(const GUID& EngineId, Microsoft::VisualStudio::Debugger::DkmEngineSettings** ppSettings)
{
    return ProcEAB82333D65B545623818EFFC257B255(EngineId, ppSettings);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmEngineSettings::GetSettings(Microsoft::VisualStudio::Debugger::DkmArray<Microsoft::VisualStudio::Debugger::DkmEngineSettings*>* pSettings)
{
    return ProcB58779AE70E61CE2C137F2DC7C7E39A2(pSettings);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmEngineSettings::FindProcess(const GUID& UniqueId, Microsoft::VisualStudio::Debugger::DkmProcess** ppProcess)
{
    return Proc66C5B8466345C8B890DE700EC642A0DF(this, UniqueId, ppProcess);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmEngineSettings::GetProcesses(Microsoft::VisualStudio::Debugger::DkmArray<Microsoft::VisualStudio::Debugger::DkmProcess*>* pProcesses)
{
    return ProcCFA56E1A30696A54C78DD3B62C48CB58(this, pProcesses);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmEngineSettings::GetLanguage(const Microsoft::VisualStudio::Debugger::Evaluation::DkmCompilerId& CompilerId, Microsoft::VisualStudio::Debugger::Evaluation::DkmLanguage** ppLanguage)
{
    return Proc55C239704FB9EE8A91BCDFF2A41E9307(this, CompilerId, ppLanguage);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmEngineSettings::GetCodeViewCompilers(Microsoft::VisualStudio::Debugger::DkmArray<Microsoft::VisualStudio::Debugger::Symbols::DkmCodeViewCompilerId>* pCodeViewCompilers)
{
    return Proc712AEE7B1CBFE90A27AABC87EDA764C0(this, pCodeViewCompilers);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmEngineSettings::GetUserDocumentPath(Microsoft::VisualStudio::Debugger::DkmString** ppUserDocumentPath)
{
    return Proc785B704BB677152C77F39C102DD245C6(this, ppUserDocumentPath);
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<Microsoft::VisualStudio::Debugger::DkmString*>* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Symbols::DkmEngineSymbolSettings::SymbolPaths()
{
    return this->m_pSymbolPaths;
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmString* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Symbols::DkmEngineSymbolSettings::SymbolCachePath()
{
    return this->m_pSymbolCachePath;
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<Microsoft::VisualStudio::Debugger::DkmString*>* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Symbols::DkmEngineSymbolSettings::IncludeList()
{
    return this->m_pIncludeList;
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<Microsoft::VisualStudio::Debugger::DkmString*>* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Symbols::DkmEngineSymbolSettings::ExcludeList()
{
    return this->m_pExcludeList;
}

inline DECLSPEC_NOTHROW bool STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Symbols::DkmEngineSymbolSettings::ManualLoading()
{
    return this->m_ManualLoading;
}

inline DECLSPEC_NOTHROW bool STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Symbols::DkmEngineSymbolSettings::LoadAdjacentSymbols()
{
    return this->m_LoadAdjacentSymbols;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Symbols::DkmEngineSymbolSettings::Create(Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<Microsoft::VisualStudio::Debugger::DkmString*>* pSymbolPaths, Microsoft::VisualStudio::Debugger::DkmString* pSymbolCachePath, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<Microsoft::VisualStudio::Debugger::DkmString*>* pIncludeList, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<Microsoft::VisualStudio::Debugger::DkmString*>* pExcludeList, bool ManualLoading, bool LoadAdjacentSymbols, Microsoft::VisualStudio::Debugger::Symbols::DkmEngineSymbolSettings** ppCreatedObject)
{
    return Proc22A1D0256F691113C635408F3AB12787(pSymbolPaths, pSymbolCachePath, pIncludeList, pExcludeList, ManualLoading, LoadAdjacentSymbols, ppCreatedObject);
}

#ifndef EXCLUDE_MONITOR_ONLY_APIS
_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::Breakpoints::DkmRuntimeBreakpoint* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Breakpoints::DkmEvaluationBreakpointCondition::RuntimeBreakpoint()
{
    return this->m_pRuntimeBreakpoint;
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::Breakpoints::DkmBreakpointCondition* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Breakpoints::DkmEvaluationBreakpointCondition::Source()
{
    return this->m_pSource;
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::Evaluation::DkmLanguage* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Breakpoints::DkmEvaluationBreakpointCondition::Language()
{
    return this->m_pLanguage;
}

inline DECLSPEC_NOTHROW const GUID& STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Breakpoints::DkmEvaluationBreakpointCondition::UniqueId()
{
    return this->m_UniqueId;
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmRuntimeInstance* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Breakpoints::DkmEvaluationBreakpointCondition::RuntimeInstance()
{
    return this->m_pRuntimeBreakpoint->RuntimeInstance();
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Breakpoints::DkmEvaluationBreakpointCondition::Close()
{
    return Proc7DFB0CC45F58E9F2422E3D6ADD30D56C(this);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Breakpoints::DkmEvaluationBreakpointCondition::Create(Microsoft::VisualStudio::Debugger::Breakpoints::DkmRuntimeBreakpoint* pRuntimeBreakpoint, Microsoft::VisualStudio::Debugger::Breakpoints::DkmBreakpointCondition* pSource, Microsoft::VisualStudio::Debugger::Evaluation::DkmLanguage* pLanguage, const Microsoft::VisualStudio::Debugger::DkmDataItem& DataItem, Microsoft::VisualStudio::Debugger::Breakpoints::DkmEvaluationBreakpointCondition** ppCreatedObject)
{
    return ProcDA01083FD1F7BC6E21CF70FEBE852E08(pRuntimeBreakpoint, pSource, pLanguage, DataItem, ppCreatedObject);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Breakpoints::DkmEvaluationBreakpointCondition::Parse(Microsoft::VisualStudio::Debugger::DkmString** ppErrorText)
{
    return ProcC551A87289B36A81E4E7DC67503FA13B(this, ppErrorText);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Breakpoints::DkmEvaluationBreakpointCondition::Evaluate(Microsoft::VisualStudio::Debugger::CallStack::DkmStackWalkFrame* pStackFrame, bool* pStop, Microsoft::VisualStudio::Debugger::DkmString** ppErrorText)
{
    return Proc22969485654512BB4766B642E35146B1(this, pStackFrame, pStop, ppErrorText);
}
#endif // #ifndef EXCLUDE_MONITOR_ONLY_APIS

inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::Evaluation::DkmEvaluationResult::Tag_t STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmEvaluationResult::TagValue()
{
    return this->m_TagValue;
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::Evaluation::DkmInspectionContext* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmEvaluationResult::InspectionContext()
{
    return this->m_pInspectionContext;
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::CallStack::DkmStackWalkFrame* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmEvaluationResult::StackFrame()
{
    return this->m_pStackFrame;
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmString* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmEvaluationResult::Name()
{
    return this->m_pName;
}

_Ret_opt_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmString* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmEvaluationResult::FullName()
{
    return this->m_pFullName;
}

inline DECLSPEC_NOTHROW const GUID& STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmEvaluationResult::UniqueId()
{
    return this->m_UniqueId;
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::Evaluation::DkmLanguage* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmEvaluationResult::Language()
{
    return this->m_pInspectionContext->Language();
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::Evaluation::DkmInspectionSession* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmEvaluationResult::InspectionSession()
{
    return this->m_pInspectionContext->InspectionSession();
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmRuntimeInstance* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmEvaluationResult::RuntimeInstance()
{
    return this->m_pInspectionContext->RuntimeInstance();
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmEvaluationResult::Close()
{
    return Proc18F3F98E2BDA11EE2E0551E6EB174A15(this);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmEvaluationResult::GetChildren(Microsoft::VisualStudio::Debugger::DkmWorkList* pWorkList, UINT32 InitialRequestSize, Microsoft::VisualStudio::Debugger::Evaluation::DkmInspectionContext* pInspectionContext, Microsoft::VisualStudio::Debugger::IDkmCompletionRoutine<Microsoft::VisualStudio::Debugger::Evaluation::DkmGetChildrenAsyncResult>* pCompletionRoutine)
{
    return Proc304D6F6048468BB211A98ECADD5190CC(this, pWorkList, InitialRequestSize, pInspectionContext, pCompletionRoutine);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmEvaluationResult::SetValueAsString(Microsoft::VisualStudio::Debugger::DkmString* pValue, UINT32 Timeout, Microsoft::VisualStudio::Debugger::DkmString** ppErrorText)
{
    return Proc0D96A87BB543F851A5DE00719E779D3C(this, pValue, Timeout, ppErrorText);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmEvaluationResult::GetUnderlyingString(Microsoft::VisualStudio::Debugger::DkmString** ppStringValue)
{
    return Proc4943C591B2842416B41CCEDF949F0CAA(this, ppStringValue);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmEvaluationResult::CreateObjectId()
{
    return Proc4F92F70F3E82F62D90F9A64274110E0E(this);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmEvaluationResult::DestroyObjectId()
{
    return ProcE7EB085795DD0AF19384C3FEDDC02346(this);
}

inline DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmEvaluationResultEnumContext::Count()
{
    return this->m_Count;
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::CallStack::DkmStackWalkFrame* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmEvaluationResultEnumContext::StackFrame()
{
    return this->m_pStackFrame;
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::Evaluation::DkmInspectionContext* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmEvaluationResultEnumContext::InspectionContext()
{
    return this->m_pInspectionContext;
}

inline DECLSPEC_NOTHROW const GUID& STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmEvaluationResultEnumContext::UniqueId()
{
    return this->m_UniqueId;
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::Evaluation::DkmLanguage* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmEvaluationResultEnumContext::Language()
{
    return this->m_pInspectionContext->Language();
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::Evaluation::DkmInspectionSession* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmEvaluationResultEnumContext::InspectionSession()
{
    return this->m_pInspectionContext->InspectionSession();
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmRuntimeInstance* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmEvaluationResultEnumContext::RuntimeInstance()
{
    return this->m_pInspectionContext->RuntimeInstance();
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmEvaluationResultEnumContext::Close()
{
    return Proc893685F10EC87472D047E00FE7DBEF94(this);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmEvaluationResultEnumContext::Create(UINT32 Count, Microsoft::VisualStudio::Debugger::CallStack::DkmStackWalkFrame* pStackFrame, Microsoft::VisualStudio::Debugger::Evaluation::DkmInspectionContext* pInspectionContext, const Microsoft::VisualStudio::Debugger::DkmDataItem& DataItem, Microsoft::VisualStudio::Debugger::Evaluation::DkmEvaluationResultEnumContext** ppCreatedObject)
{
    return ProcF0C60D4E64737DC5E907AC0500338F29(Count, pStackFrame, pInspectionContext, DataItem, ppCreatedObject);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmEvaluationResultEnumContext::GetItems(Microsoft::VisualStudio::Debugger::DkmWorkList* pWorkList, UINT32 StartIndex, UINT32 Count, Microsoft::VisualStudio::Debugger::IDkmCompletionRoutine<Microsoft::VisualStudio::Debugger::Evaluation::DkmEvaluationEnumAsyncResult>* pCompletionRoutine)
{
    return ProcD2CB7DED0F650EA239322E6F3A6CB5A2(this, pWorkList, StartIndex, Count, pCompletionRoutine);
}

inline DECLSPEC_NOTHROW const GUID& STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Exceptions::DkmExceptionCategoryTrigger::ExceptionCategory()
{
    return this->m_ExceptionCategory;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Exceptions::DkmExceptionCategoryTrigger::Create(Microsoft::VisualStudio::Debugger::Exceptions::DkmExceptionProcessingStage_t ProcessingStage, Microsoft::VisualStudio::Debugger::DkmThread* pThread, const GUID& ExceptionCategory, Microsoft::VisualStudio::Debugger::Exceptions::DkmExceptionCategoryTrigger** ppCreatedObject)
{
    return ProcA277FC9EA1AD7D48A50697B88E56D01A(ProcessingStage, pThread, ExceptionCategory, ppCreatedObject);
}

inline DECLSPEC_NOTHROW const GUID& STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Exceptions::DkmExceptionCodeTrigger::ExceptionCategory()
{
    return this->m_ExceptionCategory;
}

inline DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Exceptions::DkmExceptionCodeTrigger::Code()
{
    return this->m_Code;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Exceptions::DkmExceptionCodeTrigger::Create(Microsoft::VisualStudio::Debugger::Exceptions::DkmExceptionProcessingStage_t ProcessingStage, Microsoft::VisualStudio::Debugger::DkmThread* pThread, const GUID& ExceptionCategory, UINT32 Code, Microsoft::VisualStudio::Debugger::Exceptions::DkmExceptionCodeTrigger** ppCreatedObject)
{
    return ProcDC69BC0A967710B649D98D8171E6AB4E(ProcessingStage, pThread, ExceptionCategory, Code, ppCreatedObject);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Exceptions::DkmExceptionGlobalTrigger::Create(Microsoft::VisualStudio::Debugger::Exceptions::DkmExceptionProcessingStage_t ProcessingStage, Microsoft::VisualStudio::Debugger::DkmThread* pThread, Microsoft::VisualStudio::Debugger::Exceptions::DkmExceptionGlobalTrigger** ppCreatedObject)
{
    return ProcD3051BA529DC1A0C80DE71D6B8A5D237(ProcessingStage, pThread, ppCreatedObject);
}

inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::Exceptions::DkmExceptionInformation::Tag_t STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Exceptions::DkmExceptionInformation::TagValue()
{
    return this->m_TagValue;
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmRuntimeInstance* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Exceptions::DkmExceptionInformation::RuntimeInstance()
{
    return this->m_pRuntimeInstance;
}

inline DECLSPEC_NOTHROW const GUID& STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Exceptions::DkmExceptionInformation::ExceptionCategory()
{
    return this->m_ExceptionCategory;
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmThread* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Exceptions::DkmExceptionInformation::Thread()
{
    return this->m_pThread;
}

_Ret_opt_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmInstructionAddress* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Exceptions::DkmExceptionInformation::InstructionAddress()
{
    return this->m_pInstructionAddress;
}

_Ret_opt_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmString* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Exceptions::DkmExceptionInformation::Name()
{
    return this->m_pName;
}

inline DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Exceptions::DkmExceptionInformation::Code()
{
    return this->m_Code;
}

inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::Exceptions::DkmExceptionProcessingStage_t STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Exceptions::DkmExceptionInformation::ProcessingStage()
{
    return this->m_ProcessingStage;
}

_Ret_opt_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::Exceptions::DkmExceptionInformation* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Exceptions::DkmExceptionInformation::ImplementationException()
{
    return this->m_pImplementationException;
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmProcess* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Exceptions::DkmExceptionInformation::Process()
{
    return this->m_pThread->Process();
}

#ifndef EXCLUDE_MONITOR_ONLY_APIS
inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Exceptions::DkmExceptionInformation::OnDebugMonitorException()
{
    return Proc46F4EBD73CFB584D76BA34433F61DB86(this);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Exceptions::DkmExceptionInformation::OnContinued()
{
    return Proc2BDC566C9437414EFB44DCA2FB0655BF(this);
}
#endif // #ifndef EXCLUDE_MONITOR_ONLY_APIS

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Exceptions::DkmExceptionInformation::CanModifyProcessing(bool* pResult)
{
    return ProcC4606A8DA0BC602AF74AB3F9240E24F8(this, pResult);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Exceptions::DkmExceptionInformation::SquashProcessing()
{
    return Proc7CBBB15E9B8502248D458346A2C09640(this);
}

#ifndef EXCLUDE_MONITOR_ONLY_APIS
inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Exceptions::DkmExceptionInformation::GetDescription(Microsoft::VisualStudio::Debugger::DkmString** ppValue)
{
    return Proc6D04FF97A36E6FBE5A873E9E4D373191(this, ppValue);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Exceptions::DkmExceptionInformation::GetAdditionalInformation(Microsoft::VisualStudio::Debugger::DkmString** ppValue)
{
    return ProcA507F5EA1FFFB25DB6C264A1A3E9D9A0(this, ppValue);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Exceptions::DkmExceptionInformation::GetWinRTErrorInfo(Microsoft::VisualStudio::Debugger::DkmString** ppRestrictedDescription, Microsoft::VisualStudio::Debugger::DkmString** ppRestrictedErrorReference, Microsoft::VisualStudio::Debugger::DkmString** ppRestrictedCapabilitySid)
{
    return Proc32C54A299942A4DF0FC187766A44B6D8(this, ppRestrictedDescription, ppRestrictedErrorReference, ppRestrictedCapabilitySid);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Exceptions::DkmExceptionInformation::OnOutOfBandException()
{
    return Proc8DE481C3F9EEB3173D2DF9D68D38D3BE(this);
}
#endif // #ifndef EXCLUDE_MONITOR_ONLY_APIS

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Exceptions::DkmExceptionInformation::GetExceptionStackTrace(Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<Microsoft::VisualStudio::Debugger::DkmInstructionAddress*>** ppStackTrace)
{
    return Proc4102811B876B002C9EBF58B1231D3419(this, ppStackTrace);
}

inline DECLSPEC_NOTHROW const GUID& STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Exceptions::DkmExceptionNameTrigger::ExceptionCategory()
{
    return this->m_ExceptionCategory;
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmString* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Exceptions::DkmExceptionNameTrigger::Name()
{
    return this->m_pName;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Exceptions::DkmExceptionNameTrigger::Create(Microsoft::VisualStudio::Debugger::Exceptions::DkmExceptionProcessingStage_t ProcessingStage, Microsoft::VisualStudio::Debugger::DkmThread* pThread, const GUID& ExceptionCategory, Microsoft::VisualStudio::Debugger::DkmString* pName, Microsoft::VisualStudio::Debugger::Exceptions::DkmExceptionNameTrigger** ppCreatedObject)
{
    return Proc2997D2B4489466E485DF7E7BA9519AA0(ProcessingStage, pThread, ExceptionCategory, pName, ppCreatedObject);
}

inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::Exceptions::DkmExceptionTrigger::Tag_t STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Exceptions::DkmExceptionTrigger::TagValue()
{
    return this->m_TagValue;
}

inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::Exceptions::DkmExceptionProcessingStage_t STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Exceptions::DkmExceptionTrigger::ProcessingStage()
{
    return this->m_ProcessingStage;
}

_Ret_opt_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmThread* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Exceptions::DkmExceptionTrigger::Thread()
{
    return this->m_pThread;
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::Exceptions::DkmExceptionInformation* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Exceptions::DkmExceptionTriggerHit::Exception()
{
    return this->m_pException;
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmString* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Exceptions::DkmExceptionTriggerHit::Description()
{
    return this->m_pDescription;
}

_Ret_opt_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmString* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Exceptions::DkmExceptionTriggerHit::RestrictedErrorDescription()
{
    return this->m_pRestrictedErrorDescription;
}

_Ret_opt_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmString* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Exceptions::DkmExceptionTriggerHit::CapabilitySid()
{
    return this->m_pCapabilitySid;
}

_Ret_opt_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmString* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Exceptions::DkmExceptionTriggerHit::RestrictedReference()
{
    return this->m_pRestrictedReference;
}

_Ret_opt_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmString* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Exceptions::DkmExceptionTriggerHit::AdditionalInformation()
{
    return this->m_pAdditionalInformation;
}

inline DECLSPEC_NOTHROW const GUID& STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Exceptions::DkmExceptionTriggerHit::SourceId()
{
    return this->m_SourceId;
}

_Ret_opt_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<Microsoft::VisualStudio::Debugger::DkmInstructionAddress*>* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Exceptions::DkmExceptionTriggerHit::StackTrace()
{
    // This method was introduced after the initial version of the API. The caller is
    // responsible for taking steps to ensure that this method is not called when running
    // against earlier versions of vsdebugeng.dll.
    ATLASSERT(DkmComponentManager::IsApiVersionSupported(DkmApiVersion::VS12RTM) || !"Invalid usage detected. Process will crash or bogus data will be returned");
    return this->m__pExtendedData->pStackTrace;
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmProcess* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Exceptions::DkmExceptionTriggerHit::Process()
{
    return this->m_pException->Process();
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmThread* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Exceptions::DkmExceptionTriggerHit::Thread()
{
    return this->m_pException->Thread();
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmRuntimeInstance* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Exceptions::DkmExceptionTriggerHit::RuntimeInstance()
{
    return this->m_pException->RuntimeInstance();
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Exceptions::DkmExceptionTriggerHit::Create(Microsoft::VisualStudio::Debugger::Exceptions::DkmExceptionInformation* pException, Microsoft::VisualStudio::Debugger::DkmString* pDescription, Microsoft::VisualStudio::Debugger::DkmString* pRestrictedErrorDescription, Microsoft::VisualStudio::Debugger::DkmString* pCapabilitySid, Microsoft::VisualStudio::Debugger::DkmString* pRestrictedReference, Microsoft::VisualStudio::Debugger::DkmString* pAdditionalInformation, const GUID& SourceId, Microsoft::VisualStudio::Debugger::Exceptions::DkmExceptionTriggerHit** ppCreatedObject)
{
    return Proc82C475324C56B876A52EA3F7C064EFC7(pException, pDescription, pRestrictedErrorDescription, pCapabilitySid, pRestrictedReference, pAdditionalInformation, SourceId, ppCreatedObject);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Exceptions::DkmExceptionTriggerHit::Create(Microsoft::VisualStudio::Debugger::Exceptions::DkmExceptionInformation* pException, Microsoft::VisualStudio::Debugger::DkmString* pDescription, Microsoft::VisualStudio::Debugger::DkmString* pRestrictedErrorDescription, Microsoft::VisualStudio::Debugger::DkmString* pCapabilitySid, Microsoft::VisualStudio::Debugger::DkmString* pRestrictedReference, Microsoft::VisualStudio::Debugger::DkmString* pAdditionalInformation, const GUID& SourceId, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<Microsoft::VisualStudio::Debugger::DkmInstructionAddress*>* pStackTrace, Microsoft::VisualStudio::Debugger::Exceptions::DkmExceptionTriggerHit** ppCreatedObject)
{
    return Proc7C607E439F8FC343B781AA531EE6CBEB(pException, pDescription, pRestrictedErrorDescription, pCapabilitySid, pRestrictedReference, pAdditionalInformation, SourceId, pStackTrace, ppCreatedObject);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Exceptions::DkmExceptionTriggerHit::Send()
{
    return ProcB462A99D32FCE88A7D5A90C41736C64D(this);
}

inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::Evaluation::DkmExpressionValueHome::Tag_t STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmExpressionValueHome::TagValue()
{
    return this->m_TagValue;
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmString* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::Group::DkmFailedContextGroupEvaluationResult::ErrorMessage()
{
    return this->m_pErrorMessage;
}

inline DECLSPEC_NOTHROW bool STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::Group::DkmFailedContextGroupEvaluationResult::HasSideEffects()
{
    return this->m_HasSideEffects;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::Group::DkmFailedContextGroupEvaluationResult::Create(Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<UINT64>* pThreadIds, HRESULT EvaluationResults, Microsoft::VisualStudio::Debugger::DkmString* pName, Microsoft::VisualStudio::Debugger::DkmString* pFullName, Microsoft::VisualStudio::Debugger::DkmRuntimeInstance* pRuntimeInstance, Microsoft::VisualStudio::Debugger::DkmString* pErrorMessage, bool HasSideEffects, const Microsoft::VisualStudio::Debugger::DkmDataItem& DataItem, Microsoft::VisualStudio::Debugger::Evaluation::Group::DkmFailedContextGroupEvaluationResult** ppCreatedObject)
{
    return ProcF87D21978E9C526845E798A88842F450(pThreadIds, EvaluationResults, pName, pFullName, pRuntimeInstance, pErrorMessage, HasSideEffects, DataItem, ppCreatedObject);
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmString* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmFailedEvaluationResult::ErrorMessage()
{
    return this->m_pErrorMessage;
}

inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::Evaluation::DkmEvaluationResultFlags_t STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmFailedEvaluationResult::Flags()
{
    return this->m_Flags;
}

_Ret_opt_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmString* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmFailedEvaluationResult::Type()
{
    // This method was introduced after the initial version of the API. The caller is
    // responsible for taking steps to ensure that this method is not called when running
    // against earlier versions of vsdebugeng.dll.
    ATLASSERT(DkmComponentManager::IsApiVersionSupported(DkmApiVersion::VS12RTM) || !"Invalid usage detected. Process will crash or bogus data will be returned");
    return this->m__pExtendedData->pType;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmFailedEvaluationResult::Create(Microsoft::VisualStudio::Debugger::Evaluation::DkmInspectionContext* pInspectionContext, Microsoft::VisualStudio::Debugger::CallStack::DkmStackWalkFrame* pStackFrame, Microsoft::VisualStudio::Debugger::DkmString* pName, Microsoft::VisualStudio::Debugger::DkmString* pFullName, Microsoft::VisualStudio::Debugger::DkmString* pErrorMessage, Microsoft::VisualStudio::Debugger::Evaluation::DkmEvaluationResultFlags_t Flags, const Microsoft::VisualStudio::Debugger::DkmDataItem& DataItem, Microsoft::VisualStudio::Debugger::Evaluation::DkmFailedEvaluationResult** ppCreatedObject)
{
    return Proc25600235530C4F6D98FFF804F230681D(pInspectionContext, pStackFrame, pName, pFullName, pErrorMessage, Flags, DataItem, ppCreatedObject);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmFailedEvaluationResult::Create(Microsoft::VisualStudio::Debugger::Evaluation::DkmInspectionContext* pInspectionContext, Microsoft::VisualStudio::Debugger::CallStack::DkmStackWalkFrame* pStackFrame, Microsoft::VisualStudio::Debugger::DkmString* pName, Microsoft::VisualStudio::Debugger::DkmString* pFullName, Microsoft::VisualStudio::Debugger::DkmString* pErrorMessage, Microsoft::VisualStudio::Debugger::Evaluation::DkmEvaluationResultFlags_t Flags, Microsoft::VisualStudio::Debugger::DkmString* pType, const Microsoft::VisualStudio::Debugger::DkmDataItem& DataItem, Microsoft::VisualStudio::Debugger::Evaluation::DkmFailedEvaluationResult** ppCreatedObject)
{
    return ProcCB940B4E5BD2C7FE35C1403BA8667C6F(pInspectionContext, pStackFrame, pName, pFullName, pErrorMessage, Flags, pType, DataItem, ppCreatedObject);
}

inline DECLSPEC_NOTHROW UINT64 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmFakeValueHome::Address()
{
    return this->m_Address;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmFakeValueHome::Create(UINT64 Address, Microsoft::VisualStudio::Debugger::Evaluation::DkmFakeValueHome** ppCreatedObject)
{
    return ProcD1DED409EDEADF892DF44AC593A875CA(Address, ppCreatedObject);
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmString* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DefaultPort::DkmFileInfo::FileName()
{
    return this->m_pFileName;
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmString* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DefaultPort::DkmFileInfo::FilePath()
{
    return this->m_pFilePath;
}

inline DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DefaultPort::DkmFileInfo::Attributes()
{
    return this->m_Attributes;
}

inline DECLSPEC_NOTHROW UINT64 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DefaultPort::DkmFileInfo::CreationTime()
{
    return this->m_CreationTime;
}

inline DECLSPEC_NOTHROW UINT64 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DefaultPort::DkmFileInfo::LastAccessTime()
{
    return this->m_LastAccessTime;
}

inline DECLSPEC_NOTHROW UINT64 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DefaultPort::DkmFileInfo::LastWriteTime()
{
    return this->m_LastWriteTime;
}

inline DECLSPEC_NOTHROW UINT64 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DefaultPort::DkmFileInfo::FileSize()
{
    return this->m_FileSize;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DefaultPort::DkmFileInfo::Create(Microsoft::VisualStudio::Debugger::DkmString* pFileName, Microsoft::VisualStudio::Debugger::DkmString* pFilePath, UINT32 Attributes, UINT64 CreationTime, UINT64 LastAccessTime, UINT64 LastWriteTime, UINT64 FileSize, Microsoft::VisualStudio::Debugger::DefaultPort::DkmFileInfo** ppCreatedObject)
{
    return Proc128B9579786732D548FB332A0B330884(pFileName, pFilePath, Attributes, CreationTime, LastAccessTime, LastWriteTime, FileSize, ppCreatedObject);
}

inline DECLSPEC_NOTHROW const GUID& STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DefaultPort::DkmFileTransferStream::UniqueId()
{
    return this->m_UniqueId;
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DefaultPort::DkmTransportConnection* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DefaultPort::DkmFileTransferStream::Connection()
{
    return this->m_pConnection;
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmString* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DefaultPort::DkmFileTransferStream::RemoteFilePath()
{
    return this->m_pRemoteFilePath;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DefaultPort::DkmFileTransferStream::Close()
{
    return ProcE20B1EDA2CA598DA00992416EE3EBC95(this);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DefaultPort::DkmFileTransferStream::Create(Microsoft::VisualStudio::Debugger::DefaultPort::DkmTransportConnection* pConnection, Microsoft::VisualStudio::Debugger::DkmString* pRemoteFilePath, const Microsoft::VisualStudio::Debugger::DkmDataItem& DataItem, Microsoft::VisualStudio::Debugger::DefaultPort::DkmFileTransferStream** ppCreatedObject)
{
    return Proc512DAF21364C293BE3611EE0A2AB259B(pConnection, pRemoteFilePath, DataItem, ppCreatedObject);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DefaultPort::DkmFileTransferStream::WriteFirst(const Microsoft::VisualStudio::Debugger::DkmArray<BYTE>& Content, UINT64 TotalFileSize, UINT64 LastWriteTime, bool OverwriteExisting)
{
    return ProcBF5C3FB352B37CE289A04F7F698B6005(this, Content, TotalFileSize, LastWriteTime, OverwriteExisting);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DefaultPort::DkmFileTransferStream::WriteNext(const Microsoft::VisualStudio::Debugger::DkmArray<BYTE>& Content)
{
    return Proc394EABA320D7CFF611EB0D16BA910E50(this, Content);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DefaultPort::DkmFileTransferStream::ReadFirst(void* pContentBuffer, UINT32 BufferSize, UINT32* pBytesRead, UINT64* pLastWriteTime, UINT64* pTotalFileSize)
{
    return Proc8213AA4FF03A692BCCC88DDB65068B50(this, pContentBuffer, BufferSize, pBytesRead, pLastWriteTime, pTotalFileSize);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DefaultPort::DkmFileTransferStream::ReadNext(void* pContentBuffer, UINT32 BufferSize, UINT32* pBytesRead)
{
    return Proc9B59AAB03E31F3B304B956E0EAA505B4(this, pContentBuffer, BufferSize, pBytesRead);
}

inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::CallStack::DkmFrameRegisters::Tag_t STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::CallStack::DkmFrameRegisters::TagValue()
{
    return this->m_TagValue;
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<Microsoft::VisualStudio::Debugger::CallStack::DkmUnwoundRegister*>* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::CallStack::DkmFrameRegisters::UnwoundRegisters()
{
    return this->m_pUnwoundRegisters;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::CallStack::DkmFrameRegisters::GetInstructionPointer(UINT64* pValue)
{
    return Proc0B7E2AD76C535C1C35C3948F1F2C45DF(this, pValue);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::CallStack::DkmFrameRegisters::GetStackPointer(UINT64* pValue)
{
    return ProcC0AB0BE9B5D47BDCB64470DFC9FA2B70(this, pValue);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::CallStack::DkmFrameRegisters::GetRegisterValue(UINT32 Id, void* pBuffer, UINT32 Size, UINT32* pBytesRead)
{
    return Proc14365162F719EE309833526528F9F58D(this, Id, pBuffer, Size, pBytesRead);
}

inline DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::GPU::DkmGPUComputeKernel::DispatchId()
{
    return this->m_DispatchId;
}

inline DECLSPEC_NOTHROW UINT64 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::GPU::DkmGPUComputeKernel::GPUDevice()
{
    return this->m_GPUDevice;
}

inline DECLSPEC_NOTHROW UINT64 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::GPU::DkmGPUComputeKernel::GPUShader()
{
    return this->m_GPUShader;
}

inline DECLSPEC_NOTHROW UINT64 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::GPU::DkmGPUComputeKernel::GPUShaderDispatch()
{
    return this->m_GPUShaderDispatch;
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<UINT32>* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::GPU::DkmGPUComputeKernel::GroupDimensions()
{
    return this->m_pGroupDimensions;
}

inline DECLSPEC_NOTHROW UINT64 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::GPU::DkmGPUComputeKernel::NumberOfGroups()
{
    return this->m_NumberOfGroups;
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<UINT32>* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::GPU::DkmGPUComputeKernel::ThreadDimensions()
{
    return this->m_pThreadDimensions;
}

inline DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::GPU::DkmGPUComputeKernel::NumberOfThreads()
{
    return this->m_NumberOfThreads;
}

inline DECLSPEC_NOTHROW const GUID& STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::GPU::DkmGPUComputeKernel::UniqueId()
{
    return this->m_UniqueId;
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmProcess* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::GPU::DkmGPUComputeKernel::Process()
{
    return this->m_pProcess;
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DefaultPort::DkmTransportConnection* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::GPU::DkmGPUComputeKernel::Connection()
{
    return this->m_pProcess->Connection();
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::GPU::DkmGPUComputeKernel::Create(UINT32 DispatchId, UINT64 GPUDevice, UINT64 GPUShader, UINT64 GPUShaderDispatch, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<UINT32>* pGroupDimensions, UINT64 NumberOfGroups, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<UINT32>* pThreadDimensions, UINT32 NumberOfThreads, Microsoft::VisualStudio::Debugger::DkmProcess* pProcess, const Microsoft::VisualStudio::Debugger::DkmDataItem& DataItem, Microsoft::VisualStudio::Debugger::GPU::DkmGPUComputeKernel** ppCreatedObject)
{
    return Proc70432FE96C3AD9E0FF944F8DEDE6D609(DispatchId, GPUDevice, GPUShader, GPUShaderDispatch, pGroupDimensions, NumberOfGroups, pThreadDimensions, NumberOfThreads, pProcess, DataItem, ppCreatedObject);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::GPU::DkmGPUComputeKernel::Unload(UINT32 ExitCode)
{
    return ProcD8C5AEC94B361E4D97A914AAFF227264(this, ExitCode);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::GPU::DkmGPUComputeKernel::FindComputeThread(UINT64 GlobalThreadIndex, Microsoft::VisualStudio::Debugger::GPU::DkmGPUComputeThread** ppComputeThread)
{
    return Proc7555F39063D612CCEC13E6563676F002(this, GlobalThreadIndex, ppComputeThread);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::GPU::DkmGPUComputeKernel::GetComputeVectorWidth(UINT32* pWidth)
{
    return Proc6DE89FDFD6A2F6751D3C5B48FF2E1B99(this, pWidth);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::GPU::DkmGPUComputeKernel::GetActiveThreadGroups(Microsoft::VisualStudio::Debugger::DkmArray<UINT64>* pActiveThreadGroups, UINT32* pNumberOfGroups)
{
    return Proc08309D087A5DE326E3C34B180D4043BE(this, pActiveThreadGroups, pNumberOfGroups);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::GPU::DkmGPUComputeKernel::GetCurrentThreadDimensions(Microsoft::VisualStudio::Debugger::DkmArray<UINT32>* pThreadDimensions, UINT32* pNumberOfDimensions)
{
    return Proc26BA35089930A40C5436AE4DC5794A7A(this, pThreadDimensions, pNumberOfDimensions);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::GPU::DkmGPUComputeKernel::GetCurrentGroupDimensions(Microsoft::VisualStudio::Debugger::DkmArray<UINT32>* pGroupDimensions, UINT32* pNumberOfDimensions)
{
    return Proc3E4C247AE33A7932565EF80AD32F3135(this, pGroupDimensions, pNumberOfDimensions);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::GPU::DkmGPUComputeKernel::GetComputeKernelName(Microsoft::VisualStudio::Debugger::DkmString** ppComputeKernelName)
{
    return Proc00D7D596CD9722CDE7B7901FFBB9DBF2(this, ppComputeKernelName);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::GPU::DkmGPUComputeKernel::GetComputeKernelProperties(Microsoft::VisualStudio::Debugger::DkmArray<Microsoft::VisualStudio::Debugger::GPU::DkmComputeProperty>* pComputeProperties, UINT32* pNumberOfProperties)
{
    return Proc2E465FDD46A4B4DC92D709FF51472ADC(this, pComputeProperties, pNumberOfProperties);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::GPU::DkmGPUComputeKernel::Select(Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<UINT64>* pFrom, const Microsoft::VisualStudio::Debugger::GPU::DkmWhereClause& Where, Microsoft::VisualStudio::Debugger::DkmArray<Microsoft::VisualStudio::Debugger::GPU::DkmComputeThreadInfo>* pThreadInfoArray)
{
    return Proc9C1FD869706730AA7EFF44A78D267C92(this, pFrom, Where, pThreadInfoArray);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::GPU::DkmGPUComputeKernel::GroupBy(Microsoft::VisualStudio::Debugger::GPU::DkmQueryComputeThreadInfoFlags_t GroupByFlags, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<UINT64>* pFrom, const Microsoft::VisualStudio::Debugger::GPU::DkmWhereClause& Where, Microsoft::VisualStudio::Debugger::DkmArray<Microsoft::VisualStudio::Debugger::GPU::DkmComputeThreadInfo>* pThreadInfoArray)
{
    return ProcD4C3C1C4B0F5F1BAA4647C8F7EF693FD(this, GroupByFlags, pFrom, Where, pThreadInfoArray);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::GPU::DkmGPUComputeKernel::GetStoppedThreads(Microsoft::VisualStudio::Debugger::DkmArray<UINT64>* pThreadIdArray)
{
    return Proc9EB53CEDD4070927EF381FE18879D14F(this, pThreadIdArray);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::GPU::DkmGPUComputeKernel::GetThreadFromId(UINT64 ThreadId, Microsoft::VisualStudio::Debugger::GPU::DkmGPUComputeThread** ppThread)
{
    return ProcAA5382361712FF7C2DB61AF2F559F507(this, ThreadId, ppThread);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::GPU::DkmGPUComputeKernel::UpdateFlaggedState(const Microsoft::VisualStudio::Debugger::GPU::DkmWhereClause& Where, bool Flagged)
{
    return Proc91AD1E7974AB8724E982A8D9BDA27FAF(this, Where, Flagged);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::GPU::DkmGPUComputeKernel::UpdateFrozenState(const Microsoft::VisualStudio::Debugger::GPU::DkmWhereClause& Where, bool Frozen)
{
    return ProcA153D09816AF6B9868DED1F2AA6D1A13(this, Where, Frozen);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::GPU::DkmGPUComputeKernel::GetFlatComputeKernelDimensions(Microsoft::VisualStudio::Debugger::DkmArray<UINT32>* pFlatThreadDimensions, Microsoft::VisualStudio::Debugger::DkmArray<INT32>* pFlatIndexBase, UINT32* pNumberOfDimensions, Microsoft::VisualStudio::Debugger::GPU::DkmComputeKernelModel_t* pModel)
{
    return ProcC21FFEF8BC14B5A4DD66728B44AE9EC2(this, pFlatThreadDimensions, pFlatIndexBase, pNumberOfDimensions, pModel);
}

inline DECLSPEC_NOTHROW UINT64 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::GPU::DkmGPUComputeThread::GlobalThreadIndex()
{
    return this->m_GlobalThreadIndex;
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::GPU::DkmGPUComputeKernel* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::GPU::DkmGPUComputeThread::ComputeKernel()
{
    return this->m_pComputeKernel;
}

_Ret_opt_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmThread* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::GPU::DkmGPUComputeThread::NativeThread()
{
    // This method was introduced after the initial version of the API. The caller is
    // responsible for taking steps to ensure that this method is not called when running
    // against earlier versions of vsdebugeng.dll.
    ATLASSERT(DkmComponentManager::IsApiVersionSupported(DkmApiVersion::VS12RTM) || !"Invalid usage detected. Process will crash or bogus data will be returned");
    return this->m__pExtendedData->pNativeThread;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::GPU::DkmGPUComputeThread::Create(Microsoft::VisualStudio::Debugger::DkmProcess* pProcess, UINT64 NativeStartAddress, bool IsMainThread, UINT64 GlobalThreadIndex, Microsoft::VisualStudio::Debugger::GPU::DkmGPUComputeKernel* pComputeKernel, const Microsoft::VisualStudio::Debugger::DkmThread::System* pSystem, const Microsoft::VisualStudio::Debugger::DkmDataItem& DataItem, Microsoft::VisualStudio::Debugger::GPU::DkmGPUComputeThread** ppCreatedObject)
{
    return ProcE1CD74A61F4598BDC8CE45676C134C2C(pProcess, NativeStartAddress, IsMainThread, GlobalThreadIndex, pComputeKernel, pSystem, DataItem, ppCreatedObject);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::GPU::DkmGPUComputeThread::Create(Microsoft::VisualStudio::Debugger::DkmProcess* pProcess, UINT64 NativeStartAddress, bool IsMainThread, UINT64 GlobalThreadIndex, Microsoft::VisualStudio::Debugger::GPU::DkmGPUComputeKernel* pComputeKernel, Microsoft::VisualStudio::Debugger::DkmThread* pNativeThread, const Microsoft::VisualStudio::Debugger::DkmThread::System* pSystem, const Microsoft::VisualStudio::Debugger::DkmDataItem& DataItem, Microsoft::VisualStudio::Debugger::GPU::DkmGPUComputeThread** ppCreatedObject)
{
    return Proc5E4EC8BBF3CBA2610A47A3950747990A(pProcess, NativeStartAddress, IsMainThread, GlobalThreadIndex, pComputeKernel, pNativeThread, pSystem, DataItem, ppCreatedObject);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::GPU::DkmGPUComputeThread::GetThisThreadDimension(Microsoft::VisualStudio::Debugger::DkmArray<UINT32>* pThreadDimensions, UINT32* pNumberOfDimensions)
{
    return ProcDE293BC2897E94BBAB8BAC9654D13D93(this, pThreadDimensions, pNumberOfDimensions);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::GPU::DkmGPUComputeThread::GetThisGroupDimension(Microsoft::VisualStudio::Debugger::DkmArray<UINT32>* pGroupDimensions, UINT32* pNumberOfDimensions)
{
    return ProcFE2ED3D7FCB8CBBF9CB8C6E5DAF90BED(this, pGroupDimensions, pNumberOfDimensions);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::GPU::DkmGPUComputeThread::GetThreadId(Microsoft::VisualStudio::Debugger::DkmArray<UINT32>* pThreadDimensions, UINT32* pNumberOfDimensions)
{
    return Proc835E736595E58DBBC0780B8878972850(this, pThreadDimensions, pNumberOfDimensions);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::GPU::DkmGPUComputeThread::GetGroupId(Microsoft::VisualStudio::Debugger::DkmArray<UINT32>* pGroupDimensions, UINT32* pNumberOfDimensions)
{
    return Proc064A81821D7B41B5152C78C6D4D1B1F8(this, pGroupDimensions, pNumberOfDimensions);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::GPU::DkmGPUComputeThread::ReadMemory(UINT64 Address, UINT64 InstructionPointer, Microsoft::VisualStudio::Debugger::DkmReadMemoryFlags_t Flags, void* pBuffer, UINT32 Size, UINT32* pBytesRead)
{
    return Proc2FAC62524E17B80FA70A0CC17E6ACC59(this, Address, InstructionPointer, Flags, pBuffer, Size, pBytesRead);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::GPU::DkmGPUComputeThread::WriteMemory(UINT64 Address, UINT64 InstructionPointer, const Microsoft::VisualStudio::Debugger::DkmArray<BYTE>& Data)
{
    return ProcD076451B3D57BBE20AF66FD87DB7A3CA(this, Address, InstructionPointer, Data);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::GPU::DkmGPUComputeThread::UpdateBufferTag(UINT32 InputTag, UINT32* pForwardedTag)
{
    return Proc9DBDC9183214716614E7527CD4D03D0B(this, InputTag, pForwardedTag);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::GPU::DkmGPUComputeThread::ValidateAddress(UINT64 Address, bool* pIsValidGpuMemoryAddress)
{
    return Proc48C49A28A6651642540A84275D9B1CA0(this, Address, pIsValidGpuMemoryAddress);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::GPU::DkmGPUComputeThread::GetRegisterDescriptions(Microsoft::VisualStudio::Debugger::DkmArray<Microsoft::VisualStudio::Debugger::GPU::DkmGPURegisterDescription>* pRegisterDescriptions)
{
    return ProcFB143392ABCA694056F9F89070E283E4(this, pRegisterDescriptions);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::GPU::DkmGPUComputeThread::SetRegisterValue(const Microsoft::VisualStudio::Debugger::GPU::DkmGPURegisterDescription& RegisterDescription, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<BYTE>* pRegisterValue)
{
    return ProcB4B5B53005AB2ACB4A337CC2906C6988(this, RegisterDescription, pRegisterValue);
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::GPU::DkmGPUComputeThread* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::GPU::DkmGPUDataAddress::ComputeThread()
{
    return this->m_pComputeThread;
}

inline DECLSPEC_NOTHROW UINT64 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::GPU::DkmGPUDataAddress::InstructionPointer()
{
    return this->m_InstructionPointer;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::GPU::DkmGPUDataAddress::Create(Microsoft::VisualStudio::Debugger::DkmRuntimeInstance* pRuntimeInstance, UINT64 Value, Microsoft::VisualStudio::Debugger::DkmInstructionAddress* pInstructionAddress, Microsoft::VisualStudio::Debugger::GPU::DkmGPUComputeThread* pComputeThread, UINT64 InstructionPointer, Microsoft::VisualStudio::Debugger::GPU::DkmGPUDataAddress** ppCreatedObject)
{
    return Proc865C2DC79B308E28B79594200F171F1B(pRuntimeInstance, Value, pInstructionAddress, pComputeThread, InstructionPointer, ppCreatedObject);
}

inline DECLSPEC_NOTHROW UINT64 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::GPU::DkmGPUMemoryAccessExceptionInformation::ConflictingInstructionAddress()
{
    return this->m_ConflictingInstructionAddress;
}

inline DECLSPEC_NOTHROW UINT64 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::GPU::DkmGPUMemoryAccessExceptionInformation::ConflictingThreadGlobalIndex()
{
    return this->m_ConflictingThreadGlobalIndex;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::GPU::DkmGPUMemoryAccessExceptionInformation::Create(Microsoft::VisualStudio::Debugger::DkmRuntimeInstance* pRuntimeInstance, Microsoft::VisualStudio::Debugger::DkmThread* pThread, Microsoft::VisualStudio::Debugger::DkmInstructionAddress* pInstructionAddress, Microsoft::VisualStudio::Debugger::DkmString* pName, UINT32 Code, Microsoft::VisualStudio::Debugger::Exceptions::DkmExceptionProcessingStage_t ProcessingStage, UINT64 ConflictingInstructionAddress, UINT64 ConflictingThreadGlobalIndex, Microsoft::VisualStudio::Debugger::GPU::DkmGPUMemoryAccessExceptionInformation** ppCreatedObject)
{
    return Proc55A345846D53FC406B1E062190CCBFF1(pRuntimeInstance, pThread, pInstructionAddress, pName, Code, ProcessingStage, ConflictingInstructionAddress, ConflictingThreadGlobalIndex, ppCreatedObject);
}

inline DECLSPEC_NOTHROW void STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::GPU::DkmGPURegisterDescription::Release(Microsoft::VisualStudio::Debugger::GPU::DkmGPURegisterDescription* pItem)
{
    return Proc5685DA4F5C12B2EFEE7911100FE853C7(pItem);
}

inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmPrimitiveObjectType_t STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILAdd::Type()
{
    return this->m_Type;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILAdd::Create(Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmPrimitiveObjectType_t Type, Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILAdd** ppCreatedObject)
{
    return Proc59332EB271778BB3304504B24A36496A(Type, ppCreatedObject);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILAmpAdjustBufferTag::Create(Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILAmpAdjustBufferTag** ppCreatedObject)
{
    return Proc7AC349E33ACBF2C7B296609A50B19D40(ppCreatedObject);
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILCatchBlock*>* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILBeginTry::CatchBlocks()
{
    return this->m_pCatchBlocks;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILBeginTry::Create(Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILCatchBlock*>* pCatchBlocks, Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILBeginTry** ppCreatedObject)
{
    return ProcF71648263D0EBB6AB423F469F8345896(pCatchBlocks, ppCreatedObject);
}

inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmPrimitiveObjectType_t STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILBitAnd::Type()
{
    return this->m_Type;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILBitAnd::Create(Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmPrimitiveObjectType_t Type, Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILBitAnd** ppCreatedObject)
{
    return Proc274F93BAEC7EDA11FB3D8D31398F3E66(Type, ppCreatedObject);
}

inline DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILBitFieldRead::BitPosition()
{
    return this->m_BitPosition;
}

inline DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILBitFieldRead::NumBits()
{
    return this->m_NumBits;
}

inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmPrimitiveObjectType_t STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILBitFieldRead::Type()
{
    return this->m_Type;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILBitFieldRead::Create(UINT32 BitPosition, UINT32 NumBits, Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmPrimitiveObjectType_t Type, Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILBitFieldRead** ppCreatedObject)
{
    return ProcE164CFE08792BADA3AFC457FC373E7CD(BitPosition, NumBits, Type, ppCreatedObject);
}

inline DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILBitFieldReadFromBytes::ByteOffset()
{
    return this->m_ByteOffset;
}

inline DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILBitFieldReadFromBytes::BitPosition()
{
    return this->m_BitPosition;
}

inline DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILBitFieldReadFromBytes::NumBits()
{
    return this->m_NumBits;
}

inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmPrimitiveObjectType_t STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILBitFieldReadFromBytes::Type()
{
    return this->m_Type;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILBitFieldReadFromBytes::Create(UINT32 ByteOffset, UINT32 BitPosition, UINT32 NumBits, Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmPrimitiveObjectType_t Type, Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILBitFieldReadFromBytes** ppCreatedObject)
{
    return Proc3CC641081A4F8E38DBA8B9D7F910E648(ByteOffset, BitPosition, NumBits, Type, ppCreatedObject);
}

inline DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILBitFieldWrite::BitPosition()
{
    return this->m_BitPosition;
}

inline DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILBitFieldWrite::NumBits()
{
    return this->m_NumBits;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILBitFieldWrite::Create(UINT32 BitPosition, UINT32 NumBits, Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILBitFieldWrite** ppCreatedObject)
{
    return ProcC88C854EE79528CEF5806D3E9A5AAD3E(BitPosition, NumBits, ppCreatedObject);
}

inline DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILBitFieldWriteToBytes::ByteOffset()
{
    return this->m_ByteOffset;
}

inline DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILBitFieldWriteToBytes::BitPosition()
{
    return this->m_BitPosition;
}

inline DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILBitFieldWriteToBytes::NumBits()
{
    return this->m_NumBits;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILBitFieldWriteToBytes::Create(UINT32 ByteOffset, UINT32 BitPosition, UINT32 NumBits, Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILBitFieldWriteToBytes** ppCreatedObject)
{
    return ProcC065B509F9ABC0BAC4BBD770D73E7FEB(ByteOffset, BitPosition, NumBits, ppCreatedObject);
}

inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmPrimitiveObjectType_t STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILBitNot::Type()
{
    return this->m_Type;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILBitNot::Create(Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmPrimitiveObjectType_t Type, Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILBitNot** ppCreatedObject)
{
    return ProcFD8A3508ABF025DFCBF615679CA43098(Type, ppCreatedObject);
}

inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmPrimitiveObjectType_t STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILBitOr::Type()
{
    return this->m_Type;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILBitOr::Create(Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmPrimitiveObjectType_t Type, Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILBitOr** ppCreatedObject)
{
    return Proc67294CD5516F29DD623A0335B01E2B2D(Type, ppCreatedObject);
}

inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmPrimitiveObjectType_t STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILBitShiftLeft::Type()
{
    return this->m_Type;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILBitShiftLeft::Create(Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmPrimitiveObjectType_t Type, Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILBitShiftLeft** ppCreatedObject)
{
    return ProcF28A7C520914A2C602F64AC12940AEDD(Type, ppCreatedObject);
}

inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmPrimitiveObjectType_t STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILBitShiftRight::Type()
{
    return this->m_Type;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILBitShiftRight::Create(Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmPrimitiveObjectType_t Type, Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILBitShiftRight** ppCreatedObject)
{
    return ProcB1F5C35BB7205E5859519C63CAB11717(Type, ppCreatedObject);
}

inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmPrimitiveObjectType_t STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILBitXor::Type()
{
    return this->m_Type;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILBitXor::Create(Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmPrimitiveObjectType_t Type, Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILBitXor** ppCreatedObject)
{
    return ProcF7DC8A9B604DB7991F313B300879DB14(Type, ppCreatedObject);
}

inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILFailureReason_t STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILCatchBlock::ErrorCode()
{
    return this->m_ErrorCode;
}

inline DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILCatchBlock::Target()
{
    return this->m_Target;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILCatchBlock::Create(Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILFailureReason_t ErrorCode, UINT32 Target, Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILCatchBlock** ppCreatedObject)
{
    return Proc513A853ACBA57C6224E96AFED178B6FC(ErrorCode, Target, ppCreatedObject);
}

inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmPrimitiveObjectType_t STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILCompareEqual::Type()
{
    return this->m_Type;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILCompareEqual::Create(Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmPrimitiveObjectType_t Type, Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILCompareEqual** ppCreatedObject)
{
    return Proc7F719CBB10CD5D871FFE04E029F3DB2E(Type, ppCreatedObject);
}

inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmPrimitiveObjectType_t STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILCompareGreaterThan::Type()
{
    return this->m_Type;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILCompareGreaterThan::Create(Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmPrimitiveObjectType_t Type, Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILCompareGreaterThan** ppCreatedObject)
{
    return ProcF61679F72873B9BAE44FF902F92DDDCC(Type, ppCreatedObject);
}

inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmPrimitiveObjectType_t STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILCompareGreaterThanOrEqual::Type()
{
    return this->m_Type;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILCompareGreaterThanOrEqual::Create(Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmPrimitiveObjectType_t Type, Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILCompareGreaterThanOrEqual** ppCreatedObject)
{
    return Proc42D2B23BCA47F96E95181509DEC12952(Type, ppCreatedObject);
}

inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmPrimitiveObjectType_t STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILCompareLessThan::Type()
{
    return this->m_Type;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILCompareLessThan::Create(Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmPrimitiveObjectType_t Type, Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILCompareLessThan** ppCreatedObject)
{
    return Proc651C8C57EB784CC5D51DA3D9F911EC27(Type, ppCreatedObject);
}

inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmPrimitiveObjectType_t STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILCompareLessThanOrEqual::Type()
{
    return this->m_Type;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILCompareLessThanOrEqual::Create(Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmPrimitiveObjectType_t Type, Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILCompareLessThanOrEqual** ppCreatedObject)
{
    return Proc5F637D126578416C0D844318F488E927(Type, ppCreatedObject);
}

inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmPrimitiveObjectType_t STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILCompareNotEqual::Type()
{
    return this->m_Type;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILCompareNotEqual::Create(Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmPrimitiveObjectType_t Type, Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILCompareNotEqual** ppCreatedObject)
{
    return Proc4C34599EEC6D0C6D02539A6CE0D3F759(Type, ppCreatedObject);
}

_Ret_opt_ inline DECLSPEC_NOTHROW const Microsoft::VisualStudio::Debugger::Evaluation::DkmILContext::ThreadOverride* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmILContext::ThreadOverridePart()
{
    return this->m_pThreadOverride;
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::CallStack::DkmStackWalkFrame* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmILContext::StackFrame()
{
    return this->m_pStackFrame;
}

_Ret_opt_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::Evaluation::DkmCustomDataContainer* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmILContext::DataContainer()
{
    // This method was introduced after the initial version of the API. The caller is
    // responsible for taking steps to ensure that this method is not called when running
    // against earlier versions of vsdebugeng.dll.
    ATLASSERT(DkmComponentManager::IsApiVersionSupported(DkmApiVersion::VS14RTM) || !"Invalid usage detected. Process will crash or bogus data will be returned");
    return this->m__pExtendedData->pDataContainer;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmILContext::Create(Microsoft::VisualStudio::Debugger::CallStack::DkmStackWalkFrame* pStackFrame, const Microsoft::VisualStudio::Debugger::Evaluation::DkmILContext::ThreadOverride* pThreadOverride, Microsoft::VisualStudio::Debugger::Evaluation::DkmILContext** ppCreatedObject)
{
    return ProcA18DDACFF36E48D6F0D56719700A0A68(pStackFrame, pThreadOverride, ppCreatedObject);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmILContext::Create(Microsoft::VisualStudio::Debugger::CallStack::DkmStackWalkFrame* pStackFrame, Microsoft::VisualStudio::Debugger::Evaluation::DkmCustomDataContainer* pDataContainer, const Microsoft::VisualStudio::Debugger::Evaluation::DkmILContext::ThreadOverride* pThreadOverride, Microsoft::VisualStudio::Debugger::Evaluation::DkmILContext** ppCreatedObject)
{
    return Proc73B7F93E9843CE3F03DCE965DE48D1BD(pStackFrame, pDataContainer, pThreadOverride, ppCreatedObject);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmILContext::Close()
{
    return ProcD90E2CBB49C005FC3439C6A37E4DD05E(this);
}

inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmPrimitiveObjectType_t STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILConvert::OriginalType()
{
    return this->m_OriginalType;
}

inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmPrimitiveObjectType_t STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILConvert::TargetType()
{
    return this->m_TargetType;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILConvert::Create(Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmPrimitiveObjectType_t OriginalType, Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmPrimitiveObjectType_t TargetType, Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILConvert** ppCreatedObject)
{
    return Proc9F997DC1F7AF29677A4047813E08FDCB(OriginalType, TargetType, ppCreatedObject);
}

inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmPrimitiveObjectType_t STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILDivide::Type()
{
    return this->m_Type;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILDivide::Create(Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmPrimitiveObjectType_t Type, Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILDivide** ppCreatedObject)
{
    return ProcF41F3F1AB2ABAEF7FFBC76C3B591E7F9(Type, ppCreatedObject);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILDuplicateTop::Create(Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILDuplicateTop** ppCreatedObject)
{
    return ProcC1CC800269002F7E3A1DA22DF715FE41(ppCreatedObject);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILEndTry::Create(Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILEndTry** ppCreatedObject)
{
    return Proc5C9051E01C0BD1E2540034FD47353BE5(ppCreatedObject);
}

inline DECLSPEC_NOTHROW const GUID& STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILEvaluationResult::SourceId()
{
    return this->m_SourceId;
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<BYTE>* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILEvaluationResult::ResultBytes()
{
    return this->m_pResultBytes;
}

inline DECLSPEC_NOTHROW bool STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILEvaluationResult::IsPseudoAddress()
{
    // This method was introduced after the initial version of the API. The caller is
    // responsible for taking steps to ensure that this method is not called when running
    // against earlier versions of vsdebugeng.dll.
    ATLASSERT(DkmComponentManager::IsApiVersionSupported(DkmApiVersion::VS14RTM) || !"Invalid usage detected. Process will crash or bogus data will be returned");
    return this->m__pExtendedData->IsPseudoAddress;
}

_Ret_opt_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<BYTE>* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILEvaluationResult::DereferencedBytes()
{
    // This method was introduced after the initial version of the API. The caller is
    // responsible for taking steps to ensure that this method is not called when running
    // against earlier versions of vsdebugeng.dll.
    ATLASSERT(DkmComponentManager::IsApiVersionSupported(DkmApiVersion::VS14RTM) || !"Invalid usage detected. Process will crash or bogus data will be returned");
    return this->m__pExtendedData->pDereferencedBytes;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILEvaluationResult::Create(const GUID& SourceId, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<BYTE>* pResultBytes, Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILEvaluationResult** ppCreatedObject)
{
    return ProcA2F8C324E55FE9F51080FF9117FD8A9C(SourceId, pResultBytes, ppCreatedObject);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILEvaluationResult::Create(const GUID& SourceId, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<BYTE>* pResultBytes, bool IsPseudoAddress, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<BYTE>* pDereferencedBytes, Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILEvaluationResult** ppCreatedObject)
{
    return ProcBDD5283BDC1037CAEB03E474486393D9(SourceId, pResultBytes, IsPseudoAddress, pDereferencedBytes, ppCreatedObject);
}

inline DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILExecuteFunction::ArgumentCount()
{
    return this->m_ArgumentCount;
}

inline DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILExecuteFunction::ReturnValueSize()
{
    return this->m_ReturnValueSize;
}

inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILCallingConvention_t STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILExecuteFunction::CallingConvention()
{
    return this->m_CallingConvention;
}

inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILFunctionEvaluationFlags_t STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILExecuteFunction::Flags()
{
    return this->m_Flags;
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILFunctionEvaluationArgumentFlags_t>* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILExecuteFunction::ArgumentFlags()
{
    return this->m_pArgumentFlags;
}

inline DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILExecuteFunction::UniformComplexReturnElementSize()
{
    return this->m_UniformComplexReturnElementSize;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILExecuteFunction::Create(UINT32 ArgumentCount, UINT32 ReturnValueSize, Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILCallingConvention_t CallingConvention, Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILFunctionEvaluationFlags_t Flags, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILFunctionEvaluationArgumentFlags_t>* pArgumentFlags, UINT32 UniformComplexReturnElementSize, Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILExecuteFunction** ppCreatedObject)
{
    return Proc6E64A892D574E60D055678E92E919AB5(ArgumentCount, ReturnValueSize, CallingConvention, Flags, pArgumentFlags, UniformComplexReturnElementSize, ppCreatedObject);
}

inline DECLSPEC_NOTHROW const GUID& STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILExecuteIntrinsic::SourceId()
{
    return this->m_SourceId;
}

inline DECLSPEC_NOTHROW const GUID& STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILExecuteIntrinsic::LanguageId()
{
    return this->m_LanguageId;
}

inline DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILExecuteIntrinsic::Id()
{
    return this->m_Id;
}

inline DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILExecuteIntrinsic::ArgumentCount()
{
    return this->m_ArgumentCount;
}

_Ret_opt_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<Microsoft::VisualStudio::Debugger::Evaluation::DkmCompiledInspectionQuery*>* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILExecuteIntrinsic::Subroutines()
{
    return this->m_pSubroutines;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILExecuteIntrinsic::Create(const GUID& SourceId, const GUID& LanguageId, UINT32 Id, UINT32 ArgumentCount, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<Microsoft::VisualStudio::Debugger::Evaluation::DkmCompiledInspectionQuery*>* pSubroutines, Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILExecuteIntrinsic** ppCreatedObject)
{
    return ProcBBA18CD27180C60E9E997C0A6FE75438(SourceId, LanguageId, Id, ArgumentCount, pSubroutines, ppCreatedObject);
}

#ifndef EXCLUDE_MONITOR_ONLY_APIS
inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILExecuteIntrinsic::Execute(Microsoft::VisualStudio::Debugger::Evaluation::DkmILContext* pILContext, const Microsoft::VisualStudio::Debugger::DkmArray<Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILEvaluationResult*>& Arguments, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<Microsoft::VisualStudio::Debugger::Evaluation::DkmCompiledInspectionQuery*>* pSubroutines, Microsoft::VisualStudio::Debugger::DkmArray<Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILEvaluationResult*>* pResults, Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILFailureReason_t* pFailureReason)
{
    return Proc97F5838B80CF47DFBB5C7A66C074A06E(this, pILContext, Arguments, pSubroutines, pResults, pFailureReason);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILExecuteIntrinsic::Execute(Microsoft::VisualStudio::Debugger::Evaluation::DkmILContext* pILContext, Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmCompiledILInspectionQuery* pInspectionQuery, const Microsoft::VisualStudio::Debugger::DkmArray<Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILEvaluationResult*>& Arguments, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<Microsoft::VisualStudio::Debugger::Evaluation::DkmCompiledInspectionQuery*>* pSubroutines, Microsoft::VisualStudio::Debugger::DkmArray<Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILEvaluationResult*>* pResults, Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILFailureReason_t* pFailureReason)
{
    return Proc8C672BDBCF020F7AE79341774958AEB9(this, pILContext, pInspectionQuery, Arguments, pSubroutines, pResults, pFailureReason);
}
#endif // #ifndef EXCLUDE_MONITOR_ONLY_APIS

inline DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILExtractBytes::Offset()
{
    return this->m_Offset;
}

inline DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILExtractBytes::Length()
{
    return this->m_Length;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILExtractBytes::Create(UINT32 Offset, UINT32 Length, Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILExtractBytes** ppCreatedObject)
{
    return ProcB3E3D0B3952EE50F42598DF26DF31016(Offset, Length, ppCreatedObject);
}

inline DECLSPEC_NOTHROW CV_HREG_e STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILHlslBufferRead::RegisterId()
{
    return this->m_RegisterId;
}

inline DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILHlslBufferRead::RegisterIndex()
{
    return this->m_RegisterIndex;
}

inline DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILHlslBufferRead::BytesToRead()
{
    return this->m_BytesToRead;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILHlslBufferRead::Create(CV_HREG_e RegisterId, UINT32 RegisterIndex, UINT32 BytesToRead, Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILHlslBufferRead** ppCreatedObject)
{
    return ProcEF0A249A2437F16F1944B917B7FD8CB2(RegisterId, RegisterIndex, BytesToRead, ppCreatedObject);
}

inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::GPU::DkmHlslThreadIdComponents_t STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILHlslGetGroupId::GroupIdComponents()
{
    return this->m_GroupIdComponents;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILHlslGetGroupId::Create(Microsoft::VisualStudio::Debugger::GPU::DkmHlslThreadIdComponents_t GroupIdComponents, Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILHlslGetGroupId** ppCreatedObject)
{
    return Proc85D3C05E777E3DDC1C1378AC47BC997D(GroupIdComponents, ppCreatedObject);
}

inline DECLSPEC_NOTHROW bool STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILHlslGetThreadId::UseDispatchId()
{
    return this->m_UseDispatchId;
}

inline DECLSPEC_NOTHROW bool STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILHlslGetThreadId::UseFlatModel()
{
    return this->m_UseFlatModel;
}

inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::GPU::DkmHlslThreadIdComponents_t STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILHlslGetThreadId::ThreadIdComponents()
{
    return this->m_ThreadIdComponents;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILHlslGetThreadId::Create(bool UseDispatchId, bool UseFlatModel, Microsoft::VisualStudio::Debugger::GPU::DkmHlslThreadIdComponents_t ThreadIdComponents, Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILHlslGetThreadId** ppCreatedObject)
{
    return ProcFD5E9535C1990A0F26896BACBB2E116E(UseDispatchId, UseFlatModel, ThreadIdComponents, ppCreatedObject);
}

inline DECLSPEC_NOTHROW CV_HREG_e STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILHlslIndexedRegisterRead::RegisterId()
{
    return this->m_RegisterId;
}

inline DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILHlslIndexedRegisterRead::RegisterIndex()
{
    return this->m_RegisterIndex;
}

inline DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILHlslIndexedRegisterRead::ByteOffset()
{
    return this->m_ByteOffset;
}

inline DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILHlslIndexedRegisterRead::BytesToRead()
{
    return this->m_BytesToRead;
}

inline DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILHlslIndexedRegisterRead::VectorElements()
{
    return this->m_VectorElements;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILHlslIndexedRegisterRead::Create(CV_HREG_e RegisterId, UINT32 RegisterIndex, UINT32 ByteOffset, UINT32 BytesToRead, UINT32 VectorElements, Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILHlslIndexedRegisterRead** ppCreatedObject)
{
    return Proc9D1082BBE4C79FA90A9A6DB49A461250(RegisterId, RegisterIndex, ByteOffset, BytesToRead, VectorElements, ppCreatedObject);
}

inline DECLSPEC_NOTHROW CV_HREG_e STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILHlslRegisterRead::RegisterId()
{
    return this->m_RegisterId;
}

inline DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILHlslRegisterRead::RegisterIndex()
{
    return this->m_RegisterIndex;
}

inline DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILHlslRegisterRead::ByteOffset()
{
    return this->m_ByteOffset;
}

inline DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILHlslRegisterRead::BytesToRead()
{
    return this->m_BytesToRead;
}

inline DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILHlslRegisterRead::FirstElement()
{
    return this->m_FirstElement;
}

inline DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILHlslRegisterRead::VectorElements()
{
    return this->m_VectorElements;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILHlslRegisterRead::Create(CV_HREG_e RegisterId, UINT32 RegisterIndex, UINT32 ByteOffset, UINT32 BytesToRead, UINT32 FirstElement, UINT32 VectorElements, Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILHlslRegisterRead** ppCreatedObject)
{
    return Proc0E7C3B425A75C063D8423649080FECF2(RegisterId, RegisterIndex, ByteOffset, BytesToRead, FirstElement, VectorElements, ppCreatedObject);
}

inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILInstruction::Tag_t STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILInstruction::TagValue()
{
    return this->m_TagValue;
}

inline DECLSPEC_NOTHROW const GUID& STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILInstruction::UniqueId()
{
    return this->m_UniqueId;
}

inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmPrimitiveObjectType_t STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILIsFalse::Type()
{
    return this->m_Type;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILIsFalse::Create(Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmPrimitiveObjectType_t Type, Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILIsFalse** ppCreatedObject)
{
    return Proc54CE95E6EDCFE52433F058A2FCD32205(Type, ppCreatedObject);
}

inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmPrimitiveObjectType_t STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILIsTrue::Type()
{
    return this->m_Type;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILIsTrue::Create(Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmPrimitiveObjectType_t Type, Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILIsTrue** ppCreatedObject)
{
    return ProcE724C2C7F8598586BC2AE84E232C2A4B(Type, ppCreatedObject);
}

inline DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILJump::Target()
{
    return this->m_Target;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILJump::Create(UINT32 Target, Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILJump** ppCreatedObject)
{
    return ProcFFB2CBC90C25CF40C1EC0ADEF943DD21(Target, ppCreatedObject);
}

inline DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILJumpIfFalse::Target()
{
    return this->m_Target;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILJumpIfFalse::Create(UINT32 Target, Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILJumpIfFalse** ppCreatedObject)
{
    return Proc2A6EFECEEC08A414F708C9237A23820A(Target, ppCreatedObject);
}

inline DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILJumpIfTrue::Target()
{
    return this->m_Target;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILJumpIfTrue::Create(UINT32 Target, Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILJumpIfTrue** ppCreatedObject)
{
    return ProcFA7E1E2E0DFF33CDC7B49FE9A2BF2A22(Target, ppCreatedObject);
}

inline DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILLoad::Index()
{
    return this->m_Index;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILLoad::Create(UINT32 Index, Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILLoad** ppCreatedObject)
{
    return ProcBB0D564A3653A0A30F1FC72C203C9C15(Index, ppCreatedObject);
}

inline DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILMemoryRead::Size()
{
    return this->m_Size;
}

inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmReadMemoryFlags_t STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILMemoryRead::Flags()
{
    return this->m_Flags;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILMemoryRead::Create(UINT32 Size, Microsoft::VisualStudio::Debugger::DkmReadMemoryFlags_t Flags, Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILMemoryRead** ppCreatedObject)
{
    return Proc52F772C3D63AAE4A52633DD19BFDC964(Size, Flags, ppCreatedObject);
}

inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmReadMemoryFlags_t STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILMemoryStringRead::Flags()
{
    return this->m_Flags;
}

inline DECLSPEC_NOTHROW UINT16 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILMemoryStringRead::CharacterSize()
{
    return this->m_CharacterSize;
}

inline DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILMemoryStringRead::MaxCharacters()
{
    return this->m_MaxCharacters;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILMemoryStringRead::Create(Microsoft::VisualStudio::Debugger::DkmReadMemoryFlags_t Flags, UINT16 CharacterSize, UINT32 MaxCharacters, Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILMemoryStringRead** ppCreatedObject)
{
    return ProcDA48987D0C3B6A7E18E3AC29CAAD314D(Flags, CharacterSize, MaxCharacters, ppCreatedObject);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILMemoryWrite::Create(Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILMemoryWrite** ppCreatedObject)
{
    return Proc61C52246DE45479B72BA6997F2B2A8F1(ppCreatedObject);
}

inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmPrimitiveObjectType_t STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILMultiply::Type()
{
    return this->m_Type;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILMultiply::Create(Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmPrimitiveObjectType_t Type, Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILMultiply** ppCreatedObject)
{
    return Proc401CC9B272AC84D4FD02EB44812606BA(Type, ppCreatedObject);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILNop::Create(Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILNop** ppCreatedObject)
{
    return Proc45F2C6048794F68C28A16C1614F4F4EA(ppCreatedObject);
}

inline DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILParameterValue::LocalIndex()
{
    return this->m_LocalIndex;
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<BYTE>* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILParameterValue::ValueBytes()
{
    return this->m_pValueBytes;
}

inline DECLSPEC_NOTHROW bool STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILParameterValue::IsByRef()
{
    // This method was introduced after the initial version of the API. The caller is
    // responsible for taking steps to ensure that this method is not called when running
    // against earlier versions of vsdebugeng.dll.
    ATLASSERT(DkmComponentManager::IsApiVersionSupported(DkmApiVersion::VS14RTM) || !"Invalid usage detected. Process will crash or bogus data will be returned");
    return this->m__pExtendedData->IsByRef;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILParameterValue::Create(UINT32 LocalIndex, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<BYTE>* pValueBytes, Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILParameterValue** ppCreatedObject)
{
    return ProcFD4EE301C59FC0351D8CF4431CBC623B(LocalIndex, pValueBytes, ppCreatedObject);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILParameterValue::Create(UINT32 LocalIndex, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<BYTE>* pValueBytes, bool IsByRef, Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILParameterValue** ppCreatedObject)
{
    return ProcCE37C359ECDC6F99185E4B406EE8ABCC(LocalIndex, pValueBytes, IsByRef, ppCreatedObject);
}

_Ret_opt_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILParameterValue*>* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::Group::DkmILParameterValueCollection::Parameters()
{
    return this->m_pParameters;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::Group::DkmILParameterValueCollection::Create(Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILParameterValue*>* pParameters, Microsoft::VisualStudio::Debugger::Evaluation::Group::DkmILParameterValueCollection** ppCreatedObject)
{
    return Proc9DF1C12E7E667FAA07405E2EB93A3FA5(pParameters, ppCreatedObject);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILPop::Create(Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILPop** ppCreatedObject)
{
    return Proc1DC79D92A0938AE9690076CE9323DAC7(ppCreatedObject);
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<BYTE>* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILPushConstant::Value()
{
    return this->m_pValue;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILPushConstant::Create(Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<BYTE>* pValue, Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILPushConstant** ppCreatedObject)
{
    return ProcE4F5DD31DD2BC1EDC34C6E1135328142(pValue, ppCreatedObject);
}

inline DECLSPEC_NOTHROW CV_HREG_e STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILRegisterRead::RegisterId()
{
    return this->m_RegisterId;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILRegisterRead::Create(CV_HREG_e RegisterId, Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILRegisterRead** ppCreatedObject)
{
    return Proc58B9915C02C6BE805485E625EBF9C530(RegisterId, ppCreatedObject);
}

inline DECLSPEC_NOTHROW CV_HREG_e STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILRegisterWrite::RegisterId()
{
    return this->m_RegisterId;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILRegisterWrite::Create(CV_HREG_e RegisterId, Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILRegisterWrite** ppCreatedObject)
{
    return ProcDCC91AD8A2E048D1EA602989BF72949C(RegisterId, ppCreatedObject);
}

inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmPrimitiveObjectType_t STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILRemainder::Type()
{
    return this->m_Type;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILRemainder::Create(Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmPrimitiveObjectType_t Type, Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILRemainder** ppCreatedObject)
{
    return ProcF5C9FC936A5A04CE6DF00B7345A7E8CA(Type, ppCreatedObject);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILReturnTop::Create(Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILReturnTop** ppCreatedObject)
{
    return ProcF3C1D5377032837C2404235250E0B451(ppCreatedObject);
}

inline DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILSave::Index()
{
    return this->m_Index;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILSave::Create(UINT32 Index, Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILSave** ppCreatedObject)
{
    return ProcD8B6F020C004300F488AA5F72045BC59(Index, ppCreatedObject);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILSetBytesRegion::Create(Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILSetBytesRegion** ppCreatedObject)
{
    return Proc256DC5FA8167A7B12392751E76AD665A(ppCreatedObject);
}

inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmPrimitiveObjectType_t STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILSubtract::Type()
{
    return this->m_Type;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILSubtract::Create(Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmPrimitiveObjectType_t Type, Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILSubtract** ppCreatedObject)
{
    return ProcB74FE600C741C9E0EA9A5EB02EC32244(Type, ppCreatedObject);
}

inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILFailureReason_t STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILThrow::FailureCode()
{
    return this->m_FailureCode;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILThrow::Create(Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILFailureReason_t FailureCode, Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILThrow** ppCreatedObject)
{
    return ProcDC178BD53797D38351843A49AAE130A1(FailureCode, ppCreatedObject);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILTlsGetValue::Create(Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILTlsGetValue** ppCreatedObject)
{
    return ProcDDCD8B82D3B57686F096172A6C076243(ppCreatedObject);
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::Evaluation::DkmInspectionSession* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmInspectionContext::InspectionSession()
{
    return this->m_pInspectionSession;
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmRuntimeInstance* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmInspectionContext::RuntimeInstance()
{
    return this->m_pRuntimeInstance;
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmThread* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmInspectionContext::Thread()
{
    return this->m_pThread;
}

inline DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmInspectionContext::Timeout()
{
    return this->m_Timeout;
}

inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::Evaluation::DkmEvaluationFlags_t STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmInspectionContext::EvaluationFlags()
{
    return this->m_EvaluationFlags;
}

inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::Evaluation::DkmFuncEvalFlags_t STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmInspectionContext::FuncEvalFlags()
{
    return this->m_FuncEvalFlags;
}

inline DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmInspectionContext::Radix()
{
    return this->m_Radix;
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::Evaluation::DkmLanguage* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmInspectionContext::Language()
{
    return this->m_pLanguage;
}

_Ret_opt_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::Evaluation::DkmRawReturnValue* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmInspectionContext::ReturnValue()
{
    return this->m_pReturnValue;
}

_Ret_opt_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::Evaluation::DkmCompiledVisualizationData* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmInspectionContext::AdditionalVisualizationData()
{
    // This method was introduced after the initial version of the API. The caller is
    // responsible for taking steps to ensure that this method is not called when running
    // against earlier versions of vsdebugeng.dll.
    ATLASSERT(DkmComponentManager::IsApiVersionSupported(DkmApiVersion::VS12RTM) || !"Invalid usage detected. Process will crash or bogus data will be returned");
    return this->m__pExtendedData->pAdditionalVisualizationData;
}

inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::Evaluation::DkmCompiledVisualizationDataPriority_t STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmInspectionContext::AdditionalVisualizationDataPriority()
{
    // This method was introduced after the initial version of the API. The caller is
    // responsible for taking steps to ensure that this method is not called when running
    // against earlier versions of vsdebugeng.dll.
    ATLASSERT(DkmComponentManager::IsApiVersionSupported(DkmApiVersion::VS12RTM) || !"Invalid usage detected. Process will crash or bogus data will be returned");
    return this->m__pExtendedData->AdditionalVisualizationDataPriority;
}

_Ret_opt_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<Microsoft::VisualStudio::Debugger::Evaluation::DkmRawReturnValueContainer*>* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmInspectionContext::ReturnValues()
{
    // This method was introduced after the initial version of the API. The caller is
    // responsible for taking steps to ensure that this method is not called when running
    // against earlier versions of vsdebugeng.dll.
    ATLASSERT(DkmComponentManager::IsApiVersionSupported(DkmApiVersion::VS14RTM) || !"Invalid usage detected. Process will crash or bogus data will be returned");
    return this->m__pExtendedData->pReturnValues;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmInspectionContext::Create(Microsoft::VisualStudio::Debugger::Evaluation::DkmInspectionSession* pInspectionSession, Microsoft::VisualStudio::Debugger::DkmRuntimeInstance* pRuntimeInstance, Microsoft::VisualStudio::Debugger::DkmThread* pThread, UINT32 Timeout, Microsoft::VisualStudio::Debugger::Evaluation::DkmEvaluationFlags_t EvaluationFlags, Microsoft::VisualStudio::Debugger::Evaluation::DkmFuncEvalFlags_t FuncEvalFlags, UINT32 Radix, Microsoft::VisualStudio::Debugger::Evaluation::DkmLanguage* pLanguage, Microsoft::VisualStudio::Debugger::Evaluation::DkmRawReturnValue* pReturnValue, Microsoft::VisualStudio::Debugger::Evaluation::DkmInspectionContext** ppCreatedObject)
{
    return Proc3E44E2254CE4725B5E4A486A9B526329(pInspectionSession, pRuntimeInstance, pThread, Timeout, EvaluationFlags, FuncEvalFlags, Radix, pLanguage, pReturnValue, ppCreatedObject);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmInspectionContext::Create(Microsoft::VisualStudio::Debugger::Evaluation::DkmInspectionSession* pInspectionSession, Microsoft::VisualStudio::Debugger::DkmRuntimeInstance* pRuntimeInstance, Microsoft::VisualStudio::Debugger::DkmThread* pThread, UINT32 Timeout, Microsoft::VisualStudio::Debugger::Evaluation::DkmEvaluationFlags_t EvaluationFlags, Microsoft::VisualStudio::Debugger::Evaluation::DkmFuncEvalFlags_t FuncEvalFlags, UINT32 Radix, Microsoft::VisualStudio::Debugger::Evaluation::DkmLanguage* pLanguage, Microsoft::VisualStudio::Debugger::Evaluation::DkmRawReturnValue* pReturnValue, Microsoft::VisualStudio::Debugger::Evaluation::DkmCompiledVisualizationData* pAdditionalVisualizationData, Microsoft::VisualStudio::Debugger::Evaluation::DkmCompiledVisualizationDataPriority_t AdditionalVisualizationDataPriority, Microsoft::VisualStudio::Debugger::Evaluation::DkmInspectionContext** ppCreatedObject)
{
    return Proc1B8F796B6C622B33C8D151185C0D2B9C(pInspectionSession, pRuntimeInstance, pThread, Timeout, EvaluationFlags, FuncEvalFlags, Radix, pLanguage, pReturnValue, pAdditionalVisualizationData, AdditionalVisualizationDataPriority, ppCreatedObject);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmInspectionContext::Create(Microsoft::VisualStudio::Debugger::Evaluation::DkmInspectionSession* pInspectionSession, Microsoft::VisualStudio::Debugger::DkmRuntimeInstance* pRuntimeInstance, Microsoft::VisualStudio::Debugger::DkmThread* pThread, UINT32 Timeout, Microsoft::VisualStudio::Debugger::Evaluation::DkmEvaluationFlags_t EvaluationFlags, Microsoft::VisualStudio::Debugger::Evaluation::DkmFuncEvalFlags_t FuncEvalFlags, UINT32 Radix, Microsoft::VisualStudio::Debugger::Evaluation::DkmLanguage* pLanguage, Microsoft::VisualStudio::Debugger::Evaluation::DkmRawReturnValue* pReturnValue, Microsoft::VisualStudio::Debugger::Evaluation::DkmCompiledVisualizationData* pAdditionalVisualizationData, Microsoft::VisualStudio::Debugger::Evaluation::DkmCompiledVisualizationDataPriority_t AdditionalVisualizationDataPriority, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<Microsoft::VisualStudio::Debugger::Evaluation::DkmRawReturnValueContainer*>* pReturnValues, Microsoft::VisualStudio::Debugger::Evaluation::DkmInspectionContext** ppCreatedObject)
{
    return Proc1BB47B2873705FF468D77E2EB1CE6D18(pInspectionSession, pRuntimeInstance, pThread, Timeout, EvaluationFlags, FuncEvalFlags, Radix, pLanguage, pReturnValue, pAdditionalVisualizationData, AdditionalVisualizationDataPriority, pReturnValues, ppCreatedObject);
}

#ifndef EXCLUDE_IDE_ONLY_APIS
inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmInspectionContext::EvaluateExpressionOnThreads(Microsoft::VisualStudio::Debugger::DkmWorkList* pWorkList, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<UINT64>* pThreads, Microsoft::VisualStudio::Debugger::CallStack::DkmStackWalkFrame* pStackFrame, Microsoft::VisualStudio::Debugger::Evaluation::DkmLanguageExpression* pExpression, Microsoft::VisualStudio::Debugger::IDkmCompletionRoutine<Microsoft::VisualStudio::Debugger::Evaluation::Group::DkmEvaluateExpressionOnThreadsAsyncResult>* pCompletionRoutine)
{
    return Proc086780F7AB96BE98E973B6DADFEEC905(this, pWorkList, pThreads, pStackFrame, pExpression, pCompletionRoutine);
}
#endif // #ifndef EXCLUDE_IDE_ONLY_APIS

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmInspectionContext::EvaluateExpression(Microsoft::VisualStudio::Debugger::DkmWorkList* pWorkList, Microsoft::VisualStudio::Debugger::Evaluation::DkmLanguageExpression* pExpression, Microsoft::VisualStudio::Debugger::CallStack::DkmStackWalkFrame* pStackFrame, Microsoft::VisualStudio::Debugger::IDkmCompletionRoutine<Microsoft::VisualStudio::Debugger::Evaluation::DkmEvaluateExpressionAsyncResult>* pCompletionRoutine)
{
    return ProcF7531579429F4DBD3A2C1DEED15F6A9B(this, pWorkList, pExpression, pStackFrame, pCompletionRoutine);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmInspectionContext::GetFrameLocals(Microsoft::VisualStudio::Debugger::DkmWorkList* pWorkList, Microsoft::VisualStudio::Debugger::CallStack::DkmStackWalkFrame* pStackFrame, Microsoft::VisualStudio::Debugger::IDkmCompletionRoutine<Microsoft::VisualStudio::Debugger::Evaluation::DkmGetFrameLocalsAsyncResult>* pCompletionRoutine)
{
    return Proc22DAB17B5E419C4DFC5198EFBCADBC18(this, pWorkList, pStackFrame, pCompletionRoutine);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmInspectionContext::GetFrameArguments(Microsoft::VisualStudio::Debugger::DkmWorkList* pWorkList, Microsoft::VisualStudio::Debugger::CallStack::DkmStackWalkFrame* pFrame, Microsoft::VisualStudio::Debugger::IDkmCompletionRoutine<Microsoft::VisualStudio::Debugger::Evaluation::DkmGetFrameArgumentsAsyncResult>* pCompletionRoutine)
{
    return ProcCEB972D13FE445A9D304AD753C757552(this, pWorkList, pFrame, pCompletionRoutine);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmInspectionContext::GetFrameName(Microsoft::VisualStudio::Debugger::DkmWorkList* pWorkList, Microsoft::VisualStudio::Debugger::CallStack::DkmStackWalkFrame* pFrame, Microsoft::VisualStudio::Debugger::Evaluation::DkmVariableInfoFlags_t ArgumentFlags, Microsoft::VisualStudio::Debugger::IDkmCompletionRoutine<Microsoft::VisualStudio::Debugger::Evaluation::DkmGetFrameNameAsyncResult>* pCompletionRoutine)
{
    return Proc44DBDEA6AB474E8EB67B5F2348EDCC20(this, pWorkList, pFrame, ArgumentFlags, pCompletionRoutine);
}

#ifndef EXCLUDE_IDE_ONLY_APIS
inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmInspectionContext::GetFrameReturnType(Microsoft::VisualStudio::Debugger::DkmWorkList* pWorkList, Microsoft::VisualStudio::Debugger::CallStack::DkmStackWalkFrame* pFrame, Microsoft::VisualStudio::Debugger::IDkmCompletionRoutine<Microsoft::VisualStudio::Debugger::Evaluation::DkmGetFrameReturnTypeAsyncResult>* pCompletionRoutine)
{
    return Proc281BD02CCE55B2A58FC2C8301699BF33(this, pWorkList, pFrame, pCompletionRoutine);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmInspectionContext::EvaluateReturnValue(Microsoft::VisualStudio::Debugger::DkmWorkList* pWorkList, Microsoft::VisualStudio::Debugger::CallStack::DkmStackWalkFrame* pStackFrame, Microsoft::VisualStudio::Debugger::Evaluation::DkmRawReturnValue* pRawReturnValue, Microsoft::VisualStudio::Debugger::IDkmCompletionRoutine<Microsoft::VisualStudio::Debugger::Evaluation::DkmEvaluateReturnValueAsyncResult>* pCompletionRoutine)
{
    return Proc8100E1C553B1AE153B3AEF9DAE275F33(this, pWorkList, pStackFrame, pRawReturnValue, pCompletionRoutine);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmInspectionContext::GetClrLocalVariableQuery(Microsoft::VisualStudio::Debugger::Clr::DkmClrInstructionAddress* pInstructionAddress, bool ArgumentsOnly, Microsoft::VisualStudio::Debugger::Evaluation::ClrCompilation::DkmCompiledClrLocalsQuery** ppResult)
{
    return Proc92260B87C04ECE6862D88F7A45EECD13(this, pInstructionAddress, ArgumentsOnly, ppResult);
}
#endif // #ifndef EXCLUDE_IDE_ONLY_APIS

#ifndef EXCLUDE_MONITOR_ONLY_APIS
inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmInspectionContext::GetTypeName(Microsoft::VisualStudio::Debugger::Clr::DkmClrType* pClrType, Microsoft::VisualStudio::Debugger::Evaluation::ClrCompilation::DkmClrCustomTypeInfo* pCustomTypeInfo, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<Microsoft::VisualStudio::Debugger::DkmString*>* pFormatSpecifiers, Microsoft::VisualStudio::Debugger::DkmString** ppTypeName)
{
    return Proc0343604ED036A20BFD02BE7C9A4CB730(this, pClrType, pCustomTypeInfo, pFormatSpecifiers, ppTypeName);
}
#endif // #ifndef EXCLUDE_MONITOR_ONLY_APIS

#ifndef EXCLUDE_IDE_ONLY_APIS
inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmInspectionContext::EvaluateReturnValue2(Microsoft::VisualStudio::Debugger::DkmWorkList* pWorkList, Microsoft::VisualStudio::Debugger::CallStack::DkmStackWalkFrame* pStackFrame, Microsoft::VisualStudio::Debugger::Evaluation::DkmRawReturnValueContainer* pRawReturnValue, Microsoft::VisualStudio::Debugger::IDkmCompletionRoutine<Microsoft::VisualStudio::Debugger::Evaluation::DkmEvaluateReturnValueAsyncResult2>* pCompletionRoutine)
{
    return Proc8BFD65439118D33CF7BD0C4D95F940EE(this, pWorkList, pStackFrame, pRawReturnValue, pCompletionRoutine);
}
#endif // #ifndef EXCLUDE_IDE_ONLY_APIS

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmProcess* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmInspectionSession::Process()
{
    return this->m_pProcess;
}

inline DECLSPEC_NOTHROW const GUID& STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmInspectionSession::UniqueId()
{
    return this->m_UniqueId;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmInspectionSession::Close()
{
    return Proc2DCEF64A20FA074BCCA5B25B25800DEC(this);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmInspectionSession::Create(Microsoft::VisualStudio::Debugger::DkmProcess* pProcess, const Microsoft::VisualStudio::Debugger::DkmDataItem& DataItem, Microsoft::VisualStudio::Debugger::Evaluation::DkmInspectionSession** ppCreatedObject)
{
    return Proc094F295F322424992BB5E795A7035884(pProcess, DataItem, ppCreatedObject);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmInspectionSession::FindReturnValueContainer(UINT32 Id, Microsoft::VisualStudio::Debugger::Evaluation::DkmRawReturnValueContainer** ppReturnValueContainer)
{
    return Proc2A390C1D1F33EDBD1ACC2F03C450252B(this, Id, ppReturnValueContainer);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmInspectionSession::GetReturnValueContainers(Microsoft::VisualStudio::Debugger::DkmArray<Microsoft::VisualStudio::Debugger::Evaluation::DkmRawReturnValueContainer*>* pReturnValueContainers)
{
    return ProcB6994295ABE30C2D9DEEF34C72334641(this, pReturnValueContainers);
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DefaultPort::DkmAppPackageId* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DefaultPort::DkmInstalledAppPackageInfo::AppPackageId()
{
    return this->m_pAppPackageId;
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmString* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DefaultPort::DkmInstalledAppPackageInfo::DisplayName()
{
    return this->m_pDisplayName;
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmString* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DefaultPort::DkmInstalledAppPackageInfo::Version()
{
    return this->m_pVersion;
}

_Ret_opt_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmString* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DefaultPort::DkmInstalledAppPackageInfo::LogoPath()
{
    return this->m_pLogoPath;
}

_Ret_opt_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<Microsoft::VisualStudio::Debugger::DefaultPort::DkmInstalledApplicationInfo*>* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DefaultPort::DkmInstalledAppPackageInfo::Applications()
{
    return this->m_pApplications;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DefaultPort::DkmInstalledAppPackageInfo::Create(Microsoft::VisualStudio::Debugger::DefaultPort::DkmAppPackageId* pAppPackageId, Microsoft::VisualStudio::Debugger::DkmString* pDisplayName, Microsoft::VisualStudio::Debugger::DkmString* pVersion, Microsoft::VisualStudio::Debugger::DkmString* pLogoPath, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<Microsoft::VisualStudio::Debugger::DefaultPort::DkmInstalledApplicationInfo*>* pApplications, Microsoft::VisualStudio::Debugger::DefaultPort::DkmInstalledAppPackageInfo** ppCreatedObject)
{
    return Proc2EA0223CA2C28FD2A44B1ABE5EAA38E6(pAppPackageId, pDisplayName, pVersion, pLogoPath, pApplications, ppCreatedObject);
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmString* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DefaultPort::DkmInstalledApplicationInfo::AppUserModelId()
{
    return this->m_pAppUserModelId;
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmString* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DefaultPort::DkmInstalledApplicationInfo::DisplayName()
{
    return this->m_pDisplayName;
}

_Ret_opt_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmString* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DefaultPort::DkmInstalledApplicationInfo::Executable()
{
    return this->m_pExecutable;
}

_Ret_opt_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmString* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DefaultPort::DkmInstalledApplicationInfo::SmallLogoPath()
{
    return this->m_pSmallLogoPath;
}

_Ret_opt_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmString* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DefaultPort::DkmInstalledApplicationInfo::BackgroundColor()
{
    return this->m_pBackgroundColor;
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmString* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DefaultPort::DkmInstalledApplicationInfo::Description()
{
    return this->m_pDescription;
}

inline DECLSPEC_NOTHROW const GUID& STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DefaultPort::DkmInstalledApplicationInfo::DefaultDebugEngine()
{
    return this->m_DefaultDebugEngine;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DefaultPort::DkmInstalledApplicationInfo::Create(Microsoft::VisualStudio::Debugger::DkmString* pAppUserModelId, Microsoft::VisualStudio::Debugger::DkmString* pDisplayName, Microsoft::VisualStudio::Debugger::DkmString* pExecutable, Microsoft::VisualStudio::Debugger::DkmString* pSmallLogoPath, Microsoft::VisualStudio::Debugger::DkmString* pBackgroundColor, Microsoft::VisualStudio::Debugger::DkmString* pDescription, const GUID& DefaultDebugEngine, Microsoft::VisualStudio::Debugger::DefaultPort::DkmInstalledApplicationInfo** ppCreatedObject)
{
    return Proc5C4A41F2572CF238937F847AC2A3B828(pAppUserModelId, pDisplayName, pExecutable, pSmallLogoPath, pBackgroundColor, pDescription, DefaultDebugEngine, ppCreatedObject);
}

_Ret_opt_ inline DECLSPEC_NOTHROW const Microsoft::VisualStudio::Debugger::DkmInstructionAddress::CPUInstruction* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmInstructionAddress::CPUInstructionPart()
{
    return this->m_pCPUInstruction;
}

inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmInstructionAddress::Tag_t STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmInstructionAddress::TagValue()
{
    return this->m_TagValue;
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmRuntimeInstance* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmInstructionAddress::RuntimeInstance()
{
    return this->m_pRuntimeInstance;
}

_Ret_opt_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmModuleInstance* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmInstructionAddress::ModuleInstance()
{
    return this->m_pModuleInstance;
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmProcess* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmInstructionAddress::Process()
{
    return this->m_pRuntimeInstance->Process();
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmInstructionAddress::GetSymbol(Microsoft::VisualStudio::Debugger::Symbols::DkmInstructionSymbol** ppSymbol)
{
    return Proc2063EA8A5827C04D2BF6A7BA85E27556(this, ppSymbol);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmInstructionAddress::CompareTo(Microsoft::VisualStudio::Debugger::DkmInstructionAddress* pOther, INT32* pResult)
{
    return Proc94A165B2D7D457C800C0044AEE4DF1CB(this, pOther, pResult);
}

#ifndef EXCLUDE_IDE_ONLY_APIS
inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmInstructionAddress::IsInSameFunction(Microsoft::VisualStudio::Debugger::DkmInstructionAddress* pOther, bool* pResult)
{
    return ProcCAA57817DCAB36FA6857F059CC28E22C(this, pOther, pResult);
}
#endif // #ifndef EXCLUDE_IDE_ONLY_APIS

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmInstructionAddress::GetCurrentCPUAddress(Microsoft::VisualStudio::Debugger::DkmArray<UINT64>* pInstructionPointers)
{
    return Proc52D25C4E1682ABDE2CA361EA4457EC20(this, pInstructionPointers);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmInstructionAddress::GetCurrentCPUAddress(Microsoft::VisualStudio::Debugger::DkmWorkList* pWorkList, Microsoft::VisualStudio::Debugger::IDkmCompletionRoutine<Microsoft::VisualStudio::Debugger::DkmGetCurrentCPUAddressAsyncResult>* pCompletionRoutine)
{
    return ProcACB1ED9131E740FA3BE29B6308FECCB2(this, pWorkList, pCompletionRoutine);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmInstructionAddress::IsUserCode(Microsoft::VisualStudio::Debugger::DkmWorkList* pWorkList, Microsoft::VisualStudio::Debugger::IDkmCompletionRoutine<Microsoft::VisualStudio::Debugger::Symbols::DkmIsUserCodeAsyncResult>* pCompletionRoutine)
{
    return Proc9B7FAC38CDD9E0656EF668FB4B062428(this, pWorkList, pCompletionRoutine);
}

inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::Symbols::DkmInstructionSymbol::Tag_t STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Symbols::DkmInstructionSymbol::TagValue()
{
    return this->m_TagValue;
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::Symbols::DkmModule* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Symbols::DkmInstructionSymbol::Module()
{
    return this->m_pModule;
}

inline DECLSPEC_NOTHROW const GUID& STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Symbols::DkmInstructionSymbol::RuntimeType()
{
    return this->m_RuntimeType;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Symbols::DkmInstructionSymbol::Bind(Microsoft::VisualStudio::Debugger::DkmModuleInstance* pModuleInstance, Microsoft::VisualStudio::Debugger::DkmInstructionAddress** ppAddress)
{
    return ProcAC852ACB3B15D4C2B177E7AA9ED66C3F(this, pModuleInstance, ppAddress);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Symbols::DkmInstructionSymbol::GetGPUInstructionMetadataCallback(Microsoft::VisualStudio::Debugger::DkmInstructionAddress* pInstructionAddress, Microsoft::VisualStudio::Debugger::Symbols::DkmInstructionSymbol* pNextInstruction, Microsoft::VisualStudio::Debugger::GPU::DkmGPUAddressType_t* pMetadata)
{
    return Proc31D347AE67B44CCB5C5B5025DAC7D49F(this, pInstructionAddress, pNextInstruction, pMetadata);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Symbols::DkmInstructionSymbol::GetNoSourceRanges(Microsoft::VisualStudio::Debugger::DkmArray<Microsoft::VisualStudio::Debugger::Symbols::DkmSteppingRange>* pRanges)
{
    return Proc862FD79FBD0E048B914012C907E6262E(this, pRanges);
}

#ifndef EXCLUDE_MONITOR_ONLY_APIS
inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Symbols::DkmInstructionSymbol::GetUserCodeSourcePositionCallback(Microsoft::VisualStudio::Debugger::Evaluation::DkmInspectionSession* pInspectionSession, Microsoft::VisualStudio::Debugger::Symbols::DkmSourcePosition** ppSourcePosition)
{
    return ProcBDD11793EA51E5D4A4A47BB5D6AF1606(this, pInspectionSession, ppSourcePosition);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Symbols::DkmInstructionSymbol::GetUserCodeSourcePositionCallback(Microsoft::VisualStudio::Debugger::DkmWorkList* pWorkList, Microsoft::VisualStudio::Debugger::Evaluation::DkmInspectionSession* pInspectionSession, Microsoft::VisualStudio::Debugger::IDkmCompletionRoutine<Microsoft::VisualStudio::Debugger::Symbols::DkmGetUserCodeSourcePositionCallbackAsyncResult>* pCompletionRoutine)
{
    return ProcC8D8FC52CDB2195F51CF25F6E35EF5FB(this, pWorkList, pInspectionSession, pCompletionRoutine);
}
#endif // #ifndef EXCLUDE_MONITOR_ONLY_APIS

#ifndef EXCLUDE_IDE_ONLY_APIS
inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Symbols::DkmInstructionSymbol::GetDisassemblyLabel(Microsoft::VisualStudio::Debugger::Evaluation::DkmInspectionSession* pInspectionSession, Microsoft::VisualStudio::Debugger::DkmString** ppLabel)
{
    return Proc11B96E95076AEBD19435335693648C9F(this, pInspectionSession, ppLabel);
}
#endif // #ifndef EXCLUDE_IDE_ONLY_APIS

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Symbols::DkmInstructionSymbol::GetCompilerId(Microsoft::VisualStudio::Debugger::Evaluation::DkmInspectionSession* pInspectionSession, Microsoft::VisualStudio::Debugger::Evaluation::DkmCompilerId* pCompilerId)
{
    return Proc25C283D1FA9B4F1F3979BA9CA8917013(this, pInspectionSession, pCompilerId);
}

#ifndef EXCLUDE_IDE_ONLY_APIS
inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Symbols::DkmInstructionSymbol::IsHiddenCode(Microsoft::VisualStudio::Debugger::DkmWorkList* pWorkList, Microsoft::VisualStudio::Debugger::Evaluation::DkmInspectionSession* pInspectionSession, Microsoft::VisualStudio::Debugger::DkmInstructionAddress* pInstructionAddress, Microsoft::VisualStudio::Debugger::IDkmCompletionRoutine<Microsoft::VisualStudio::Debugger::Symbols::DkmIsHiddenCodeAsyncResult>* pCompletionRoutine)
{
    return ProcA273139AC02E5BE47E4FAD7C165037C1(this, pWorkList, pInspectionSession, pInstructionAddress, pCompletionRoutine);
}
#endif // #ifndef EXCLUDE_IDE_ONLY_APIS

#ifndef EXCLUDE_MONITOR_ONLY_APIS
inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Symbols::DkmInstructionSymbol::GetSteppingRanges(Microsoft::VisualStudio::Debugger::Symbols::DkmSteppingRangeBoundary_t RangeBoundary, bool IncludeInline, Microsoft::VisualStudio::Debugger::DkmArray<Microsoft::VisualStudio::Debugger::Symbols::DkmSteppingRange>* pRanges)
{
    return ProcE3287B6AD1874438A4638A94F83D8907(this, RangeBoundary, IncludeInline, pRanges);
}
#endif // #ifndef EXCLUDE_MONITOR_ONLY_APIS

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Symbols::DkmInstructionSymbol::HasLineInfo(bool* pResult)
{
    return Proc23E28172B8ED4C1CF1065854ACDA6236(this, pResult);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Symbols::DkmInstructionSymbol::HasLineInfo(Microsoft::VisualStudio::Debugger::DkmWorkList* pWorkList, Microsoft::VisualStudio::Debugger::IDkmCompletionRoutine<Microsoft::VisualStudio::Debugger::Symbols::DkmHasLineInfoAsyncResult>* pCompletionRoutine)
{
    return ProcEECEDA2F659A9B7F31A4E9CEBAF928D5(this, pWorkList, pCompletionRoutine);
}

#ifndef EXCLUDE_MONITOR_ONLY_APIS
inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Symbols::DkmInstructionSymbol::GetCurrentStatementRange(Microsoft::VisualStudio::Debugger::Symbols::DkmSteppingRange* pResult)
{
    return Proc312C43C3EBD40AA19100FC0BE9A909AB(this, pResult);
}
#endif // #ifndef EXCLUDE_MONITOR_ONLY_APIS

#ifndef EXCLUDE_IDE_ONLY_APIS
inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Symbols::DkmInstructionSymbol::GetSourcePosition(Microsoft::VisualStudio::Debugger::Symbols::DkmSourcePositionFlags_t Flags, Microsoft::VisualStudio::Debugger::Evaluation::DkmInspectionSession* pInspectionSession, bool* pStartOfLine, Microsoft::VisualStudio::Debugger::Symbols::DkmSourcePosition** ppSourcePosition)
{
    return Proc74625D16DFFBC0BBB0B76F58AC775415(this, Flags, pInspectionSession, pStartOfLine, ppSourcePosition);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Symbols::DkmInstructionSymbol::GetSourcePosition(Microsoft::VisualStudio::Debugger::DkmWorkList* pWorkList, Microsoft::VisualStudio::Debugger::Symbols::DkmSourcePositionFlags_t Flags, Microsoft::VisualStudio::Debugger::Evaluation::DkmInspectionSession* pInspectionSession, Microsoft::VisualStudio::Debugger::IDkmCompletionRoutine<Microsoft::VisualStudio::Debugger::Symbols::DkmGetSourcePositionAsyncResult>* pCompletionRoutine)
{
    return ProcF1DC26DBD878FEE1EC011A3321EF806F(this, pWorkList, Flags, pInspectionSession, pCompletionRoutine);
}
#endif // #ifndef EXCLUDE_IDE_ONLY_APIS

#ifndef EXCLUDE_MONITOR_ONLY_APIS
inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Symbols::DkmInstructionSymbol::GetSourcePositionCallback(Microsoft::VisualStudio::Debugger::Symbols::DkmSourcePositionFlags_t Flags, Microsoft::VisualStudio::Debugger::Evaluation::DkmInspectionSession* pInspectionSession, bool* pStartOfLine, Microsoft::VisualStudio::Debugger::Symbols::DkmSourcePosition** ppSourcePosition)
{
    return Proc93764ECF9C2251D624F78B0CE24C436C(this, Flags, pInspectionSession, pStartOfLine, ppSourcePosition);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Symbols::DkmInstructionSymbol::GetSourcePositionCallback(Microsoft::VisualStudio::Debugger::DkmWorkList* pWorkList, Microsoft::VisualStudio::Debugger::Symbols::DkmSourcePositionFlags_t Flags, Microsoft::VisualStudio::Debugger::Evaluation::DkmInspectionSession* pInspectionSession, Microsoft::VisualStudio::Debugger::IDkmCompletionRoutine<Microsoft::VisualStudio::Debugger::Symbols::DkmGetSourcePositionCallbackAsyncResult>* pCompletionRoutine)
{
    return Proc04DEBA8C7D7338ACBE9E489F5CDDEEC3(this, pWorkList, Flags, pInspectionSession, pCompletionRoutine);
}
#endif // #ifndef EXCLUDE_MONITOR_ONLY_APIS

#ifndef EXCLUDE_IDE_ONLY_APIS
inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Symbols::DkmInstructionSymbol::GetAlternateSourcePosition(Microsoft::VisualStudio::Debugger::Symbols::DkmSourcePositionFlags_t Flags, Microsoft::VisualStudio::Debugger::Symbols::DkmSourcePosition** ppSourcePosition)
{
    return Proc9EBFFE4FF0C0B8719F419B9AA576BCFB(this, Flags, ppSourcePosition);
}
#endif // #ifndef EXCLUDE_IDE_ONLY_APIS

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmString* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmLanguage::Name()
{
    return this->m_pName;
}

inline DECLSPEC_NOTHROW const Microsoft::VisualStudio::Debugger::Evaluation::DkmCompilerId& STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmLanguage::Id()
{
    return this->m_Id;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmLanguage::Create(Microsoft::VisualStudio::Debugger::DkmString* pName, const Microsoft::VisualStudio::Debugger::Evaluation::DkmCompilerId& Id, Microsoft::VisualStudio::Debugger::Evaluation::DkmLanguage** ppCreatedObject)
{
    return Proc456FB60B9E4993FCB92B225C95A1B152(pName, Id, ppCreatedObject);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmLanguage::GetLanguageSettings(Microsoft::VisualStudio::Debugger::DkmArray<Microsoft::VisualStudio::Debugger::DkmLanguageRegistrySetting*>* pSettings)
{
    return Proc59530E264B592B0BFF5FDCD149513A30(this, pSettings);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmLanguage::GetLanguageSettings(Microsoft::VisualStudio::Debugger::DkmWorkList* pWorkList, Microsoft::VisualStudio::Debugger::IDkmCompletionRoutine<Microsoft::VisualStudio::Debugger::Evaluation::DkmGetLanguageSettingsAsyncResult>* pCompletionRoutine)
{
    return ProcF1D4F60E91C176CB2494DD14B47089A1(this, pWorkList, pCompletionRoutine);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmLanguage::GetEEMetricFile(Microsoft::VisualStudio::Debugger::DkmString* pMetricName, Microsoft::VisualStudio::Debugger::DkmString** ppContents)
{
    return Proc4B24038B5804A260021A129904C9BBC6(this, pMetricName, ppContents);
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::Evaluation::DkmLanguage* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmLanguageExpression::Language()
{
    return this->m_pLanguage;
}

inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::Evaluation::DkmEvaluationFlags_t STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmLanguageExpression::CompilationFlags()
{
    return this->m_CompilationFlags;
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmString* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmLanguageExpression::Text()
{
    return this->m_pText;
}

inline DECLSPEC_NOTHROW const GUID& STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmLanguageExpression::UniqueId()
{
    return this->m_UniqueId;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmLanguageExpression::Close()
{
    return ProcD69DC66A57C38CA4CAB503AEA3C31D11(this);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmLanguageExpression::Create(Microsoft::VisualStudio::Debugger::Evaluation::DkmLanguage* pLanguage, Microsoft::VisualStudio::Debugger::Evaluation::DkmEvaluationFlags_t CompilationFlags, Microsoft::VisualStudio::Debugger::DkmString* pText, const Microsoft::VisualStudio::Debugger::DkmDataItem& DataItem, Microsoft::VisualStudio::Debugger::Evaluation::DkmLanguageExpression** ppCreatedObject)
{
    return Proc8CE02648478ABDF8A3F6F73CE84429FA(pLanguage, CompilationFlags, pText, DataItem, ppCreatedObject);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmLanguageExpression::CompileExpression(Microsoft::VisualStudio::Debugger::Clr::DkmClrInstructionAddress* pInstructionAddress, Microsoft::VisualStudio::Debugger::Evaluation::DkmInspectionContext* pInspectionContext, Microsoft::VisualStudio::Debugger::DkmString** ppError, Microsoft::VisualStudio::Debugger::Evaluation::ClrCompilation::DkmCompiledClrInspectionQuery** ppResult)
{
    return ProcB3BE8CF198DBF082F2F19BE994CAC4C5(this, pInstructionAddress, pInspectionContext, ppError, ppResult);
}

#ifndef EXCLUDE_IDE_ONLY_APIS
inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmLanguageExpression::CompileAssignment(Microsoft::VisualStudio::Debugger::Clr::DkmClrInstructionAddress* pInstructionAddress, Microsoft::VisualStudio::Debugger::Evaluation::DkmEvaluationResult* pLValue, Microsoft::VisualStudio::Debugger::DkmString** ppError, Microsoft::VisualStudio::Debugger::Evaluation::ClrCompilation::DkmCompiledClrInspectionQuery** ppResult)
{
    return Proc454BD0C84C668A0A125BCB6475524F31(this, pInstructionAddress, pLValue, ppError, ppResult);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmLanguageExpression::CompileDisplayAttribute(Microsoft::VisualStudio::Debugger::Clr::DkmClrModuleInstance* pModuleInstance, UINT32 Token, Microsoft::VisualStudio::Debugger::DkmString** ppError, Microsoft::VisualStudio::Debugger::Evaluation::ClrCompilation::DkmCompiledClrInspectionQuery** ppResult)
{
    return ProcC5676EEB270E5D63EEDBBA79A6A10809(this, pModuleInstance, Token, ppError, ppResult);
}
#endif // #ifndef EXCLUDE_IDE_ONLY_APIS

#ifndef EXCLUDE_MONITOR_ONLY_APIS
inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmLanguageExpression::CompileDisplayAttributeInternal(Microsoft::VisualStudio::Debugger::Clr::DkmClrModuleInstance* pModuleInstance, UINT32 Token, Microsoft::VisualStudio::Debugger::DkmString** ppError, Microsoft::VisualStudio::Debugger::Evaluation::ClrCompilation::DkmCompiledClrInspectionQuery** ppResult)
{
    return ProcF14399E29BCD6CF68684B4E4FACCE08B(this, pModuleInstance, Token, ppError, ppResult);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmLanguageExpression::CompileDisplayAttributeInternal(Microsoft::VisualStudio::Debugger::DkmWorkList* pWorkList, Microsoft::VisualStudio::Debugger::Clr::DkmClrModuleInstance* pModuleInstance, UINT32 Token, Microsoft::VisualStudio::Debugger::IDkmCompletionRoutine<Microsoft::VisualStudio::Debugger::Evaluation::DkmCompileDisplayAttributeInternalAsyncResult>* pCompletionRoutine)
{
    return ProcD2487F1CCF357A31DF51A101750E2793(this, pWorkList, pModuleInstance, Token, pCompletionRoutine);
}
#endif // #ifndef EXCLUDE_MONITOR_ONLY_APIS

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::Evaluation::DkmLanguage* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmLanguageInstructionAddress::Language()
{
    return this->m_pLanguage;
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmInstructionAddress* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmLanguageInstructionAddress::Address()
{
    return this->m_pAddress;
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmRuntimeInstance* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmLanguageInstructionAddress::RuntimeInstance()
{
    return this->m_pAddress->RuntimeInstance();
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmLanguageInstructionAddress::Create(Microsoft::VisualStudio::Debugger::Evaluation::DkmLanguage* pLanguage, Microsoft::VisualStudio::Debugger::DkmInstructionAddress* pAddress, Microsoft::VisualStudio::Debugger::Evaluation::DkmLanguageInstructionAddress** ppCreatedObject)
{
    return Proc425C8315F654ADA55907101C9C65A89A(pLanguage, pAddress, ppCreatedObject);
}

#ifndef EXCLUDE_IDE_ONLY_APIS
inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmLanguageInstructionAddress::Compile(Microsoft::VisualStudio::Debugger::Evaluation::DkmLanguageExpression* pExpression, Microsoft::VisualStudio::Debugger::Evaluation::DkmFailedEvaluationResult** ppError)
{
    return Proc9EACD04F3FD1CA479AF6A3CE86B9E9FA(this, pExpression, ppError);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmLanguageInstructionAddress::CompileCondition(Microsoft::VisualStudio::Debugger::Breakpoints::DkmBreakpointCondition* pCondition, Microsoft::VisualStudio::Debugger::Evaluation::DkmCompiledInspectionQuery** ppCompiledCondition, Microsoft::VisualStudio::Debugger::DkmString** ppErrorText)
{
    return Proc4A691C7F7E4EA945A06F4071763491F1(this, pCondition, ppCompiledCondition, ppErrorText);
}
#endif // #ifndef EXCLUDE_IDE_ONLY_APIS

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmLanguageInstructionAddress::GetMethodName(Microsoft::VisualStudio::Debugger::Evaluation::DkmVariableInfoFlags_t ArgumentFlags, Microsoft::VisualStudio::Debugger::DkmString** ppMethodName)
{
    return Proc02B8A45DC663391C88C64FF8F16423AE(this, ArgumentFlags, ppMethodName);
}

#ifndef EXCLUDE_IDE_ONLY_APIS
inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmLanguageInstructionAddress::GetStepIntoFlags(Microsoft::VisualStudio::Debugger::Stepping::DkmLanguageStepIntoFlags_t* pStepIntoFlags)
{
    return Proc6217600D01C4D2ECBE61829AFD936139(this, pStepIntoFlags);
}
#endif // #ifndef EXCLUDE_IDE_ONLY_APIS

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmString* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmLanguageRegistrySetting::Name()
{
    return this->m_pName;
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmVariant* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmLanguageRegistrySetting::Value()
{
    return this->m_pValue;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmLanguageRegistrySetting::Create(Microsoft::VisualStudio::Debugger::DkmString* pName, Microsoft::VisualStudio::Debugger::DkmVariant* pValue, Microsoft::VisualStudio::Debugger::DkmLanguageRegistrySetting** ppCreatedObject)
{
    return Proc68AD630132C16798EB187E26E4B8E18B(pName, pValue, ppCreatedObject);
}

inline DECLSPEC_NOTHROW int STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Symbols::DkmMD5HashValue::CompareTo(const Microsoft::VisualStudio::Debugger::Symbols::DkmMD5HashValue& other) const
{
    return Proc19F3BC72A701F59F6D869826B65D2C66(*this, other);
}

inline DECLSPEC_NOTHROW const Microsoft::VisualStudio::Debugger::Symbols::DkmModuleId& STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Symbols::DkmModule::Id()
{
    return this->m_Id;
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmString* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Symbols::DkmModule::Name()
{
    return this->m_pName;
}

inline DECLSPEC_NOTHROW const Microsoft::VisualStudio::Debugger::Evaluation::DkmCompilerId& STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Symbols::DkmModule::CompilerId()
{
    return this->m_CompilerId;
}

_Ret_opt_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DefaultPort::DkmTransportConnection* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Symbols::DkmModule::Connection()
{
    return this->m_pConnection;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Symbols::DkmModule::FindModule(const Microsoft::VisualStudio::Debugger::Symbols::DkmModuleId& Id, Microsoft::VisualStudio::Debugger::Symbols::DkmModule** ppModule)
{
    return Proc5291958220F6BA230E62F74538F8E025(Id, ppModule);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Symbols::DkmModule::GetModules(Microsoft::VisualStudio::Debugger::DkmArray<Microsoft::VisualStudio::Debugger::Symbols::DkmModule*>* pModules)
{
    return Proc8CBFCEEC88661ADC3F294DFCA4AF14BD(pModules);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Symbols::DkmModule::Create(const Microsoft::VisualStudio::Debugger::Symbols::DkmModuleId& Id, Microsoft::VisualStudio::Debugger::DkmString* pName, const Microsoft::VisualStudio::Debugger::Evaluation::DkmCompilerId& CompilerId, Microsoft::VisualStudio::Debugger::DefaultPort::DkmTransportConnection* pConnection, const Microsoft::VisualStudio::Debugger::DkmDataItem& DataItem, Microsoft::VisualStudio::Debugger::Symbols::DkmModule** ppCreatedObject)
{
    return ProcD60BA609E5572E71FE7454972F0CC2FE(Id, pName, CompilerId, pConnection, DataItem, ppCreatedObject);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Symbols::DkmModule::GetScriptDocuments(Microsoft::VisualStudio::Debugger::DkmArray<Microsoft::VisualStudio::Debugger::Script::DkmScriptDocument*>* pScriptDocuments)
{
    return Proc1893989E63FB4502D761835AA167574F(this, pScriptDocuments);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Symbols::DkmModule::GetMethodSymbolStoreData(const Microsoft::VisualStudio::Debugger::Clr::DkmClrMethodId& MethodId, Microsoft::VisualStudio::Debugger::DkmArray<Microsoft::VisualStudio::Debugger::Clr::DkmClrMethodScopeData>* pScopes)
{
    return Proc787E6277F93875EC906A2F61947281D1(this, MethodId, pScopes);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Symbols::DkmModule::GetMethodSymbolStoreData(Microsoft::VisualStudio::Debugger::DkmWorkList* pWorkList, const Microsoft::VisualStudio::Debugger::Clr::DkmClrMethodId& MethodId, Microsoft::VisualStudio::Debugger::IDkmCompletionRoutine<Microsoft::VisualStudio::Debugger::Symbols::DkmGetMethodSymbolStoreDataAsyncResult>* pCompletionRoutine)
{
    return Proc0F050A725D2A1A68D6AEA249072A74CA(this, pWorkList, MethodId, pCompletionRoutine);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Symbols::DkmModule::GetFirstMethodInFirstDocument(Microsoft::VisualStudio::Debugger::Clr::DkmClrMethodId* pMethod)
{
    return ProcBBBD87DA3F9E7D240B27461DD59C7F82(this, pMethod);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Symbols::DkmModule::GetMethodSymbolStoreDataPreRemap(const Microsoft::VisualStudio::Debugger::Clr::DkmClrMethodId& MethodId, UINT32* pRemapToken, Microsoft::VisualStudio::Debugger::DkmArray<Microsoft::VisualStudio::Debugger::Clr::DkmClrMethodScopeData>* pScopes)
{
    return ProcAB14A3D49AB97EEE5634A0BE1114A8DB(this, MethodId, pRemapToken, pScopes);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Symbols::DkmModule::GetMethodSymbolStoreDataPreRemap(Microsoft::VisualStudio::Debugger::DkmWorkList* pWorkList, const Microsoft::VisualStudio::Debugger::Clr::DkmClrMethodId& MethodId, Microsoft::VisualStudio::Debugger::IDkmCompletionRoutine<Microsoft::VisualStudio::Debugger::Symbols::DkmGetMethodSymbolStoreDataPreRemapAsyncResult>* pCompletionRoutine)
{
    return ProcFA4AE503D69BFA42C4969ADBDC1209A3(this, pWorkList, MethodId, pCompletionRoutine);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Symbols::DkmModule::GetTokenSymbolStoreAttribute(UINT32 ParentToken, bool IsPreRemap, Microsoft::VisualStudio::Debugger::DkmString* pAttributeName, Microsoft::VisualStudio::Debugger::DkmArray<BYTE>* pData)
{
    return ProcD01D70ACAE8430CBB07B5F422017B9D6(this, ParentToken, IsPreRemap, pAttributeName, pData);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Symbols::DkmModule::GetTokenSymbolStoreAttribute(Microsoft::VisualStudio::Debugger::DkmWorkList* pWorkList, UINT32 ParentToken, bool IsPreRemap, Microsoft::VisualStudio::Debugger::DkmString* pAttributeName, Microsoft::VisualStudio::Debugger::IDkmCompletionRoutine<Microsoft::VisualStudio::Debugger::Symbols::DkmGetTokenSymbolStoreAttributeAsyncResult>* pCompletionRoutine)
{
    return ProcA0F5CAEEAAB4BB662F0A035412F7BBC6(this, pWorkList, ParentToken, IsPreRemap, pAttributeName, pCompletionRoutine);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Symbols::DkmModule::TranslateAcceleratorTagByIP(UINT32 InputTag, UINT32 InstructionPointer, UINT32* pRegisterType, UINT32* pRegisterIndex, UINT32* pFirstElement, UINT32* pVectorElements, UINT32* pByteOffset, UINT32* pVectorElementSize)
{
    return ProcD04C7DFC744864F9E28B48FDE7FC2E93(this, InputTag, InstructionPointer, pRegisterType, pRegisterIndex, pFirstElement, pVectorElements, pByteOffset, pVectorElementSize);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Symbols::DkmModule::GetCompilerOptions(Microsoft::VisualStudio::Debugger::DkmString** ppCompilerOptions)
{
    return Proc1FA09A66CFC6C30956FDF9F38B06E31F(this, ppCompilerOptions);
}

#ifndef EXCLUDE_IDE_ONLY_APIS
inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Symbols::DkmModule::TranslateAcceleratorTagByRva(UINT32 InputTag, UINT32 Rva, UINT32* pRegisterType, UINT32* pRegisterIndex, UINT32* pFirstElement, UINT32* pVectorElements, UINT32* pByteOffset, UINT32* pVectorElementSize)
{
    return Proc09E6E2514FF654881B54EB0150C7AC32(this, InputTag, Rva, pRegisterType, pRegisterIndex, pFirstElement, pVectorElements, pByteOffset, pVectorElementSize);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Symbols::DkmModule::IsValidAcceleratorTag(UINT32 InputTag, UINT32 Rva, bool* pIsValid)
{
    return Proc8C41A92D8B47ABE0375B9D7756FD489D(this, InputTag, Rva, pIsValid);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Symbols::DkmModule::GetPointerToHLSLRegister(CV_HREG_e RegisterType, UINT32 RegisterIndex, UINT32 FirstElement, UINT32 VectorElements, UINT32 ByteOffset, UINT32 VectorElementSize, UINT32 Rva, UINT32 StartLiveRange, UINT32 EndLiveRange, UINT64* pAddress, bool* pIsNewDynamicTag)
{
    return Proc5F33BB9A16D050DC6A11F8D02254B011(this, RegisterType, RegisterIndex, FirstElement, VectorElements, ByteOffset, VectorElementSize, Rva, StartLiveRange, EndLiveRange, pAddress, pIsNewDynamicTag);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Symbols::DkmModule::SetPointerToHLSLRegister(UINT64 Address, CV_HREG_e RegisterType, UINT32 RegisterIndex, UINT32 FirstElement, UINT32 VectorElements, UINT32 ByteOffset, UINT32 VectorElementSize, UINT32 StartLiveRange, UINT32 EndLiveRange)
{
    return Proc9DF311E58282BDB725263E4F8096A4C5(this, Address, RegisterType, RegisterIndex, FirstElement, VectorElements, ByteOffset, VectorElementSize, StartLiveRange, EndLiveRange);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Symbols::DkmModule::GetAcceleratorTagTableSize(UINT32* pSize, UINT32* pSizeOfForwardedTags)
{
    return Proc4621B3FD8E354DF3C09CD7AF4EFA6890(this, pSize, pSizeOfForwardedTags);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Symbols::DkmModule::GetInstructionOffsetForRva(UINT32 RVA, UINT32* pInstructionOffset)
{
    return Proc5134BC888343F0CBDC3CFF37F53CE11F(this, RVA, pInstructionOffset);
}
#endif // #ifndef EXCLUDE_IDE_ONLY_APIS

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Symbols::DkmModule::GetModuleInstances(Microsoft::VisualStudio::Debugger::DkmArray<Microsoft::VisualStudio::Debugger::DkmModuleInstance*>* pModules)
{
    return Proc101685421B67B01CA3E0DB5E650B022E(this, pModules);
}

#ifndef EXCLUDE_IDE_ONLY_APIS
inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Symbols::DkmModule::UndecorateName(Microsoft::VisualStudio::Debugger::DkmString* pDecoratedName, UINT32 Options, Microsoft::VisualStudio::Debugger::DkmString** ppUndecoratedName)
{
    return ProcE94B97BDA30ADC68B86021B4E04E88B9(this, pDecoratedName, Options, ppUndecoratedName);
}
#endif // #ifndef EXCLUDE_IDE_ONLY_APIS

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Symbols::DkmModule::GetPublicSymbolByNameCallback(Microsoft::VisualStudio::Debugger::DkmString* pPublicName, Microsoft::VisualStudio::Debugger::Native::DkmNativeInstructionSymbol** ppAddress)
{
    return ProcB78DCC1D97D2784074F1B8AD23A79A8D(this, pPublicName, ppAddress);
}

#ifndef EXCLUDE_IDE_ONLY_APIS
inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Symbols::DkmModule::GetSourceServerData(Microsoft::VisualStudio::Debugger::DkmModuleInstance* pModuleInstance, Microsoft::VisualStudio::Debugger::DkmArray<BYTE>* pStreamData)
{
    return Proc6F7D7F50E471D11AD110BF84C52571CC(this, pModuleInstance, pStreamData);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Symbols::DkmModule::FindDocuments(Microsoft::VisualStudio::Debugger::Symbols::DkmSourceFileId* pSourceFileId, Microsoft::VisualStudio::Debugger::DkmArray<Microsoft::VisualStudio::Debugger::Symbols::DkmResolvedDocument*>* pDocuments)
{
    return ProcCCBBBEED8A02B87E7A41F8504E31545E(this, pSourceFileId, pDocuments);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Symbols::DkmModule::FindDocuments(Microsoft::VisualStudio::Debugger::DkmWorkList* pWorkList, Microsoft::VisualStudio::Debugger::Symbols::DkmSourceFileId* pSourceFileId, Microsoft::VisualStudio::Debugger::IDkmCompletionRoutine<Microsoft::VisualStudio::Debugger::Symbols::DkmFindDocumentsAsyncResult>* pCompletionRoutine)
{
    return Proc203BC1170806E54DBAAF1B3530F58C16(this, pWorkList, pSourceFileId, pCompletionRoutine);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Symbols::DkmModule::GetSymbolFilePath(Microsoft::VisualStudio::Debugger::DkmString** ppFilePath)
{
    return Proc63D01FE35215A6F186CDAAF3981ECB78(this, ppFilePath);
}
#endif // #ifndef EXCLUDE_IDE_ONLY_APIS

#ifndef EXCLUDE_MONITOR_ONLY_APIS
inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Symbols::DkmModule::GetEntryPointSymbols(Microsoft::VisualStudio::Debugger::DkmArray<Microsoft::VisualStudio::Debugger::Symbols::DkmInstructionSymbol*>* pPossibleEntryPoints)
{
    return ProcD1DA8568A04474B5C880F261EDF65D23(this, pPossibleEntryPoints);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Symbols::DkmModule::GetFunctionInfo(Microsoft::VisualStudio::Debugger::DkmString* pFunctionName, Microsoft::VisualStudio::Debugger::DkmArray<Microsoft::VisualStudio::Debugger::Symbols::DkmRVASizePair>* pResults)
{
    return ProcB3AE544A716277EBD21AB3A79E73A97D(this, pFunctionName, pResults);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Symbols::DkmModule::GetFunctionInfo(Microsoft::VisualStudio::Debugger::DkmWorkList* pWorkList, Microsoft::VisualStudio::Debugger::DkmString* pFunctionName, Microsoft::VisualStudio::Debugger::IDkmCompletionRoutine<Microsoft::VisualStudio::Debugger::Symbols::DkmGetFunctionInfoAsyncResult>* pCompletionRoutine)
{
    return Proc8BFB1F00FB320ADA9A2FD47EB5E00505(this, pWorkList, pFunctionName, pCompletionRoutine);
}
#endif // #ifndef EXCLUDE_MONITOR_ONLY_APIS

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Symbols::DkmModule::GetSymbolInterface(const GUID& InterfaceID, IUnknown** ppSymbolInterface)
{
    return ProcF1B19E03C0D1B1CB1DFED383F9D9A51C(this, InterfaceID, ppSymbolInterface);
}

inline DECLSPEC_NOTHROW int STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Symbols::DkmModuleId::CompareTo(const Microsoft::VisualStudio::Debugger::Symbols::DkmModuleId& other) const
{
    return Proc1B02BC6A77ED80B4C26F62A6EA215225(*this, other);
}

_Ret_opt_ inline DECLSPEC_NOTHROW const Microsoft::VisualStudio::Debugger::DkmModuleInstance::MinidumpInfo* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmModuleInstance::MinidumpInfoPart()
{
    return this->m_pMinidumpInfo;
}

inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmModuleInstance::Tag_t STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmModuleInstance::TagValue()
{
    return this->m_TagValue;
}

inline DECLSPEC_NOTHROW const GUID& STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmModuleInstance::UniqueId()
{
    return this->m_UniqueId;
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmString* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmModuleInstance::Name()
{
    return this->m_pName;
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmString* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmModuleInstance::FullName()
{
    return this->m_pFullName;
}

inline DECLSPEC_NOTHROW UINT64 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmModuleInstance::TimeDateStamp()
{
    return this->m_TimeDateStamp;
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmRuntimeInstance* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmModuleInstance::RuntimeInstance()
{
    return this->m_pRuntimeInstance;
}

_Ret_opt_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmModuleVersion* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmModuleInstance::Version()
{
    return this->m_pVersion;
}

_Ret_opt_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::Symbols::DkmSymbolFileId* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmModuleInstance::SymbolFileId()
{
    return this->m_pSymbolFileId;
}

inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmModuleFlags_t STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmModuleInstance::Flags()
{
    return this->m_Flags;
}

inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmModuleMemoryLayout_t STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmModuleInstance::MemoryLayout()
{
    return this->m_MemoryLayout;
}

inline DECLSPEC_NOTHROW UINT64 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmModuleInstance::BaseAddress()
{
    return this->m_BaseAddress;
}

inline DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmModuleInstance::LoadOrder()
{
    return this->m_LoadOrder;
}

inline DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmModuleInstance::Size()
{
    return this->m_Size;
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmString* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmModuleInstance::LoadContext()
{
    return this->m_pLoadContext;
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmProcess* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmModuleInstance::Process()
{
    return this->m_pRuntimeInstance->Process();
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DefaultPort::DkmTransportConnection* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmModuleInstance::Connection()
{
    return this->m_pRuntimeInstance->Connection();
}

inline DECLSPEC_NOTHROW bool STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmModuleInstance::IsDisabled()
{
    return this->m_IsDisabled;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmModuleInstance::GetModule(_Deref_out_opt_ Microsoft::VisualStudio::Debugger::Symbols::DkmModule** ppValue)
{
    return Get645AD40C25493913B4F735C441506A16(this, ppValue);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmModuleInstance::SetDisabled(bool IsDisabled)
{
    return ProcEC7B013CEB23AA93633EDBA7FAB549B1(this, IsDisabled);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmModuleInstance::GetGPUDisassembly(UINT64 Address, UINT32 Count, bool IsForward, Microsoft::VisualStudio::Debugger::DkmArray<BYTE>* pDisassembly, bool* pIsEnd)
{
    return ProcA2068CD9D703B7D4CE4B42E82A5C761E(this, Address, Count, IsForward, pDisassembly, pIsEnd);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmModuleInstance::GetGPUDisassemblySize(UINT64* pSize)
{
    return Proc07E9A8763D0D6AD6ACDBED6ED0AFEC7A(this, pSize);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmModuleInstance::GetNextGPUInstructionAddress(UINT64 StartAddress, UINT64* pNextAddress)
{
    return Proc5CE38E6CF8E905E0A2FDD562AE2B9F6F(this, StartAddress, pNextAddress);
}

#ifndef EXCLUDE_MONITOR_ONLY_APIS
inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmModuleInstance::OnSymbolsLoaded(Microsoft::VisualStudio::Debugger::Symbols::DkmModule* pModule, bool IsReload)
{
    return Proc00D734DD81ACDC01605A9CFD79A152DD(this, pModule, IsReload);
}
#endif // #ifndef EXCLUDE_MONITOR_ONLY_APIS

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmModuleInstance::SetModule(Microsoft::VisualStudio::Debugger::Symbols::DkmModule* pModule, bool IsReload)
{
    return ProcA2A87FA9B2EABE057C973454C4D0E0FE(this, pModule, IsReload);
}

#ifndef EXCLUDE_MONITOR_ONLY_APIS
inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmModuleInstance::FlagAsTransitionModule()
{
    return Proc5A1A29171D03FC392A4795717141E0C3(this);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmModuleInstance::ClearTransitionModuleFlag()
{
    return Proc1880B774E3CEB4FFE43F3E5FFFFFC505(this);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmModuleInstance::IsTransitionModule(bool* pResult)
{
    return Proc4B179835811F44DCE0F243F176717948(this, pResult);
}
#endif // #ifndef EXCLUDE_MONITOR_ONLY_APIS

#ifndef EXCLUDE_IDE_ONLY_APIS
inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmModuleInstance::TryLoadBinary()
{
    return Proc0B9652121F6BC866281A1E15F8B76330(this);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmModuleInstance::TryLoadSymbols()
{
    return Proc34893D26C250199161E3A453FFEEF918(this);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmModuleInstance::GetSymbolStatusMessage(bool ExcludeCommonErrors, Microsoft::VisualStudio::Debugger::DkmString** ppStatus)
{
    return ProcE57162D15B9C4A9B50CAF4AF489C894F(this, ExcludeCommonErrors, ppStatus);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmModuleInstance::GetSymbolLoadInformation(Microsoft::VisualStudio::Debugger::DkmString** ppDescription)
{
    return ProcC2B6CE7C926FEA8B7BB1737D6705C84C(this, ppDescription);
}
#endif // #ifndef EXCLUDE_IDE_ONLY_APIS

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmModuleInstance::ReadSymbols(Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<BYTE>** ppSymbolBuffer)
{
    return Proc5411B0DDBEF94775850CBFCCE24FDAA0(this, ppSymbolBuffer);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmModuleInstance::Unload()
{
    return Proc1DF3FBE6FE204B1CB87244F8FE368C24(this);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmModuleInstance::OnSymbolsUpdated(Microsoft::VisualStudio::Debugger::Symbols::DkmModule* pModule)
{
    return Proc7C740EFAED2FCAE33007EF4EB2BCA3CF(this, pModule);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmModuleInstance::OnBinaryLoaded(Microsoft::VisualStudio::Debugger::DkmString* pPath)
{
    return Proc3FCE740432071F95E811C82C437CB8D0(this, pPath);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmModuleInstance::IsUserCode(bool* pIsUserCode)
{
    return ProcF386FCA16584C1EAE2CEB33B55A36BA3(this, pIsUserCode);
}

#ifndef EXCLUDE_MONITOR_ONLY_APIS
inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmModuleInstance::OnBinaryReloadOpportunity()
{
    return Proc52D5288CF84A94E56C713A4E2F5B6947(this);
}
#endif // #ifndef EXCLUDE_MONITOR_ONLY_APIS

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmModuleInstance::IsSuppressed(bool* pResult)
{
    return ProcA1906536FCD2F44CD6AADD9DF63D8C47(this, pResult);
}

#ifndef EXCLUDE_MONITOR_ONLY_APIS
inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmModuleInstance::OnModuleModified()
{
    return ProcA4A76835B9CD64AE968BA52BC84263FB(this);
}
#endif // #ifndef EXCLUDE_MONITOR_ONLY_APIS

_Ret_opt_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmString* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmModuleVersion::FileVersionString()
{
    return this->m_pFileVersionString;
}

_Ret_opt_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmString* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmModuleVersion::CompanyName()
{
    return this->m_pCompanyName;
}

inline DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmModuleVersion::FileVersionMS()
{
    return this->m_FileVersionMS;
}

inline DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmModuleVersion::FileVersionLS()
{
    return this->m_FileVersionLS;
}

inline DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmModuleVersion::ProductVersionMS()
{
    return this->m_ProductVersionMS;
}

inline DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmModuleVersion::ProductVersionLS()
{
    return this->m_ProductVersionLS;
}

inline DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmModuleVersion::VersionFlags()
{
    return this->m_VersionFlags;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmModuleVersion::Create(Microsoft::VisualStudio::Debugger::DkmString* pFileVersionString, Microsoft::VisualStudio::Debugger::DkmString* pCompanyName, UINT32 FileVersionMS, UINT32 FileVersionLS, UINT32 ProductVersionMS, UINT32 ProductVersionLS, UINT32 VersionFlags, Microsoft::VisualStudio::Debugger::DkmModuleVersion** ppCreatedObject)
{
    return Proc2717980A0CDDDFF0805419095281221C(pFileVersionString, pCompanyName, FileVersionMS, FileVersionLS, ProductVersionMS, ProductVersionLS, VersionFlags, ppCreatedObject);
}

#ifndef EXCLUDE_MONITOR_ONLY_APIS
_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmRuntimeInstance* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::CallStack::DkmMonitorStackWalkContext::RuntimeInstance()
{
    return this->m_pRuntimeInstance;
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmThread* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::CallStack::DkmMonitorStackWalkContext::Thread()
{
    return this->m_pThread;
}

_Ret_opt_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<BYTE>* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::CallStack::DkmMonitorStackWalkContext::ThreadContext()
{
    return this->m_pThreadContext;
}

inline DECLSPEC_NOTHROW const GUID& STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::CallStack::DkmMonitorStackWalkContext::UniqueId()
{
    return this->m_UniqueId;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::CallStack::DkmMonitorStackWalkContext::Close()
{
    return ProcDC7ED1E90FA2A6178BEA83BB0A11B501(this);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::CallStack::DkmMonitorStackWalkContext::Create(Microsoft::VisualStudio::Debugger::DkmRuntimeInstance* pRuntimeInstance, Microsoft::VisualStudio::Debugger::DkmThread* pThread, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<BYTE>* pThreadContext, const Microsoft::VisualStudio::Debugger::DkmDataItem& DataItem, Microsoft::VisualStudio::Debugger::CallStack::DkmMonitorStackWalkContext** ppCreatedObject)
{
    return ProcA29A9B6A00CD4E346ACD54992947A817(pRuntimeInstance, pThread, pThreadContext, DataItem, ppCreatedObject);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::CallStack::DkmMonitorStackWalkContext::Initialize(Microsoft::VisualStudio::Debugger::CallStack::DkmFrameRegisters* pRegisters, UINT32 StackRangeSize)
{
    return Proc2D82CAC96183DD7B6D1DF3394318FC27(this, pRegisters, StackRangeSize);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::CallStack::DkmMonitorStackWalkContext::UpdatePosition(Microsoft::VisualStudio::Debugger::CallStack::DkmFrameRegisters* pRegisters, UINT32 StackRangeSize)
{
    return Proc8A1248C3A4D0B316E04BDEB5C39F281A(this, pRegisters, StackRangeSize);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::CallStack::DkmMonitorStackWalkContext::WalkNextFrame(Microsoft::VisualStudio::Debugger::CallStack::DkmMonitorStackWalkResult* pResult)
{
    return Proc35BF8659E4F78CFC4EDCF9F8C35DCF25(this, pResult);
}
#endif // #ifndef EXCLUDE_MONITOR_ONLY_APIS

inline DECLSPEC_NOTHROW void STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::CallStack::DkmMonitorStackWalkResult::Release(Microsoft::VisualStudio::Debugger::CallStack::DkmMonitorStackWalkResult* pItem)
{
    return ProcF077EF6B9A532BB38F440A3E41457FEE(pItem);
}

inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::Native::DkmNativeAddressType_t STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Native::DkmNativeAddressMetadata::AddressType()
{
    return this->m_AddressType;
}

inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::Native::DkmNativeAddressStepType_t STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Native::DkmNativeAddressMetadata::StepType()
{
    return this->m_StepType;
}

inline DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Native::DkmNativeAddressMetadata::AddressTypeLength()
{
    return this->m_AddressTypeLength;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Native::DkmNativeAddressMetadata::Create(Microsoft::VisualStudio::Debugger::Native::DkmNativeAddressType_t AddressType, Microsoft::VisualStudio::Debugger::Native::DkmNativeAddressStepType_t StepType, UINT32 AddressTypeLength, Microsoft::VisualStudio::Debugger::Native::DkmNativeAddressMetadata** ppCreatedObject)
{
    return Proc3CC4BB810E58E0616B44FC6441DB2E43(AddressType, StepType, AddressTypeLength, ppCreatedObject);
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::Native::DkmNativeRuntimeInstance* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Native::DkmNativeInstructionAddress::RuntimeInstance()
{
    return static_cast<Microsoft::VisualStudio::Debugger::Native::DkmNativeRuntimeInstance*>(DkmInstructionAddress::RuntimeInstance());
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::Native::DkmNativeModuleInstance* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Native::DkmNativeInstructionAddress::ModuleInstance()
{
    return static_cast<Microsoft::VisualStudio::Debugger::Native::DkmNativeModuleInstance*>(DkmInstructionAddress::ModuleInstance());
}

inline DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Native::DkmNativeInstructionAddress::RVA()
{
    return this->m_RVA;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Native::DkmNativeInstructionAddress::Create(Microsoft::VisualStudio::Debugger::Native::DkmNativeRuntimeInstance* pRuntimeInstance, Microsoft::VisualStudio::Debugger::Native::DkmNativeModuleInstance* pModuleInstance, UINT32 RVA, const Microsoft::VisualStudio::Debugger::DkmInstructionAddress::CPUInstruction* pCPUInstruction, Microsoft::VisualStudio::Debugger::Native::DkmNativeInstructionAddress** ppCreatedObject)
{
    return Proc1EA107D7E0BFF457B5E6A661C838536A(pRuntimeInstance, pModuleInstance, RVA, pCPUInstruction, ppCreatedObject);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Native::DkmNativeInstructionAddress::FindNearestExport(Microsoft::VisualStudio::Debugger::DkmString** ppExportName, INT32* pByteOffset)
{
    return Proc918993F014B90FB01D72E7053BB1AAF2(this, ppExportName, pByteOffset);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Native::DkmNativeInstructionAddress::FindNearestExport(Microsoft::VisualStudio::Debugger::DkmWorkList* pWorkList, Microsoft::VisualStudio::Debugger::IDkmCompletionRoutine<Microsoft::VisualStudio::Debugger::Native::DkmFindNearestExportAsyncResult>* pCompletionRoutine)
{
    return Proc60E84CC95C998F0AD7E7E519F0209668(this, pWorkList, pCompletionRoutine);
}

#ifndef EXCLUDE_IDE_ONLY_APIS
inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Native::DkmNativeInstructionAddress::GetSteppingCallSites(const Microsoft::VisualStudio::Debugger::DkmArray<Microsoft::VisualStudio::Debugger::Symbols::DkmSteppingRange>& SteppingRanges, Microsoft::VisualStudio::Debugger::DkmArray<Microsoft::VisualStudio::Debugger::Stepping::DkmNativeSteppingCallSite*>* pCallSites)
{
    return Proc44EADD160F31BE6B3796FA9A467F646C(this, SteppingRanges, pCallSites);
}
#endif // #ifndef EXCLUDE_IDE_ONLY_APIS

inline DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Native::DkmNativeInstructionSymbol::RVA()
{
    return this->m_RVA;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Native::DkmNativeInstructionSymbol::Create(Microsoft::VisualStudio::Debugger::Symbols::DkmModule* pModule, UINT32 RVA, Microsoft::VisualStudio::Debugger::Native::DkmNativeInstructionSymbol** ppCreatedObject)
{
    return Proc62D0A91244300EC2F3874A30E936DF26(pModule, RVA, ppCreatedObject);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Native::DkmNativeInstructionSymbol::GetNativeInstructionMetadataCallback(Microsoft::VisualStudio::Debugger::DkmInstructionAddress* pInstructionAddress, Microsoft::VisualStudio::Debugger::Native::DkmNativeAddressMetadata** ppMetadata)
{
    return ProcA5DB4FF28172AC8EE337B4F616F0D8FC(this, pInstructionAddress, ppMetadata);
}

#ifndef EXCLUDE_MONITOR_ONLY_APIS
inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Native::DkmNativeInstructionSymbol::GetSteppingRanges(Microsoft::VisualStudio::Debugger::DkmModuleInstance* pModuleInstance, Microsoft::VisualStudio::Debugger::DkmInstructionAddress* pStepStartingAddress, Microsoft::VisualStudio::Debugger::Symbols::DkmSteppingRangeBoundary_t RangeBoundary, bool IncludeInline, Microsoft::VisualStudio::Debugger::DkmArray<Microsoft::VisualStudio::Debugger::Symbols::DkmSteppingRange>* pRanges)
{
    return Proc20C5AC2C29FFB6772842DB423E85767C(this, pModuleInstance, pStepStartingAddress, RangeBoundary, IncludeInline, pRanges);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Native::DkmNativeInstructionSymbol::GetSteppingNativeInstructionMetadata(Microsoft::VisualStudio::Debugger::DkmModuleInstance* pModuleInstance, Microsoft::VisualStudio::Debugger::DkmInstructionAddress* pStepStartingAddress, Microsoft::VisualStudio::Debugger::Native::DkmNativeAddressMetadata** ppMetadata)
{
    return Proc08CD058CAA9E5478B87D9248545A2D2E(this, pModuleInstance, pStepStartingAddress, ppMetadata);
}
#endif // #ifndef EXCLUDE_MONITOR_ONLY_APIS

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::Native::DkmNativeRuntimeInstance* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Native::DkmNativeModuleInstance::RuntimeInstance()
{
    return static_cast<Microsoft::VisualStudio::Debugger::Native::DkmNativeRuntimeInstance*>(DkmModuleInstance::RuntimeInstance());
}

inline DECLSPEC_NOTHROW UINT64 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Native::DkmNativeModuleInstance::BaseAddress()
{
    return static_cast<UINT64>(DkmModuleInstance::BaseAddress());
}

inline DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Native::DkmNativeModuleInstance::Size()
{
    return static_cast<UINT32>(DkmModuleInstance::Size());
}

inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::Clr::DkmClrHeaderStatus_t STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Native::DkmNativeModuleInstance::ClrHeaderStatus()
{
    return this->m_ClrHeaderStatus;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Native::DkmNativeModuleInstance::Create(Microsoft::VisualStudio::Debugger::DkmString* pName, Microsoft::VisualStudio::Debugger::DkmString* pFullName, UINT64 TimeDateStamp, Microsoft::VisualStudio::Debugger::DkmModuleVersion* pVersion, Microsoft::VisualStudio::Debugger::Symbols::DkmSymbolFileId* pSymbolFileId, Microsoft::VisualStudio::Debugger::DkmModuleFlags_t Flags, Microsoft::VisualStudio::Debugger::DkmModuleMemoryLayout_t MemoryLayout, UINT32 LoadOrder, Microsoft::VisualStudio::Debugger::DkmString* pLoadContext, Microsoft::VisualStudio::Debugger::Native::DkmNativeRuntimeInstance* pRuntimeInstance, UINT64 BaseAddress, UINT32 Size, Microsoft::VisualStudio::Debugger::Clr::DkmClrHeaderStatus_t ClrHeaderStatus, bool IsDisabled, Microsoft::VisualStudio::Debugger::Symbols::DkmModule* pModule, const Microsoft::VisualStudio::Debugger::DkmModuleInstance::MinidumpInfo* pMinidumpInfo, const Microsoft::VisualStudio::Debugger::DkmDataItem& DataItem, Microsoft::VisualStudio::Debugger::Native::DkmNativeModuleInstance** ppCreatedObject)
{
    return ProcB8D112804ACF0EF98486C2DBE47F5860(pName, pFullName, TimeDateStamp, pVersion, pSymbolFileId, Flags, MemoryLayout, LoadOrder, pLoadContext, pRuntimeInstance, BaseAddress, Size, ClrHeaderStatus, IsDisabled, pModule, pMinidumpInfo, DataItem, ppCreatedObject);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Native::DkmNativeModuleInstance::GetFunctionTableEntry(UINT64 Address, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<BYTE>** ppEntry)
{
    return Proc7C33005073B197E468D344B6CC30046F(this, Address, ppEntry);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Native::DkmNativeModuleInstance::FindExportName(Microsoft::VisualStudio::Debugger::DkmString* pName, bool IgnoreDataExports, Microsoft::VisualStudio::Debugger::Native::DkmNativeInstructionAddress** ppAddress)
{
    return Proc88303C178160F6B7A48F74A2AE8D50B5(this, pName, IgnoreDataExports, ppAddress);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Native::DkmNativeModuleInstance::FindExportName(Microsoft::VisualStudio::Debugger::DkmWorkList* pWorkList, Microsoft::VisualStudio::Debugger::DkmString* pName, bool IgnoreDataExports, Microsoft::VisualStudio::Debugger::IDkmCompletionRoutine<Microsoft::VisualStudio::Debugger::Native::DkmFindExportNameAsyncResult>* pCompletionRoutine)
{
    return Proc80A9F462958D3BF363A4E3F18DB01E46(this, pWorkList, pName, IgnoreDataExports, pCompletionRoutine);
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<Microsoft::VisualStudio::Debugger::Evaluation::DkmNativeReturnValueRegister*>* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmNativeRawReturnValue::Registers()
{
    return this->m_pRegisters;
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<BYTE>* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmNativeRawReturnValue::Memory()
{
    return this->m_pMemory;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmNativeRawReturnValue::Create(Microsoft::VisualStudio::Debugger::DkmInstructionAddress* pReturnFrom, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<Microsoft::VisualStudio::Debugger::Evaluation::DkmNativeReturnValueRegister*>* pRegisters, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<BYTE>* pMemory, Microsoft::VisualStudio::Debugger::Evaluation::DkmNativeRawReturnValue** ppCreatedObject)
{
    return ProcC6565F2B8739BF2909221336A3BBE9C6(pReturnFrom, pRegisters, pMemory, ppCreatedObject);
}

inline DECLSPEC_NOTHROW CV_HREG_e STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmNativeReturnValueRegister::Identifier()
{
    return this->m_Identifier;
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<BYTE>* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmNativeReturnValueRegister::Value()
{
    return this->m_pValue;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmNativeReturnValueRegister::Create(CV_HREG_e Identifier, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<BYTE>* pValue, Microsoft::VisualStudio::Debugger::Evaluation::DkmNativeReturnValueRegister** ppCreatedObject)
{
    return Proc12B8AEBDE8DC06ECC146022EFDF43BA0(Identifier, pValue, ppCreatedObject);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Native::DkmNativeRuntimeInstance::Create(Microsoft::VisualStudio::Debugger::DkmProcess* pProcess, const Microsoft::VisualStudio::Debugger::DkmRuntimeInstanceId& Id, const Microsoft::VisualStudio::Debugger::DkmDataItem& DataItem, Microsoft::VisualStudio::Debugger::Native::DkmNativeRuntimeInstance** ppCreatedObject)
{
    return Proc0C813EFC4A612A8F0E0975C93D9CA8B2(pProcess, Id, DataItem, ppCreatedObject);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Native::DkmNativeRuntimeInstance::Create(Microsoft::VisualStudio::Debugger::DkmProcess* pProcess, const Microsoft::VisualStudio::Debugger::DkmRuntimeInstanceId& Id, Microsoft::VisualStudio::Debugger::DkmRuntimeCapabilities_t Capabilities, Microsoft::VisualStudio::Debugger::DkmRuntimeInstance* pParentRuntime, const Microsoft::VisualStudio::Debugger::DkmDataItem& DataItem, Microsoft::VisualStudio::Debugger::Native::DkmNativeRuntimeInstance** ppCreatedObject)
{
    return ProcACB567FCFFFF620887A60A7FEDA08D1F(pProcess, Id, Capabilities, pParentRuntime, DataItem, ppCreatedObject);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Native::DkmNativeRuntimeInstance::FindNativeModuleInstance(UINT64 BaseAddress, Microsoft::VisualStudio::Debugger::Native::DkmNativeModuleInstance** ppNativeModuleInstance)
{
    return Proc32F748045CAE5D710346099F66C76CBF(this, BaseAddress, ppNativeModuleInstance);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Native::DkmNativeRuntimeInstance::GetNativeModuleInstances(Microsoft::VisualStudio::Debugger::DkmArray<Microsoft::VisualStudio::Debugger::Native::DkmNativeModuleInstance*>* pNativeModuleInstances)
{
    return ProcFD045CFE2611847953C966E4D4891465(this, pNativeModuleInstances);
}

#ifndef EXCLUDE_IDE_ONLY_APIS
inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Native::DkmNativeRuntimeInstance::ApplyCodeChange(const Microsoft::VisualStudio::Debugger::DkmArray<Microsoft::VisualStudio::Debugger::Native::DkmNativeInstructionAddress*>& ModifiedStackIPAddresses, const Microsoft::VisualStudio::Debugger::DkmArray<UINT32>& LineHints, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<Microsoft::VisualStudio::Debugger::DkmString*>** ppWarnings, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<Microsoft::VisualStudio::Debugger::DkmString*>** ppErrors)
{
    return ProcD01245BBCCF50A985F33D7F2B376C6A3(this, ModifiedStackIPAddresses, LineHints, ppWarnings, ppErrors);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Native::DkmNativeRuntimeInstance::CommitCodeChange(Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<Microsoft::VisualStudio::Debugger::DkmString*>** ppWarnings, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<Microsoft::VisualStudio::Debugger::DkmString*>** ppErrors)
{
    return ProcECA60A812FB3EBE489041C773FE06A85(this, ppWarnings, ppErrors);
}
#endif // #ifndef EXCLUDE_IDE_ONLY_APIS

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::Native::DkmNativeInstructionAddress* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Stepping::DkmNativeSteppingCallSite::CallSite()
{
    return this->m_pCallSite;
}

_Ret_opt_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::Native::DkmNativeInstructionAddress* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Stepping::DkmNativeSteppingCallSite::CallTarget()
{
    return this->m_pCallTarget;
}

_Ret_opt_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::Native::DkmNativeInstructionAddress* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Stepping::DkmNativeSteppingCallSite::CallTargetAddress()
{
    return this->m_pCallTargetAddress;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Stepping::DkmNativeSteppingCallSite::Create(Microsoft::VisualStudio::Debugger::Native::DkmNativeInstructionAddress* pCallSite, Microsoft::VisualStudio::Debugger::Native::DkmNativeInstructionAddress* pCallTarget, Microsoft::VisualStudio::Debugger::Native::DkmNativeInstructionAddress* pCallTargetAddress, Microsoft::VisualStudio::Debugger::Stepping::DkmNativeSteppingCallSite** ppCreatedObject)
{
    return Proc9712D292D3F561C85D575D1D1A169743(pCallSite, pCallTarget, pCallTargetAddress, ppCreatedObject);
}

inline DECLSPEC_NOTHROW const GUID& STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Symbols::DkmPdbFileId::Mvid()
{
    return this->m_Mvid;
}

inline DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Symbols::DkmPdbFileId::Age()
{
    return this->m_Age;
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmString* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Symbols::DkmPdbFileId::PdbName()
{
    return this->m_pPdbName;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Symbols::DkmPdbFileId::Create(const GUID& SymbolProviderId, const GUID& Mvid, UINT32 Age, Microsoft::VisualStudio::Debugger::DkmString* pPdbName, Microsoft::VisualStudio::Debugger::Symbols::DkmPdbFileId** ppCreatedObject)
{
    return ProcFD1ECC0384614A7BB087DDC735CC263F(SymbolProviderId, Mvid, Age, pPdbName, ppCreatedObject);
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmInstructionAddress* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Breakpoints::DkmPendingAddressBreakpoint::InstructionAddress()
{
    return this->m_pInstructionAddress;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Breakpoints::DkmPendingAddressBreakpoint::Create(const GUID& SourceId, const Microsoft::VisualStudio::Debugger::Evaluation::DkmCompilerId& CompilerId, Microsoft::VisualStudio::Debugger::DkmThread* pThread, bool IsBarrier, Microsoft::VisualStudio::Debugger::DkmInstructionAddress* pInstructionAddress, const Microsoft::VisualStudio::Debugger::DkmDataItem& DataItem, Microsoft::VisualStudio::Debugger::Breakpoints::DkmPendingAddressBreakpoint** ppCreatedObject)
{
    return ProcF0887F8CD77331C223C58112B02B3D06(SourceId, CompilerId, pThread, IsBarrier, pInstructionAddress, DataItem, ppCreatedObject);
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmString* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Breakpoints::DkmPendingAddressNameBreakpoint::ModuleName()
{
    return this->m_pModuleName;
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmString* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Breakpoints::DkmPendingAddressNameBreakpoint::AddressName()
{
    return this->m_pAddressName;
}

_Ret_opt_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmString* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Breakpoints::DkmPendingAddressNameBreakpoint::FunctionName()
{
    return this->m_pFunctionName;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Breakpoints::DkmPendingAddressNameBreakpoint::Create(Microsoft::VisualStudio::Debugger::DkmProcess* pProcess, const GUID& SourceId, const Microsoft::VisualStudio::Debugger::Evaluation::DkmCompilerId& CompilerId, Microsoft::VisualStudio::Debugger::DkmThread* pThread, bool IsBarrier, Microsoft::VisualStudio::Debugger::DkmString* pModuleName, Microsoft::VisualStudio::Debugger::DkmString* pAddressName, Microsoft::VisualStudio::Debugger::DkmString* pFunctionName, const Microsoft::VisualStudio::Debugger::DkmDataItem& DataItem, Microsoft::VisualStudio::Debugger::Breakpoints::DkmPendingAddressNameBreakpoint** ppCreatedObject)
{
    return Proc60332A18F85A4FFB428E5704BCDD2A1E(pProcess, SourceId, CompilerId, pThread, IsBarrier, pModuleName, pAddressName, pFunctionName, DataItem, ppCreatedObject);
}

inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::Breakpoints::DkmPendingBreakpoint::Tag_t STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Breakpoints::DkmPendingBreakpoint::TagValue()
{
    return this->m_TagValue;
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmProcess* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Breakpoints::DkmPendingBreakpoint::Process()
{
    return this->m_pProcess;
}

inline DECLSPEC_NOTHROW const GUID& STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Breakpoints::DkmPendingBreakpoint::UniqueId()
{
    return this->m_UniqueId;
}

inline DECLSPEC_NOTHROW const GUID& STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Breakpoints::DkmPendingBreakpoint::SourceId()
{
    return this->m_SourceId;
}

inline DECLSPEC_NOTHROW const Microsoft::VisualStudio::Debugger::Evaluation::DkmCompilerId& STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Breakpoints::DkmPendingBreakpoint::CompilerId()
{
    return this->m_CompilerId;
}

_Ret_opt_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmThread* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Breakpoints::DkmPendingBreakpoint::Thread()
{
    return this->m_pThread;
}

inline DECLSPEC_NOTHROW bool STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Breakpoints::DkmPendingBreakpoint::IsBarrier()
{
    return this->m_IsBarrier;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Breakpoints::DkmPendingBreakpoint::Close()
{
    return Proc4921BEC0D30D1765A57ECFF2126DBB4B(this);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Breakpoints::DkmPendingBreakpoint::GetBoundBreakpoints(Microsoft::VisualStudio::Debugger::DkmArray<Microsoft::VisualStudio::Debugger::Breakpoints::DkmBoundBreakpoint*>* pBoundBreakpoints)
{
    return ProcD1322FBC5A4F53CD71D904A9129D140F(this, pBoundBreakpoints);
}

#ifndef EXCLUDE_IDE_ONLY_APIS
inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Breakpoints::DkmPendingBreakpoint::Enable(Microsoft::VisualStudio::Debugger::DkmWorkList* pWorkList, Microsoft::VisualStudio::Debugger::IDkmCompletionRoutine<Microsoft::VisualStudio::Debugger::Breakpoints::DkmEnablePendingBreakpointAsyncResult>* pCompletionRoutine)
{
    return ProcA128E99A1AEAC21ACBFA950EE3F3B480(this, pWorkList, pCompletionRoutine);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Breakpoints::DkmPendingBreakpoint::Disable(Microsoft::VisualStudio::Debugger::DkmWorkList* pWorkList, Microsoft::VisualStudio::Debugger::IDkmCompletionRoutine<Microsoft::VisualStudio::Debugger::Breakpoints::DkmDisablePendingBreakpointAsyncResult>* pCompletionRoutine)
{
    return Proc3AA44FB37FBBCFFA6FBBE1CA72E86896(this, pWorkList, pCompletionRoutine);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Breakpoints::DkmPendingBreakpoint::Enroll(Microsoft::VisualStudio::Debugger::DkmWorkList* pWorkList, Microsoft::VisualStudio::Debugger::IDkmCompletionRoutine<Microsoft::VisualStudio::Debugger::Breakpoints::DkmEnrollPendingBreakpointAsyncResult>* pCompletionRoutine)
{
    return ProcEFEC79D1BCD21D1131F213381B99DD64(this, pWorkList, pCompletionRoutine);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Breakpoints::DkmPendingBreakpoint::SetCondition(Microsoft::VisualStudio::Debugger::DkmWorkList* pWorkList, Microsoft::VisualStudio::Debugger::Breakpoints::DkmBreakpointCondition* pCondition, Microsoft::VisualStudio::Debugger::IDkmCompletionRoutine<Microsoft::VisualStudio::Debugger::Breakpoints::DkmSetPendingBreakpointConditionAsyncResult>* pCompletionRoutine)
{
    return Proc477ABB8F3A0820484777E4374E219075(this, pWorkList, pCondition, pCompletionRoutine);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Breakpoints::DkmPendingBreakpoint::SetHitCountCondition(Microsoft::VisualStudio::Debugger::DkmWorkList* pWorkList, Microsoft::VisualStudio::Debugger::Breakpoints::DkmBreakpointHitCountCondition* pCondition, Microsoft::VisualStudio::Debugger::IDkmCompletionRoutine<Microsoft::VisualStudio::Debugger::Breakpoints::DkmSetPendingBreakpointHitCountConditionAsyncResult>* pCompletionRoutine)
{
    return Proc292FF758655DE22ECB36F4C74707AA8A(this, pWorkList, pCondition, pCompletionRoutine);
}
#endif // #ifndef EXCLUDE_IDE_ONLY_APIS

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Breakpoints::DkmPendingBreakpoint::OnBreakpointBound(const Microsoft::VisualStudio::Debugger::DkmArray<Microsoft::VisualStudio::Debugger::Breakpoints::DkmBoundBreakpoint*>& BoundBreakpoints)
{
    return ProcB460D8699FACB2F98617CEE663F430B5(this, BoundBreakpoints);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Breakpoints::DkmPendingBreakpoint::OnBreakpointUnbound(const Microsoft::VisualStudio::Debugger::DkmArray<Microsoft::VisualStudio::Debugger::Breakpoints::DkmBoundBreakpoint*>& BoundBreakpoints, Microsoft::VisualStudio::Debugger::Breakpoints::DkmBreakpointUnboundReason_t Reason)
{
    return ProcA9A34CABE5D34924B96CEC8E5546A656(this, BoundBreakpoints, Reason);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Breakpoints::DkmPendingBreakpoint::OnBreakpointMessage(Microsoft::VisualStudio::Debugger::Breakpoints::DkmBreakpointMessageLevel_t Level, Microsoft::VisualStudio::Debugger::DkmString* pMessage)
{
    return Proc99CA4912ED11CCD3CA63F744165160AB(this, Level, pMessage);
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmString* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Breakpoints::DkmPendingDataBreakpoint::DataElementLocation()
{
    return this->m_pDataElementLocation;
}

inline DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Breakpoints::DkmPendingDataBreakpoint::Size()
{
    return this->m_Size;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Breakpoints::DkmPendingDataBreakpoint::Create(Microsoft::VisualStudio::Debugger::DkmProcess* pProcess, const GUID& SourceId, const Microsoft::VisualStudio::Debugger::Evaluation::DkmCompilerId& CompilerId, Microsoft::VisualStudio::Debugger::DkmThread* pThread, bool IsBarrier, Microsoft::VisualStudio::Debugger::DkmString* pDataElementLocation, UINT32 Size, const Microsoft::VisualStudio::Debugger::DkmDataItem& DataItem, Microsoft::VisualStudio::Debugger::Breakpoints::DkmPendingDataBreakpoint** ppCreatedObject)
{
    return Proc8ECC658EC2242BE249FD192CBE25E53F(pProcess, SourceId, CompilerId, pThread, IsBarrier, pDataElementLocation, Size, DataItem, ppCreatedObject);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Breakpoints::DkmPendingFileLineBreakpoint::Create(Microsoft::VisualStudio::Debugger::DkmProcess* pProcess, const GUID& SourceId, const Microsoft::VisualStudio::Debugger::Evaluation::DkmCompilerId& CompilerId, Microsoft::VisualStudio::Debugger::DkmThread* pThread, bool IsBarrier, const Microsoft::VisualStudio::Debugger::DkmDataItem& DataItem, Microsoft::VisualStudio::Debugger::Breakpoints::DkmPendingFileLineBreakpoint** ppCreatedObject)
{
    return Proc6053B28C3096673FC90D26445A76528D(pProcess, SourceId, CompilerId, pThread, IsBarrier, DataItem, ppCreatedObject);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Breakpoints::DkmPendingFileLineBreakpoint::GetCurrentSourcePosition(Microsoft::VisualStudio::Debugger::Symbols::DkmSourcePosition** ppCurrentPosition)
{
    return Proc9B0261EA0FE6234EFD936CB4480EA78D(this, ppCurrentPosition);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Breakpoints::DkmPendingFileLineBreakpoint::GetCurrentSourceText(Microsoft::VisualStudio::Debugger::DkmString** ppCurrentText)
{
    return ProcF9D4693132F4DAF29D2D657F564DEF25(this, ppCurrentText);
}

_Ret_opt_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmString* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Breakpoints::DkmPendingFunctionBreakpoint::ModuleName()
{
    return this->m_pModuleName;
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmString* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Breakpoints::DkmPendingFunctionBreakpoint::FunctionName()
{
    return this->m_pFunctionName;
}

inline DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Breakpoints::DkmPendingFunctionBreakpoint::LineOffset()
{
    return this->m_LineOffset;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Breakpoints::DkmPendingFunctionBreakpoint::Create(Microsoft::VisualStudio::Debugger::DkmProcess* pProcess, const GUID& SourceId, const Microsoft::VisualStudio::Debugger::Evaluation::DkmCompilerId& CompilerId, Microsoft::VisualStudio::Debugger::DkmThread* pThread, bool IsBarrier, Microsoft::VisualStudio::Debugger::DkmString* pModuleName, Microsoft::VisualStudio::Debugger::DkmString* pFunctionName, UINT32 LineOffset, const Microsoft::VisualStudio::Debugger::DkmDataItem& DataItem, Microsoft::VisualStudio::Debugger::Breakpoints::DkmPendingFunctionBreakpoint** ppCreatedObject)
{
    return ProcE56F511514FFDB6E7EBB991014B63565(pProcess, SourceId, CompilerId, pThread, IsBarrier, pModuleName, pFunctionName, LineOffset, DataItem, ppCreatedObject);
}

inline DECLSPEC_NOTHROW UINT64 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmPointerValueHome::Address()
{
    return this->m_Address;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmPointerValueHome::Create(UINT64 Address, Microsoft::VisualStudio::Debugger::Evaluation::DkmPointerValueHome** ppCreatedObject)
{
    return ProcC2C38CE8A50D042DEED2E1DBADC5CB25(Address, ppCreatedObject);
}

_Ret_opt_ inline DECLSPEC_NOTHROW const Microsoft::VisualStudio::Debugger::DkmProcess::Live* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmProcess::LivePart()
{
    return this->m_pLive;
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DefaultPort::DkmTransportConnection* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmProcess::Connection()
{
    return this->m_pConnection;
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmString* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmProcess::Path()
{
    return this->m_pPath;
}

inline DECLSPEC_NOTHROW const GUID& STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmProcess::UniqueId()
{
    return this->m_UniqueId;
}

inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::Start::DkmStartMethod_t STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmProcess::StartMethod()
{
    return this->m_StartMethod;
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmEngineSettings* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmProcess::EngineSettings()
{
    return this->m_pEngineSettings;
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::Start::DkmDebugLaunchSettings* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmProcess::DebugLaunchSettings()
{
    return this->m_pDebugLaunchSettings;
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DefaultPort::DkmSystemInformation* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmProcess::SystemInformation()
{
    return this->m_pSystemInformation;
}

inline DECLSPEC_NOTHROW const GUID& STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmProcess::BaseDebugMonitorId()
{
    return this->m_BaseDebugMonitorId;
}

inline DECLSPEC_NOTHROW bool STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmProcess::IsAppPackage()
{
    // This method was introduced after the initial version of the API. The caller is
    // responsible for taking steps to ensure that this method is not called when running
    // against earlier versions of vsdebugeng.dll.
    ATLASSERT(DkmComponentManager::IsApiVersionSupported(DkmApiVersion::VS12RTM) || !"Invalid usage detected. Process will crash or bogus data will be returned");
    return this->m__pExtendedData->IsAppPackage;
}

inline DECLSPEC_NOTHROW bool STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmProcess::IsNativeDebuggingEnabled()
{
    return this->m_IsNativeDebuggingEnabled;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmProcess::FindProcess(const GUID& UniqueId, Microsoft::VisualStudio::Debugger::DkmProcess** ppProcess)
{
    return Proc3878B0A51524BC8FD74356AF6390338C(UniqueId, ppProcess);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmProcess::GetProcesses(Microsoft::VisualStudio::Debugger::DkmArray<Microsoft::VisualStudio::Debugger::DkmProcess*>* pProcesses)
{
    return Proc33E7E6971423BF9A85008A3E9CFD7DC9(pProcesses);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmProcess::Create(Microsoft::VisualStudio::Debugger::DefaultPort::DkmTransportConnection* pConnection, Microsoft::VisualStudio::Debugger::DkmString* pPath, const GUID& UniqueId, Microsoft::VisualStudio::Debugger::Start::DkmStartMethod_t StartMethod, Microsoft::VisualStudio::Debugger::DkmEngineSettings* pEngineSettings, Microsoft::VisualStudio::Debugger::Start::DkmDebugLaunchSettings* pDebugLaunchSettings, Microsoft::VisualStudio::Debugger::DefaultPort::DkmSystemInformation* pSystemInformation, const GUID& BaseDebugMonitorId, bool IsNativeDebuggingEnabled, const Microsoft::VisualStudio::Debugger::DkmProcess::Live* pLive, const Microsoft::VisualStudio::Debugger::DkmDataItem& DataItem, Microsoft::VisualStudio::Debugger::DkmProcess** ppCreatedObject)
{
    return ProcC475EB6F33F01CF8E23EBF14281DC9D5(pConnection, pPath, UniqueId, StartMethod, pEngineSettings, pDebugLaunchSettings, pSystemInformation, BaseDebugMonitorId, IsNativeDebuggingEnabled, pLive, DataItem, ppCreatedObject);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmProcess::Create(Microsoft::VisualStudio::Debugger::DefaultPort::DkmTransportConnection* pConnection, Microsoft::VisualStudio::Debugger::DkmString* pPath, const GUID& UniqueId, Microsoft::VisualStudio::Debugger::Start::DkmStartMethod_t StartMethod, Microsoft::VisualStudio::Debugger::DkmEngineSettings* pEngineSettings, Microsoft::VisualStudio::Debugger::Start::DkmDebugLaunchSettings* pDebugLaunchSettings, Microsoft::VisualStudio::Debugger::DefaultPort::DkmSystemInformation* pSystemInformation, const GUID& BaseDebugMonitorId, bool IsAppPackage, bool IsNativeDebuggingEnabled, const Microsoft::VisualStudio::Debugger::DkmProcess::Live* pLive, const Microsoft::VisualStudio::Debugger::DkmDataItem& DataItem, Microsoft::VisualStudio::Debugger::DkmProcess** ppCreatedObject)
{
    return Proc106265AC3459BC4D58F9E120E7890A5B(pConnection, pPath, UniqueId, StartMethod, pEngineSettings, pDebugLaunchSettings, pSystemInformation, BaseDebugMonitorId, IsAppPackage, IsNativeDebuggingEnabled, pLive, DataItem, ppCreatedObject);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmProcess::GetThreads(Microsoft::VisualStudio::Debugger::DkmArray<Microsoft::VisualStudio::Debugger::DkmThread*>* pThreads)
{
    return ProcC36364A347A1331856E21EB8986BAE70(this, pThreads);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmProcess::FindSystemThread(UINT32 Id, Microsoft::VisualStudio::Debugger::DkmThread** ppThread)
{
    return Proc271368D023C6928C09CB19546C3F1AD1(this, Id, ppThread);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmProcess::OnAsyncBreakComplete(Microsoft::VisualStudio::Debugger::DkmAsyncBreakStatus_t Status, Microsoft::VisualStudio::Debugger::DkmThread* pThread)
{
    return ProcED5672D2B090E000D7A7F7AD376C8B29(this, Status, pThread);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmProcess::GetPendingBreakpoints(Microsoft::VisualStudio::Debugger::DkmArray<Microsoft::VisualStudio::Debugger::Breakpoints::DkmPendingBreakpoint*>* pPendingBreakpoints)
{
    return Proc4A0E15FDF157B102C15D0945524E44EA(this, pPendingBreakpoints);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmProcess::FindRuntimeInstance(const Microsoft::VisualStudio::Debugger::DkmRuntimeInstanceId& Id, Microsoft::VisualStudio::Debugger::DkmRuntimeInstance** ppRuntimeInstance)
{
    return ProcE26FC60E9788891FD620E40D02F8214A(this, Id, ppRuntimeInstance);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmProcess::GetRuntimeInstances(Microsoft::VisualStudio::Debugger::DkmArray<Microsoft::VisualStudio::Debugger::DkmRuntimeInstance*>* pRuntimeInstances)
{
    return Proc6A4CB9E6ACE0329D50B59CB473BB5DA6(this, pRuntimeInstances);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmProcess::GetComputeKernels(Microsoft::VisualStudio::Debugger::DkmArray<Microsoft::VisualStudio::Debugger::GPU::DkmGPUComputeKernel*>* pComputeKernels)
{
    return Proc83904421FD75D950D0C529A5A96F888B(this, pComputeKernels);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmProcess::GetRuntimeFunctionResolutionRequests(Microsoft::VisualStudio::Debugger::DkmArray<Microsoft::VisualStudio::Debugger::FunctionResolution::DkmRuntimeFunctionResolutionRequest*>* pRuntimeFunctionResolutionRequests)
{
    return ProcFE2313088C600310FB7FB38145E2E44A(this, pRuntimeFunctionResolutionRequests);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmProcess::OnEntryPoint(Microsoft::VisualStudio::Debugger::DkmThread* pThread)
{
    return ProcDF334C7812DE5779F127659C7CD0F4FC(this, pThread);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmProcess::CreateNativeInstructionAddress(UINT64 InstructionPointer, Microsoft::VisualStudio::Debugger::DkmInstructionAddress** ppAddressObject)
{
    return Proc5A54344DA99A8E8110ED35DAA5DA2324(this, InstructionPointer, ppAddressObject);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmProcess::FindNativeModule(UINT64 Address, Microsoft::VisualStudio::Debugger::Native::DkmNativeModuleInstance** ppModuleInstance)
{
    return ProcF4FA5D54D06ED8FB9E7DEB680FC83C0D(this, Address, ppModuleInstance);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmProcess::FindNativeModule(UINT64 Address, bool IncludeDisabledModules, Microsoft::VisualStudio::Debugger::Native::DkmNativeModuleInstance** ppModuleInstance)
{
    return Proc8A6D7EC2A52F26AD397C691D3330A926(this, Address, IncludeDisabledModules, ppModuleInstance);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmProcess::AsyncBreak(bool StopImmediately)
{
    return ProcAF31D72F6E65E289D17CCB5D3D2F418F(this, StopImmediately);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmProcess::LocateBinary(Microsoft::VisualStudio::Debugger::DkmString* pApplicationPath, Microsoft::VisualStudio::Debugger::DkmString* pDumpPath, Microsoft::VisualStudio::Debugger::DkmString* pOriginalPath, UINT32 TimeDateStamp, UINT32 ImageSize, Microsoft::VisualStudio::Debugger::DkmString** ppFoundPath)
{
    return Proc1BA75E1240F3CFD277658D59B4759BAB(this, pApplicationPath, pDumpPath, pOriginalPath, TimeDateStamp, ImageSize, ppFoundPath);
}

#ifndef EXCLUDE_IDE_ONLY_APIS
inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmProcess::Disassemble(Microsoft::VisualStudio::Debugger::DkmInstructionAddress* pAddress, UINT32 Count, Microsoft::VisualStudio::Debugger::DkmArray<Microsoft::VisualStudio::Debugger::Disassembly::DkmDisassembledInstruction*>* pDisassembledInstructions)
{
    return Proc1BFA716C410EE92B5D9550D310574100(this, pAddress, Count, pDisassembledInstructions);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmProcess::GetInstructionAddress(Microsoft::VisualStudio::Debugger::DkmInstructionAddress* pStartAddress, INT32 InstructionOffset, Microsoft::VisualStudio::Debugger::DkmInstructionAddress** ppAddress)
{
    return Proc418F9EE0619D1B155F4CBF61E05C3742(this, pStartAddress, InstructionOffset, ppAddress);
}
#endif // #ifndef EXCLUDE_IDE_ONLY_APIS

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmProcess::WriteDump(Microsoft::VisualStudio::Debugger::DkmDumpType_t DumpType, Microsoft::VisualStudio::Debugger::DkmString* pPath, Microsoft::VisualStudio::Debugger::DkmThread* pTargetThread)
{
    return Proc78457549C84AD5A4D3E96DDC28B4A91D(this, DumpType, pPath, pTargetThread);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmProcess::AddExceptionTrigger(const GUID& SourceId, Microsoft::VisualStudio::Debugger::Exceptions::DkmExceptionTrigger* pTrigger)
{
    return Proc9FB80C6A3DB27E2C52259C3282AE46F7(this, SourceId, pTrigger);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmProcess::AddExceptionTrigger(Microsoft::VisualStudio::Debugger::DkmWorkList* pWorkList, const GUID& SourceId, Microsoft::VisualStudio::Debugger::Exceptions::DkmExceptionTrigger* pTrigger, Microsoft::VisualStudio::Debugger::IDkmCompletionRoutine<Microsoft::VisualStudio::Debugger::Exceptions::DkmAddExceptionTriggerAsyncResult>* pCompletionRoutine)
{
    return Proc433805FB32119EF9F52D897E3DB167CC(this, pWorkList, SourceId, pTrigger, pCompletionRoutine);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmProcess::ClearExceptionTriggers(const GUID& SourceId)
{
    return ProcD2F3BF5A81EA26B2F9702DE5AA7F854E(this, SourceId);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmProcess::SearchRuntimeFunctionTable(UINT64 Address, UINT64* pBaseAddress, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<BYTE>** ppFunctionTableEntry)
{
    return Proc94A9989CD07F6E368BE9234F2C761007(this, Address, pBaseAddress, ppFunctionTableEntry);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmProcess::GetGPUBreakpointBehavior(Microsoft::VisualStudio::Debugger::GPU::DkmGPUBreakpointBehaviorFlags_t* pBreakpointBehavior)
{
    return Proc2A48A9D77297CAE270C2A2DBC52F163B(this, pBreakpointBehavior);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmProcess::SetGPUMemoryAccessWarning(UINT32 WarningCode, bool Enable)
{
    return Proc221A1C16A0CA91E399F361A5B5A38AC9(this, WarningCode, Enable);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmProcess::ClearAllGPUMemoryAccessWarnings()
{
    return Proc8D47871CB4A49A7D7E9DB77822948CFD(this);
}

#ifndef EXCLUDE_IDE_ONLY_APIS
inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmProcess::GetInstructionAddress(Microsoft::VisualStudio::Debugger::DkmWorkList* pWorkList, UINT64 InstructionPointer, Microsoft::VisualStudio::Debugger::IDkmCompletionRoutine<Microsoft::VisualStudio::Debugger::DkmGetInstructionAddressAsyncResult>* pCompletionRoutine)
{
    return Proc9D6623C601DB3190377A91A37C7419B0(this, pWorkList, InstructionPointer, pCompletionRoutine);
}
#endif // #ifndef EXCLUDE_IDE_ONLY_APIS

#ifndef EXCLUDE_MONITOR_ONLY_APIS
inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmProcess::OnInstructionPatchInserted(UINT64 Address, const Microsoft::VisualStudio::Debugger::DkmArray<BYTE>& OriginalMemory)
{
    return ProcBBC3412E622A85C7A9C9A2B97362ACC4(this, Address, OriginalMemory);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmProcess::OnInstructionPatchRemoved(UINT64 Address, const Microsoft::VisualStudio::Debugger::DkmArray<BYTE>& OriginalMemory)
{
    return Proc6B1CD2F016C6DF558BBBB8943EC462EA(this, Address, OriginalMemory);
}
#endif // #ifndef EXCLUDE_MONITOR_ONLY_APIS

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmProcess::ReadMemory(UINT64 Address, Microsoft::VisualStudio::Debugger::DkmReadMemoryFlags_t Flags, void* pBuffer, UINT32 Size, UINT32* pBytesRead)
{
    return Proc43F8B1A71560988CDA93783A20518F4C(this, Address, Flags, pBuffer, Size, pBytesRead);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmProcess::ReadMemoryString(UINT64 Address, Microsoft::VisualStudio::Debugger::DkmReadMemoryFlags_t Flags, UINT16 CharacterSize, UINT32 MaxCharacters, Microsoft::VisualStudio::Debugger::DkmArray<BYTE>* pStringMemory)
{
    return ProcFB08A1C7BD77B71CAE548E8932D320E1(this, Address, Flags, CharacterSize, MaxCharacters, pStringMemory);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmProcess::WriteMemory(UINT64 Address, const Microsoft::VisualStudio::Debugger::DkmArray<BYTE>& Data)
{
    return ProcCB54C33EFFC65296BF4C0F6267CAF6B9(this, Address, Data);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmProcess::InvisibleWriteMemory(UINT64 Address, const Microsoft::VisualStudio::Debugger::DkmArray<BYTE>& Data)
{
    return Proc6918CAE6B208EA57C2B5EFC585308EA4(this, Address, Data);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmProcess::GetHandleCount(UINT32* pHandleCount)
{
    return Proc264596E3D714E689ED29EB416C0EDB59(this, pHandleCount);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmProcess::GetRunningTime(UINT64* pRunningTime)
{
    return Proc535260FC7FAE6E6D8632B4D1639CFB53(this, pRunningTime);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmProcess::SetRunningTime(UINT64 RunningTime)
{
    return Proc4013D302AF1F5E1D81F7B9F13E7BE15C(this, RunningTime);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmProcess::GetNativeRuntimeInstance(Microsoft::VisualStudio::Debugger::Native::DkmNativeRuntimeInstance** ppRuntimeInstance)
{
    return Proc9FA203E127EE0B8B16CF94D1DBF8F7E5(this, ppRuntimeInstance);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmProcess::Detach()
{
    return Proc6CE4E58CC03DB77D9C770472F95BCF46(this);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmProcess::Terminate(UINT32 ExitCode)
{
    return Proc47D4E3D46CE7EA40D78544A4E2F2CCCB(this, ExitCode);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmProcess::StoppingEventProcessingBegin(bool ForceQueue)
{
    return Proc7AB53941FD46A190C2C1AA3D528041D9(this, ForceQueue);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmProcess::StoppingEventProcessingContinue(Microsoft::VisualStudio::Debugger::DkmStoppingEventProcessingNextAction_t* pNextAction)
{
    return ProcD53F280F1F4958974C7D9C5765C56D3D(this, pNextAction);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmProcess::AbortingFuncEvalExecution(Microsoft::VisualStudio::Debugger::Evaluation::DkmFuncEvalFlags_t Flags)
{
    return Proc4DD206531745B166ED6A848124817007(this, Flags);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmProcess::IsStopped(bool* pResult)
{
    return ProcEC0AAA177C50B8CBA6F8BDF561155D7D(this, pResult);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmProcess::GetSystemThreads(Microsoft::VisualStudio::Debugger::DkmArray<Microsoft::VisualStudio::Debugger::DkmThread*>* pSystemThreads)
{
    return ProcFC48FDC6FDEA04D6E5196CF1CBEEE2E4(this, pSystemThreads);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmProcess::AllocateVirtualMemory(UINT64 Address, UINT32 Size, UINT32 AllocationType, UINT32 PageProtection, UINT64* pAllocatedAddress)
{
    return ProcA863A9CAB9B57E2180E37E0162F20CE1(this, Address, Size, AllocationType, PageProtection, pAllocatedAddress);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmProcess::FreeVirtualMemory(UINT64 Address, UINT32 Size, UINT32 FreeType)
{
    return Proc4C097F77E57173F0A64E1BC1D0723263(this, Address, Size, FreeType);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmProcess::VolatileReadMemory(UINT64 Address, void* pBuffer, UINT32 Size)
{
    return Proc38B421E6EE7506792532303AF2226FCE(this, Address, pBuffer, Size);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmProcess::VolatileWriteMemory(UINT64 Address, const Microsoft::VisualStudio::Debugger::DkmArray<BYTE>& Data)
{
    return Proc9DE0E3BEAA03DD17B309B44950EB2366(this, Address, Data);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmProcess::OnLoadComplete()
{
    return Proc1045230454C0D39659EA1D5AD3413E7E(this);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmProcess::Unload(UINT32 ExitCode)
{
    return Proc353AC2FCF8655B4292847535571BE6DA(this, ExitCode);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmProcess::TryLocateBinary(Microsoft::VisualStudio::Debugger::DkmString* pApplicationPath, Microsoft::VisualStudio::Debugger::DkmString* pDumpPath, Microsoft::VisualStudio::Debugger::DkmString* pOriginalPath, UINT32 TimeDateStamp, UINT32 ImageSize, Microsoft::VisualStudio::Debugger::DkmString** ppFoundPath)
{
    return Proc912C6A5D8C8520F4EE9D8D805F709792(this, pApplicationPath, pDumpPath, pOriginalPath, TimeDateStamp, ImageSize, ppFoundPath);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmProcess::GetDumpExePath(Microsoft::VisualStudio::Debugger::DkmString** ppExePath)
{
    return Proc0F286FA438BB0A3E8BE280B348C50768(this, ppExePath);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmProcess::IsLoadComplete(bool* pResult)
{
    return Proc4BCA75CF3D92FD0EA881A7C0933E56F6(this, pResult);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmProcess::GetStowedExceptions(Microsoft::VisualStudio::Debugger::DkmArray<Microsoft::VisualStudio::Debugger::Exceptions::DkmStowedExceptionInformation*>* pStowedExceptions)
{
    return Proc2C3E4F93686B031E62765DCF2E354C55(this, pStowedExceptions);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmProcess::GetNativeStowedException(Microsoft::VisualStudio::Debugger::Exceptions::DkmStowedExceptionInformation** ppNativeStowedException)
{
    return Proc11AE8BE85B54FCBEC61658A6EC5669AE(this, ppNativeStowedException);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmProcess::GetManagedStowedException(Microsoft::VisualStudio::Debugger::Exceptions::DkmStowedExceptionInformation** ppManagedStowedException)
{
    return Proc74C5490FBA85CA138364F8B0304B5527(this, ppManagedStowedException);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmProcess::OnHiddenEntryPoint(Microsoft::VisualStudio::Debugger::DkmThread* pThread)
{
    return ProcF0490F8C71F1B2038D9EFFE562E9CF9B(this, pThread);
}

#ifndef EXCLUDE_IDE_ONLY_APIS
inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmProcess::BeforeStopDebugging()
{
    return Proc3F1D247E5CBE9876F22B1D94330B371C(this);
}
#endif // #ifndef EXCLUDE_IDE_ONLY_APIS

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmProcess::SetDetachUnavailable(HRESULT ReasonCode)
{
    return Proc444AC9BCFD60B3815B326D50A57FB1A3(this, ReasonCode);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmProcess::RemoveExceptionTrigger(const GUID& SourceId, Microsoft::VisualStudio::Debugger::Exceptions::DkmExceptionTrigger* pTrigger)
{
    return ProcF9282C86885E264678A6962758BB80A6(this, SourceId, pTrigger);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmProcess::RemoveExceptionTrigger(Microsoft::VisualStudio::Debugger::DkmWorkList* pWorkList, const GUID& SourceId, Microsoft::VisualStudio::Debugger::Exceptions::DkmExceptionTrigger* pTrigger, Microsoft::VisualStudio::Debugger::IDkmCompletionRoutine<Microsoft::VisualStudio::Debugger::Exceptions::DkmRemoveExceptionTriggerAsyncResult>* pCompletionRoutine)
{
    return Proc9F4AAC0BCB8074D0750AA7E25A7605D6(this, pWorkList, SourceId, pTrigger, pCompletionRoutine);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmProcess::QueryPerformanceCounters(Microsoft::VisualStudio::Debugger::DkmWorkList* pWorkList, Microsoft::VisualStudio::Debugger::IDkmCompletionRoutine<Microsoft::VisualStudio::Debugger::DkmPerformanceCountersAsyncResult>* pCompletionRoutine)
{
    return ProcDE09D55133C268C263EACD3C416BF51B(this, pWorkList, pCompletionRoutine);
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DefaultPort::DkmTransportConnection* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Start::DkmProcessAttachRequest::Connection()
{
    return this->m_pConnection;
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmString* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Start::DkmProcessAttachRequest::Path()
{
    return this->m_pPath;
}

inline DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Start::DkmProcessAttachRequest::ProcessId()
{
    return this->m_ProcessId;
}

inline DECLSPEC_NOTHROW const GUID& STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Start::DkmProcessAttachRequest::UniqueProcessId()
{
    return this->m_UniqueProcessId;
}

inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::Start::DkmStartMethod_t STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Start::DkmProcessAttachRequest::StartMethod()
{
    return this->m_StartMethod;
}

inline DECLSPEC_NOTHROW const GUID& STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Start::DkmProcessAttachRequest::HostingProcessLanguage()
{
    return this->m_HostingProcessLanguage;
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmEngineSettings* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Start::DkmProcessAttachRequest::EngineSettings()
{
    return this->m_pEngineSettings;
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::Start::DkmDebugLaunchSettings* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Start::DkmProcessAttachRequest::DebugLaunchSettings()
{
    return this->m_pDebugLaunchSettings;
}

inline DECLSPEC_NOTHROW UINT64 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Start::DkmProcessAttachRequest::StartTime()
{
    // This method was introduced after the initial version of the API. The caller is
    // responsible for taking steps to ensure that this method is not called when running
    // against earlier versions of vsdebugeng.dll.
    ATLASSERT(DkmComponentManager::IsApiVersionSupported(DkmApiVersion::VS14RTM) || !"Invalid usage detected. Process will crash or bogus data will be returned");
    return this->m__pExtendedData->StartTime;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Start::DkmProcessAttachRequest::Create(Microsoft::VisualStudio::Debugger::DefaultPort::DkmTransportConnection* pConnection, Microsoft::VisualStudio::Debugger::DkmString* pPath, UINT32 ProcessId, const GUID& UniqueProcessId, Microsoft::VisualStudio::Debugger::Start::DkmStartMethod_t StartMethod, const GUID& HostingProcessLanguage, Microsoft::VisualStudio::Debugger::DkmEngineSettings* pEngineSettings, Microsoft::VisualStudio::Debugger::Start::DkmDebugLaunchSettings* pDebugLaunchSettings, Microsoft::VisualStudio::Debugger::Start::DkmProcessAttachRequest** ppCreatedObject)
{
    return Proc95205A6BC436A6D493CD550A588C10F8(pConnection, pPath, ProcessId, UniqueProcessId, StartMethod, HostingProcessLanguage, pEngineSettings, pDebugLaunchSettings, ppCreatedObject);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Start::DkmProcessAttachRequest::Create(Microsoft::VisualStudio::Debugger::DefaultPort::DkmTransportConnection* pConnection, Microsoft::VisualStudio::Debugger::DkmString* pPath, UINT32 ProcessId, const GUID& UniqueProcessId, Microsoft::VisualStudio::Debugger::Start::DkmStartMethod_t StartMethod, const GUID& HostingProcessLanguage, Microsoft::VisualStudio::Debugger::DkmEngineSettings* pEngineSettings, Microsoft::VisualStudio::Debugger::Start::DkmDebugLaunchSettings* pDebugLaunchSettings, UINT64 StartTime, Microsoft::VisualStudio::Debugger::Start::DkmProcessAttachRequest** ppCreatedObject)
{
    return ProcEED23EBC51D0283776E53E11AC6B53AD(pConnection, pPath, ProcessId, UniqueProcessId, StartMethod, HostingProcessLanguage, pEngineSettings, pDebugLaunchSettings, StartTime, ppCreatedObject);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Start::DkmProcessAttachRequest::AttachToProcess(Microsoft::VisualStudio::Debugger::DkmProcess** ppProcess)
{
    return Proc609FC4C1EFA5159E8A99CB48C4A049B6(this, ppProcess);
}

#ifndef EXCLUDE_MONITOR_ONLY_APIS
inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Start::DkmProcessLaunchEnvironmentFilterList::GetAdditionalEnvironmentVariables(UINT32 ImplementationIndex, Microsoft::VisualStudio::Debugger::Start::DkmDebugLaunchSettings* pDebugLaunchSettings, Microsoft::VisualStudio::Debugger::Start::DkmProcessLaunchEnvironmentFilterScenario_t Scenario, Microsoft::VisualStudio::Debugger::DkmString** ppAdditionalEnvironmentBlock)
{
    return ProcF505EE31F3B51D5736BBC626A76BFA18(this, ImplementationIndex, pDebugLaunchSettings, Scenario, ppAdditionalEnvironmentBlock);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Start::DkmProcessLaunchEnvironmentFilterList::Create(Microsoft::VisualStudio::Debugger::Start::DkmProcessLaunchEnvironmentFilterList** ppCreatedObject)
{
    return Proc7E7DA05F4F334A3C130300B9DE219574(ppCreatedObject);
}
#endif // #ifndef EXCLUDE_MONITOR_ONLY_APIS
_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmString* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Start::DkmProcessLaunchRequest::FileName()
{
    return this->m_pFileName;
}

_Ret_opt_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmString* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Start::DkmProcessLaunchRequest::Arguments()
{
    return this->m_pArguments;
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmString* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Start::DkmProcessLaunchRequest::WorkingDirectory()
{
    return this->m_pWorkingDirectory;
}

_Ret_opt_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmString* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Start::DkmProcessLaunchRequest::Environment()
{
    return this->m_pEnvironment;
}

_Ret_opt_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::Start::DkmProcessStartupInfo* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Start::DkmProcessLaunchRequest::StartupInfo()
{
    return this->m_pStartupInfo;
}

inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::Start::DkmProcessLaunchModeFlags_t STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Start::DkmProcessLaunchRequest::ModeFlags()
{
    return this->m_ModeFlags;
}

inline DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Start::DkmProcessLaunchRequest::Win32Flags()
{
    return this->m_Win32Flags;
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DefaultPort::DkmTransportConnection* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Start::DkmProcessLaunchRequest::Connection()
{
    return this->m_pConnection;
}

inline DECLSPEC_NOTHROW const GUID& STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Start::DkmProcessLaunchRequest::UniqueId()
{
    return this->m_UniqueId;
}

_Ret_opt_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmEngineSettings* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Start::DkmProcessLaunchRequest::EngineSettings()
{
    return this->m_pEngineSettings;
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::Start::DkmDebugLaunchSettings* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Start::DkmProcessLaunchRequest::DebugLaunchSettings()
{
    return this->m_pDebugLaunchSettings;
}

inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::Start::DkmProcessLaunchFlags_t STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Start::DkmProcessLaunchRequest::LaunchFlags()
{
    // This method was introduced after the initial version of the API. The caller is
    // responsible for taking steps to ensure that this method is not called when running
    // against earlier versions of vsdebugeng.dll.
    ATLASSERT(DkmComponentManager::IsApiVersionSupported(DkmApiVersion::VS14RTM) || !"Invalid usage detected. Process will crash or bogus data will be returned");
    return this->m__pExtendedData->LaunchFlags;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Start::DkmProcessLaunchRequest::Close()
{
    return Proc133D28FFA03AD3445985EA795062324F(this);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Start::DkmProcessLaunchRequest::Create(Microsoft::VisualStudio::Debugger::DkmString* pFileName, Microsoft::VisualStudio::Debugger::DkmString* pArguments, Microsoft::VisualStudio::Debugger::DkmString* pWorkingDirectory, Microsoft::VisualStudio::Debugger::DkmString* pEnvironment, Microsoft::VisualStudio::Debugger::Start::DkmProcessStartupInfo* pStartupInfo, Microsoft::VisualStudio::Debugger::Start::DkmProcessLaunchModeFlags_t ModeFlags, UINT32 Win32Flags, Microsoft::VisualStudio::Debugger::DefaultPort::DkmTransportConnection* pConnection, Microsoft::VisualStudio::Debugger::DkmEngineSettings* pEngineSettings, Microsoft::VisualStudio::Debugger::Start::DkmDebugLaunchSettings* pDebugLaunchSettings, const Microsoft::VisualStudio::Debugger::DkmDataItem& DataItem, Microsoft::VisualStudio::Debugger::Start::DkmProcessLaunchRequest** ppCreatedObject)
{
    return ProcCE60681703B6B3BE0727ACD155F1F4B0(pFileName, pArguments, pWorkingDirectory, pEnvironment, pStartupInfo, ModeFlags, Win32Flags, pConnection, pEngineSettings, pDebugLaunchSettings, DataItem, ppCreatedObject);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Start::DkmProcessLaunchRequest::Create(Microsoft::VisualStudio::Debugger::DkmString* pFileName, Microsoft::VisualStudio::Debugger::DkmString* pArguments, Microsoft::VisualStudio::Debugger::DkmString* pWorkingDirectory, Microsoft::VisualStudio::Debugger::DkmString* pEnvironment, Microsoft::VisualStudio::Debugger::Start::DkmProcessStartupInfo* pStartupInfo, Microsoft::VisualStudio::Debugger::Start::DkmProcessLaunchModeFlags_t ModeFlags, UINT32 Win32Flags, Microsoft::VisualStudio::Debugger::DefaultPort::DkmTransportConnection* pConnection, Microsoft::VisualStudio::Debugger::DkmEngineSettings* pEngineSettings, Microsoft::VisualStudio::Debugger::Start::DkmDebugLaunchSettings* pDebugLaunchSettings, Microsoft::VisualStudio::Debugger::Start::DkmProcessLaunchFlags_t LaunchFlags, const Microsoft::VisualStudio::Debugger::DkmDataItem& DataItem, Microsoft::VisualStudio::Debugger::Start::DkmProcessLaunchRequest** ppCreatedObject)
{
    return Proc626F2CDEB514881451E5BC89AD48ABC9(pFileName, pArguments, pWorkingDirectory, pEnvironment, pStartupInfo, ModeFlags, Win32Flags, pConnection, pEngineSettings, pDebugLaunchSettings, LaunchFlags, DataItem, ppCreatedObject);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Start::DkmProcessLaunchRequest::LaunchProcess(UINT32 AdditionalWin32Flags, Microsoft::VisualStudio::Debugger::Start::DkmLaunchedProcessInfo* pLaunchedProcess)
{
    return ProcEE04EDDA44575ACCE2D895843CC5E455(this, AdditionalWin32Flags, pLaunchedProcess);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Start::DkmProcessLaunchRequest::ResumeProcess()
{
    return Proc92D5E0C5D4EAF1F319BEA651257EFED6(this);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Start::DkmProcessLaunchRequest::LaunchDebuggedProcess(Microsoft::VisualStudio::Debugger::Start::DkmLaunchedProcessInfo* pLaunchedProcess)
{
    return ProcB93000BE4745096FE67A3B4F7FC0E930(this, pLaunchedProcess);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Start::DkmProcessLaunchRequest::ResumeDebuggedProcess(const GUID& UniqueProcessId, Microsoft::VisualStudio::Debugger::DkmProcess** ppProcess)
{
    return Proc048095810FEB921258184BC243942C8C(this, UniqueProcessId, ppProcess);
}

_Ret_opt_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmString* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Start::DkmProcessStartupInfo::Desktop()
{
    return this->m_pDesktop;
}

_Ret_opt_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmString* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Start::DkmProcessStartupInfo::Title()
{
    return this->m_pTitle;
}

inline DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Start::DkmProcessStartupInfo::X()
{
    return this->m_X;
}

inline DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Start::DkmProcessStartupInfo::Y()
{
    return this->m_Y;
}

inline DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Start::DkmProcessStartupInfo::XSize()
{
    return this->m_XSize;
}

inline DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Start::DkmProcessStartupInfo::YSize()
{
    return this->m_YSize;
}

inline DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Start::DkmProcessStartupInfo::XCountChars()
{
    return this->m_XCountChars;
}

inline DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Start::DkmProcessStartupInfo::YCountChars()
{
    return this->m_YCountChars;
}

inline DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Start::DkmProcessStartupInfo::FillAttribute()
{
    return this->m_FillAttribute;
}

inline DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Start::DkmProcessStartupInfo::Flags()
{
    return this->m_Flags;
}

inline DECLSPEC_NOTHROW UINT16 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Start::DkmProcessStartupInfo::ShowWindow()
{
    return this->m_ShowWindow;
}

inline DECLSPEC_NOTHROW UINT64 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Start::DkmProcessStartupInfo::StdInputHandle()
{
    return this->m_StdInputHandle;
}

inline DECLSPEC_NOTHROW UINT64 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Start::DkmProcessStartupInfo::StdOutputHandle()
{
    return this->m_StdOutputHandle;
}

inline DECLSPEC_NOTHROW UINT64 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Start::DkmProcessStartupInfo::StdErrorHandle()
{
    return this->m_StdErrorHandle;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Start::DkmProcessStartupInfo::Create(Microsoft::VisualStudio::Debugger::DkmString* pDesktop, Microsoft::VisualStudio::Debugger::DkmString* pTitle, UINT32 X, UINT32 Y, UINT32 XSize, UINT32 YSize, UINT32 XCountChars, UINT32 YCountChars, UINT32 FillAttribute, UINT32 Flags, UINT16 ShowWindow, UINT64 StdInputHandle, UINT64 StdOutputHandle, UINT64 StdErrorHandle, Microsoft::VisualStudio::Debugger::Start::DkmProcessStartupInfo** ppCreatedObject)
{
    return ProcA8FADDCF3708A1A38F469A40A28BA3B8(pDesktop, pTitle, X, Y, XSize, YSize, XCountChars, YCountChars, FillAttribute, Flags, ShowWindow, StdInputHandle, StdOutputHandle, StdErrorHandle, ppCreatedObject);
}

inline DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Internal::DkmPropertyProxy::Id()
{
    return this->m_Id;
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::Evaluation::DkmSuccessEvaluationResult* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Internal::DkmPropertyProxy::EvaluationResult()
{
    return this->m_pEvaluationResult;
}

inline DECLSPEC_NOTHROW const GUID& STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Internal::DkmPropertyProxy::UniqueId()
{
    return this->m_UniqueId;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Internal::DkmPropertyProxy::Create(UINT32 Id, Microsoft::VisualStudio::Debugger::Evaluation::DkmSuccessEvaluationResult* pEvaluationResult, const Microsoft::VisualStudio::Debugger::DkmDataItem& DataItem, Microsoft::VisualStudio::Debugger::Internal::DkmPropertyProxy** ppCreatedObject)
{
    return Proc5E7FD8F8CCFD4B162EAF3C29B5240CD8(Id, pEvaluationResult, DataItem, ppCreatedObject);
}

#ifndef EXCLUDE_IDE_ONLY_APIS
inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Internal::DkmPropertyProxy::InitSourceDataProvider(Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<BYTE>** ppDataOut)
{
    return ProcAC74F0017B56DBED5A20E546C72C4091(this, ppDataOut);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Internal::DkmPropertyProxy::GetManagedViewerCreationData(Microsoft::VisualStudio::Debugger::DkmString** ppAssemblyName, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<BYTE>** ppAssemblyBytes, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<BYTE>** ppAssemblyPdb, Microsoft::VisualStudio::Debugger::DkmString** ppClassName, UINT32* pAssemblyResolution, bool* pReplacementOk)
{
    return ProcD00A582A8E46FA8DA5A6390AC691465D(this, ppAssemblyName, ppAssemblyBytes, ppAssemblyPdb, ppClassName, pAssemblyResolution, pReplacementOk);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Internal::DkmPropertyProxy::InPlaceUpdateObject(const Microsoft::VisualStudio::Debugger::DkmArray<BYTE>& DataIn, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<BYTE>** ppDataOut)
{
    return ProcC17D73FF4688C3A6F221FDC45D39BEFA(this, DataIn, ppDataOut);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Internal::DkmPropertyProxy::ResolveAssemblyReference(Microsoft::VisualStudio::Debugger::DkmString* pAssemblyName, UINT32 Flags, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<BYTE>** ppAssemblyBytes, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<BYTE>** ppAssemblyPdb, Microsoft::VisualStudio::Debugger::DkmString** ppAssemblyLocation, UINT32* pAssemblyResolution)
{
    return Proc24A65EB99D5591E0DD35D8B55E0614F8(this, pAssemblyName, Flags, ppAssemblyBytes, ppAssemblyPdb, ppAssemblyLocation, pAssemblyResolution);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Internal::DkmPropertyProxy::GetInitialData(Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<BYTE>** ppDataOut)
{
    return Proc53BD85DE362C9852CF729B63A0D58D8B(this, ppDataOut);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Internal::DkmPropertyProxy::CreateReplacementObject(const Microsoft::VisualStudio::Debugger::DkmArray<BYTE>& DataIn, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<BYTE>** ppDataOut)
{
    return Proc7E66F613557B51733EA6A6D6A87087D7(this, DataIn, ppDataOut);
}
#endif // #ifndef EXCLUDE_IDE_ONLY_APIS

_Ret_opt_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmString* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DefaultPort::DkmPublishedProgramInfo::FriendlyName()
{
    return this->m_pFriendlyName;
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<GUID>* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DefaultPort::DkmPublishedProgramInfo::EngineIds()
{
    return this->m_pEngineIds;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DefaultPort::DkmPublishedProgramInfo::Create(Microsoft::VisualStudio::Debugger::DkmString* pFriendlyName, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<GUID>* pEngineIds, Microsoft::VisualStudio::Debugger::DefaultPort::DkmPublishedProgramInfo** ppCreatedObject)
{
    return Proc302B29EB2B5017008BE1DC136F1ED5EE(pFriendlyName, pEngineIds, ppCreatedObject);
}

inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::Evaluation::DkmRawReturnValue::Tag_t STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmRawReturnValue::TagValue()
{
    return this->m_TagValue;
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmInstructionAddress* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmRawReturnValue::ReturnFrom()
{
    return this->m_pReturnFrom;
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::Symbols::DkmModule* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Symbols::DkmResolvedDocument::Module()
{
    return this->m_pModule;
}

inline DECLSPEC_NOTHROW const GUID& STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Symbols::DkmResolvedDocument::UniqueId()
{
    return this->m_UniqueId;
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmString* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Symbols::DkmResolvedDocument::DocumentName()
{
    return this->m_pDocumentName;
}

_Ret_opt_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::Script::DkmScriptDocument* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Symbols::DkmResolvedDocument::ScriptDocument()
{
    return this->m_pScriptDocument;
}

inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::Symbols::DkmDocumentMatchStrength_t STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Symbols::DkmResolvedDocument::MatchStrength()
{
    return this->m_MatchStrength;
}

inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::Symbols::DkmResolvedDocumentWarning_t STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Symbols::DkmResolvedDocument::Warning()
{
    return this->m_Warning;
}

inline DECLSPEC_NOTHROW bool STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Symbols::DkmResolvedDocument::TextRequested()
{
    return this->m_TextRequested;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Symbols::DkmResolvedDocument::Close()
{
    return Proc2DB31E954D2ED062F8C66B849EE60429(this);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Symbols::DkmResolvedDocument::Create(Microsoft::VisualStudio::Debugger::Symbols::DkmModule* pModule, Microsoft::VisualStudio::Debugger::DkmString* pDocumentName, Microsoft::VisualStudio::Debugger::Script::DkmScriptDocument* pScriptDocument, Microsoft::VisualStudio::Debugger::Symbols::DkmDocumentMatchStrength_t MatchStrength, Microsoft::VisualStudio::Debugger::Symbols::DkmResolvedDocumentWarning_t Warning, bool TextRequested, const Microsoft::VisualStudio::Debugger::DkmDataItem& DataItem, Microsoft::VisualStudio::Debugger::Symbols::DkmResolvedDocument** ppCreatedObject)
{
    return Proc4E2ECDABAF53878BC2CB86BB0CA5DE92(pModule, pDocumentName, pScriptDocument, MatchStrength, Warning, TextRequested, DataItem, ppCreatedObject);
}

#ifndef EXCLUDE_IDE_ONLY_APIS
inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Symbols::DkmResolvedDocument::FindSymbols(const Microsoft::VisualStudio::Debugger::Symbols::DkmTextSpan& TextSpan, Microsoft::VisualStudio::Debugger::DkmString* pText, Microsoft::VisualStudio::Debugger::DkmArray<Microsoft::VisualStudio::Debugger::Symbols::DkmInstructionSymbol*>* pInstructionSymbols, Microsoft::VisualStudio::Debugger::DkmArray<Microsoft::VisualStudio::Debugger::Symbols::DkmSourcePosition*>* pSymbolLocation)
{
    return Proc1A9C348A582748AB15065E17A667A486(this, TextSpan, pText, pInstructionSymbols, pSymbolLocation);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Symbols::DkmResolvedDocument::FindSymbols(Microsoft::VisualStudio::Debugger::DkmWorkList* pWorkList, const Microsoft::VisualStudio::Debugger::Symbols::DkmTextSpan& TextSpan, Microsoft::VisualStudio::Debugger::DkmString* pText, Microsoft::VisualStudio::Debugger::IDkmCompletionRoutine<Microsoft::VisualStudio::Debugger::Symbols::DkmFindSymbolsAsyncResult>* pCompletionRoutine)
{
    return ProcB9407B9EAA35C920D32759FE968A25CA(this, pWorkList, TextSpan, pText, pCompletionRoutine);
}
#endif // #ifndef EXCLUDE_IDE_ONLY_APIS

_Ret_opt_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<Microsoft::VisualStudio::Debugger::Script::DkmScriptBlockMappingInfo*>* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Symbols::DkmResolvedMappedDocument::ScriptBlocks()
{
    return this->m_pScriptBlocks;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Symbols::DkmResolvedMappedDocument::Create(Microsoft::VisualStudio::Debugger::Symbols::DkmModule* pModule, Microsoft::VisualStudio::Debugger::DkmString* pDocumentName, Microsoft::VisualStudio::Debugger::Script::DkmScriptDocument* pScriptDocument, Microsoft::VisualStudio::Debugger::Symbols::DkmDocumentMatchStrength_t MatchStrength, Microsoft::VisualStudio::Debugger::Symbols::DkmResolvedDocumentWarning_t Warning, bool TextRequested, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<Microsoft::VisualStudio::Debugger::Script::DkmScriptBlockMappingInfo*>* pScriptBlocks, const Microsoft::VisualStudio::Debugger::DkmDataItem& DataItem, Microsoft::VisualStudio::Debugger::Symbols::DkmResolvedMappedDocument** ppCreatedObject)
{
    return Proc00BCCC33F43438DB686C5A05BE34F2E9(pModule, pDocumentName, pScriptDocument, MatchStrength, Warning, TextRequested, pScriptBlocks, DataItem, ppCreatedObject);
}

_Ret_opt_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::Symbols::DkmModule* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmRootVisualizedExpression::Module()
{
    return this->m_pModule;
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmString* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmRootVisualizedExpression::Name()
{
    return this->m_pName;
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmString* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmRootVisualizedExpression::FullName()
{
    return this->m_pFullName;
}

inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::Evaluation::DkmRootVisualizedExpressionFlags_t STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmRootVisualizedExpression::Flags()
{
    return this->m_Flags;
}

inline DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmRootVisualizedExpression::ArrayLength()
{
    return this->m_ArrayLength;
}

_Ret_opt_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmString* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmRootVisualizedExpression::Type()
{
    // This method was introduced after the initial version of the API. The caller is
    // responsible for taking steps to ensure that this method is not called when running
    // against earlier versions of vsdebugeng.dll.
    ATLASSERT(DkmComponentManager::IsApiVersionSupported(DkmApiVersion::VS14RTM) || !"Invalid usage detected. Process will crash or bogus data will be returned");
    return this->m__pExtendedData->pType;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmRootVisualizedExpression::Create(Microsoft::VisualStudio::Debugger::Evaluation::DkmInspectionContext* pInspectionContext, const GUID& VisualizerId, const GUID& SourceId, Microsoft::VisualStudio::Debugger::CallStack::DkmStackWalkFrame* pStackFrame, Microsoft::VisualStudio::Debugger::Evaluation::DkmExpressionValueHome* pValueHome, Microsoft::VisualStudio::Debugger::Symbols::DkmModule* pModule, Microsoft::VisualStudio::Debugger::DkmString* pName, Microsoft::VisualStudio::Debugger::DkmString* pFullName, Microsoft::VisualStudio::Debugger::Evaluation::DkmRootVisualizedExpressionFlags_t Flags, UINT32 ArrayLength, const Microsoft::VisualStudio::Debugger::DkmDataItem& DataItem, Microsoft::VisualStudio::Debugger::Evaluation::DkmRootVisualizedExpression** ppCreatedObject)
{
    return ProcE236B855866DB4A74880D6FEA3185901(pInspectionContext, VisualizerId, SourceId, pStackFrame, pValueHome, pModule, pName, pFullName, Flags, ArrayLength, DataItem, ppCreatedObject);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmRootVisualizedExpression::Create(Microsoft::VisualStudio::Debugger::Evaluation::DkmInspectionContext* pInspectionContext, const GUID& VisualizerId, const GUID& SourceId, Microsoft::VisualStudio::Debugger::CallStack::DkmStackWalkFrame* pStackFrame, Microsoft::VisualStudio::Debugger::Evaluation::DkmExpressionValueHome* pValueHome, Microsoft::VisualStudio::Debugger::Symbols::DkmModule* pModule, Microsoft::VisualStudio::Debugger::DkmString* pName, Microsoft::VisualStudio::Debugger::DkmString* pFullName, Microsoft::VisualStudio::Debugger::Evaluation::DkmRootVisualizedExpressionFlags_t Flags, UINT32 ArrayLength, Microsoft::VisualStudio::Debugger::DkmString* pType, const Microsoft::VisualStudio::Debugger::DkmDataItem& DataItem, Microsoft::VisualStudio::Debugger::Evaluation::DkmRootVisualizedExpression** ppCreatedObject)
{
    return Proc8FA048E453B8822275B07A0A9A0BF6F0(pInspectionContext, VisualizerId, SourceId, pStackFrame, pValueHome, pModule, pName, pFullName, Flags, ArrayLength, pType, DataItem, ppCreatedObject);
}

inline DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DefaultPort::DkmRunningProcessInfo::Id()
{
    return this->m_Id;
}

inline DECLSPEC_NOTHROW UINT64 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DefaultPort::DkmRunningProcessInfo::StartTime()
{
    return this->m_StartTime;
}

inline DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DefaultPort::DkmRunningProcessInfo::SessionId()
{
    return this->m_SessionId;
}

_Ret_opt_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmString* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DefaultPort::DkmRunningProcessInfo::Name()
{
    return this->m_pName;
}

_Ret_opt_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmString* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DefaultPort::DkmRunningProcessInfo::Title()
{
    return this->m_pTitle;
}

_Ret_opt_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmString* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DefaultPort::DkmRunningProcessInfo::UserName()
{
    return this->m_pUserName;
}

_Ret_opt_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<Microsoft::VisualStudio::Debugger::DkmString*>* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DefaultPort::DkmRunningProcessInfo::ClrVersions()
{
    return this->m_pClrVersions;
}

_Ret_opt_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmString* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DefaultPort::DkmRunningProcessInfo::CommandLine()
{
    return this->m_pCommandLine;
}

_Ret_opt_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmString* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DefaultPort::DkmRunningProcessInfo::CurrentDirectory()
{
    return this->m_pCurrentDirectory;
}

_Ret_opt_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmString* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DefaultPort::DkmRunningProcessInfo::EnvironmentBlock()
{
    return this->m_pEnvironmentBlock;
}

inline DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DefaultPort::DkmRunningProcessInfo::IntegrityLevel()
{
    return this->m_IntegrityLevel;
}

_Ret_opt_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<Microsoft::VisualStudio::Debugger::DefaultPort::DkmPublishedProgramInfo*>* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DefaultPort::DkmRunningProcessInfo::PublishedPrograms()
{
    return this->m_pPublishedPrograms;
}

inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DefaultPort::DkmRunningProcessFlags_t STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DefaultPort::DkmRunningProcessInfo::Flags()
{
    return this->m_Flags;
}

inline DECLSPEC_NOTHROW UINT16 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DefaultPort::DkmRunningProcessInfo::ProcessorArchitecture()
{
    return this->m_ProcessorArchitecture;
}

_Ret_opt_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DefaultPort::DkmAppPackageId* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DefaultPort::DkmRunningProcessInfo::AppPackageId()
{
    return this->m_pAppPackageId;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DefaultPort::DkmRunningProcessInfo::Create(UINT32 Id, UINT64 StartTime, UINT32 SessionId, Microsoft::VisualStudio::Debugger::DkmString* pName, Microsoft::VisualStudio::Debugger::DkmString* pTitle, Microsoft::VisualStudio::Debugger::DkmString* pUserName, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<Microsoft::VisualStudio::Debugger::DkmString*>* pClrVersions, Microsoft::VisualStudio::Debugger::DkmString* pCommandLine, Microsoft::VisualStudio::Debugger::DkmString* pCurrentDirectory, Microsoft::VisualStudio::Debugger::DkmString* pEnvironmentBlock, UINT32 IntegrityLevel, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<Microsoft::VisualStudio::Debugger::DefaultPort::DkmPublishedProgramInfo*>* pPublishedPrograms, Microsoft::VisualStudio::Debugger::DefaultPort::DkmRunningProcessFlags_t Flags, UINT16 ProcessorArchitecture, Microsoft::VisualStudio::Debugger::DefaultPort::DkmAppPackageId* pAppPackageId, Microsoft::VisualStudio::Debugger::DefaultPort::DkmRunningProcessInfo** ppCreatedObject)
{
    return Proc37D73B0F874CC8F77777D40219EDB14A(Id, StartTime, SessionId, pName, pTitle, pUserName, pClrVersions, pCommandLine, pCurrentDirectory, pEnvironmentBlock, IntegrityLevel, pPublishedPrograms, Flags, ProcessorArchitecture, pAppPackageId, ppCreatedObject);
}

inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::Breakpoints::DkmRuntimeBreakpoint::Tag_t STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Breakpoints::DkmRuntimeBreakpoint::TagValue()
{
    return this->m_TagValue;
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmRuntimeInstance* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Breakpoints::DkmRuntimeBreakpoint::RuntimeInstance()
{
    return this->m_pRuntimeInstance;
}

inline DECLSPEC_NOTHROW const GUID& STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Breakpoints::DkmRuntimeBreakpoint::UniqueId()
{
    return this->m_UniqueId;
}

inline DECLSPEC_NOTHROW const GUID& STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Breakpoints::DkmRuntimeBreakpoint::SourceId()
{
    return this->m_SourceId;
}

_Ret_opt_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmThread* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Breakpoints::DkmRuntimeBreakpoint::Thread()
{
    return this->m_pThread;
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmProcess* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Breakpoints::DkmRuntimeBreakpoint::Process()
{
    return this->m_pRuntimeInstance->Process();
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Breakpoints::DkmRuntimeBreakpoint::Close()
{
    return Proc7729A748D025D8D1D27D5F70D2E2971C(this);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Breakpoints::DkmRuntimeBreakpoint::SetCompiledConditionPending()
{
    return ProcFC9C6DD35B19AD87E29CF388843DEF42(this);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Breakpoints::DkmRuntimeBreakpoint::SetCompiledConditionPending(Microsoft::VisualStudio::Debugger::DkmWorkList* pWorkList, Microsoft::VisualStudio::Debugger::IDkmCompletionRoutine<Microsoft::VisualStudio::Debugger::Breakpoints::DkmSetCompiledConditionPendingAsyncResult>* pCompletionRoutine)
{
    return Proc0245E3B12859026D7920DFF4858DF38F(this, pWorkList, pCompletionRoutine);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Breakpoints::DkmRuntimeBreakpoint::SetEvaluationCondition(Microsoft::VisualStudio::Debugger::Breakpoints::DkmBreakpointCondition* pCondition, Microsoft::VisualStudio::Debugger::DkmString** ppErrorText)
{
    return ProcE46325D07FF9ECFA31F70280E1A0DD0F(this, pCondition, ppErrorText);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Breakpoints::DkmRuntimeBreakpoint::SetEvaluationCondition(Microsoft::VisualStudio::Debugger::DkmWorkList* pWorkList, Microsoft::VisualStudio::Debugger::Breakpoints::DkmBreakpointCondition* pCondition, Microsoft::VisualStudio::Debugger::IDkmCompletionRoutine<Microsoft::VisualStudio::Debugger::Breakpoints::DkmSetEvaluationConditionAsyncResult>* pCompletionRoutine)
{
    return ProcA19DF47DA04A1D5C32B02E7F4032BED7(this, pWorkList, pCondition, pCompletionRoutine);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Breakpoints::DkmRuntimeBreakpoint::ClearConditions()
{
    return ProcF4A3B764CCDEFECC871133DFB3DABD74(this);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Breakpoints::DkmRuntimeBreakpoint::ClearConditions(Microsoft::VisualStudio::Debugger::DkmWorkList* pWorkList, Microsoft::VisualStudio::Debugger::IDkmCompletionRoutine<Microsoft::VisualStudio::Debugger::Breakpoints::DkmClearRuntimeBreakpointConditionsAsyncResult>* pCompletionRoutine)
{
    return Proc99E8152F458A4714289FF221F4100D2F(this, pWorkList, pCompletionRoutine);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Breakpoints::DkmRuntimeBreakpoint::SetHitCountCondition(Microsoft::VisualStudio::Debugger::Breakpoints::DkmBreakpointHitCountCondition* pCondition, UINT32 HitCountValue)
{
    return Proc1E9AD8DA5F656684C0C7A9CBFACB19A3(this, pCondition, HitCountValue);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Breakpoints::DkmRuntimeBreakpoint::SetHitCountCondition(Microsoft::VisualStudio::Debugger::DkmWorkList* pWorkList, Microsoft::VisualStudio::Debugger::Breakpoints::DkmBreakpointHitCountCondition* pCondition, UINT32 HitCountValue, Microsoft::VisualStudio::Debugger::IDkmCompletionRoutine<Microsoft::VisualStudio::Debugger::Breakpoints::DkmSetRuntimeBreakpointHitCountConditionAsyncResult>* pCompletionRoutine)
{
    return Proc2F391C137BC1096F8C013BDECD30B957(this, pWorkList, pCondition, HitCountValue, pCompletionRoutine);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Breakpoints::DkmRuntimeBreakpoint::ClearHitCountCondition(Microsoft::VisualStudio::Debugger::Breakpoints::DkmBreakpointHitCountCondition* pCondition, UINT32* pCurrentHitCount)
{
    return ProcF9E386AD9771E9F2C3058D5834F64CB5(this, pCondition, pCurrentHitCount);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Breakpoints::DkmRuntimeBreakpoint::ClearHitCountCondition(Microsoft::VisualStudio::Debugger::DkmWorkList* pWorkList, Microsoft::VisualStudio::Debugger::Breakpoints::DkmBreakpointHitCountCondition* pCondition, Microsoft::VisualStudio::Debugger::IDkmCompletionRoutine<Microsoft::VisualStudio::Debugger::Breakpoints::DkmClearRuntimeBreakpointHitCountConditionAsyncResult>* pCompletionRoutine)
{
    return Proc8F395CEE476179C6FEBC6905D21E7A85(this, pWorkList, pCondition, pCompletionRoutine);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Breakpoints::DkmRuntimeBreakpoint::GetHitCountConditionStatus(UINT32* pCurrentHitCount)
{
    return Proc2933A0DFA7612550A1AF4A41C1E9C15F(this, pCurrentHitCount);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Breakpoints::DkmRuntimeBreakpoint::GetHitCountConditionStatus(Microsoft::VisualStudio::Debugger::DkmWorkList* pWorkList, Microsoft::VisualStudio::Debugger::IDkmCompletionRoutine<Microsoft::VisualStudio::Debugger::Breakpoints::DkmGetRuntimeBreakpointHitCountConditionAsyncResult>* pCompletionRoutine)
{
    return Proc4C9A3BE3A5112A28D0AF6CA87F562C70(this, pWorkList, pCompletionRoutine);
}

#ifndef EXCLUDE_MONITOR_ONLY_APIS
inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Breakpoints::DkmRuntimeBreakpoint::GetCompiledCondition(Microsoft::VisualStudio::Debugger::DkmInstructionAddress* pInstructionAddress, Microsoft::VisualStudio::Debugger::Breakpoints::DkmBreakpointConditionOperator_t* pConditionOperator, Microsoft::VisualStudio::Debugger::Evaluation::DkmCompiledInspectionQuery** ppCompiledCondition)
{
    return Proc41499D88B1F6924ECF29547583D8DD95(this, pInstructionAddress, pConditionOperator, ppCompiledCondition);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Breakpoints::DkmRuntimeBreakpoint::OnBreakpointConditionFailed(Microsoft::VisualStudio::Debugger::DkmString* pErrorMessage)
{
    return ProcE8EF7EF6768418441FE22C86348944FC(this, pErrorMessage);
}
#endif // #ifndef EXCLUDE_MONITOR_ONLY_APIS

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Breakpoints::DkmRuntimeBreakpoint::RequestBreakpointEventOnModifiedThread(Microsoft::VisualStudio::Debugger::DkmThread* pModifiedBreakThread)
{
    return Proc39CF936CBBD422C18149B4C96CF48257(this, pModifiedBreakThread);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Breakpoints::DkmRuntimeBreakpoint::RequestBreakpointEventOnModifiedThread(Microsoft::VisualStudio::Debugger::DkmWorkList* pWorkList, Microsoft::VisualStudio::Debugger::DkmThread* pModifiedBreakThread, Microsoft::VisualStudio::Debugger::IDkmCompletionRoutine<Microsoft::VisualStudio::Debugger::Breakpoints::DkmRequestBreakpointEventOnModifiedThreadAsyncResult>* pCompletionRoutine)
{
    return ProcA6288D90C3F6D3DECB145E59C1E2E0BE(this, pWorkList, pModifiedBreakThread, pCompletionRoutine);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Breakpoints::DkmRuntimeBreakpoint::Enable()
{
    return Proc93E2EB641A58D187BC71A1FD19D779A4(this);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Breakpoints::DkmRuntimeBreakpoint::Enable(Microsoft::VisualStudio::Debugger::DkmWorkList* pWorkList, Microsoft::VisualStudio::Debugger::IDkmCompletionRoutine<Microsoft::VisualStudio::Debugger::Breakpoints::DkmEnableRuntimeBreakpointAsyncResult>* pCompletionRoutine)
{
    return Proc9893B43ADE803E4FF563307C23A5DE77(this, pWorkList, pCompletionRoutine);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Breakpoints::DkmRuntimeBreakpoint::Test()
{
    return ProcFFE7BBBBC1EC94B9CB3791B48190C3C2(this);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Breakpoints::DkmRuntimeBreakpoint::Test(Microsoft::VisualStudio::Debugger::DkmWorkList* pWorkList, Microsoft::VisualStudio::Debugger::IDkmCompletionRoutine<Microsoft::VisualStudio::Debugger::Breakpoints::DkmTestRuntimeBreakpointAsyncResult>* pCompletionRoutine)
{
    return ProcAB4964C8D77D3256EFE0D6A44501C685(this, pWorkList, pCompletionRoutine);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Breakpoints::DkmRuntimeBreakpoint::Disable()
{
    return Proc37D0CD0D0909DE69E045690F177B6ED0(this);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Breakpoints::DkmRuntimeBreakpoint::Disable(Microsoft::VisualStudio::Debugger::DkmWorkList* pWorkList, Microsoft::VisualStudio::Debugger::IDkmCompletionRoutine<Microsoft::VisualStudio::Debugger::Breakpoints::DkmDisableRuntimeBreakpointAsyncResult>* pCompletionRoutine)
{
    return Proc7F86958C6499B678D002E26D8724C3E4(this, pWorkList, pCompletionRoutine);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Breakpoints::DkmRuntimeBreakpoint::OnHit(Microsoft::VisualStudio::Debugger::DkmThread* pThread, bool HasException)
{
    return Proc11942CA3E32D2CC5E71549580B4EEE2F(this, pThread, HasException);
}

#ifndef EXCLUDE_MONITOR_ONLY_APIS
inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Breakpoints::DkmRuntimeBreakpoint::EvaluateConditionAndSelectThread(Microsoft::VisualStudio::Debugger::DkmThread* pFirstStoppedThread, Microsoft::VisualStudio::Debugger::DkmThread** ppConditionMetThread)
{
    return ProcA744AE7AD70089B93C050396189C0E6D(this, pFirstStoppedThread, ppConditionMetThread);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Breakpoints::DkmRuntimeBreakpoint::EvaluateConditionAndSelectThread(Microsoft::VisualStudio::Debugger::DkmWorkList* pWorkList, Microsoft::VisualStudio::Debugger::DkmThread* pFirstStoppedThread, Microsoft::VisualStudio::Debugger::IDkmCompletionRoutine<Microsoft::VisualStudio::Debugger::Breakpoints::DkmEvaluateConditionAndSelectThreadAsyncResult>* pCompletionRoutine)
{
    return Proc654E5E6C9B16E21E572DC1F61E81FC11(this, pWorkList, pFirstStoppedThread, pCompletionRoutine);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Breakpoints::DkmRuntimeBreakpoint::OnBreakpointConditionFailed(Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILFailureReason_t ErrorCode)
{
    return ProcE1E4C9C8AACD6229ECEA07922F384831(this, ErrorCode);
}
#endif // #ifndef EXCLUDE_MONITOR_ONLY_APIS

inline DECLSPEC_NOTHROW const GUID& STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::FunctionResolution::DkmRuntimeFunctionResolutionRequest::UniqueId()
{
    return this->m_UniqueId;
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmProcess* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::FunctionResolution::DkmRuntimeFunctionResolutionRequest::Process()
{
    return this->m_pProcess;
}

inline DECLSPEC_NOTHROW const Microsoft::VisualStudio::Debugger::Evaluation::DkmCompilerId& STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::FunctionResolution::DkmRuntimeFunctionResolutionRequest::CompilerId()
{
    return this->m_CompilerId;
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmString* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::FunctionResolution::DkmRuntimeFunctionResolutionRequest::FunctionName()
{
    return this->m_pFunctionName;
}

inline DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::FunctionResolution::DkmRuntimeFunctionResolutionRequest::LineOffset()
{
    return this->m_LineOffset;
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmString* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::FunctionResolution::DkmRuntimeFunctionResolutionRequest::ModuleName()
{
    return this->m_pModuleName;
}

inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::FunctionResolution::DkmAddressSearchFlags_t STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::FunctionResolution::DkmRuntimeFunctionResolutionRequest::SearchFlags()
{
    return this->m_SearchFlags;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::FunctionResolution::DkmRuntimeFunctionResolutionRequest::Close()
{
    return Proc1CB7AA5C0E18E7C2533CABD78EF033B3(this);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::FunctionResolution::DkmRuntimeFunctionResolutionRequest::Create(Microsoft::VisualStudio::Debugger::DkmProcess* pProcess, const Microsoft::VisualStudio::Debugger::Evaluation::DkmCompilerId& CompilerId, Microsoft::VisualStudio::Debugger::DkmString* pFunctionName, UINT32 LineOffset, Microsoft::VisualStudio::Debugger::DkmString* pModuleName, Microsoft::VisualStudio::Debugger::FunctionResolution::DkmAddressSearchFlags_t SearchFlags, const Microsoft::VisualStudio::Debugger::DkmDataItem& DataItem, Microsoft::VisualStudio::Debugger::FunctionResolution::DkmRuntimeFunctionResolutionRequest** ppCreatedObject)
{
    return Proc02F5B636B11CFD1F31E0C794EE4631B8(pProcess, CompilerId, pFunctionName, LineOffset, pModuleName, SearchFlags, DataItem, ppCreatedObject);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::FunctionResolution::DkmRuntimeFunctionResolutionRequest::EnableResolution(Microsoft::VisualStudio::Debugger::DkmWorkList* pWorkList)
{
    return ProcDF15402D0A339E45CC2A57DB2F63EBE3(this, pWorkList);
}

#ifndef EXCLUDE_MONITOR_ONLY_APIS
inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::FunctionResolution::DkmRuntimeFunctionResolutionRequest::OnFunctionResolved(Microsoft::VisualStudio::Debugger::DkmInstructionAddress* pAddress)
{
    return ProcB7DF07C7E259E057345053EA721F2BCE(this, pAddress);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::FunctionResolution::DkmRuntimeFunctionResolutionRequest::OnFunctionResolved(Microsoft::VisualStudio::Debugger::DkmWorkList* pWorkList, Microsoft::VisualStudio::Debugger::DkmInstructionAddress* pAddress, Microsoft::VisualStudio::Debugger::IDkmCompletionRoutine<Microsoft::VisualStudio::Debugger::FunctionResolution::DkmOnFunctionResolvedAsyncResult>* pCompletionRoutine)
{
    return Proc4C6C4F1118EF07A4E19E8D544DBDEEA0(this, pWorkList, pAddress, pCompletionRoutine);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::FunctionResolution::DkmRuntimeFunctionResolutionRequest::OnResolverMessage(Microsoft::VisualStudio::Debugger::Breakpoints::DkmBreakpointMessageLevel_t Level, Microsoft::VisualStudio::Debugger::DkmString* pMessage)
{
    return Proc10A22778D523D607BD6C09729AD0F35E(this, Level, pMessage);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::FunctionResolution::DkmRuntimeFunctionResolutionRequest::OnResolverMessage(Microsoft::VisualStudio::Debugger::DkmWorkList* pWorkList, Microsoft::VisualStudio::Debugger::Breakpoints::DkmBreakpointMessageLevel_t Level, Microsoft::VisualStudio::Debugger::DkmString* pMessage, Microsoft::VisualStudio::Debugger::IDkmCompletionRoutine<Microsoft::VisualStudio::Debugger::FunctionResolution::DkmOnResolverMessageAsyncResult>* pCompletionRoutine)
{
    return ProcC1543CFD5ACC8E9540123E1C97C081EC(this, pWorkList, Level, pMessage, pCompletionRoutine);
}
#endif // #ifndef EXCLUDE_MONITOR_ONLY_APIS

inline DECLSPEC_NOTHROW UINT64 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Breakpoints::DkmRuntimeHardwareDataBreakpoint::Address()
{
    return this->m_Address;
}

inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::Breakpoints::DkmDataAccessStopMask_t STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Breakpoints::DkmRuntimeHardwareDataBreakpoint::Access()
{
    return this->m_Access;
}

inline DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Breakpoints::DkmRuntimeHardwareDataBreakpoint::Size()
{
    return this->m_Size;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Breakpoints::DkmRuntimeHardwareDataBreakpoint::Create(Microsoft::VisualStudio::Debugger::DkmRuntimeInstance* pRuntimeInstance, const GUID& SourceId, Microsoft::VisualStudio::Debugger::DkmThread* pThread, UINT64 Address, Microsoft::VisualStudio::Debugger::Breakpoints::DkmDataAccessStopMask_t Access, UINT32 Size, const Microsoft::VisualStudio::Debugger::DkmDataItem& DataItem, Microsoft::VisualStudio::Debugger::Breakpoints::DkmRuntimeHardwareDataBreakpoint** ppCreatedObject)
{
    return Proc473E9833342ED425C288649015CC324B(pRuntimeInstance, SourceId, pThread, Address, Access, Size, DataItem, ppCreatedObject);
}

inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmRuntimeInstance::Tag_t STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmRuntimeInstance::TagValue()
{
    return this->m_TagValue;
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmProcess* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmRuntimeInstance::Process()
{
    return this->m_pProcess;
}

inline DECLSPEC_NOTHROW const Microsoft::VisualStudio::Debugger::DkmRuntimeInstanceId& STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmRuntimeInstance::Id()
{
    return this->m_Id;
}

inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmRuntimeCapabilities_t STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmRuntimeInstance::Capabilities()
{
    // This method was introduced after the initial version of the API. The caller is
    // responsible for taking steps to ensure that this method is not called when running
    // against earlier versions of vsdebugeng.dll.
    ATLASSERT(DkmComponentManager::IsApiVersionSupported(DkmApiVersion::VS12RTM) || !"Invalid usage detected. Process will crash or bogus data will be returned");
    return this->m__pExtendedData->Capabilities;
}

_Ret_opt_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmRuntimeInstance* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmRuntimeInstance::ParentRuntime()
{
    // This method was introduced after the initial version of the API. The caller is
    // responsible for taking steps to ensure that this method is not called when running
    // against earlier versions of vsdebugeng.dll.
    ATLASSERT(DkmComponentManager::IsApiVersionSupported(DkmApiVersion::VS12RTM) || !"Invalid usage detected. Process will crash or bogus data will be returned");
    return this->m__pExtendedData->pParentRuntime;
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DefaultPort::DkmTransportConnection* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmRuntimeInstance::Connection()
{
    return this->m_pProcess->Connection();
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmRuntimeInstance::GetScriptDocumentTreeNodes(Microsoft::VisualStudio::Debugger::DkmArray<Microsoft::VisualStudio::Debugger::Script::DkmScriptDocumentTreeNode*>* pScriptDocumentTreeNodes)
{
    return Proc0E8B280F47F46C4B2A2734040F7FA707(this, pScriptDocumentTreeNodes);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmRuntimeInstance::GetModuleInstances(Microsoft::VisualStudio::Debugger::DkmArray<Microsoft::VisualStudio::Debugger::DkmModuleInstance*>* pModuleInstances)
{
    return Proc245EB5834F220A1C282AA6E2B457151C(this, pModuleInstances);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmRuntimeInstance::GetTaskProviders(Microsoft::VisualStudio::Debugger::DkmArray<Microsoft::VisualStudio::Debugger::ParallelTasks::DkmTaskProvider*>* pTaskProviders)
{
    return Proc9E83BEF15E45216D9E571931B801FC8F(this, pTaskProviders);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmRuntimeInstance::ResolveCPUInstructionAddress(UINT64 InstructionPointer, Microsoft::VisualStudio::Debugger::DkmInstructionAddress** ppAddressObject, bool* pFirstAddress)
{
    return ProcF47641A9B4F4EF84594FF51457BD43AD(this, InstructionPointer, ppAddressObject, pFirstAddress);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmRuntimeInstance::ResolveCPUInstructionAddress(Microsoft::VisualStudio::Debugger::DkmWorkList* pWorkList, UINT64 InstructionPointer, Microsoft::VisualStudio::Debugger::IDkmCompletionRoutine<Microsoft::VisualStudio::Debugger::DkmResolveCPUInstructionAddressAsyncResult>* pCompletionRoutine)
{
    return ProcDDA5249C91A40BC1C63ABF57EE417F35(this, pWorkList, InstructionPointer, pCompletionRoutine);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmRuntimeInstance::FindModulesByName(Microsoft::VisualStudio::Debugger::DkmString* pSearchKey, Microsoft::VisualStudio::Debugger::DkmArray<Microsoft::VisualStudio::Debugger::DkmModuleInstance*>* pMatches)
{
    return Proc10463036625AB2B5AAA7F05509328531(this, pSearchKey, pMatches);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmRuntimeInstance::SetRegisterValue(Microsoft::VisualStudio::Debugger::CallStack::DkmStackWalkFrame* pStackWalkFrame, CV_HREG_e RegisterIndex, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<BYTE>* pValue)
{
    return Proc49AB6C5E8A36B60EA1D587680080E9ED(this, pStackWalkFrame, RegisterIndex, pValue);
}

#ifndef EXCLUDE_MONITOR_ONLY_APIS
inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmRuntimeInstance::BeforeEnableNewStepper(Microsoft::VisualStudio::Debugger::Stepping::DkmStepper* pStepper)
{
    return Proc003CEB61065326C60432436C71B15AF3(this, pStepper);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmRuntimeInstance::OwnsCurrentExecutionLocation(Microsoft::VisualStudio::Debugger::Stepping::DkmStepper* pStepper, Microsoft::VisualStudio::Debugger::Stepping::DkmStepArbitrationReason_t Reason, bool* pOwnsFrame)
{
    return ProcFF2EBEF240F6308F4BC2649DFFAED7C9(this, pStepper, Reason, pOwnsFrame);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmRuntimeInstance::Step(Microsoft::VisualStudio::Debugger::Stepping::DkmStepper* pStepper, Microsoft::VisualStudio::Debugger::Stepping::DkmStepArbitrationReason_t Reason)
{
    return Proc803C37AF1E9AECCD4C7CAE2B2785162A(this, pStepper, Reason);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmRuntimeInstance::StopStep(Microsoft::VisualStudio::Debugger::Stepping::DkmStepper* pStepper)
{
    return ProcC0CB9DB875E57138C93DFCE332C3D32C(this, pStepper);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmRuntimeInstance::AfterSteppingArbitration(Microsoft::VisualStudio::Debugger::Stepping::DkmStepper* pStepper, Microsoft::VisualStudio::Debugger::Stepping::DkmStepArbitrationReason_t Reason, Microsoft::VisualStudio::Debugger::DkmRuntimeInstance* pNewControllingRuntimeInstance)
{
    return ProcAA61459CFDC30CEC49DA6E3BBD21802C(this, pStepper, Reason, pNewControllingRuntimeInstance);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmRuntimeInstance::OnNewControllingRuntimeInstance(Microsoft::VisualStudio::Debugger::Stepping::DkmStepper* pStepper, Microsoft::VisualStudio::Debugger::Stepping::DkmStepArbitrationReason_t Reason, Microsoft::VisualStudio::Debugger::DkmRuntimeInstance* pControllingRuntimeInstance)
{
    return Proc6C79DBE9F40FE80E961282947D988039(this, pStepper, Reason, pControllingRuntimeInstance);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmRuntimeInstance::StepControlRequested(Microsoft::VisualStudio::Debugger::Stepping::DkmStepper* pStepper, Microsoft::VisualStudio::Debugger::Stepping::DkmStepArbitrationReason_t Reason, Microsoft::VisualStudio::Debugger::DkmRuntimeInstance* pCallingRuntimeInstance, bool* pGranted)
{
    return ProcF0247C5D3632A8B6B5A018211C1D2410(this, pStepper, Reason, pCallingRuntimeInstance, pGranted);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmRuntimeInstance::TakeStepControl(Microsoft::VisualStudio::Debugger::Stepping::DkmStepper* pStepper, bool LeaveGuardsInPlace, Microsoft::VisualStudio::Debugger::Stepping::DkmStepArbitrationReason_t Reason, Microsoft::VisualStudio::Debugger::DkmRuntimeInstance* pCallingRuntimeInstance)
{
    return Proc17820A171C58275B4CB2469D9614049B(this, pStepper, LeaveGuardsInPlace, Reason, pCallingRuntimeInstance);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmRuntimeInstance::NotifyStepComplete(Microsoft::VisualStudio::Debugger::Stepping::DkmStepper* pStepper)
{
    return Proc2344FF3BDFEDB69A0DC72C3155B8F61B(this, pStepper);
}
#endif // #ifndef EXCLUDE_MONITOR_ONLY_APIS

#ifndef EXCLUDE_IDE_ONLY_APIS
inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmRuntimeInstance::GetThreadDisplayProperties(Microsoft::VisualStudio::Debugger::DkmWorkList* pWorkList, Microsoft::VisualStudio::Debugger::DkmThread* pThread, Microsoft::VisualStudio::Debugger::IDkmCompletionRoutine<Microsoft::VisualStudio::Debugger::ThreadProperties::DkmGetThreadDisplayPropertiesAsyncResult>* pCompletionRoutine)
{
    return ProcB0B79064BF97FA5726711951AECE4E77(this, pWorkList, pThread, pCompletionRoutine);
}
#endif // #ifndef EXCLUDE_IDE_ONLY_APIS

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmRuntimeInstance::GetThreadName(Microsoft::VisualStudio::Debugger::DkmThread* pThread, Microsoft::VisualStudio::Debugger::DkmString** ppName)
{
    return Proc2EA1B4DEDF4599B865E8E1A2E5718E86(this, pThread, ppName);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmRuntimeInstance::GetThreadName(Microsoft::VisualStudio::Debugger::DkmWorkList* pWorkList, Microsoft::VisualStudio::Debugger::DkmThread* pThread, Microsoft::VisualStudio::Debugger::IDkmCompletionRoutine<Microsoft::VisualStudio::Debugger::ThreadProperties::DkmGetThreadNameAsyncResult>* pCompletionRoutine)
{
    return ProcA73EB0668CACF4528C6378839C71F455(this, pWorkList, pThread, pCompletionRoutine);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmRuntimeInstance::Unload()
{
    return ProcCA285C60E7286A27F6D525028789BEB1(this);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmRuntimeInstance::GetManagedHeapSamplers(Microsoft::VisualStudio::Debugger::DkmArray<Microsoft::VisualStudio::Debugger::Clr::DkmManagedHeapSampler*>* pManagedHeapSamplers)
{
    return ProcB94CF78451EDBCA915BAFD75C300EF35(this, pManagedHeapSamplers);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmRuntimeInstance::GetManagedHeapWalkers(Microsoft::VisualStudio::Debugger::DkmArray<Microsoft::VisualStudio::Debugger::Clr::DkmManagedHeapWalker*>* pManagedHeapWalkers)
{
    return ProcA4A36CF75EB42A472782FD7825A58C9D(this, pManagedHeapWalkers);
}

#ifndef EXCLUDE_MONITOR_ONLY_APIS
inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmRuntimeInstance::GetCodePathsInRange(ICorDebugFrame* pCorFrame, UINT32 StartILOffset, UINT32 EndILOffset, Microsoft::VisualStudio::Debugger::DkmArray<Microsoft::VisualStudio::Debugger::Stepping::DkmSteppingCodePath*>* pCodePaths)
{
    return Proc1DF54DB322921281DE98E82C2A0D2D12(this, pCorFrame, StartILOffset, EndILOffset, pCodePaths);
}
#endif // #ifndef EXCLUDE_MONITOR_ONLY_APIS

#ifndef EXCLUDE_IDE_ONLY_APIS
inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmRuntimeInstance::Disassemble(Microsoft::VisualStudio::Debugger::DkmInstructionAddress* pAddress, UINT32 Count, Microsoft::VisualStudio::Debugger::DkmArray<Microsoft::VisualStudio::Debugger::Disassembly::DkmDisassembledInstruction*>* pDisassembledInstructions)
{
    return ProcA67728A0C5C3D3B4EACB1F1C598A20D7(this, pAddress, Count, pDisassembledInstructions);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmRuntimeInstance::GetInstructionAddress(Microsoft::VisualStudio::Debugger::DkmInstructionAddress* pStartAddress, INT32 InstructionOffset, Microsoft::VisualStudio::Debugger::DkmInstructionAddress** ppAddress)
{
    return Proc147D5B957653AEED0BF962688F3879AE(this, pStartAddress, InstructionOffset, ppAddress);
}
#endif // #ifndef EXCLUDE_IDE_ONLY_APIS

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmRuntimeInstance::OnLoadComplete()
{
    return Proc698471DF4195CB1B70826EC3715C2DF8(this);
}

inline DECLSPEC_NOTHROW int STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmRuntimeInstanceId::CompareTo(const Microsoft::VisualStudio::Debugger::DkmRuntimeInstanceId& other) const
{
    return ProcE97BC9882851F8E9E5A3179B48A6A534(*this, other);
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmInstructionAddress* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Breakpoints::DkmRuntimeInstructionBreakpoint::InstructionAddress()
{
    return this->m_pInstructionAddress;
}

inline DECLSPEC_NOTHROW bool STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Breakpoints::DkmRuntimeInstructionBreakpoint::IsBarrier()
{
    return this->m_IsBarrier;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Breakpoints::DkmRuntimeInstructionBreakpoint::Create(const GUID& SourceId, Microsoft::VisualStudio::Debugger::DkmThread* pThread, Microsoft::VisualStudio::Debugger::DkmInstructionAddress* pInstructionAddress, bool IsBarrier, const Microsoft::VisualStudio::Debugger::DkmDataItem& DataItem, Microsoft::VisualStudio::Debugger::Breakpoints::DkmRuntimeInstructionBreakpoint** ppCreatedObject)
{
    return ProcCB83857C81F60315EF70D865BF0E4B1A(SourceId, pThread, pInstructionAddress, IsBarrier, DataItem, ppCreatedObject);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Breakpoints::DkmRuntimeInstructionBreakpoint::SetCompiledCondition(Microsoft::VisualStudio::Debugger::Evaluation::DkmCompiledInspectionQuery* pCompiledCondition, Microsoft::VisualStudio::Debugger::Breakpoints::DkmBreakpointConditionOperator_t ConditionOperator)
{
    return ProcE485A2033078735C920AC84BD6F97736(this, pCompiledCondition, ConditionOperator);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Breakpoints::DkmRuntimeInstructionBreakpoint::SetCompiledCondition(Microsoft::VisualStudio::Debugger::DkmWorkList* pWorkList, Microsoft::VisualStudio::Debugger::Evaluation::DkmCompiledInspectionQuery* pCompiledCondition, Microsoft::VisualStudio::Debugger::Breakpoints::DkmBreakpointConditionOperator_t ConditionOperator, Microsoft::VisualStudio::Debugger::IDkmCompletionRoutine<Microsoft::VisualStudio::Debugger::Breakpoints::DkmSetCompiledConditionAsyncResult>* pCompletionRoutine)
{
    return Proc7AF36FD7B7E0B4CE88AC133EBE2CA062(this, pWorkList, pCompiledCondition, ConditionOperator, pCompletionRoutine);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Breakpoints::DkmRuntimeInstructionBreakpoint::TryPushConditionToTargetDevice(Microsoft::VisualStudio::Debugger::Evaluation::DkmCompiledInspectionQuery* pCompiledCondition, Microsoft::VisualStudio::Debugger::Breakpoints::DkmBreakpointConditionOperator_t ConditionOperator)
{
    return ProcB7BFDF6A5DD40400B07E77E9E74DD0ED(this, pCompiledCondition, ConditionOperator);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Breakpoints::DkmRuntimeInstructionBreakpoint::TryPushConditionToTargetDevice(Microsoft::VisualStudio::Debugger::DkmWorkList* pWorkList, Microsoft::VisualStudio::Debugger::Evaluation::DkmCompiledInspectionQuery* pCompiledCondition, Microsoft::VisualStudio::Debugger::Breakpoints::DkmBreakpointConditionOperator_t ConditionOperator, Microsoft::VisualStudio::Debugger::IDkmCompletionRoutine<Microsoft::VisualStudio::Debugger::Breakpoints::DkmTryPushConditionToTargetDeviceAsyncResult>* pCompletionRoutine)
{
    return Proc3ABAEA10372ACE2485C57CA038BBC209(this, pWorkList, pCompiledCondition, ConditionOperator, pCompletionRoutine);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Breakpoints::DkmRuntimeInstructionBreakpoint::TryClearConditionOnTargetDevice()
{
    return Proc720EFC94A30F2FDA0A06EC4DDEA4C417(this);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Breakpoints::DkmRuntimeInstructionBreakpoint::TryClearConditionOnTargetDevice(Microsoft::VisualStudio::Debugger::DkmWorkList* pWorkList, Microsoft::VisualStudio::Debugger::IDkmCompletionRoutine<Microsoft::VisualStudio::Debugger::Breakpoints::DkmTryClearConditionOnTargetDeviceAsyncResult>* pCompletionRoutine)
{
    return Proc79B572DB628856A7B5E44CCD638AF7DC(this, pWorkList, pCompletionRoutine);
}

inline DECLSPEC_NOTHROW int STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Symbols::DkmSHA1HashValue::CompareTo(const Microsoft::VisualStudio::Debugger::Symbols::DkmSHA1HashValue& other) const
{
    return Proc3DE111A28EFA51314B6DEABFD2A12DB2(*this, other);
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmString* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Script::DkmScriptBlockMappingInfo::CodeText()
{
    return this->m_pCodeText;
}

inline DECLSPEC_NOTHROW const Microsoft::VisualStudio::Debugger::Symbols::DkmTextSpan& STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Script::DkmScriptBlockMappingInfo::TextSpan()
{
    return this->m_TextSpan;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Script::DkmScriptBlockMappingInfo::Create(Microsoft::VisualStudio::Debugger::DkmString* pCodeText, const Microsoft::VisualStudio::Debugger::Symbols::DkmTextSpan& TextSpan, Microsoft::VisualStudio::Debugger::Script::DkmScriptBlockMappingInfo** ppCreatedObject)
{
    return Proc50B5D8DA1C11FB7B3B25AF5A65A55FB0(pCodeText, TextSpan, ppCreatedObject);
}

inline DECLSPEC_NOTHROW const GUID& STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Script::DkmScriptDocument::UniqueId()
{
    return static_cast<const GUID&>(DkmScriptDocumentTreeNode::UniqueId());
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::Symbols::DkmModule* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Script::DkmScriptDocument::Module()
{
    return this->m_pModule;
}

_Ret_opt_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmString* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Script::DkmScriptDocument::Url()
{
    return this->m_pUrl;
}

_Ret_opt_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmString* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Script::DkmScriptDocument::FilePath()
{
    return this->m_pFilePath;
}

inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::Script::DkmScriptDocumentFlags_t STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Script::DkmScriptDocument::Flags()
{
    return this->m_Flags;
}

inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::Script::DkmScriptDocumentContentType_t STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Script::DkmScriptDocument::ContentType()
{
    // This method was introduced after the initial version of the API. The caller is
    // responsible for taking steps to ensure that this method is not called when running
    // against earlier versions of vsdebugeng.dll.
    ATLASSERT(DkmComponentManager::IsApiVersionSupported(DkmApiVersion::VS12RTM) || !"Invalid usage detected. Process will crash or bogus data will be returned");
    return this->m__pExtendedData->ContentType;
}

inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::Script::DkmScriptEmbeddedDocumentKind_t STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Script::DkmScriptDocument::EmbeddedDocumentKind()
{
    // This method was introduced after the initial version of the API. The caller is
    // responsible for taking steps to ensure that this method is not called when running
    // against earlier versions of vsdebugeng.dll.
    ATLASSERT(DkmComponentManager::IsApiVersionSupported(DkmApiVersion::VS12RTM) || !"Invalid usage detected. Process will crash or bogus data will be returned");
    return this->m__pExtendedData->EmbeddedDocumentKind;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Script::DkmScriptDocument::GetSourceProjectItem(_Deref_out_opt_ Microsoft::VisualStudio::Debugger::Script::DkmScriptSourceProjectItem** ppValue)
{
    return GetC5849E9833F5F36297EB088EC664A234(this, ppValue);
}

inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::Script::DkmScriptDocumentJmcState_t STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Script::DkmScriptDocument::JmcState()
{
    // This method was introduced after the initial version of the API. The caller is
    // responsible for taking steps to ensure that this method is not called when running
    // against earlier versions of vsdebugeng.dll.
    ATLASSERT(DkmComponentManager::IsApiVersionSupported(DkmApiVersion::VS12RTM) || !"Invalid usage detected. Process will crash or bogus data will be returned");
    return this->m__pExtendedData->JmcState;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Script::DkmScriptDocument::Create(Microsoft::VisualStudio::Debugger::DkmRuntimeInstance* pRuntimeInstance, Microsoft::VisualStudio::Debugger::Script::DkmScriptDocumentTreeNode* pParent, Microsoft::VisualStudio::Debugger::DkmString* pTitle, Microsoft::VisualStudio::Debugger::Symbols::DkmModule* pModule, Microsoft::VisualStudio::Debugger::DkmString* pUrl, Microsoft::VisualStudio::Debugger::DkmString* pFilePath, Microsoft::VisualStudio::Debugger::Script::DkmScriptDocumentFlags_t Flags, Microsoft::VisualStudio::Debugger::Script::DkmScriptSourceProjectItem* pSourceProjectItem, const Microsoft::VisualStudio::Debugger::DkmDataItem& DataItem, Microsoft::VisualStudio::Debugger::Script::DkmScriptDocument** ppCreatedObject)
{
    return ProcEA0F13D8EBAAD5C57D07D7CA0ADFBE54(pRuntimeInstance, pParent, pTitle, pModule, pUrl, pFilePath, Flags, pSourceProjectItem, DataItem, ppCreatedObject);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Script::DkmScriptDocument::Create(Microsoft::VisualStudio::Debugger::DkmRuntimeInstance* pRuntimeInstance, Microsoft::VisualStudio::Debugger::Script::DkmScriptDocumentTreeNode* pParent, Microsoft::VisualStudio::Debugger::DkmString* pTitle, Microsoft::VisualStudio::Debugger::Symbols::DkmModule* pModule, Microsoft::VisualStudio::Debugger::DkmString* pUrl, Microsoft::VisualStudio::Debugger::DkmString* pFilePath, Microsoft::VisualStudio::Debugger::Script::DkmScriptDocumentFlags_t Flags, Microsoft::VisualStudio::Debugger::Script::DkmScriptDocumentContentType_t ContentType, Microsoft::VisualStudio::Debugger::Script::DkmScriptEmbeddedDocumentKind_t EmbeddedDocumentKind, Microsoft::VisualStudio::Debugger::Script::DkmScriptSourceProjectItem* pSourceProjectItem, Microsoft::VisualStudio::Debugger::Script::DkmScriptDocumentJmcState_t JmcState, const Microsoft::VisualStudio::Debugger::DkmDataItem& DataItem, Microsoft::VisualStudio::Debugger::Script::DkmScriptDocument** ppCreatedObject)
{
    return ProcA673B7F58C93640EC322B5C0A2E63F79(pRuntimeInstance, pParent, pTitle, pModule, pUrl, pFilePath, Flags, ContentType, EmbeddedDocumentKind, pSourceProjectItem, JmcState, DataItem, ppCreatedObject);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Script::DkmScriptDocument::GetContent(bool EnableContentEvents, Microsoft::VisualStudio::Debugger::DkmString** ppContent, Microsoft::VisualStudio::Debugger::DkmArray<UINT32>* pSectionDividers)
{
    return Proc605D280FE9838181FA3A4A2B68F0F82B(this, EnableContentEvents, ppContent, pSectionDividers);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Script::DkmScriptDocument::SetRaiseContentEvents(bool Enable)
{
    return ProcB907C0A7AFABDB032781F0EB78062FA2(this, Enable);
}

#ifndef EXCLUDE_IDE_ONLY_APIS
inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Script::DkmScriptDocument::TryResolve(Microsoft::VisualStudio::Debugger::Symbols::DkmSourceFileId* pSourceFileId, Microsoft::VisualStudio::Debugger::Symbols::DkmResolvedDocument** ppResolvedDocument)
{
    return Proc3070F6337FAFE9328B926573E08C6350(this, pSourceFileId, ppResolvedDocument);
}
#endif // #ifndef EXCLUDE_IDE_ONLY_APIS

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Script::DkmScriptDocument::SetRaiseSymbolEvents(bool Enable)
{
    return ProcDEE08F4607BF904380CD375869159CAA(this, Enable);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Script::DkmScriptDocument::SetRaiseSymbolEvents(Microsoft::VisualStudio::Debugger::DkmWorkList* pWorkList, bool Enable, Microsoft::VisualStudio::Debugger::IDkmCompletionRoutine<Microsoft::VisualStudio::Debugger::Script::DkmSetRaiseSymbolEventsAsyncResult>* pCompletionRoutine)
{
    return Proc2E0CDF0E0AEBB33AA8AE4C476F46A6E1(this, pWorkList, Enable, pCompletionRoutine);
}

#ifndef EXCLUDE_IDE_ONLY_APIS
inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Script::DkmScriptDocument::GetProjectItemScriptBlocks(Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<Microsoft::VisualStudio::Debugger::Script::DkmScriptBlockMappingInfo*>** ppScriptBlocks)
{
    return Proc6C9638A955AE91EA6325FFD14E45E14C(this, ppScriptBlocks);
}
#endif // #ifndef EXCLUDE_IDE_ONLY_APIS

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Script::DkmScriptDocument::OnContentInsert(const Microsoft::VisualStudio::Debugger::Symbols::DkmTextSpan& Span, Microsoft::VisualStudio::Debugger::DkmString* pNewText)
{
    return ProcE2EA22D316F3FD9C3A1E03841E45F509(this, Span, pNewText);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Script::DkmScriptDocument::OnContentRemove(const Microsoft::VisualStudio::Debugger::Symbols::DkmTextSpan& Span, UINT32 CharsToRemove)
{
    return Proc28927B0EE826B95D2F3582541114A6FB(this, Span, CharsToRemove);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Script::DkmScriptDocument::SetJmcState(Microsoft::VisualStudio::Debugger::Script::DkmScriptDocumentJmcState_t NewValue)
{
    return Proc6110C67BD847D8134C925AC608E254E1(this, NewValue);
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmRuntimeInstance* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Script::DkmScriptDocumentTreeNode::RuntimeInstance()
{
    return this->m_pRuntimeInstance;
}

_Ret_opt_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::Script::DkmScriptDocumentTreeNode* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Script::DkmScriptDocumentTreeNode::Parent()
{
    return this->m_pParent;
}

inline DECLSPEC_NOTHROW const GUID& STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Script::DkmScriptDocumentTreeNode::UniqueId()
{
    return this->m_UniqueId;
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmString* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Script::DkmScriptDocumentTreeNode::Title()
{
    return this->m_pTitle;
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmProcess* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Script::DkmScriptDocumentTreeNode::Process()
{
    return this->m_pRuntimeInstance->Process();
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Script::DkmScriptDocumentTreeNode::Create(Microsoft::VisualStudio::Debugger::DkmRuntimeInstance* pRuntimeInstance, Microsoft::VisualStudio::Debugger::Script::DkmScriptDocumentTreeNode* pParent, Microsoft::VisualStudio::Debugger::DkmString* pTitle, const Microsoft::VisualStudio::Debugger::DkmDataItem& DataItem, Microsoft::VisualStudio::Debugger::Script::DkmScriptDocumentTreeNode** ppCreatedObject)
{
    return Proc1AE37B2274C1C965566B6B7955EABD47(pRuntimeInstance, pParent, pTitle, DataItem, ppCreatedObject);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Script::DkmScriptDocumentTreeNode::Unload()
{
    return Proc14A934ACD96B407ADFD71AE6C2B5C520(this);
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::Script::DkmScriptRuntimeInstance* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Script::DkmScriptInstructionAddress::RuntimeInstance()
{
    return static_cast<Microsoft::VisualStudio::Debugger::Script::DkmScriptRuntimeInstance*>(DkmInstructionAddress::RuntimeInstance());
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::Script::DkmScriptDocument* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Script::DkmScriptInstructionAddress::Document()
{
    return this->m_pDocument;
}

inline DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Script::DkmScriptInstructionAddress::Revision()
{
    return this->m_Revision;
}

inline DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Script::DkmScriptInstructionAddress::StartIndex()
{
    return this->m_StartIndex;
}

inline DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Script::DkmScriptInstructionAddress::StatementLength()
{
    return this->m_StatementLength;
}

_Ret_opt_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<BYTE>* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Script::DkmScriptInstructionAddress::AdditionalData()
{
    return this->m_pAdditionalData;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Script::DkmScriptInstructionAddress::Create(Microsoft::VisualStudio::Debugger::DkmModuleInstance* pModuleInstance, Microsoft::VisualStudio::Debugger::Script::DkmScriptRuntimeInstance* pRuntimeInstance, Microsoft::VisualStudio::Debugger::Script::DkmScriptDocument* pDocument, UINT32 Revision, UINT32 StartIndex, UINT32 StatementLength, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<BYTE>* pAdditionalData, const Microsoft::VisualStudio::Debugger::DkmInstructionAddress::CPUInstruction* pCPUInstruction, Microsoft::VisualStudio::Debugger::Script::DkmScriptInstructionAddress** ppCreatedObject)
{
    return ProcF1A9A362454701895C74085D767B0A84(pModuleInstance, pRuntimeInstance, pDocument, Revision, StartIndex, StatementLength, pAdditionalData, pCPUInstruction, ppCreatedObject);
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::Script::DkmScriptDocument* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Script::DkmScriptInstructionSymbol::Document()
{
    return this->m_pDocument;
}

inline DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Script::DkmScriptInstructionSymbol::Revision()
{
    return this->m_Revision;
}

inline DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Script::DkmScriptInstructionSymbol::StartIndex()
{
    return this->m_StartIndex;
}

inline DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Script::DkmScriptInstructionSymbol::StatementLength()
{
    return this->m_StatementLength;
}

_Ret_opt_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<BYTE>* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Script::DkmScriptInstructionSymbol::AdditionalData()
{
    return this->m_pAdditionalData;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Script::DkmScriptInstructionSymbol::Create(Microsoft::VisualStudio::Debugger::Symbols::DkmModule* pModule, const GUID& RuntimeType, Microsoft::VisualStudio::Debugger::Script::DkmScriptDocument* pDocument, UINT32 Revision, UINT32 StartIndex, UINT32 StatementLength, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<BYTE>* pAdditionalData, Microsoft::VisualStudio::Debugger::Script::DkmScriptInstructionSymbol** ppCreatedObject)
{
    return ProcB0BD63F2B9661E923F8200970F45D067(pModule, RuntimeType, pDocument, Revision, StartIndex, StatementLength, pAdditionalData, ppCreatedObject);
}

#ifndef EXCLUDE_MONITOR_ONLY_APIS
inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Script::DkmScriptInstructionSymbol::GetNextSteppingAction(Microsoft::VisualStudio::Debugger::Script::DkmScriptInstructionSymbol* pStartingInstruction, bool IsSteppingByLine, Microsoft::VisualStudio::Debugger::Script::DkmScriptSymbolNextSteppingAction_t* pResult)
{
    return Proc35C553500D44E1B4057B6A4FA0819122(this, pStartingInstruction, IsSteppingByLine, pResult);
}
#endif // #ifndef EXCLUDE_MONITOR_ONLY_APIS

inline DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Script::DkmScriptRuntimeInstance::LoadOrderIndex()
{
    return this->m_LoadOrderIndex;
}

inline DECLSPEC_NOTHROW bool STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Script::DkmScriptRuntimeInstance::IsEdgeHtmlDll()
{
    // This method was introduced after the initial version of the API. The caller is
    // responsible for taking steps to ensure that this method is not called when running
    // against earlier versions of vsdebugeng.dll.
    ATLASSERT(DkmComponentManager::IsApiVersionSupported(DkmApiVersion::VS14RTM) || !"Invalid usage detected. Process will crash or bogus data will be returned");
    return this->m__pExtendedData->IsEdgeHtmlDll;
}

inline DECLSPEC_NOTHROW UINT64 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Script::DkmScriptRuntimeInstance::ScriptHostVersion()
{
    // This method was introduced after the initial version of the API. The caller is
    // responsible for taking steps to ensure that this method is not called when running
    // against earlier versions of vsdebugeng.dll.
    ATLASSERT(DkmComponentManager::IsApiVersionSupported(DkmApiVersion::VS14RTM) || !"Invalid usage detected. Process will crash or bogus data will be returned");
    return this->m__pExtendedData->ScriptHostVersion;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Script::DkmScriptRuntimeInstance::Create(Microsoft::VisualStudio::Debugger::DkmProcess* pProcess, const Microsoft::VisualStudio::Debugger::DkmRuntimeInstanceId& Id, UINT32 LoadOrderIndex, const Microsoft::VisualStudio::Debugger::DkmDataItem& DataItem, Microsoft::VisualStudio::Debugger::Script::DkmScriptRuntimeInstance** ppCreatedObject)
{
    return Proc470676CA7F49CBA39017F29721BF5721(pProcess, Id, LoadOrderIndex, DataItem, ppCreatedObject);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Script::DkmScriptRuntimeInstance::Create(Microsoft::VisualStudio::Debugger::DkmProcess* pProcess, const Microsoft::VisualStudio::Debugger::DkmRuntimeInstanceId& Id, Microsoft::VisualStudio::Debugger::DkmRuntimeCapabilities_t Capabilities, Microsoft::VisualStudio::Debugger::DkmRuntimeInstance* pParentRuntime, UINT32 LoadOrderIndex, const Microsoft::VisualStudio::Debugger::DkmDataItem& DataItem, Microsoft::VisualStudio::Debugger::Script::DkmScriptRuntimeInstance** ppCreatedObject)
{
    return ProcB33C67B27C7D54EBA23E2C2FB33D4DBC(pProcess, Id, Capabilities, pParentRuntime, LoadOrderIndex, DataItem, ppCreatedObject);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Script::DkmScriptRuntimeInstance::Create(Microsoft::VisualStudio::Debugger::DkmProcess* pProcess, const Microsoft::VisualStudio::Debugger::DkmRuntimeInstanceId& Id, Microsoft::VisualStudio::Debugger::DkmRuntimeCapabilities_t Capabilities, Microsoft::VisualStudio::Debugger::DkmRuntimeInstance* pParentRuntime, UINT32 LoadOrderIndex, bool IsEdgeHtmlDll, UINT64 ScriptHostVersion, const Microsoft::VisualStudio::Debugger::DkmDataItem& DataItem, Microsoft::VisualStudio::Debugger::Script::DkmScriptRuntimeInstance** ppCreatedObject)
{
    return ProcCAE8512E35EA05E7C9580B90ACA14D37(pProcess, Id, Capabilities, pParentRuntime, LoadOrderIndex, IsEdgeHtmlDll, ScriptHostVersion, DataItem, ppCreatedObject);
}

#ifndef EXCLUDE_MONITOR_ONLY_APIS
inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Script::DkmScriptRuntimeInstance::GetRemoteDebugApplication(IRemoteDebugApplication** ppApplication)
{
    return Proc7BC07BA209278B7749391B532A06C4B1(this, ppApplication);
}
#endif // #ifndef EXCLUDE_MONITOR_ONLY_APIS

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Script::DkmScriptRuntimeInstance::AbortExecutionOnResume()
{
    return Proc69A328E0ADD079DF0ACFF13D910911C8(this);
}

#ifndef EXCLUDE_MONITOR_ONLY_APIS
inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Script::DkmScriptRuntimeInstance::OnScriptCriticalError(Microsoft::VisualStudio::Debugger::DkmWorkList* pWorkList, Microsoft::VisualStudio::Debugger::DkmString* pSource, UINT32 MessageId, Microsoft::VisualStudio::Debugger::DkmString* pMessage, Microsoft::VisualStudio::Debugger::Script::DkmScriptInstructionAddress* pInstructionAddress, Microsoft::VisualStudio::Debugger::Symbols::DkmSourcePosition* pSourcePosition, Microsoft::VisualStudio::Debugger::IDkmCompletionRoutine<Microsoft::VisualStudio::Debugger::Script::DkmOnScriptCriticalErrorAsyncResult>* pCompletionRoutine)
{
    return Proc128384C8203A27AA4CD3890344DFF576(this, pWorkList, pSource, MessageId, pMessage, pInstructionAddress, pSourcePosition, pCompletionRoutine);
}
#endif // #ifndef EXCLUDE_MONITOR_ONLY_APIS

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Script::DkmScriptRuntimeInstance::OnScriptSymbolsUpdated(const Microsoft::VisualStudio::Debugger::DkmArray<Microsoft::VisualStudio::Debugger::Script::DkmScriptDocument*>& Documents)
{
    return ProcAEDE145089DD531D49D8D3AFC3277A6C(this, Documents);
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmString* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Script::DkmScriptSourceProjectItem::Path()
{
    return this->m_pPath;
}

inline DECLSPEC_NOTHROW bool STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Script::DkmScriptSourceProjectItem::IsGenerated()
{
    return this->m_IsGenerated;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Script::DkmScriptSourceProjectItem::Create(Microsoft::VisualStudio::Debugger::DkmString* pPath, bool IsGenerated, Microsoft::VisualStudio::Debugger::Script::DkmScriptSourceProjectItem** ppCreatedObject)
{
    return Proc2F17F66CDE0E78674E5011F343327F56(pPath, IsGenerated, ppCreatedObject);
}

inline DECLSPEC_NOTHROW const GUID& STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Stepping::DkmSingleStepRequest::SourceId()
{
    return this->m_SourceId;
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmThread* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Stepping::DkmSingleStepRequest::Thread()
{
    return this->m_pThread;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Stepping::DkmSingleStepRequest::Create(const GUID& SourceId, Microsoft::VisualStudio::Debugger::DkmThread* pThread, Microsoft::VisualStudio::Debugger::Stepping::DkmSingleStepRequest** ppCreatedObject)
{
    return Proc8C8881FB7D3648D13E24DE5A80DD1F83(SourceId, pThread, ppCreatedObject);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Stepping::DkmSingleStepRequest::OnGPUSingleStepComplete(Microsoft::VisualStudio::Debugger::DkmThread* pThread)
{
    return ProcADBB6CC055D2BD215B9891EC59C55284(this, pThread);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Stepping::DkmSingleStepRequest::EnableTempBreak(const Microsoft::VisualStudio::Debugger::DkmArray<UINT64>& TempBreakInstructions)
{
    return Proc5C34DFAF0E3CA60C3523472E5C911930(this, TempBreakInstructions);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Stepping::DkmSingleStepRequest::ClearTempBreak()
{
    return Proc39295C4B4207546A5413781780E09C01(this);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Stepping::DkmSingleStepRequest::EnableSingleStep()
{
    return ProcAE64E2E60E05EDDB9DBF80F18CB6B1D1(this);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Stepping::DkmSingleStepRequest::ClearSingleStep()
{
    return ProcE5290FEE5BE393C4CBEFDBC334154102(this);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Stepping::DkmSingleStepRequest::OnSingleStepComplete()
{
    return Proc96B2A0869281F2E9E1E8FB63DDDC012B(this);
}

_Ret_opt_ inline DECLSPEC_NOTHROW const Microsoft::VisualStudio::Debugger::Symbols::DkmSourceFileId::MD5Hash* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Symbols::DkmSourceFileId::MD5HashPart()
{
    return this->m_pMD5Hash;
}

_Ret_opt_ inline DECLSPEC_NOTHROW const Microsoft::VisualStudio::Debugger::Symbols::DkmSourceFileId::SHA1Hash* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Symbols::DkmSourceFileId::SHA1HashPart()
{
    return this->m_pSHA1Hash;
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmString* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Symbols::DkmSourceFileId::DocumentName()
{
    return this->m_pDocumentName;
}

_Ret_opt_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::Script::DkmScriptDocument* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Symbols::DkmSourceFileId::ScriptDocument()
{
    return this->m_pScriptDocument;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Symbols::DkmSourceFileId::Create(Microsoft::VisualStudio::Debugger::DkmString* pDocumentName, Microsoft::VisualStudio::Debugger::Script::DkmScriptDocument* pScriptDocument, const Microsoft::VisualStudio::Debugger::Symbols::DkmSourceFileId::MD5Hash* pMD5Hash, const Microsoft::VisualStudio::Debugger::Symbols::DkmSourceFileId::SHA1Hash* pSHA1Hash, Microsoft::VisualStudio::Debugger::Symbols::DkmSourceFileId** ppCreatedObject)
{
    return Proc8CB20AF3128815B290295CECB4F778C2(pDocumentName, pScriptDocument, pMD5Hash, pSHA1Hash, ppCreatedObject);
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::Symbols::DkmSourceFileId* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Symbols::DkmSourcePosition::SourceFileId()
{
    return this->m_pSourceFileId;
}

inline DECLSPEC_NOTHROW const Microsoft::VisualStudio::Debugger::Symbols::DkmTextSpan& STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Symbols::DkmSourcePosition::TextSpan()
{
    return this->m_TextSpan;
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmString* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Symbols::DkmSourcePosition::DocumentName()
{
    return this->m_pSourceFileId->DocumentName();
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Symbols::DkmSourcePosition::Create(Microsoft::VisualStudio::Debugger::Symbols::DkmSourceFileId* pSourceFileId, const Microsoft::VisualStudio::Debugger::Symbols::DkmTextSpan& TextSpan, Microsoft::VisualStudio::Debugger::Symbols::DkmSourcePosition** ppCreatedObject)
{
    return ProcC7F5C260E52A1B26A2C10C0D8BF7787C(pSourceFileId, TextSpan, ppCreatedObject);
}

#ifndef EXCLUDE_IDE_ONLY_APIS
_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::Evaluation::DkmInspectionSession* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::CallStack::DkmStackContext::InspectionSession()
{
    return this->m_pInspectionSession;
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmThread* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::CallStack::DkmStackContext::Thread()
{
    return this->m_pThread;
}

inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::CallStack::DkmCallStackFilterOptions_t STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::CallStack::DkmStackContext::FilterOptions()
{
    return this->m_FilterOptions;
}

inline DECLSPEC_NOTHROW const Microsoft::VisualStudio::Debugger::CallStack::DkmFrameFormatOptions& STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::CallStack::DkmStackContext::FormatOptions()
{
    return this->m_FormatOptions;
}

_Ret_opt_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<BYTE>* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::CallStack::DkmStackContext::ThreadContext()
{
    return this->m_pThreadContext;
}

inline DECLSPEC_NOTHROW const GUID& STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::CallStack::DkmStackContext::UniqueId()
{
    return this->m_UniqueId;
}

_Ret_opt_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::CallStack::DkmAsyncStackWalkContext* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::CallStack::DkmStackContext::AsyncContext()
{
    // This method was introduced after the initial version of the API. The caller is
    // responsible for taking steps to ensure that this method is not called when running
    // against earlier versions of vsdebugeng.dll.
    ATLASSERT(DkmComponentManager::IsApiVersionSupported(DkmApiVersion::VS12RTM) || !"Invalid usage detected. Process will crash or bogus data will be returned");
    return this->m__pExtendedData->pAsyncContext;
}

inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::CallStack::DkmStackWalkOperation_t STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::CallStack::DkmStackContext::Operation()
{
    // This method was introduced after the initial version of the API. The caller is
    // responsible for taking steps to ensure that this method is not called when running
    // against earlier versions of vsdebugeng.dll.
    ATLASSERT(DkmComponentManager::IsApiVersionSupported(DkmApiVersion::VS12RTM) || !"Invalid usage detected. Process will crash or bogus data will be returned");
    return this->m__pExtendedData->Operation;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::CallStack::DkmStackContext::Close()
{
    return ProcFFE6AA7C220F41C1F306FAAC721E5E76(this);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::CallStack::DkmStackContext::Create(Microsoft::VisualStudio::Debugger::Evaluation::DkmInspectionSession* pInspectionSession, Microsoft::VisualStudio::Debugger::DkmThread* pThread, Microsoft::VisualStudio::Debugger::CallStack::DkmCallStackFilterOptions_t FilterOptions, const Microsoft::VisualStudio::Debugger::CallStack::DkmFrameFormatOptions& FormatOptions, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<BYTE>* pThreadContext, const Microsoft::VisualStudio::Debugger::DkmDataItem& DataItem, Microsoft::VisualStudio::Debugger::CallStack::DkmStackContext** ppCreatedObject)
{
    return ProcDEEC88626A3FA552218C1327D95542B1(pInspectionSession, pThread, FilterOptions, FormatOptions, pThreadContext, DataItem, ppCreatedObject);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::CallStack::DkmStackContext::Create(Microsoft::VisualStudio::Debugger::Evaluation::DkmInspectionSession* pInspectionSession, Microsoft::VisualStudio::Debugger::DkmThread* pThread, Microsoft::VisualStudio::Debugger::CallStack::DkmCallStackFilterOptions_t FilterOptions, const Microsoft::VisualStudio::Debugger::CallStack::DkmFrameFormatOptions& FormatOptions, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<BYTE>* pThreadContext, Microsoft::VisualStudio::Debugger::CallStack::DkmAsyncStackWalkContext* pAsyncContext, Microsoft::VisualStudio::Debugger::CallStack::DkmStackWalkOperation_t Operation, const Microsoft::VisualStudio::Debugger::DkmDataItem& DataItem, Microsoft::VisualStudio::Debugger::CallStack::DkmStackContext** ppCreatedObject)
{
    return Proc25F3629003D01C15D2C699A63D201EAD(pInspectionSession, pThread, FilterOptions, FormatOptions, pThreadContext, pAsyncContext, Operation, DataItem, ppCreatedObject);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::CallStack::DkmStackContext::GetNextFrames(Microsoft::VisualStudio::Debugger::DkmWorkList* pWorkList, UINT32 RequestSize, Microsoft::VisualStudio::Debugger::IDkmCompletionRoutine<Microsoft::VisualStudio::Debugger::CallStack::DkmGetNextFramesAsyncResult>* pCompletionRoutine)
{
    return ProcC523C229635B2E14B58D880FD561BD8B(this, pWorkList, RequestSize, pCompletionRoutine);
}
#endif // #ifndef EXCLUDE_IDE_ONLY_APIS

#ifndef EXCLUDE_IDE_ONLY_APIS
inline DECLSPEC_NOTHROW const Microsoft::VisualStudio::Debugger::CallStack::DkmFrameFormatOptions& STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::CallStack::DkmStackFrame::Options()
{
    return this->m_Options;
}

inline DECLSPEC_NOTHROW const Microsoft::VisualStudio::Debugger::Evaluation::DkmCompilerId& STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::CallStack::DkmStackFrame::CompilerId()
{
    return this->m_CompilerId;
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmString* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::CallStack::DkmStackFrame::FrameName()
{
    return this->m_pFrameName;
}

_Ret_opt_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmString* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::CallStack::DkmStackFrame::ReturnType()
{
    return this->m_pReturnType;
}

_Ret_opt_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::Symbols::DkmSourcePosition* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::CallStack::DkmStackFrame::SourcePosition()
{
    return this->m_pSourcePosition;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::CallStack::DkmStackFrame::Create(Microsoft::VisualStudio::Debugger::CallStack::DkmStackWalkFrame* pFrame, const Microsoft::VisualStudio::Debugger::CallStack::DkmFrameFormatOptions& Options, const Microsoft::VisualStudio::Debugger::Evaluation::DkmCompilerId& CompilerId, Microsoft::VisualStudio::Debugger::DkmString* pFrameName, Microsoft::VisualStudio::Debugger::DkmString* pReturnType, Microsoft::VisualStudio::Debugger::Symbols::DkmSourcePosition* pSourcePosition, Microsoft::VisualStudio::Debugger::CallStack::DkmStackFrame** ppCreatedObject)
{
    return Proc28D1273D015808E5A637BACE1F82718C(pFrame, Options, CompilerId, pFrameName, pReturnType, pSourcePosition, ppCreatedObject);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::CallStack::DkmStackFrame::GetEffectiveAddresses(Microsoft::VisualStudio::Debugger::DkmInstructionAddress* pAddress, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<Microsoft::VisualStudio::Debugger::Disassembly::DkmEffectiveAddress>** ppEffectiveAddresses)
{
    return Proc4C1B28C21F3C11BDC1687B7F3D78B840(this, pAddress, ppEffectiveAddresses);
}
#endif // #ifndef EXCLUDE_IDE_ONLY_APIS

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmThread* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::CallStack::DkmStackHash::Thread()
{
    return this->m_pThread;
}

inline DECLSPEC_NOTHROW const Microsoft::VisualStudio::Debugger::CallStack::DkmStackMemoryRange& STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::CallStack::DkmStackHash::StackMemoryRange()
{
    return this->m_StackMemoryRange;
}

inline DECLSPEC_NOTHROW const Microsoft::VisualStudio::Debugger::Symbols::DkmMD5HashValue& STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::CallStack::DkmStackHash::RegisterHash()
{
    return this->m_RegisterHash;
}

inline DECLSPEC_NOTHROW const Microsoft::VisualStudio::Debugger::Symbols::DkmMD5HashValue& STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::CallStack::DkmStackHash::MemoryHash()
{
    return this->m_MemoryHash;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::CallStack::DkmStackHash::Create(Microsoft::VisualStudio::Debugger::DkmThread* pThread, const Microsoft::VisualStudio::Debugger::CallStack::DkmStackMemoryRange& StackMemoryRange, const Microsoft::VisualStudio::Debugger::Symbols::DkmMD5HashValue& RegisterHash, const Microsoft::VisualStudio::Debugger::Symbols::DkmMD5HashValue& MemoryHash, Microsoft::VisualStudio::Debugger::CallStack::DkmStackHash** ppCreatedObject)
{
    return Proc7F3F889DF5BFA8C78C8D53CD3D56516D(pThread, StackMemoryRange, RegisterHash, MemoryHash, ppCreatedObject);
}

inline DECLSPEC_NOTHROW int STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::CallStack::DkmStackMemoryRange::CompareTo(const Microsoft::VisualStudio::Debugger::CallStack::DkmStackMemoryRange& other) const
{
    return Proc9828B496783EE3A4837AA6A8CB8EA07F(*this, other);
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmThread* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::CallStack::DkmStackWalkContext::Thread()
{
    return this->m_pThread;
}

_Ret_opt_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<BYTE>* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::CallStack::DkmStackWalkContext::ThreadContext()
{
    return this->m_pThreadContext;
}

inline DECLSPEC_NOTHROW const GUID& STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::CallStack::DkmStackWalkContext::UniqueId()
{
    return this->m_UniqueId;
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmProcess* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::CallStack::DkmStackWalkContext::Process()
{
    return this->m_pThread->Process();
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::CallStack::DkmStackWalkContext::Close()
{
    return Proc0F86415E78B3D06F5C59926FF40D2E0A(this);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::CallStack::DkmStackWalkContext::Create(Microsoft::VisualStudio::Debugger::DkmThread* pThread, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<BYTE>* pThreadContext, const Microsoft::VisualStudio::Debugger::DkmDataItem& DataItem, Microsoft::VisualStudio::Debugger::CallStack::DkmStackWalkContext** ppCreatedObject)
{
    return ProcA34DFAA73EBF7F9AFDC8E6C494472623(pThread, pThreadContext, DataItem, ppCreatedObject);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::CallStack::DkmStackWalkContext::FindSymbolStackWalkContext(const GUID& SymbolProviderId, Microsoft::VisualStudio::Debugger::CallStack::DkmSymbolStackWalkContext** ppSymbolStackWalkContext)
{
    return ProcC5D26383F8A6987AA14E7F72D5BAB969(this, SymbolProviderId, ppSymbolStackWalkContext);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::CallStack::DkmStackWalkContext::HeuristicWalkFrames(Microsoft::VisualStudio::Debugger::CallStack::DkmFrameRegisters* pRegisters, UINT32 RequestSize, UINT64 EndStackPointer, Microsoft::VisualStudio::Debugger::DkmArray<Microsoft::VisualStudio::Debugger::CallStack::DkmStackWalkFrame*>* pFrames, Microsoft::VisualStudio::Debugger::CallStack::DkmFrameRegisters** ppNextRegisters, bool* pEndOfStack)
{
    return Proc565FEFF060E22589D7A3DA86DBF0C5A9(this, pRegisters, RequestSize, EndStackPointer, pFrames, ppNextRegisters, pEndOfStack);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::CallStack::DkmStackWalkContext::HeuristicWalkFrames(Microsoft::VisualStudio::Debugger::DkmWorkList* pWorkList, Microsoft::VisualStudio::Debugger::CallStack::DkmFrameRegisters* pRegisters, UINT32 RequestSize, UINT64 EndStackPointer, Microsoft::VisualStudio::Debugger::IDkmCompletionRoutine<Microsoft::VisualStudio::Debugger::CallStack::DkmHeuristicWalkFramesAsyncResult>* pCompletionRoutine)
{
    return ProcD8298F6AEBCFE639A5277E7C6B4C291E(this, pWorkList, pRegisters, RequestSize, EndStackPointer, pCompletionRoutine);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::CallStack::DkmStackWalkContext::RuntimeWalkNextFramesAndCheckCache(UINT32 RequestSizeHintIfCacheIsValid, UINT32 RequestSizeHintIfCacheIsInvalid, Microsoft::VisualStudio::Debugger::CallStack::DkmStackHash* pCachedHash, Microsoft::VisualStudio::Debugger::DkmArray<Microsoft::VisualStudio::Debugger::CallStack::DkmStackWalkFrame*>* pFrames, bool* pEndOfStack, Microsoft::VisualStudio::Debugger::CallStack::DkmStackHash** ppActualStackHash, Microsoft::VisualStudio::Debugger::CallStack::DkmStackWalkContext** ppActualStackWalkContext, bool* pIsCacheValid)
{
    return Proc919F289A3BBDF586B90161CC0F85674B(this, RequestSizeHintIfCacheIsValid, RequestSizeHintIfCacheIsInvalid, pCachedHash, pFrames, pEndOfStack, ppActualStackHash, ppActualStackWalkContext, pIsCacheValid);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::CallStack::DkmStackWalkContext::RuntimeWalkNextFramesAndCheckCache(Microsoft::VisualStudio::Debugger::DkmWorkList* pWorkList, UINT32 RequestSizeHintIfCacheIsValid, UINT32 RequestSizeHintIfCacheIsInvalid, Microsoft::VisualStudio::Debugger::CallStack::DkmStackHash* pCachedHash, Microsoft::VisualStudio::Debugger::IDkmCompletionRoutine<Microsoft::VisualStudio::Debugger::CallStack::DkmRuntimeWalkNextFramesAndCheckCacheAsyncResult>* pCompletionRoutine)
{
    return Proc582931453CE802630963C16E4C3CE31C(this, pWorkList, RequestSizeHintIfCacheIsValid, RequestSizeHintIfCacheIsInvalid, pCachedHash, pCompletionRoutine);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::CallStack::DkmStackWalkContext::RuntimeWalkNextFrames(UINT32 RequestSizeHint, Microsoft::VisualStudio::Debugger::DkmArray<Microsoft::VisualStudio::Debugger::CallStack::DkmStackWalkFrame*>* pFrames, bool* pEndOfStack)
{
    return ProcD6F5490DFB1533AA47E6BFB583FACB52(this, RequestSizeHint, pFrames, pEndOfStack);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::CallStack::DkmStackWalkContext::RuntimeWalkNextFrames(Microsoft::VisualStudio::Debugger::DkmWorkList* pWorkList, UINT32 RequestSizeHint, Microsoft::VisualStudio::Debugger::IDkmCompletionRoutine<Microsoft::VisualStudio::Debugger::CallStack::DkmRuntimeWalkNextFramesAsyncResult>* pCompletionRoutine)
{
    return ProcD7B60D34DF9743384ECC91AAED076C34(this, pWorkList, RequestSizeHint, pCompletionRoutine);
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmThread* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::CallStack::DkmStackWalkFrame::Thread()
{
    return this->m_pThread;
}

_Ret_opt_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmInstructionAddress* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::CallStack::DkmStackWalkFrame::InstructionAddress()
{
    return this->m_pInstructionAddress;
}

inline DECLSPEC_NOTHROW UINT64 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::CallStack::DkmStackWalkFrame::FrameBase()
{
    return this->m_FrameBase;
}

inline DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::CallStack::DkmStackWalkFrame::FrameSize()
{
    return this->m_FrameSize;
}

inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::CallStack::DkmStackWalkFrameFlags_t STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::CallStack::DkmStackWalkFrame::Flags()
{
    return this->m_Flags;
}

_Ret_opt_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmString* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::CallStack::DkmStackWalkFrame::Description()
{
    return this->m_pDescription;
}

_Ret_opt_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::CallStack::DkmFrameRegisters* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::CallStack::DkmStackWalkFrame::Registers()
{
    return this->m_pRegisters;
}

_Ret_opt_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<Microsoft::VisualStudio::Debugger::CallStack::DkmStackWalkFrameAnnotation*>* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::CallStack::DkmStackWalkFrame::Annotations()
{
    return this->m_pAnnotations;
}

_Ret_opt_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmModuleInstance* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::CallStack::DkmStackWalkFrame::AnnotatedModule()
{
    // This method was introduced after the initial version of the API. The caller is
    // responsible for taking steps to ensure that this method is not called when running
    // against earlier versions of vsdebugeng.dll.
    ATLASSERT(DkmComponentManager::IsApiVersionSupported(DkmApiVersion::VS12RTM) || !"Invalid usage detected. Process will crash or bogus data will be returned");
    return this->m__pExtendedData->pAnnotatedModule;
}

_Ret_opt_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::CallStack::DkmAsyncStackWalkContext* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::CallStack::DkmStackWalkFrame::AsyncContext()
{
    // This method was introduced after the initial version of the API. The caller is
    // responsible for taking steps to ensure that this method is not called when running
    // against earlier versions of vsdebugeng.dll.
    ATLASSERT(DkmComponentManager::IsApiVersionSupported(DkmApiVersion::VS12RTM) || !"Invalid usage detected. Process will crash or bogus data will be returned");
    return this->m__pExtendedData->pAsyncContext;
}

_Ret_opt_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::CallStack::DkmStackWalkFrameData* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::CallStack::DkmStackWalkFrame::Data()
{
    // This method was introduced after the initial version of the API. The caller is
    // responsible for taking steps to ensure that this method is not called when running
    // against earlier versions of vsdebugeng.dll.
    ATLASSERT(DkmComponentManager::IsApiVersionSupported(DkmApiVersion::VS12RTM) || !"Invalid usage detected. Process will crash or bogus data will be returned");
    return this->m__pExtendedData->pData;
}

_Ret_opt_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmRuntimeInstance* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::CallStack::DkmStackWalkFrame::RuntimeInstance()
{
    if (this->m_pInstructionAddress != NULL)
    {
        return this->m_pInstructionAddress->RuntimeInstance();
    }
    return (Microsoft::VisualStudio::Debugger::DkmRuntimeInstance*)0;
}

_Ret_opt_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmModuleInstance* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::CallStack::DkmStackWalkFrame::ModuleInstance()
{
    if (this->m_pInstructionAddress != NULL)
    {
        return this->m_pInstructionAddress->ModuleInstance();
    }
    return (Microsoft::VisualStudio::Debugger::DkmModuleInstance*)0;
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmProcess* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::CallStack::DkmStackWalkFrame::Process()
{
    return this->m_pThread->Process();
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DefaultPort::DkmTransportConnection* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::CallStack::DkmStackWalkFrame::Connection()
{
    return this->m_pThread->Connection();
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::CallStack::DkmStackWalkFrame::Create(Microsoft::VisualStudio::Debugger::DkmThread* pThread, Microsoft::VisualStudio::Debugger::DkmInstructionAddress* pInstructionAddress, UINT64 FrameBase, UINT32 FrameSize, Microsoft::VisualStudio::Debugger::CallStack::DkmStackWalkFrameFlags_t Flags, Microsoft::VisualStudio::Debugger::DkmString* pDescription, Microsoft::VisualStudio::Debugger::CallStack::DkmFrameRegisters* pRegisters, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<Microsoft::VisualStudio::Debugger::CallStack::DkmStackWalkFrameAnnotation*>* pAnnotations, Microsoft::VisualStudio::Debugger::CallStack::DkmStackWalkFrame** ppCreatedObject)
{
    return ProcA0BA43B79BBE61B6ED073DE327837C99(pThread, pInstructionAddress, FrameBase, FrameSize, Flags, pDescription, pRegisters, pAnnotations, ppCreatedObject);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::CallStack::DkmStackWalkFrame::Create(Microsoft::VisualStudio::Debugger::DkmThread* pThread, Microsoft::VisualStudio::Debugger::DkmInstructionAddress* pInstructionAddress, UINT64 FrameBase, UINT32 FrameSize, Microsoft::VisualStudio::Debugger::CallStack::DkmStackWalkFrameFlags_t Flags, Microsoft::VisualStudio::Debugger::DkmString* pDescription, Microsoft::VisualStudio::Debugger::CallStack::DkmFrameRegisters* pRegisters, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<Microsoft::VisualStudio::Debugger::CallStack::DkmStackWalkFrameAnnotation*>* pAnnotations, Microsoft::VisualStudio::Debugger::DkmModuleInstance* pAnnotatedModule, Microsoft::VisualStudio::Debugger::CallStack::DkmAsyncStackWalkContext* pAsyncContext, Microsoft::VisualStudio::Debugger::CallStack::DkmStackWalkFrameData* pData, Microsoft::VisualStudio::Debugger::CallStack::DkmStackWalkFrame** ppCreatedObject)
{
    return Proc279D105745DA281D3F61B6DCF5411056(pThread, pInstructionAddress, FrameBase, FrameSize, Flags, pDescription, pRegisters, pAnnotations, pAnnotatedModule, pAsyncContext, pData, ppCreatedObject);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::CallStack::DkmStackWalkFrame::OnSetNextStatementCompleted(Microsoft::VisualStudio::Debugger::DkmInstructionAddress* pNewStatement)
{
    return Proc4E67D055D6D2E433A2852293B6E54BA1(this, pNewStatement);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::CallStack::DkmStackWalkFrame::InterceptCurrentException(Microsoft::VisualStudio::Debugger::Exceptions::DkmExceptionInterceptActionFlags_t InterceptAction, UINT64* pCookie)
{
    return Proc1630B1D062AC4FA4C48876B44B526781(this, InterceptAction, pCookie);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::CallStack::DkmStackWalkFrame::GetUnwindAddress(Microsoft::VisualStudio::Debugger::DkmInstructionAddress** ppNewAddress)
{
    return ProcB774E248DFD633FF0DB4E742857915BF(this, ppNewAddress);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::CallStack::DkmStackWalkFrame::SetNextStatement(Microsoft::VisualStudio::Debugger::DkmInstructionAddress* pNewStatement)
{
    return ProcA21A0DDB349EAED3F11615E3530AE002(this, pNewStatement);
}

#ifndef EXCLUDE_IDE_ONLY_APIS
inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::CallStack::DkmStackWalkFrame::CanSetNextStatement(Microsoft::VisualStudio::Debugger::DkmInstructionAddress* pNewStatement, UINT32* pResult)
{
    return ProcB4069C4360C0041F560E048681EFCB5E(this, pNewStatement, pResult);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::CallStack::DkmStackWalkFrame::Format(Microsoft::VisualStudio::Debugger::Evaluation::DkmInspectionSession* pInspectionSession, const Microsoft::VisualStudio::Debugger::CallStack::DkmFrameFormatOptions& Options, Microsoft::VisualStudio::Debugger::CallStack::DkmStackFrame** ppFormattedFrame)
{
    return ProcD6009FD4D2BFA6D9143568A4A20A299E(this, pInspectionSession, Options, ppFormattedFrame);
}
#endif // #ifndef EXCLUDE_IDE_ONLY_APIS

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::CallStack::DkmStackWalkFrame::GetInstructionSymbol(Microsoft::VisualStudio::Debugger::Symbols::DkmInstructionSymbol** ppSymbol)
{
    return Proc0EE400E922AE4C51108614E9BA744DBA(this, ppSymbol);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::CallStack::DkmStackWalkFrame::GetInspectionInterface(Microsoft::VisualStudio::Debugger::Evaluation::DkmInspectionSession* pSession, const GUID& InterfaceID, IUnknown** ppFrameInterface)
{
    return Proc08B4418EC0C18825B12F3E72299F915C(this, pSession, InterfaceID, ppFrameInterface);
}

#ifndef EXCLUDE_IDE_ONLY_APIS
inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::CallStack::DkmStackWalkFrame::ComputeUserStatus(Microsoft::VisualStudio::Debugger::Evaluation::DkmInspectionSession* pInspectionSession, bool* pUser, bool* pExceptionImplementation)
{
    return Proc44D0BCBEFEC7D375AC47BA3B8004849F(this, pInspectionSession, pUser, pExceptionImplementation);
}
#endif // #ifndef EXCLUDE_IDE_ONLY_APIS

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::CallStack::DkmStackWalkFrame::GetClrGenericParameters(Microsoft::VisualStudio::Debugger::DkmArray<Microsoft::VisualStudio::Debugger::DkmString*>* pParameterTypeNames)
{
    return Proc534F96B0D6ADB61962316301422644F4(this, pParameterTypeNames);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::CallStack::DkmStackWalkFrame::GetClrGenericParameters(Microsoft::VisualStudio::Debugger::DkmWorkList* pWorkList, Microsoft::VisualStudio::Debugger::IDkmCompletionRoutine<Microsoft::VisualStudio::Debugger::CallStack::DkmGetClrGenericParametersAsyncResult>* pCompletionRoutine)
{
    return Proc44405EED9324011A0B6E9A64D1EAF513(this, pWorkList, pCompletionRoutine);
}

inline DECLSPEC_NOTHROW const GUID& STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::CallStack::DkmStackWalkFrameAnnotation::Id()
{
    return this->m_Id;
}

inline DECLSPEC_NOTHROW UINT64 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::CallStack::DkmStackWalkFrameAnnotation::Value()
{
    return this->m_Value;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::CallStack::DkmStackWalkFrameAnnotation::Create(const GUID& Id, UINT64 Value, Microsoft::VisualStudio::Debugger::CallStack::DkmStackWalkFrameAnnotation** ppCreatedObject)
{
    return Proc6094CA2A993E3F9848322098956FD3F5(Id, Value, ppCreatedObject);
}

inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DefaultPort::DkmRemoteAuthenticationMode_t STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DefaultPort::DkmStandardRemoteTransportConnection::AuthenticationMode()
{
    return this->m_AuthenticationMode;
}

_Ret_opt_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmString* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DefaultPort::DkmStandardRemoteTransportConnection::ProxyServer()
{
    return this->m_pProxyServer;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DefaultPort::DkmStandardRemoteTransportConnection::Abort()
{
    return ProcDD11033D3489012566EDD562BBE02571(this);
}

inline DECLSPEC_NOTHROW const GUID& STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Stepping::DkmStepper::UniqueId()
{
    return this->m_UniqueId;
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmThread* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Stepping::DkmStepper::Thread()
{
    return this->m_pThread;
}

_Ret_opt_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmInstructionAddress* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Stepping::DkmStepper::StartingAddress()
{
    return this->m_pStartingAddress;
}

inline DECLSPEC_NOTHROW UINT64 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Stepping::DkmStepper::FrameBase()
{
    return this->m_FrameBase;
}

inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::Stepping::DkmStepKind_t STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Stepping::DkmStepper::StepKind()
{
    return this->m_StepKind;
}

inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::Stepping::DkmStepUnit_t STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Stepping::DkmStepper::StepUnit()
{
    return this->m_StepUnit;
}

inline DECLSPEC_NOTHROW const GUID& STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Stepping::DkmStepper::SourceId()
{
    return this->m_SourceId;
}

_Ret_opt_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::Stepping::DkmSteppingCodePath* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Stepping::DkmStepper::CodePath()
{
    return this->m_pCodePath;
}

_Ret_opt_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::Stepping::DkmStepper* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Stepping::DkmStepper::CrossThreadParent()
{
    return this->m_pCrossThreadParent;
}

inline DECLSPEC_NOTHROW bool STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Stepping::DkmStepper::ShouldCaptureReturnValue()
{
    // This method was introduced after the initial version of the API. The caller is
    // responsible for taking steps to ensure that this method is not called when running
    // against earlier versions of vsdebugeng.dll.
    ATLASSERT(DkmComponentManager::IsApiVersionSupported(DkmApiVersion::VS12RTM) || !"Invalid usage detected. Process will crash or bogus data will be returned");
    return this->m__pExtendedData->ShouldCaptureReturnValue;
}

_Ret_opt_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<Microsoft::VisualStudio::Debugger::Stepping::DkmSteppingCodePath*>* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Stepping::DkmStepper::CurrentCodePaths()
{
    // This method was introduced after the initial version of the API. The caller is
    // responsible for taking steps to ensure that this method is not called when running
    // against earlier versions of vsdebugeng.dll.
    ATLASSERT(DkmComponentManager::IsApiVersionSupported(DkmApiVersion::VS12RTM) || !"Invalid usage detected. Process will crash or bogus data will be returned");
    return this->m__pExtendedData->pCurrentCodePaths;
}

_Ret_opt_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmString* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Stepping::DkmStepper::CurrentMethodName()
{
    // This method was introduced after the initial version of the API. The caller is
    // responsible for taking steps to ensure that this method is not called when running
    // against earlier versions of vsdebugeng.dll.
    ATLASSERT(DkmComponentManager::IsApiVersionSupported(DkmApiVersion::VS12RTM) || !"Invalid usage detected. Process will crash or bogus data will be returned");
    return this->m__pExtendedData->pCurrentMethodName;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Stepping::DkmStepper::Close()
{
    return Proc46A6B17E652C2B421E2B2F3B3E34CD21(this);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Stepping::DkmStepper::Create(Microsoft::VisualStudio::Debugger::DkmThread* pThread, Microsoft::VisualStudio::Debugger::DkmInstructionAddress* pStartingAddress, UINT64 FrameBase, Microsoft::VisualStudio::Debugger::Stepping::DkmStepKind_t StepKind, Microsoft::VisualStudio::Debugger::Stepping::DkmStepUnit_t StepUnit, const GUID& SourceId, Microsoft::VisualStudio::Debugger::Stepping::DkmSteppingCodePath* pCodePath, Microsoft::VisualStudio::Debugger::Stepping::DkmStepper* pCrossThreadParent, const Microsoft::VisualStudio::Debugger::DkmDataItem& DataItem, Microsoft::VisualStudio::Debugger::Stepping::DkmStepper** ppCreatedObject)
{
    return Proc614B3EA5586AF72A6005519B6F6C9C50(pThread, pStartingAddress, FrameBase, StepKind, StepUnit, SourceId, pCodePath, pCrossThreadParent, DataItem, ppCreatedObject);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Stepping::DkmStepper::Create(Microsoft::VisualStudio::Debugger::DkmThread* pThread, Microsoft::VisualStudio::Debugger::DkmInstructionAddress* pStartingAddress, UINT64 FrameBase, Microsoft::VisualStudio::Debugger::Stepping::DkmStepKind_t StepKind, Microsoft::VisualStudio::Debugger::Stepping::DkmStepUnit_t StepUnit, const GUID& SourceId, Microsoft::VisualStudio::Debugger::Stepping::DkmSteppingCodePath* pCodePath, Microsoft::VisualStudio::Debugger::Stepping::DkmStepper* pCrossThreadParent, bool ShouldCaptureReturnValue, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<Microsoft::VisualStudio::Debugger::Stepping::DkmSteppingCodePath*>* pCurrentCodePaths, Microsoft::VisualStudio::Debugger::DkmString* pCurrentMethodName, const Microsoft::VisualStudio::Debugger::DkmDataItem& DataItem, Microsoft::VisualStudio::Debugger::Stepping::DkmStepper** ppCreatedObject)
{
    return ProcC1A3683E892B091686163189B43D1000(pThread, pStartingAddress, FrameBase, StepKind, StepUnit, SourceId, pCodePath, pCrossThreadParent, ShouldCaptureReturnValue, pCurrentCodePaths, pCurrentMethodName, DataItem, ppCreatedObject);
}

#ifndef EXCLUDE_MONITOR_ONLY_APIS
inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Stepping::DkmStepper::BeforeEnable()
{
    return Proc969AFD652C52B34DFBA58A08419D9038(this);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Stepping::DkmStepper::Enable(bool RemoveOtherSteppers)
{
    return Proc7B97F0FF86BD2E2D682B864DFF17E77F(this, RemoveOtherSteppers);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Stepping::DkmStepper::CancelStepper(Microsoft::VisualStudio::Debugger::DkmRuntimeInstance* pCallingRuntimeInstance)
{
    return Proc63E53E7C4821AF09FA0624C5CADC370F(this, pCallingRuntimeInstance);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Stepping::DkmStepper::GetControllingRuntimeInstance(Microsoft::VisualStudio::Debugger::DkmRuntimeInstance** ppRuntimeInstance)
{
    return ProcE7A61A9F049FF2D74FDA1483C449EB9F(this, ppRuntimeInstance);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Stepping::DkmStepper::StepControlRequested(Microsoft::VisualStudio::Debugger::Stepping::DkmStepArbitrationReason_t Reason, Microsoft::VisualStudio::Debugger::DkmRuntimeInstance* pCallingRuntimeInstance, bool* pGranted)
{
    return Proc8A5F09971F6A17F44FEF05D97B445AFD(this, Reason, pCallingRuntimeInstance, pGranted);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Stepping::DkmStepper::TakeStepControl(bool LeaveGuardsInPlace, Microsoft::VisualStudio::Debugger::Stepping::DkmStepArbitrationReason_t Reason, Microsoft::VisualStudio::Debugger::DkmRuntimeInstance* pCallingRuntimeInstance)
{
    return Proc154EECF6D0808A631400840CD20CE9A7(this, LeaveGuardsInPlace, Reason, pCallingRuntimeInstance);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Stepping::DkmStepper::OnStepArbitration(Microsoft::VisualStudio::Debugger::Stepping::DkmStepArbitrationReason_t Reason, Microsoft::VisualStudio::Debugger::DkmRuntimeInstance* pCurrentControllingRuntimeInstance)
{
    return Proc2C4711ACA8448D643F9553C50E310375(this, Reason, pCurrentControllingRuntimeInstance);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Stepping::DkmStepper::OnCrossThreadStepArbitration(Microsoft::VisualStudio::Debugger::Stepping::DkmStepArbitrationReason_t Reason, Microsoft::VisualStudio::Debugger::DkmRuntimeInstance* pCurrentControllingRuntimeInstance, Microsoft::VisualStudio::Debugger::DkmThread* pNewThread, Microsoft::VisualStudio::Debugger::DkmInstructionAddress* pNewStartingInstructionAddress, Microsoft::VisualStudio::Debugger::Stepping::DkmStepper** ppNewStepper)
{
    return Proc75944E1AEDA5BD6E213831B42B08C09F(this, Reason, pCurrentControllingRuntimeInstance, pNewThread, pNewStartingInstructionAddress, ppNewStepper);
}
#endif // #ifndef EXCLUDE_MONITOR_ONLY_APIS

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Stepping::DkmStepper::OnReturnValues(Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<Microsoft::VisualStudio::Debugger::Evaluation::DkmRawReturnValue*>* pReturnValues, bool LastValueInCurrentContext)
{
    return ProcC1E64E1BAA30DE49027A7DBE4849ED6D(this, pReturnValues, LastValueInCurrentContext);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Stepping::DkmStepper::OnStepComplete(Microsoft::VisualStudio::Debugger::DkmThread* pThread, bool HasException)
{
    return Proc23A5971C1BF1E602DEE5AB4BEFB31342(this, pThread, HasException);
}

#ifndef EXCLUDE_MONITOR_ONLY_APIS
inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Stepping::DkmStepper::SetExceptionInFlight(bool Enable)
{
    return Proc687EB6BCECC901CC320D6678FDA635CC(this, Enable);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Stepping::DkmStepper::IsExceptionInFlight(bool* pEnabled)
{
    return ProcE3FC472EC679C1DE3AB9FFAD538956CA(this, pEnabled);
}
#endif // #ifndef EXCLUDE_MONITOR_ONLY_APIS

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmString* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Stepping::DkmSteppingCodePath::Name()
{
    return this->m_pName;
}

inline DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Stepping::DkmSteppingCodePath::CodePathOffset()
{
    return this->m_CodePathOffset;
}

inline DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Stepping::DkmSteppingCodePath::EndOffset()
{
    return this->m_EndOffset;
}

_Ret_opt_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<BYTE>* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Stepping::DkmSteppingCodePath::AdditionalData()
{
    return this->m_pAdditionalData;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Stepping::DkmSteppingCodePath::Create(Microsoft::VisualStudio::Debugger::DkmString* pName, UINT32 CodePathOffset, UINT32 EndOffset, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<BYTE>* pAdditionalData, Microsoft::VisualStudio::Debugger::Stepping::DkmSteppingCodePath** ppCreatedObject)
{
    return Proc9E2248E24ABD99A8B1E10B4450E75955(pName, CodePathOffset, EndOffset, pAdditionalData, ppCreatedObject);
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::Symbols::DkmInstructionSymbol* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Stepping::DkmSteppingCodePathSource::InstructionSymbol()
{
    return this->m_pInstructionSymbol;
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmInstructionAddress* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Stepping::DkmSteppingCodePathSource::InstructionAddress()
{
    return this->m_pInstructionAddress;
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::Evaluation::DkmLanguage* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Stepping::DkmSteppingCodePathSource::Language()
{
    return this->m_pLanguage;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Stepping::DkmSteppingCodePathSource::Create(Microsoft::VisualStudio::Debugger::Symbols::DkmInstructionSymbol* pInstructionSymbol, Microsoft::VisualStudio::Debugger::DkmInstructionAddress* pInstructionAddress, Microsoft::VisualStudio::Debugger::Evaluation::DkmLanguage* pLanguage, Microsoft::VisualStudio::Debugger::Stepping::DkmSteppingCodePathSource** ppCreatedObject)
{
    return ProcB8F55C2292C5362692D5A78BF5A1E049(pInstructionSymbol, pInstructionAddress, pLanguage, ppCreatedObject);
}

#ifndef EXCLUDE_IDE_ONLY_APIS
inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Stepping::DkmSteppingCodePathSource::GetCodePaths(Microsoft::VisualStudio::Debugger::CallStack::DkmStackWalkFrame* pStackFrame, Microsoft::VisualStudio::Debugger::Stepping::DkmStepUnit_t StepUnit, Microsoft::VisualStudio::Debugger::DkmArray<Microsoft::VisualStudio::Debugger::Stepping::DkmSteppingCodePath*>* pCodePaths)
{
    return Proc0339C3F8A834349475BA153214394E66(this, pStackFrame, StepUnit, pCodePaths);
}
#endif // #ifndef EXCLUDE_IDE_ONLY_APIS

inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::Evaluation::DkmEvaluationResultFlags_t STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::Group::DkmSuccessContextGroupEvaluationResult::Flags()
{
    return this->m_Flags;
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<Microsoft::VisualStudio::Debugger::DkmString*>* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::Group::DkmSuccessContextGroupEvaluationResult::Values()
{
    return this->m_pValues;
}

_Ret_opt_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmString* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::Group::DkmSuccessContextGroupEvaluationResult::Type()
{
    return this->m_pType;
}

inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::Evaluation::DkmEvaluationResultCategory_t STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::Group::DkmSuccessContextGroupEvaluationResult::Category()
{
    return this->m_Category;
}

inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::Evaluation::DkmEvaluationResultAccessType_t STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::Group::DkmSuccessContextGroupEvaluationResult::Access()
{
    return this->m_Access;
}

inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::Evaluation::DkmEvaluationResultStorageType_t STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::Group::DkmSuccessContextGroupEvaluationResult::StorageType()
{
    return this->m_StorageType;
}

inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::Evaluation::DkmEvaluationResultTypeModifierFlags_t STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::Group::DkmSuccessContextGroupEvaluationResult::TypeModifierFlags()
{
    return this->m_TypeModifierFlags;
}

_Ret_opt_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<Microsoft::VisualStudio::Debugger::Evaluation::DkmCustomUIVisualizerInfo*>* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::Group::DkmSuccessContextGroupEvaluationResult::CustomUIVisualizers()
{
    return this->m_pCustomUIVisualizers;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::Group::DkmSuccessContextGroupEvaluationResult::Create(Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<UINT64>* pThreadIds, HRESULT EvaluationResults, Microsoft::VisualStudio::Debugger::DkmString* pName, Microsoft::VisualStudio::Debugger::DkmString* pFullName, Microsoft::VisualStudio::Debugger::DkmRuntimeInstance* pRuntimeInstance, Microsoft::VisualStudio::Debugger::Evaluation::DkmEvaluationResultFlags_t Flags, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<Microsoft::VisualStudio::Debugger::DkmString*>* pValues, Microsoft::VisualStudio::Debugger::DkmString* pType, Microsoft::VisualStudio::Debugger::Evaluation::DkmEvaluationResultCategory_t Category, Microsoft::VisualStudio::Debugger::Evaluation::DkmEvaluationResultAccessType_t Access, Microsoft::VisualStudio::Debugger::Evaluation::DkmEvaluationResultStorageType_t StorageType, Microsoft::VisualStudio::Debugger::Evaluation::DkmEvaluationResultTypeModifierFlags_t TypeModifierFlags, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<Microsoft::VisualStudio::Debugger::Evaluation::DkmCustomUIVisualizerInfo*>* pCustomUIVisualizers, const Microsoft::VisualStudio::Debugger::DkmDataItem& DataItem, Microsoft::VisualStudio::Debugger::Evaluation::Group::DkmSuccessContextGroupEvaluationResult** ppCreatedObject)
{
    return Proc0BB87DD0FEF959F7D6EBC724EA4C6B07(pThreadIds, EvaluationResults, pName, pFullName, pRuntimeInstance, Flags, pValues, pType, Category, Access, StorageType, TypeModifierFlags, pCustomUIVisualizers, DataItem, ppCreatedObject);
}

inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::Evaluation::DkmEvaluationResultFlags_t STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmSuccessEvaluationResult::Flags()
{
    return this->m_Flags;
}

_Ret_opt_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmString* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmSuccessEvaluationResult::Value()
{
    return this->m_pValue;
}

_Ret_opt_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmString* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmSuccessEvaluationResult::EditableValue()
{
    return this->m_pEditableValue;
}

_Ret_opt_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmString* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmSuccessEvaluationResult::Type()
{
    return this->m_pType;
}

inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::Evaluation::DkmEvaluationResultCategory_t STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmSuccessEvaluationResult::Category()
{
    return this->m_Category;
}

inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::Evaluation::DkmEvaluationResultAccessType_t STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmSuccessEvaluationResult::Access()
{
    return this->m_Access;
}

inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::Evaluation::DkmEvaluationResultStorageType_t STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmSuccessEvaluationResult::StorageType()
{
    return this->m_StorageType;
}

inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::Evaluation::DkmEvaluationResultTypeModifierFlags_t STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmSuccessEvaluationResult::TypeModifierFlags()
{
    return this->m_TypeModifierFlags;
}

_Ret_opt_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::Evaluation::DkmDataAddress* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmSuccessEvaluationResult::Address()
{
    return this->m_pAddress;
}

_Ret_opt_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<Microsoft::VisualStudio::Debugger::Evaluation::DkmCustomUIVisualizerInfo*>* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmSuccessEvaluationResult::CustomUIVisualizers()
{
    return this->m_pCustomUIVisualizers;
}

_Ret_opt_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<Microsoft::VisualStudio::Debugger::DkmModuleInstance*>* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmSuccessEvaluationResult::ExternalModules()
{
    return this->m_pExternalModules;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmSuccessEvaluationResult::Create(Microsoft::VisualStudio::Debugger::Evaluation::DkmInspectionContext* pInspectionContext, Microsoft::VisualStudio::Debugger::CallStack::DkmStackWalkFrame* pStackFrame, Microsoft::VisualStudio::Debugger::DkmString* pName, Microsoft::VisualStudio::Debugger::DkmString* pFullName, Microsoft::VisualStudio::Debugger::Evaluation::DkmEvaluationResultFlags_t Flags, Microsoft::VisualStudio::Debugger::DkmString* pValue, Microsoft::VisualStudio::Debugger::DkmString* pEditableValue, Microsoft::VisualStudio::Debugger::DkmString* pType, Microsoft::VisualStudio::Debugger::Evaluation::DkmEvaluationResultCategory_t Category, Microsoft::VisualStudio::Debugger::Evaluation::DkmEvaluationResultAccessType_t Access, Microsoft::VisualStudio::Debugger::Evaluation::DkmEvaluationResultStorageType_t StorageType, Microsoft::VisualStudio::Debugger::Evaluation::DkmEvaluationResultTypeModifierFlags_t TypeModifierFlags, Microsoft::VisualStudio::Debugger::Evaluation::DkmDataAddress* pAddress, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<Microsoft::VisualStudio::Debugger::Evaluation::DkmCustomUIVisualizerInfo*>* pCustomUIVisualizers, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<Microsoft::VisualStudio::Debugger::DkmModuleInstance*>* pExternalModules, const Microsoft::VisualStudio::Debugger::DkmDataItem& DataItem, Microsoft::VisualStudio::Debugger::Evaluation::DkmSuccessEvaluationResult** ppCreatedObject)
{
    return Proc42A2B316A229EB6E25BB276960D29FB9(pInspectionContext, pStackFrame, pName, pFullName, Flags, pValue, pEditableValue, pType, Category, Access, StorageType, TypeModifierFlags, pAddress, pCustomUIVisualizers, pExternalModules, DataItem, ppCreatedObject);
}

#ifndef EXCLUDE_IDE_ONLY_APIS
inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmSuccessEvaluationResult::CreateDebuggeeSideVisualizerObject(UINT32 SelectedVisualizerIndex, Microsoft::VisualStudio::Debugger::DkmString** ppExceptionType, Microsoft::VisualStudio::Debugger::DkmString** ppExceptionStackTrace, Microsoft::VisualStudio::Debugger::DkmString** ppExceptionMessage)
{
    return ProcBF4F55B3075F1581F65EC9A0DA3B90DB(this, SelectedVisualizerIndex, ppExceptionType, ppExceptionStackTrace, ppExceptionMessage);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmSuccessEvaluationResult::DestroyDebuggeeSideVisualizerObject(bool* pResult)
{
    return ProcAE0E37DAE591F76FAA05D9A44DBD9606(this, pResult);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmSuccessEvaluationResult::ResolveAssembly(Microsoft::VisualStudio::Debugger::DkmString* pAssemblyName, Microsoft::VisualStudio::Debugger::DkmString** ppAssemblyPath, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<BYTE>** ppAssemblyBytes)
{
    return ProcF10EC243109F3B64DF8A48E7F1023A39(this, pAssemblyName, ppAssemblyPath, ppAssemblyBytes);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmSuccessEvaluationResult::GetDataFromDebuggeeSideVisualizer(Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<BYTE>** ppVisualizerObject, Microsoft::VisualStudio::Debugger::DkmString** ppExceptionType, Microsoft::VisualStudio::Debugger::DkmString** ppExceptionStackTrace, Microsoft::VisualStudio::Debugger::DkmString** ppExceptionMessage)
{
    return Proc037F7F6CB3C9C69C5DA87653781BB97D(this, ppVisualizerObject, ppExceptionType, ppExceptionStackTrace, ppExceptionMessage);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmSuccessEvaluationResult::TransferDataToDebuggeeSideVisualizer(const Microsoft::VisualStudio::Debugger::DkmArray<BYTE>& DataIn, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<BYTE>** ppResponse, Microsoft::VisualStudio::Debugger::DkmString** ppExceptionType, Microsoft::VisualStudio::Debugger::DkmString** ppExceptionStackTrace, Microsoft::VisualStudio::Debugger::DkmString** ppExceptionMessage)
{
    return Proc52E095AB0C83B4CC11E33B364EBE8CC3(this, DataIn, ppResponse, ppExceptionType, ppExceptionStackTrace, ppExceptionMessage);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmSuccessEvaluationResult::CreateReplacementObjectOnDebuggeeSideVisualizer(const Microsoft::VisualStudio::Debugger::DkmArray<BYTE>& DataIn, Microsoft::VisualStudio::Debugger::DkmString** ppExceptionType, Microsoft::VisualStudio::Debugger::DkmString** ppExceptionStackTrace, Microsoft::VisualStudio::Debugger::DkmString** ppExceptionMessage)
{
    return Proc12D6FA921255A7F58679B0276D7AC79B(this, DataIn, ppExceptionType, ppExceptionStackTrace, ppExceptionMessage);
}
#endif // #ifndef EXCLUDE_IDE_ONLY_APIS

#ifndef EXCLUDE_MONITOR_ONLY_APIS
inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmSuccessEvaluationResult::GetClrValue(Microsoft::VisualStudio::Debugger::Evaluation::ClrCompilation::DkmClrValue** ppResult)
{
    return ProcE46C1A3CC6F29F0A20ED6C5F80FD2289(this, ppResult);
}
#endif // #ifndef EXCLUDE_MONITOR_ONLY_APIS

inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::Symbols::DkmSymbolFileId::Tag_t STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Symbols::DkmSymbolFileId::TagValue()
{
    return this->m_TagValue;
}

inline DECLSPEC_NOTHROW const GUID& STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Symbols::DkmSymbolFileId::SymbolProviderId()
{
    return this->m_SymbolProviderId;
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmProcess* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::FunctionResolution::DkmSymbolFunctionResolutionRequest::Process()
{
    return this->m_pProcess;
}

_Ret_opt_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::Symbols::DkmModule* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::FunctionResolution::DkmSymbolFunctionResolutionRequest::Module()
{
    return this->m_pModule;
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::Evaluation::DkmLanguage* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::FunctionResolution::DkmSymbolFunctionResolutionRequest::Language()
{
    return this->m_pLanguage;
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmString* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::FunctionResolution::DkmSymbolFunctionResolutionRequest::FunctionName()
{
    return this->m_pFunctionName;
}

inline DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::FunctionResolution::DkmSymbolFunctionResolutionRequest::LineOffset()
{
    return this->m_LineOffset;
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmString* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::FunctionResolution::DkmSymbolFunctionResolutionRequest::ModuleName()
{
    return this->m_pModuleName;
}

inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::FunctionResolution::DkmAddressSearchFlags_t STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::FunctionResolution::DkmSymbolFunctionResolutionRequest::SearchFlags()
{
    return this->m_SearchFlags;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::FunctionResolution::DkmSymbolFunctionResolutionRequest::Create(Microsoft::VisualStudio::Debugger::DkmProcess* pProcess, Microsoft::VisualStudio::Debugger::Symbols::DkmModule* pModule, Microsoft::VisualStudio::Debugger::Evaluation::DkmLanguage* pLanguage, Microsoft::VisualStudio::Debugger::DkmString* pFunctionName, UINT32 LineOffset, Microsoft::VisualStudio::Debugger::DkmString* pModuleName, Microsoft::VisualStudio::Debugger::FunctionResolution::DkmAddressSearchFlags_t SearchFlags, Microsoft::VisualStudio::Debugger::FunctionResolution::DkmSymbolFunctionResolutionRequest** ppCreatedObject)
{
    return Proc3932AEFE94C36823D1A160EFA97E3F11(pProcess, pModule, pLanguage, pFunctionName, LineOffset, pModuleName, SearchFlags, ppCreatedObject);
}

#ifndef EXCLUDE_IDE_ONLY_APIS
inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::FunctionResolution::DkmSymbolFunctionResolutionRequest::Resolve(Microsoft::VisualStudio::Debugger::DkmArray<Microsoft::VisualStudio::Debugger::Symbols::DkmInstructionSymbol*>* pAddresses)
{
    return Proc5AFC8CFC0FF188C22A757EFC938F0AB2(this, pAddresses);
}
#endif // #ifndef EXCLUDE_IDE_ONLY_APIS

#ifndef EXCLUDE_IDE_ONLY_APIS
_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::CallStack::DkmStackWalkContext* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::CallStack::DkmSymbolStackWalkContext::StackWalkContext()
{
    return this->m_pStackWalkContext;
}

inline DECLSPEC_NOTHROW const GUID& STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::CallStack::DkmSymbolStackWalkContext::SymbolProviderId()
{
    return this->m_SymbolProviderId;
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmThread* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::CallStack::DkmSymbolStackWalkContext::Thread()
{
    return this->m_pStackWalkContext->Thread();
}

_Ret_opt_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<BYTE>* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::CallStack::DkmSymbolStackWalkContext::ThreadContext()
{
    return this->m_pStackWalkContext->ThreadContext();
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::CallStack::DkmSymbolStackWalkContext::Close()
{
    return ProcBDF0D5748E83AE15E24B5B1687A335C2(this);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::CallStack::DkmSymbolStackWalkContext::Create(Microsoft::VisualStudio::Debugger::CallStack::DkmStackWalkContext* pStackWalkContext, const GUID& SymbolProviderId, const Microsoft::VisualStudio::Debugger::DkmDataItem& DataItem, Microsoft::VisualStudio::Debugger::CallStack::DkmSymbolStackWalkContext** ppCreatedObject)
{
    return ProcA2953E3BF3583689D4AA360B2A068724(pStackWalkContext, SymbolProviderId, DataItem, ppCreatedObject);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::CallStack::DkmSymbolStackWalkContext::Initialize(Microsoft::VisualStudio::Debugger::CallStack::DkmFrameRegisters* pRegisters, UINT32 StackRangeSize)
{
    return Proc11DEBCF91819AB5C7D511F5CC8132865(this, pRegisters, StackRangeSize);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::CallStack::DkmSymbolStackWalkContext::UpdatePosition(Microsoft::VisualStudio::Debugger::CallStack::DkmFrameRegisters* pRegisters, UINT32 StackRangeSize, Microsoft::VisualStudio::Debugger::DkmInstructionAddress* pInstructionAddress)
{
    return Proc8EA48BC824C9B98D3446CD1284310781(this, pRegisters, StackRangeSize, pInstructionAddress);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::CallStack::DkmSymbolStackWalkContext::WalkNextFrame(Microsoft::VisualStudio::Debugger::CallStack::DkmFrameRegisters** ppNextRegisters, Microsoft::VisualStudio::Debugger::CallStack::DkmStackWalkFrame** ppFrameObject)
{
    return ProcE53FE4708620D30C1080556AF0FFBE3F(this, ppNextRegisters, ppFrameObject);
}
#endif // #ifndef EXCLUDE_IDE_ONLY_APIS

inline DECLSPEC_NOTHROW UINT16 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DefaultPort::DkmSystemInformation::ProcessorArchitecture()
{
    return this->m_ProcessorArchitecture;
}

inline DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DefaultPort::DkmSystemInformation::PageSize()
{
    return this->m_PageSize;
}

inline DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DefaultPort::DkmSystemInformation::OperatingSystemVersion()
{
    return this->m_OperatingSystemVersion;
}

inline DECLSPEC_NOTHROW UINT16 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DefaultPort::DkmSystemInformation::SuiteMask()
{
    return this->m_SuiteMask;
}

inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DefaultPort::DkmSystemInformationFlags_t STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DefaultPort::DkmSystemInformation::Flags()
{
    return this->m_Flags;
}

inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DefaultPort::DkmProcessorFeatures_t STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DefaultPort::DkmSystemInformation::ProcessorFeatures()
{
    return this->m_ProcessorFeatures;
}

inline DECLSPEC_NOTHROW MINIDUMP_TYPE STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DefaultPort::DkmSystemInformation::MinidumpFlags()
{
    // This method was introduced after the initial version of the API. The caller is
    // responsible for taking steps to ensure that this method is not called when running
    // against earlier versions of vsdebugeng.dll.
    ATLASSERT(DkmComponentManager::IsApiVersionSupported(DkmApiVersion::VS12RTM) || !"Invalid usage detected. Process will crash or bogus data will be returned");
    return this->m__pExtendedData->MinidumpFlags;
}

_Ret_opt_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmString* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DefaultPort::DkmSystemInformation::SystemDirectory()
{
    // This method was introduced after the initial version of the API. The caller is
    // responsible for taking steps to ensure that this method is not called when running
    // against earlier versions of vsdebugeng.dll.
    ATLASSERT(DkmComponentManager::IsApiVersionSupported(DkmApiVersion::VS12RTM) || !"Invalid usage detected. Process will crash or bogus data will be returned");
    return this->m__pExtendedData->pSystemDirectory;
}

_Ret_opt_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmString* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DefaultPort::DkmSystemInformation::SystemWow64Directory()
{
    // This method was introduced after the initial version of the API. The caller is
    // responsible for taking steps to ensure that this method is not called when running
    // against earlier versions of vsdebugeng.dll.
    ATLASSERT(DkmComponentManager::IsApiVersionSupported(DkmApiVersion::VS12RTM) || !"Invalid usage detected. Process will crash or bogus data will be returned");
    return this->m__pExtendedData->pSystemWow64Directory;
}

_Ret_opt_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DefaultPort::DkmDeviceInfo* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DefaultPort::DkmSystemInformation::DeviceInfo()
{
    // This method was introduced after the initial version of the API. The caller is
    // responsible for taking steps to ensure that this method is not called when running
    // against earlier versions of vsdebugeng.dll.
    ATLASSERT(DkmComponentManager::IsApiVersionSupported(DkmApiVersion::VS14RTM) || !"Invalid usage detected. Process will crash or bogus data will be returned");
    return this->m__pExtendedData->pDeviceInfo;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DefaultPort::DkmSystemInformation::Create(UINT16 ProcessorArchitecture, UINT32 PageSize, UINT32 OperatingSystemVersion, UINT16 SuiteMask, Microsoft::VisualStudio::Debugger::DefaultPort::DkmSystemInformationFlags_t Flags, Microsoft::VisualStudio::Debugger::DefaultPort::DkmProcessorFeatures_t ProcessorFeatures, Microsoft::VisualStudio::Debugger::DefaultPort::DkmSystemInformation** ppCreatedObject)
{
    return Proc35DBD0B3A9C4D65B34C9C9DC38DEEA7A(ProcessorArchitecture, PageSize, OperatingSystemVersion, SuiteMask, Flags, ProcessorFeatures, ppCreatedObject);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DefaultPort::DkmSystemInformation::Create(UINT16 ProcessorArchitecture, UINT32 PageSize, UINT32 OperatingSystemVersion, UINT16 SuiteMask, Microsoft::VisualStudio::Debugger::DefaultPort::DkmSystemInformationFlags_t Flags, Microsoft::VisualStudio::Debugger::DefaultPort::DkmProcessorFeatures_t ProcessorFeatures, MINIDUMP_TYPE MinidumpFlags, Microsoft::VisualStudio::Debugger::DkmString* pSystemDirectory, Microsoft::VisualStudio::Debugger::DkmString* pSystemWow64Directory, Microsoft::VisualStudio::Debugger::DefaultPort::DkmSystemInformation** ppCreatedObject)
{
    return ProcBB4C4C507C3D48982BF5C6EA6D711C9C(ProcessorArchitecture, PageSize, OperatingSystemVersion, SuiteMask, Flags, ProcessorFeatures, MinidumpFlags, pSystemDirectory, pSystemWow64Directory, ppCreatedObject);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DefaultPort::DkmSystemInformation::Create(UINT16 ProcessorArchitecture, UINT32 PageSize, UINT32 OperatingSystemVersion, UINT16 SuiteMask, Microsoft::VisualStudio::Debugger::DefaultPort::DkmSystemInformationFlags_t Flags, Microsoft::VisualStudio::Debugger::DefaultPort::DkmProcessorFeatures_t ProcessorFeatures, MINIDUMP_TYPE MinidumpFlags, Microsoft::VisualStudio::Debugger::DkmString* pSystemDirectory, Microsoft::VisualStudio::Debugger::DkmString* pSystemWow64Directory, Microsoft::VisualStudio::Debugger::DefaultPort::DkmDeviceInfo* pDeviceInfo, Microsoft::VisualStudio::Debugger::DefaultPort::DkmSystemInformation** ppCreatedObject)
{
    return Proc6A78429E482A38FE4E0A0B929B65F919(ProcessorArchitecture, PageSize, OperatingSystemVersion, SuiteMask, Flags, ProcessorFeatures, MinidumpFlags, pSystemDirectory, pSystemWow64Directory, pDeviceInfo, ppCreatedObject);
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::ParallelTasks::DkmTaskProvider* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::ParallelTasks::DkmTask::TaskProvider()
{
    return this->m_pTaskProvider;
}

_Ret_opt_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmThread* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::ParallelTasks::DkmTask::Thread()
{
    return this->m_pThread;
}

inline DECLSPEC_NOTHROW UINT64 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::ParallelTasks::DkmTask::TaskId()
{
    return this->m_TaskId;
}

inline DECLSPEC_NOTHROW UINT64 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::ParallelTasks::DkmTask::ParentTaskId()
{
    return this->m_ParentTaskId;
}

inline DECLSPEC_NOTHROW const Microsoft::VisualStudio::Debugger::ParallelTasks::DkmTaskStackSegment& STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::ParallelTasks::DkmTask::StackSegment()
{
    return this->m_StackSegment;
}

inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::ParallelTasks::DkmTaskReturnStatus_t STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::ParallelTasks::DkmTask::ReturnStatus()
{
    // This method was introduced after the initial version of the API. The caller is
    // responsible for taking steps to ensure that this method is not called when running
    // against earlier versions of vsdebugeng.dll.
    ATLASSERT(DkmComponentManager::IsApiVersionSupported(DkmApiVersion::VS12RTM) || !"Invalid usage detected. Process will crash or bogus data will be returned");
    return this->m__pExtendedData->ReturnStatus;
}

inline DECLSPEC_NOTHROW double STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::ParallelTasks::DkmTask::StartTime()
{
    // This method was introduced after the initial version of the API. The caller is
    // responsible for taking steps to ensure that this method is not called when running
    // against earlier versions of vsdebugeng.dll.
    ATLASSERT(DkmComponentManager::IsApiVersionSupported(DkmApiVersion::VS12RTM) || !"Invalid usage detected. Process will crash or bogus data will be returned");
    return this->m__pExtendedData->StartTime;
}

inline DECLSPEC_NOTHROW double STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::ParallelTasks::DkmTask::CompletedTime()
{
    // This method was introduced after the initial version of the API. The caller is
    // responsible for taking steps to ensure that this method is not called when running
    // against earlier versions of vsdebugeng.dll.
    ATLASSERT(DkmComponentManager::IsApiVersionSupported(DkmApiVersion::VS12RTM) || !"Invalid usage detected. Process will crash or bogus data will be returned");
    return this->m__pExtendedData->CompletedTime;
}

inline DECLSPEC_NOTHROW double STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::ParallelTasks::DkmTask::Duration()
{
    // This method was introduced after the initial version of the API. The caller is
    // responsible for taking steps to ensure that this method is not called when running
    // against earlier versions of vsdebugeng.dll.
    ATLASSERT(DkmComponentManager::IsApiVersionSupported(DkmApiVersion::VS12RTM) || !"Invalid usage detected. Process will crash or bogus data will be returned");
    return this->m__pExtendedData->Duration;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::ParallelTasks::DkmTask::Close()
{
    return ProcE195EB82A3658BBE184BF772FE70EE44(this);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::ParallelTasks::DkmTask::Create(Microsoft::VisualStudio::Debugger::ParallelTasks::DkmTaskProvider* pTaskProvider, Microsoft::VisualStudio::Debugger::DkmThread* pThread, UINT64 TaskId, UINT64 ParentTaskId, const Microsoft::VisualStudio::Debugger::ParallelTasks::DkmTaskStackSegment& StackSegment, const Microsoft::VisualStudio::Debugger::DkmDataItem& DataItem, Microsoft::VisualStudio::Debugger::ParallelTasks::DkmTask** ppCreatedObject)
{
    return Proc3BC141B0950632BBEDF0F3A329B42598(pTaskProvider, pThread, TaskId, ParentTaskId, StackSegment, DataItem, ppCreatedObject);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::ParallelTasks::DkmTask::Create(Microsoft::VisualStudio::Debugger::ParallelTasks::DkmTaskProvider* pTaskProvider, Microsoft::VisualStudio::Debugger::DkmThread* pThread, UINT64 TaskId, UINT64 ParentTaskId, const Microsoft::VisualStudio::Debugger::ParallelTasks::DkmTaskStackSegment& StackSegment, Microsoft::VisualStudio::Debugger::ParallelTasks::DkmTaskReturnStatus_t ReturnStatus, double StartTime, double CompletedTime, double Duration, const Microsoft::VisualStudio::Debugger::DkmDataItem& DataItem, Microsoft::VisualStudio::Debugger::ParallelTasks::DkmTask** ppCreatedObject)
{
    return ProcF67FD0F8724B847483F082B115F61994(pTaskProvider, pThread, TaskId, ParentTaskId, StackSegment, ReturnStatus, StartTime, CompletedTime, Duration, DataItem, ppCreatedObject);
}

#ifndef EXCLUDE_IDE_ONLY_APIS
inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::ParallelTasks::DkmTask::GetChildTasks(Microsoft::VisualStudio::Debugger::DkmArray<Microsoft::VisualStudio::Debugger::ParallelTasks::DkmTask*>* pItems)
{
    return Proc6F163AC98BAF7B488B85A75616791C9F(this, pItems);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::ParallelTasks::DkmTask::GetTaskProperties(UINT32 Radix, UINT32 Fields, Microsoft::VisualStudio::Debugger::ParallelTasks::DkmTaskProperties* pProperties)
{
    return Proc678BC032D274C3D145554F7DA4BCF98C(this, Radix, Fields, pProperties);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::ParallelTasks::DkmTask::GetSynchronizationObjects(Microsoft::VisualStudio::Debugger::DkmArray<Microsoft::VisualStudio::Debugger::ParallelTasks::DkmTaskSynchronizationObject*>* pItems)
{
    return ProcEAFDA659BBC3E7B5DECD28D58939CC40(this, pItems);
}
#endif // #ifndef EXCLUDE_IDE_ONLY_APIS

inline DECLSPEC_NOTHROW void STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::ParallelTasks::DkmTaskProperties::Release(Microsoft::VisualStudio::Debugger::ParallelTasks::DkmTaskProperties* pItem)
{
    return ProcA07FAFB63F4649DD290A721E8EFE4162(pItem);
}

inline DECLSPEC_NOTHROW const GUID& STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::ParallelTasks::DkmTaskProvider::TaskProviderId()
{
    return this->m_TaskProviderId;
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmString* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::ParallelTasks::DkmTaskProvider::Name()
{
    return this->m_pName;
}

inline DECLSPEC_NOTHROW const GUID& STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::ParallelTasks::DkmTaskProvider::UniqueId()
{
    return this->m_UniqueId;
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmRuntimeInstance* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::ParallelTasks::DkmTaskProvider::RuntimeInstance()
{
    return this->m_pRuntimeInstance;
}

inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::ParallelTasks::DkmTaskProviderCapabilityFlags_t STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::ParallelTasks::DkmTaskProvider::AdditionalCapabilities()
{
    // This method was introduced after the initial version of the API. The caller is
    // responsible for taking steps to ensure that this method is not called when running
    // against earlier versions of vsdebugeng.dll.
    ATLASSERT(DkmComponentManager::IsApiVersionSupported(DkmApiVersion::VS12RTM) || !"Invalid usage detected. Process will crash or bogus data will be returned");
    return this->m__pExtendedData->AdditionalCapabilities;
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmProcess* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::ParallelTasks::DkmTaskProvider::Process()
{
    return this->m_pRuntimeInstance->Process();
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::ParallelTasks::DkmTaskProvider::Close()
{
    return Proc21FB0093543B45F8828E79D9EEF3AA3A(this);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::ParallelTasks::DkmTaskProvider::Create(const GUID& TaskProviderId, Microsoft::VisualStudio::Debugger::DkmString* pName, Microsoft::VisualStudio::Debugger::DkmRuntimeInstance* pRuntimeInstance, const Microsoft::VisualStudio::Debugger::DkmDataItem& DataItem, Microsoft::VisualStudio::Debugger::ParallelTasks::DkmTaskProvider** ppCreatedObject)
{
    return ProcCCE97B15762479275D3FB2967C597CCB(TaskProviderId, pName, pRuntimeInstance, DataItem, ppCreatedObject);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::ParallelTasks::DkmTaskProvider::Create(const GUID& TaskProviderId, Microsoft::VisualStudio::Debugger::DkmString* pName, Microsoft::VisualStudio::Debugger::DkmRuntimeInstance* pRuntimeInstance, Microsoft::VisualStudio::Debugger::ParallelTasks::DkmTaskProviderCapabilityFlags_t AdditionalCapabilities, const Microsoft::VisualStudio::Debugger::DkmDataItem& DataItem, Microsoft::VisualStudio::Debugger::ParallelTasks::DkmTaskProvider** ppCreatedObject)
{
    return ProcF5AF3CCABE57E88CB0B16B900C3902FB(TaskProviderId, pName, pRuntimeInstance, AdditionalCapabilities, DataItem, ppCreatedObject);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::ParallelTasks::DkmTaskProvider::FindTask(UINT64 TaskId, Microsoft::VisualStudio::Debugger::ParallelTasks::DkmTask** ppTask)
{
    return Proc62E124921D164B7AECA13D786603EC06(this, TaskId, ppTask);
}

#ifndef EXCLUDE_IDE_ONLY_APIS
inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::ParallelTasks::DkmTaskProvider::GetTasks(bool IsRoot, UINT32 RequestCount, UINT32* pScheduledTaskCount, Microsoft::VisualStudio::Debugger::DkmArray<Microsoft::VisualStudio::Debugger::ParallelTasks::DkmTask*>* pItems, UINT32* pTaskEnumFlags)
{
    return ProcCDD4E8C991BEBFAC2D35C0F765297B11(this, IsRoot, RequestCount, pScheduledTaskCount, pItems, pTaskEnumFlags);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::ParallelTasks::DkmTaskProvider::GetPropertyNames(Microsoft::VisualStudio::Debugger::DkmArray<Microsoft::VisualStudio::Debugger::DkmString*>* pNames)
{
    return Proc1C52C73B1F05AD5D701CFE684EFF003B(this, pNames);
}
#endif // #ifndef EXCLUDE_IDE_ONLY_APIS

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::ParallelTasks::DkmTask* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::ParallelTasks::DkmTaskSynchronizationObject::Task()
{
    return this->m_pTask;
}

_Ret_opt_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmThread* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::ParallelTasks::DkmTaskSynchronizationObject::OwningThread()
{
    return this->m_pOwningThread;
}

inline DECLSPEC_NOTHROW const GUID& STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::ParallelTasks::DkmTaskSynchronizationObject::UniqueId()
{
    return this->m_UniqueId;
}

_Ret_opt_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmString* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::ParallelTasks::DkmTaskSynchronizationObject::DecimalName()
{
    return this->m_pDecimalName;
}

_Ret_opt_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmString* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::ParallelTasks::DkmTaskSynchronizationObject::HexidecimalName()
{
    return this->m_pHexidecimalName;
}

_Ret_opt_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmString* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::ParallelTasks::DkmTaskSynchronizationObject::Type()
{
    return this->m_pType;
}

inline DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::ParallelTasks::DkmTaskSynchronizationObject::WaitTime()
{
    return this->m_WaitTime;
}

inline DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::ParallelTasks::DkmTaskSynchronizationObject::Timeout()
{
    return this->m_Timeout;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::ParallelTasks::DkmTaskSynchronizationObject::Close()
{
    return ProcF54418460BC26AF2C3429E967BAEDB56(this);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::ParallelTasks::DkmTaskSynchronizationObject::Create(Microsoft::VisualStudio::Debugger::ParallelTasks::DkmTask* pTask, Microsoft::VisualStudio::Debugger::DkmThread* pOwningThread, Microsoft::VisualStudio::Debugger::DkmString* pDecimalName, Microsoft::VisualStudio::Debugger::DkmString* pHexidecimalName, Microsoft::VisualStudio::Debugger::DkmString* pType, UINT32 WaitTime, UINT32 Timeout, const Microsoft::VisualStudio::Debugger::DkmDataItem& DataItem, Microsoft::VisualStudio::Debugger::ParallelTasks::DkmTaskSynchronizationObject** ppCreatedObject)
{
    return ProcA598DC6767B6B5E321EA1C7E6742268C(pTask, pOwningThread, pDecimalName, pHexidecimalName, pType, WaitTime, Timeout, DataItem, ppCreatedObject);
}

inline DECLSPEC_NOTHROW int STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Symbols::DkmTextSpan::CompareTo(const Microsoft::VisualStudio::Debugger::Symbols::DkmTextSpan& other) const
{
    return Proc94CE83C176C18E080657DE893B3FB7D1(*this, other);
}

_Ret_opt_ inline DECLSPEC_NOTHROW const Microsoft::VisualStudio::Debugger::DkmThread::System* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmThread::SystemPart()
{
    return this->m_pSystem;
}

inline DECLSPEC_NOTHROW const GUID& STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmThread::UniqueId()
{
    return this->m_UniqueId;
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmProcess* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmThread::Process()
{
    return this->m_pProcess;
}

inline DECLSPEC_NOTHROW UINT64 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmThread::NativeStartAddress()
{
    return this->m_NativeStartAddress;
}

inline DECLSPEC_NOTHROW UINT64 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmThread::TebAddress()
{
    return this->m_TebAddress;
}

inline DECLSPEC_NOTHROW bool STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmThread::IsMainThread()
{
    return this->m_IsMainThread;
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DefaultPort::DkmTransportConnection* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmThread::Connection()
{
    return this->m_pProcess->Connection();
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DefaultPort::DkmSystemInformation* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmThread::SystemInformation()
{
    return this->m_pProcess->SystemInformation();
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmThread::Create(Microsoft::VisualStudio::Debugger::DkmProcess* pProcess, UINT64 NativeStartAddress, UINT64 TebAddress, bool IsMainThread, const Microsoft::VisualStudio::Debugger::DkmThread::System* pSystem, const Microsoft::VisualStudio::Debugger::DkmDataItem& DataItem, Microsoft::VisualStudio::Debugger::DkmThread** ppCreatedObject)
{
    return Proc660872E9B1A72FBC89EE136ED9490954(pProcess, NativeStartAddress, TebAddress, IsMainThread, pSystem, DataItem, ppCreatedObject);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmThread::GetSteppers(Microsoft::VisualStudio::Debugger::DkmArray<Microsoft::VisualStudio::Debugger::Stepping::DkmStepper*>* pSteppers)
{
    return Proc32245DDCC51A1CA87768FB26C135C6CF(this, pSteppers);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmThread::OnEmbeddedBreakpointHit(Microsoft::VisualStudio::Debugger::DkmInstructionAddress* pInstructionAddress, bool ShowAsException)
{
    return Proc9EC9594DE9AD4721F7CA1A6661474411(this, pInstructionAddress, ShowAsException);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmThread::BeginFuncEvalExecution(Microsoft::VisualStudio::Debugger::Evaluation::DkmFuncEvalFlags_t Flags)
{
    return Proc21018EEF594F640991F4C8723510500B(this, Flags);
}

#ifndef EXCLUDE_MONITOR_ONLY_APIS
inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmThread::RaiseExecutionControlException(UINT32 ExceptionCode)
{
    return ProcCC77495B04753F1B0085CAF63BCF1679(this, ExceptionCode);
}
#endif // #ifndef EXCLUDE_MONITOR_ONLY_APIS

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmThread::GetExtendedRegisters(Microsoft::VisualStudio::Debugger::DkmArray<Microsoft::VisualStudio::Debugger::CallStack::DkmUnwoundRegister*>* pExtendedRegisters)
{
    return ProcC85E3C661A3F69393C3308D5AA724031(this, pExtendedRegisters);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmThread::SetExtendedRegisterValue(CV_HREG_e RegisterIndex, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<BYTE>* pValue)
{
    return ProcDA2C88FCD29A13D41642E51A73A0C5F3(this, RegisterIndex, pValue);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmThread::CreateFrameRegisters(const Microsoft::VisualStudio::Debugger::DkmArray<Microsoft::VisualStudio::Debugger::CallStack::DkmUnwoundRegister*>& UnwoundRegisters, UINT32 VFrame, Microsoft::VisualStudio::Debugger::CallStack::DkmFrameRegisters** ppCreatedObject)
{
    return ProcCFC90B74E86F409E42174D75C612ECC1(this, UnwoundRegisters, VFrame, ppCreatedObject);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmThread::GetManagedThreadProperties(INT32* pManagedThreadId)
{
    return Proc1F8112701DC8FD65384408A8F7AC2688(this, pManagedThreadId);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmThread::GetManagedThreadProperties(Microsoft::VisualStudio::Debugger::DkmWorkList* pWorkList, Microsoft::VisualStudio::Debugger::IDkmCompletionRoutine<Microsoft::VisualStudio::Debugger::ThreadProperties::DkmGetManagedThreadPropertiesAsyncResult>* pCompletionRoutine)
{
    return Proc32E9F18F7EC761620221F110A2CE057F(this, pWorkList, pCompletionRoutine);
}

#ifndef EXCLUDE_MONITOR_ONLY_APIS
inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmThread::GetTopStackWalkFrame(Microsoft::VisualStudio::Debugger::DkmRuntimeInstance* pRuntimeInstance, Microsoft::VisualStudio::Debugger::CallStack::DkmStackWalkFrame** ppFrame)
{
    return Proc8877C3D70304E8D4D8932D1B95A128BC(this, pRuntimeInstance, ppFrame);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmThread::GetCurrentFrameInfo(UINT64* pReturnAddress, UINT64* pFrameBase, UINT64* pVFrame)
{
    return Proc13E806B9B3C4319EF36A2D0160C5F358(this, pReturnAddress, pFrameBase, pVFrame);
}
#endif // #ifndef EXCLUDE_MONITOR_ONLY_APIS

#ifndef EXCLUDE_IDE_ONLY_APIS
inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmThread::GetTopStackFrame(Microsoft::VisualStudio::Debugger::CallStack::DkmStackWalkFrame** ppTopFrame)
{
    return ProcF5A59EE47B626A7A0FF46B584F2CF13F(this, ppTopFrame);
}
#endif // #ifndef EXCLUDE_IDE_ONLY_APIS

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmThread::GetCurrentRegisters(const Microsoft::VisualStudio::Debugger::DkmArray<Microsoft::VisualStudio::Debugger::CallStack::DkmUnwoundRegister*>& PseudoRegisters, Microsoft::VisualStudio::Debugger::CallStack::DkmFrameRegisters** ppCreatedObject)
{
    return Proc764B89CAFFE718355031F1555E23D68B(this, PseudoRegisters, ppCreatedObject);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmThread::CreateRegistersObject(const Microsoft::VisualStudio::Debugger::DkmArray<BYTE>& ThreadContext, const Microsoft::VisualStudio::Debugger::DkmArray<Microsoft::VisualStudio::Debugger::CallStack::DkmUnwoundRegister*>& PseudoRegisters, const Microsoft::VisualStudio::Debugger::DkmArray<Microsoft::VisualStudio::Debugger::CallStack::DkmUnwoundRegister*>& ExtendedRegisters, Microsoft::VisualStudio::Debugger::CallStack::DkmFrameRegisters** ppCreatedObject)
{
    return ProcE07A59DADEB847529B1EDACF190F9622(this, ThreadContext, PseudoRegisters, ExtendedRegisters, ppCreatedObject);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmThread::OnContinueExecution(bool* pContinueTargetProcess)
{
    return Proc0960E067C6E6CE7EBFEEDBBDFE1D27A8(this, pContinueTargetProcess);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmThread::OnBeginFuncEvalExecution(Microsoft::VisualStudio::Debugger::Evaluation::DkmFuncEvalFlags_t Flags, bool* pContinueTargetProcess)
{
    return Proc82FF1FA4E1EEAE6244230B42302688EF(this, Flags, pContinueTargetProcess);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmThread::EndFuncEvalExecution(Microsoft::VisualStudio::Debugger::Evaluation::DkmFuncEvalFlags_t Flags)
{
    return ProcF525CDEB2CCDEEF6A83975AAF4A2818E(this, Flags);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmThread::IsStoppingEventQueued(bool IgnoreAsyncBreakEvents, bool* pResult)
{
    return ProcEBB9C20B7D84DC94119D75E52F0311D0(this, IgnoreAsyncBreakEvents, pResult);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmThread::GetCurrentFuncEvalMode(Microsoft::VisualStudio::Debugger::DkmFuncEvalMode_t* pCurrentMode)
{
    return ProcE7E936BAFB8A03BADC8D5E852E215D5F(this, pCurrentMode);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmThread::SetContext(const Microsoft::VisualStudio::Debugger::DkmArray<BYTE>& Context)
{
    return Proc47057DDC632AD45CEC7B2F19D7C55FC5(this, Context);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmThread::GetContext(UINT32 ContextFlags, void* pContext, UINT32 ContextSize)
{
    return Proc6C71BAFC0CA8B6BB34725A9DB87FBDAC(this, ContextFlags, pContext, ContextSize);
}

#ifndef EXCLUDE_IDE_ONLY_APIS
inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmThread::GetCurrentLocation(Microsoft::VisualStudio::Debugger::DkmWorkList* pWorkList, Microsoft::VisualStudio::Debugger::IDkmCompletionRoutine<Microsoft::VisualStudio::Debugger::CallStack::DkmGetCurrentLocationAsyncResult>* pCompletionRoutine)
{
    return Proc4560E9791A28974C03DBB766B0923E3F(this, pWorkList, pCompletionRoutine);
}
#endif // #ifndef EXCLUDE_IDE_ONLY_APIS

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmThread::GetStackAddressRange(Microsoft::VisualStudio::Debugger::CallStack::DkmStackMemoryRange* pMemoryRange)
{
    return ProcBF51E4F2615C39213EB93E638D855420(this, pMemoryRange);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmThread::Suspend(bool InternalSuspension, UINT32* pExternalSuspensionCount)
{
    return Proc8B5D381DB7DEAB34963D4ED0B1F13B59(this, InternalSuspension, pExternalSuspensionCount);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmThread::Resume(bool InternalSuspension, UINT32* pExternalSuspensionCount)
{
    return Proc0CD674D84CB44BC00252F10D501563F9(this, InternalSuspension, pExternalSuspensionCount);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmThread::GetSuspensionCount(bool ShowInternal, UINT32* pSuspensionCount)
{
    return ProcD1CE80C145D86692B21A5385E307B03C(this, ShowInternal, pSuspensionCount);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmThread::GetDebuggerSuspensionCount(UINT32* pSuspensionCount)
{
    return Proc43848E55BF00ABC986124109B62D5595(this, pSuspensionCount);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmThread::GetTlsValue(UINT32 TlsIndex, UINT64* pValue)
{
    return Proc73F92C73F402A0645B5F0E13E132A009(this, TlsIndex, pValue);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmThread::SetTlsValue(UINT32 TlsIndex, UINT64 Value)
{
    return Proc2953901DB8E2A56A7761ADC76A4C51C9(this, TlsIndex, Value);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmThread::GetVolatileProperties(INT32* pPriority, UINT64* pAffinityMask)
{
    return ProcCB686005B0C45325B528A4AB178C8DDA(this, pPriority, pAffinityMask);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmThread::GetVolatileProperties(Microsoft::VisualStudio::Debugger::DkmWorkList* pWorkList, Microsoft::VisualStudio::Debugger::IDkmCompletionRoutine<Microsoft::VisualStudio::Debugger::ThreadProperties::DkmGetVolatilePropertiesAsyncResult>* pCompletionRoutine)
{
    return Proc85E5BDCC65DBFBFD46BD72850AB5598D(this, pWorkList, pCompletionRoutine);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmThread::GetVolatileFlags(Microsoft::VisualStudio::Debugger::ThreadProperties::DkmVolatileThreadFlags_t* pFlags)
{
    return Proc72D8789037B29D9BE4656FCAB8B158C1(this, pFlags);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmThread::GetVolatileFlags(Microsoft::VisualStudio::Debugger::DkmWorkList* pWorkList, Microsoft::VisualStudio::Debugger::IDkmCompletionRoutine<Microsoft::VisualStudio::Debugger::ThreadProperties::DkmGetVolatileFlagsAsyncResult>* pCompletionRoutine)
{
    return ProcE025EC0D8596C9875C1203A22839D44C(this, pWorkList, pCompletionRoutine);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmThread::OnInterceptExceptionCompleted(UINT64 Cookie)
{
    return Proc28873A94D65410FCC0056B9C83596DD0(this, Cookie);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmThread::Unload(UINT32 ExitCode)
{
    return ProcCEC10D8029BB7FE6392177BA9943EDE1(this, ExitCode);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmThread::GetThreadCurrentWinRtErrorInfo(UINT64* pWinRTErrorInfo)
{
    return ProcA889D7143B7FAC827A4BAE8265E8FB6A(this, pWinRTErrorInfo);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmThread::OnThreadNameChange()
{
    return ProcFECA898F562A1BE8B44B5148E9227073(this);
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILEvaluationResult*>* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::Group::DkmThreadEvaluationResultCollection::Results()
{
    return this->m_pResults;
}

inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILFailureReason_t STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::Group::DkmThreadEvaluationResultCollection::FailureReason()
{
    return this->m_FailureReason;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::Group::DkmThreadEvaluationResultCollection::Create(Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILEvaluationResult*>* pResults, Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILFailureReason_t FailureReason, Microsoft::VisualStudio::Debugger::Evaluation::Group::DkmThreadEvaluationResultCollection** ppCreatedObject)
{
    return ProcE6D433576CE0AC1C21EE4E98D3422D5A(pResults, FailureReason, ppCreatedObject);
}

inline DECLSPEC_NOTHROW const GUID& STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DefaultPort::DkmTransportConnection::UniqueId()
{
    return this->m_UniqueId;
}

_Ret_opt_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmString* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DefaultPort::DkmTransportConnection::Qualifier()
{
    return this->m_pQualifier;
}

inline DECLSPEC_NOTHROW const GUID& STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DefaultPort::DkmTransportConnection::Kind()
{
    return this->m_Kind;
}

inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DefaultPort::DkmTransportConnectionFlags_t STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DefaultPort::DkmTransportConnection::Flags()
{
    return this->m_Flags;
}

inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmApiVersion_t STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DefaultPort::DkmTransportConnection::ProtocolVersion()
{
    // This method was introduced after the initial version of the API. The caller is
    // responsible for taking steps to ensure that this method is not called when running
    // against earlier versions of vsdebugeng.dll.
    ATLASSERT(DkmComponentManager::IsApiVersionSupported(DkmApiVersion::VS11FeaturePack1) || !"Invalid usage detected. Process will crash or bogus data will be returned");
    return this->m__pExtendedData->ProtocolVersion;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DefaultPort::DkmTransportConnection::FindConnection(const GUID& UniqueId, Microsoft::VisualStudio::Debugger::DefaultPort::DkmTransportConnection** ppConnection)
{
    return ProcAB7E84604904D5C915B4A266F97F80F5(UniqueId, ppConnection);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DefaultPort::DkmTransportConnection::GetConnections(Microsoft::VisualStudio::Debugger::DkmArray<Microsoft::VisualStudio::Debugger::DefaultPort::DkmTransportConnection*>* pConnections)
{
    return Proc2C8F3653A7BDEAB26FDAC5E12529D820(pConnections);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DefaultPort::DkmTransportConnection::FindProcess(const GUID& UniqueId, Microsoft::VisualStudio::Debugger::DkmProcess** ppProcess)
{
    return ProcF8399B27892C4BBF5D648783DCDCBA5A(this, UniqueId, ppProcess);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DefaultPort::DkmTransportConnection::GetProcesses(Microsoft::VisualStudio::Debugger::DkmArray<Microsoft::VisualStudio::Debugger::DkmProcess*>* pProcesses)
{
    return ProcC071CA11E0A11A2E283015A2F9433338(this, pProcesses);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DefaultPort::DkmTransportConnection::FindLiveProcess(UINT32 Id, Microsoft::VisualStudio::Debugger::DkmProcess** ppProcess)
{
    return ProcD6035EBBD17B0D0141A839FB20A8A90F(this, Id, ppProcess);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DefaultPort::DkmTransportConnection::GetLiveProcesses(Microsoft::VisualStudio::Debugger::DkmArray<Microsoft::VisualStudio::Debugger::DkmProcess*>* pProcesses)
{
    return ProcDB0050730FB328F4C9D7C1BB448007A9(this, pProcesses);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DefaultPort::DkmTransportConnection::GetRequests(Microsoft::VisualStudio::Debugger::DkmArray<Microsoft::VisualStudio::Debugger::Start::DkmProcessLaunchRequest*>* pRequests)
{
    return ProcC43FD22B022A5A6DDF7F66F3A86E698F(this, pRequests);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DefaultPort::DkmTransportConnection::ActivateAppPackage(Microsoft::VisualStudio::Debugger::DkmWorkList* pWorkList, Microsoft::VisualStudio::Debugger::DefaultPort::DkmPackagedAppPlatform_t AppPlatform, Microsoft::VisualStudio::Debugger::DkmString* pActivationName, bool LaunchForDebugging, Microsoft::VisualStudio::Debugger::IDkmCompletionRoutine<Microsoft::VisualStudio::Debugger::Start::DkmActivateAppPackageAsyncResult>* pCompletionRoutine)
{
    return ProcA792859DA394A6CB2C2E468A8805621E(this, pWorkList, AppPlatform, pActivationName, LaunchForDebugging, pCompletionRoutine);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DefaultPort::DkmTransportConnection::SuspendAppPackage(Microsoft::VisualStudio::Debugger::DkmWorkList* pWorkList, Microsoft::VisualStudio::Debugger::DefaultPort::DkmAppPackageId* pAppPackageId, UINT32 SessionId, Microsoft::VisualStudio::Debugger::IDkmCompletionRoutine<Microsoft::VisualStudio::Debugger::DefaultPort::DkmSuspendAppPackageAsyncResult>* pCompletionRoutine)
{
    return ProcDE7401ACE2C30C377F9CBF611BDF4337(this, pWorkList, pAppPackageId, SessionId, pCompletionRoutine);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DefaultPort::DkmTransportConnection::ResumeAppPackage(Microsoft::VisualStudio::Debugger::DefaultPort::DkmAppPackageId* pAppPackageId, UINT32 SessionId)
{
    return ProcD2B975D78F12643226D0BB33B75EAD13(this, pAppPackageId, SessionId);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DefaultPort::DkmTransportConnection::ShutDownAppPackage(Microsoft::VisualStudio::Debugger::DkmWorkList* pWorkList, Microsoft::VisualStudio::Debugger::DefaultPort::DkmAppPackageId* pAppPackageId, UINT32 SessionId, Microsoft::VisualStudio::Debugger::IDkmCompletionRoutine<Microsoft::VisualStudio::Debugger::DefaultPort::DkmShutDownAppPackageAsyncResult>* pCompletionRoutine)
{
    return ProcB34EA264F4F8FECA9A9F132A25DCD7D8(this, pWorkList, pAppPackageId, SessionId, pCompletionRoutine);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DefaultPort::DkmTransportConnection::GetIsolatedStorageRootForApplication(Microsoft::VisualStudio::Debugger::DefaultPort::DkmAppPackageId* pAppPackageId, Microsoft::VisualStudio::Debugger::DkmString** ppDirectoryFullPath)
{
    return ProcD10A03178A61DDA50CE791FE7A50CE1A(this, pAppPackageId, ppDirectoryFullPath);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DefaultPort::DkmTransportConnection::GetAppPackageExecutionState(Microsoft::VisualStudio::Debugger::DefaultPort::DkmAppPackageId* pAppPackageId, UINT32 SessionId, Microsoft::VisualStudio::Debugger::DefaultPort::DkmPackageExecutionState_t* pAppPackageExecutionState)
{
    return ProcFE6C80165E565AC3EC08B717C8E51C9E(this, pAppPackageId, SessionId, pAppPackageExecutionState);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DefaultPort::DkmTransportConnection::EnumerateBackgroundTasks(Microsoft::VisualStudio::Debugger::DkmWorkList* pWorkList, Microsoft::VisualStudio::Debugger::DefaultPort::DkmAppPackageId* pAppPackageId, UINT32 SessionId, Microsoft::VisualStudio::Debugger::IDkmCompletionRoutine<Microsoft::VisualStudio::Debugger::DefaultPort::DkmEnumerateBackgroundTasksAsyncResult>* pCompletionRoutine)
{
    return ProcF45761B62AD6B1092A2DF893E962C810(this, pWorkList, pAppPackageId, SessionId, pCompletionRoutine);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DefaultPort::DkmTransportConnection::ActivateBackgroundTask(Microsoft::VisualStudio::Debugger::DkmWorkList* pWorkList, Microsoft::VisualStudio::Debugger::DefaultPort::DkmAppPackageId* pAppPackageId, UINT32 SessionId, const GUID& TaskId, Microsoft::VisualStudio::Debugger::IDkmCompletionRoutine<Microsoft::VisualStudio::Debugger::DefaultPort::DkmActivateBackgroundTaskAsyncResult>* pCompletionRoutine)
{
    return Proc30FEC696C9945D2B0417493F60C0A048(this, pWorkList, pAppPackageId, SessionId, TaskId, pCompletionRoutine);
}

#ifndef EXCLUDE_IDE_ONLY_APIS
inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DefaultPort::DkmTransportConnection::EnumPackages(Microsoft::VisualStudio::Debugger::DkmArray<Microsoft::VisualStudio::Debugger::DefaultPort::DkmInstalledAppPackageInfo*>* pPackages)
{
    return Proc98A6A894DD93626ADCA0978BCE953839(this, pPackages);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DefaultPort::DkmTransportConnection::DeployFile(Microsoft::VisualStudio::Debugger::DkmString* pLocalFilePath, Microsoft::VisualStudio::Debugger::DkmString* pRemoteFilePath, bool OverwriteExisting)
{
    return ProcDDD014885B12C65BD78508D907B44AD7(this, pLocalFilePath, pRemoteFilePath, OverwriteExisting);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DefaultPort::DkmTransportConnection::DownloadFile(Microsoft::VisualStudio::Debugger::DkmString* pRemoteFilePath, Microsoft::VisualStudio::Debugger::DkmString* pLocalFilePath, bool OverwriteExisting)
{
    return Proc3652ACA5E5318812E35FB3CA4438BE02(this, pRemoteFilePath, pLocalFilePath, OverwriteExisting);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DefaultPort::DkmTransportConnection::DownloadFile(Microsoft::VisualStudio::Debugger::DkmWorkList* pWorkList, Microsoft::VisualStudio::Debugger::DkmString* pRemoteFilePath, Microsoft::VisualStudio::Debugger::DkmString* pLocalFilePath, bool OverwriteExisting, Microsoft::VisualStudio::Debugger::IDkmCompletionRoutine<Microsoft::VisualStudio::Debugger::DefaultPort::DkmDownloadFileAsyncResult>* pCompletionRoutine)
{
    return ProcD5CB3FCA82CC14A00D5F13D7E222756B(this, pWorkList, pRemoteFilePath, pLocalFilePath, OverwriteExisting, pCompletionRoutine);
}
#endif // #ifndef EXCLUDE_IDE_ONLY_APIS

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DefaultPort::DkmTransportConnection::DeleteFile(Microsoft::VisualStudio::Debugger::DkmString* pRemoteFilePath)
{
    return ProcB8D5E627A1202BFABE708EACCB652FBB(this, pRemoteFilePath);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DefaultPort::DkmTransportConnection::GetDNSName(Microsoft::VisualStudio::Debugger::DkmString** ppName)
{
    return Proc215DD9BC078CB88CF23C40B8C2910BE3(this, ppName);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DefaultPort::DkmTransportConnection::CreateDirectory(Microsoft::VisualStudio::Debugger::DkmString* pRemoteDirectoryPath)
{
    return Proc97FB9A3F5C72B5CCF8B0B70D68A04767(this, pRemoteDirectoryPath);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DefaultPort::DkmTransportConnection::RemoveDirectory(Microsoft::VisualStudio::Debugger::DkmString* pRemoteDirectoryPath, bool Recursive)
{
    return Proc42B2E39E095C8CC924104C96D815A87F(this, pRemoteDirectoryPath, Recursive);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DefaultPort::DkmTransportConnection::GetFileListing(Microsoft::VisualStudio::Debugger::DkmString* pRootDirectoryPath, Microsoft::VisualStudio::Debugger::DkmString* pSearchWildcard, bool Recursive, Microsoft::VisualStudio::Debugger::DkmArray<Microsoft::VisualStudio::Debugger::DefaultPort::DkmFileInfo*>* pResults)
{
    return ProcBA58E5F29495587EE83647ED4B7CA047(this, pRootDirectoryPath, pSearchWildcard, Recursive, pResults);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DefaultPort::DkmTransportConnection::EnumRunningProcesses(bool IncludeFromAllUsers, Microsoft::VisualStudio::Debugger::DefaultPort::DkmRunningProcessInfoPropertyMask_t RequestedPropertyMask, Microsoft::VisualStudio::Debugger::DkmArray<Microsoft::VisualStudio::Debugger::DefaultPort::DkmRunningProcessInfo*>* pProcesses)
{
    return Proc78D9244B76EA8F1DE4E149D466A3067E(this, IncludeFromAllUsers, RequestedPropertyMask, pProcesses);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DefaultPort::DkmTransportConnection::GetRunningProcessInfo(UINT32 Id, UINT64 StartTime, bool IsDebuggee, Microsoft::VisualStudio::Debugger::DefaultPort::DkmRunningProcessInfoPropertyMask_t RequestedPropertyMask, Microsoft::VisualStudio::Debugger::DefaultPort::DkmRunningProcessInfo** ppProcessInfo)
{
    return Proc39246E41B82608CB696343435CB621CC(this, Id, StartTime, IsDebuggee, RequestedPropertyMask, ppProcessInfo);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DefaultPort::DkmTransportConnection::TerminateRunningProcess(UINT32 Id, UINT64 StartTime, UINT32 ExitCode)
{
    return Proc865805A776E7741A6D402D348F5B10C8(this, Id, StartTime, ExitCode);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DefaultPort::DkmTransportConnection::GetSystemInformation(bool NativeSystemInfo, Microsoft::VisualStudio::Debugger::DefaultPort::DkmSystemInformation** ppSystemInfo)
{
    return Proc2C5C54E587F4180B257B172F561B9D86(this, NativeSystemInfo, ppSystemInfo);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DefaultPort::DkmTransportConnection::GetClrVersionOfExecutable(Microsoft::VisualStudio::Debugger::DkmString* pExePath, Microsoft::VisualStudio::Debugger::DkmString** ppClrVersionString)
{
    return Proc64B5767554228566D9C77062DA22744E(this, pExePath, ppClrVersionString);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DefaultPort::DkmTransportConnection::QueryIsWOW64Executable(Microsoft::VisualStudio::Debugger::DkmString* pExePath, bool* pResult)
{
    return Proc0869184C622FC2631C3092D1F9F56171(this, pExePath, pResult);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DefaultPort::DkmTransportConnection::GetDefaultClrVersion(Microsoft::VisualStudio::Debugger::DkmString** ppClrVersionString)
{
    return Proc8B8D1408689D364C99D8A5AEA2A33BF9(this, ppClrVersionString);
}

#ifndef EXCLUDE_IDE_ONLY_APIS
inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DefaultPort::DkmTransportConnection::FlushClosedObjectQueue()
{
    return Proc455ECE81CE1CDD87D2DA5494FE7B4B03(this);
}
#endif // #ifndef EXCLUDE_IDE_ONLY_APIS

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DefaultPort::DkmTransportConnection::TriggerPrefetch(Microsoft::VisualStudio::Debugger::DkmString* pPackageFullName, Microsoft::VisualStudio::Debugger::DefaultPort::DkmPackagedAppPlatform_t Platform, HRESULT* pResult)
{
    return ProcC5753DD54FFBAD601A042910A22F7508(this, pPackageFullName, Platform, pResult);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DefaultPort::DkmTransportConnection::RemoveAppPackageFromTaskbar(Microsoft::VisualStudio::Debugger::DefaultPort::DkmAppPackageId* pAppPackageId, UINT32 SessionId)
{
    return Proc2F051284F979333EE60A5318711A2C6B(this, pAppPackageId, SessionId);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DefaultPort::DkmTransportConnection::ActivateAppPackageOnTargetMonitor(Microsoft::VisualStudio::Debugger::DkmWorkList* pWorkList, Microsoft::VisualStudio::Debugger::DefaultPort::DkmPackagedAppPlatform_t AppPlatform, Microsoft::VisualStudio::Debugger::DkmString* pActivationName, bool LaunchForDebugging, UINT32 Monitor, Microsoft::VisualStudio::Debugger::IDkmCompletionRoutine<Microsoft::VisualStudio::Debugger::Start::DkmActivateAppPackageAsyncResult>* pCompletionRoutine)
{
    return Proc60DB9E894042BDA745E19DFFE7A836B3(this, pWorkList, AppPlatform, pActivationName, LaunchForDebugging, Monitor, pCompletionRoutine);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DefaultPort::DkmTransportConnection::ActivateAppPackageWithStartupTask(Microsoft::VisualStudio::Debugger::DkmWorkList* pWorkList, Microsoft::VisualStudio::Debugger::DkmString* pActivationName, bool LaunchForDebugging, Microsoft::VisualStudio::Debugger::IDkmCompletionRoutine<Microsoft::VisualStudio::Debugger::Start::DkmActivateAppPackageAsyncResult>* pCompletionRoutine)
{
    return Proc18A5450F8560919A30800EE0FE7D9ECB(this, pWorkList, pActivationName, LaunchForDebugging, pCompletionRoutine);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmUnknownInstructionAddress::Create(Microsoft::VisualStudio::Debugger::DkmRuntimeInstance* pRuntimeInstance, const Microsoft::VisualStudio::Debugger::DkmInstructionAddress::CPUInstruction* pCPUInstruction, Microsoft::VisualStudio::Debugger::DkmUnknownInstructionAddress** ppCreatedObject)
{
    return Proc8EDE4866600ED1B4F51326202AD7B614(pRuntimeInstance, pCPUInstruction, ppCreatedObject);
}

inline DECLSPEC_NOTHROW CV_HREG_e STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::CallStack::DkmUnwoundRegister::Identifier()
{
    return this->m_Identifier;
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<BYTE>* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::CallStack::DkmUnwoundRegister::Value()
{
    return this->m_pValue;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::CallStack::DkmUnwoundRegister::Create(CV_HREG_e Identifier, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<BYTE>* pValue, Microsoft::VisualStudio::Debugger::CallStack::DkmUnwoundRegister** ppCreatedObject)
{
    return Proc466368E9818C5AAA5A91F1B4871168C3(Identifier, pValue, ppCreatedObject);
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DefaultPort::DkmTransportConnection* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmUserMessage::Connection()
{
    return this->m_pConnection;
}

_Ret_opt_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmProcess* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmUserMessage::Process()
{
    return this->m_pProcess;
}

inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmUserMessageOutputKind_t STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmUserMessage::OutputKind()
{
    return this->m_OutputKind;
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmString* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmUserMessage::MessageText()
{
    return this->m_pMessageText;
}

inline DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmUserMessage::MessageBoxFlags()
{
    return this->m_MessageBoxFlags;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmUserMessage::ErrorCode()
{
    return this->m_ErrorCode;
}

inline DECLSPEC_NOTHROW UINT64 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmUserMessage::TimeStamp()
{
    // This method was introduced after the initial version of the API. The caller is
    // responsible for taking steps to ensure that this method is not called when running
    // against earlier versions of vsdebugeng.dll.
    ATLASSERT(DkmComponentManager::IsApiVersionSupported(DkmApiVersion::VS14RTM) || !"Invalid usage detected. Process will crash or bogus data will be returned");
    return this->m__pExtendedData->TimeStamp;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmUserMessage::Create(Microsoft::VisualStudio::Debugger::DefaultPort::DkmTransportConnection* pConnection, Microsoft::VisualStudio::Debugger::DkmProcess* pProcess, Microsoft::VisualStudio::Debugger::DkmUserMessageOutputKind_t OutputKind, Microsoft::VisualStudio::Debugger::DkmString* pMessageText, UINT32 MessageBoxFlags, HRESULT ErrorCode, Microsoft::VisualStudio::Debugger::DkmUserMessage** ppCreatedObject)
{
    return ProcFDD9B7914B7C22033996520394B90F8A(pConnection, pProcess, OutputKind, pMessageText, MessageBoxFlags, ErrorCode, ppCreatedObject);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmUserMessage::Create(Microsoft::VisualStudio::Debugger::DefaultPort::DkmTransportConnection* pConnection, Microsoft::VisualStudio::Debugger::DkmProcess* pProcess, Microsoft::VisualStudio::Debugger::DkmUserMessageOutputKind_t OutputKind, Microsoft::VisualStudio::Debugger::DkmString* pMessageText, UINT32 MessageBoxFlags, HRESULT ErrorCode, UINT64 TimeStamp, Microsoft::VisualStudio::Debugger::DkmUserMessage** ppCreatedObject)
{
    return Proc99B99125827B46ADC3E97549DA4EA4DF(pConnection, pProcess, OutputKind, pMessageText, MessageBoxFlags, ErrorCode, TimeStamp, ppCreatedObject);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmUserMessage::Post()
{
    return ProcBA1057B67974B1DAE7A677E1B7156D48(this);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmUserMessage::DisplayPrompt(UINT32* pResult)
{
    return ProcA3E4FFDD239F6E8EB98DECB7AD2660ED(this, pResult);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmUserMessage::DisplayPrompt(Microsoft::VisualStudio::Debugger::DkmWorkList* pWorkList, Microsoft::VisualStudio::Debugger::IDkmCompletionRoutine<Microsoft::VisualStudio::Debugger::DkmDisplayUserMessagePromptAsyncResult>* pCompletionRoutine)
{
    return Proc724F9A5CAEC412BD5A71787991347219(this, pWorkList, pCompletionRoutine);
}

inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::Evaluation::DkmVisualizedExpression::Tag_t STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmVisualizedExpression::TagValue()
{
    return this->m_TagValue;
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::Evaluation::DkmInspectionContext* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmVisualizedExpression::InspectionContext()
{
    return this->m_pInspectionContext;
}

inline DECLSPEC_NOTHROW const GUID& STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmVisualizedExpression::UniqueId()
{
    return this->m_UniqueId;
}

inline DECLSPEC_NOTHROW const GUID& STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmVisualizedExpression::VisualizerId()
{
    return this->m_VisualizerId;
}

inline DECLSPEC_NOTHROW const GUID& STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmVisualizedExpression::SourceId()
{
    return this->m_SourceId;
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::CallStack::DkmStackWalkFrame* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmVisualizedExpression::StackFrame()
{
    return this->m_pStackFrame;
}

_Ret_opt_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::Evaluation::DkmExpressionValueHome* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmVisualizedExpression::ValueHome()
{
    return this->m_pValueHome;
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::Evaluation::DkmInspectionSession* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmVisualizedExpression::InspectionSession()
{
    return this->m_pInspectionContext->InspectionSession();
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmRuntimeInstance* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmVisualizedExpression::RuntimeInstance()
{
    return this->m_pInspectionContext->RuntimeInstance();
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmVisualizedExpression::Close()
{
    return Proc37A7A04E658357DDF89FD94C01950EDE(this);
}

#ifndef EXCLUDE_IDE_ONLY_APIS
inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmVisualizedExpression::EvaluateVisualizedExpression(Microsoft::VisualStudio::Debugger::Evaluation::DkmEvaluationResult** ppResultObject)
{
    return Proc775646EA9C2CEA81FE5E83FA6B154C80(this, ppResultObject);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmVisualizedExpression::UseDefaultEvaluationBehavior(bool* pUseDefaultEvaluationBehavior, Microsoft::VisualStudio::Debugger::Evaluation::DkmEvaluationResult** ppDefaultEvaluationResult)
{
    return Proc2EAA5EF1A1F3D78893EF5BF262A09FF1(this, pUseDefaultEvaluationBehavior, ppDefaultEvaluationResult);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmVisualizedExpression::GetChildren(UINT32 InitialRequestSize, Microsoft::VisualStudio::Debugger::Evaluation::DkmInspectionContext* pInspectionContext, Microsoft::VisualStudio::Debugger::DkmArray<Microsoft::VisualStudio::Debugger::Evaluation::DkmChildVisualizedExpression*>* pInitialChildren, Microsoft::VisualStudio::Debugger::Evaluation::DkmEvaluationResultEnumContext** ppEnumContext)
{
    return Proc16C97186D55550648ABE74675D33BF50(this, InitialRequestSize, pInspectionContext, pInitialChildren, ppEnumContext);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmVisualizedExpression::GetItems(Microsoft::VisualStudio::Debugger::Evaluation::DkmEvaluationResultEnumContext* pEnumContext, UINT32 StartIndex, UINT32 Count, Microsoft::VisualStudio::Debugger::DkmArray<Microsoft::VisualStudio::Debugger::Evaluation::DkmChildVisualizedExpression*>* pItems)
{
    return Proc0A069DACDF37E06B697F148BFAE76960(this, pEnumContext, StartIndex, Count, pItems);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmVisualizedExpression::SetValueAsString(Microsoft::VisualStudio::Debugger::DkmString* pValue, UINT32 Timeout, Microsoft::VisualStudio::Debugger::DkmString** ppErrorText)
{
    return ProcEC64BFA42F296CC9011D7887E9AA821E(this, pValue, Timeout, ppErrorText);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmVisualizedExpression::GetUnderlyingString(Microsoft::VisualStudio::Debugger::DkmString** ppStringValue)
{
    return Proc2DAB6617600220DC44DEB7DBC7D87FA6(this, ppStringValue);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmVisualizedExpression::GetSymbolInterface(const GUID& TypeSymbolInterfaceId, IUnknown** ppTypeSymbolInterface)
{
    return ProcA236F77AF12387A7771096B443CA3FC7(this, TypeSymbolInterfaceId, ppTypeSymbolInterface);
}
#endif // #ifndef EXCLUDE_IDE_ONLY_APIS

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmVisualizedExpression::EvaluateExpressionCallback(Microsoft::VisualStudio::Debugger::Evaluation::DkmInspectionContext* pInspectionContext, Microsoft::VisualStudio::Debugger::Evaluation::DkmLanguageExpression* pExpression, Microsoft::VisualStudio::Debugger::CallStack::DkmStackWalkFrame* pStackFrame, Microsoft::VisualStudio::Debugger::Evaluation::DkmEvaluationResult** ppResultObject)
{
    return Proc7138B8A8F36654C2D04C9FD6EB1981F5(this, pInspectionContext, pExpression, pStackFrame, ppResultObject);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmVisualizedExpression::CreateDefaultChildFullName(INT32 Index, Microsoft::VisualStudio::Debugger::DkmString** ppFullName)
{
    return ProcE7CC624DFD52EBFD7D8D4328B80F7B8B(this, Index, ppFullName);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmVisualizedExpression::GetChildrenCallback(Microsoft::VisualStudio::Debugger::Evaluation::DkmEvaluationResult* pDefaultEvaluationResult, UINT32 InitialRequestSize, Microsoft::VisualStudio::Debugger::Evaluation::DkmInspectionContext* pInspectionContext, Microsoft::VisualStudio::Debugger::DkmArray<Microsoft::VisualStudio::Debugger::Evaluation::DkmEvaluationResult*>* pInitialChildren, Microsoft::VisualStudio::Debugger::Evaluation::DkmEvaluationResultEnumContext** ppEnumContext)
{
    return ProcCC231CEFF16CBD971CC342AC73007747(this, pDefaultEvaluationResult, InitialRequestSize, pInspectionContext, pInitialChildren, ppEnumContext);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmVisualizedExpression::GetItemsCallback(Microsoft::VisualStudio::Debugger::Evaluation::DkmEvaluationResultEnumContext* pEnumContext, UINT32 StartIndex, UINT32 Count, Microsoft::VisualStudio::Debugger::DkmArray<Microsoft::VisualStudio::Debugger::Evaluation::DkmEvaluationResult*>* pItems)
{
    return ProcE50B12FF94F4FB40DEF8945C53BB3691(this, pEnumContext, StartIndex, Count, pItems);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmVisualizedExpression::SetValueAsStringCallback(Microsoft::VisualStudio::Debugger::Evaluation::DkmEvaluationResult* pDefaultEvaluationResult, Microsoft::VisualStudio::Debugger::DkmString* pValue, UINT32 Timeout, Microsoft::VisualStudio::Debugger::DkmString** ppErrorText)
{
    return Proc7EEBF387B7C2B848675D0F50E63E9996(this, pDefaultEvaluationResult, pValue, Timeout, ppErrorText);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmVisualizedExpression::GetUnderlyingStringCallback(Microsoft::VisualStudio::Debugger::Evaluation::DkmEvaluationResult* pDefaultEvaluationResult, Microsoft::VisualStudio::Debugger::DkmString** ppStringValue)
{
    return ProcAED1622BD40E6A09C5DE0FE3F1603171(this, pDefaultEvaluationResult, ppStringValue);
}

inline DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Native::DkmWin32ExceptionInformation::ExceptionFlags()
{
    return this->m_ExceptionFlags;
}

inline DECLSPEC_NOTHROW UINT64 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Native::DkmWin32ExceptionInformation::ParentExceptionRecordAddress()
{
    return this->m_ParentExceptionRecordAddress;
}

inline DECLSPEC_NOTHROW UINT64 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Native::DkmWin32ExceptionInformation::Address()
{
    return this->m_Address;
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<UINT64>* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Native::DkmWin32ExceptionInformation::ExceptionParameters()
{
    return this->m_pExceptionParameters;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Native::DkmWin32ExceptionInformation::Create(Microsoft::VisualStudio::Debugger::DkmRuntimeInstance* pRuntimeInstance, Microsoft::VisualStudio::Debugger::DkmThread* pThread, Microsoft::VisualStudio::Debugger::DkmInstructionAddress* pInstructionAddress, UINT32 Code, Microsoft::VisualStudio::Debugger::Exceptions::DkmExceptionProcessingStage_t ProcessingStage, UINT32 ExceptionFlags, UINT64 ParentExceptionRecordAddress, UINT64 Address, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<UINT64>* pExceptionParameters, Microsoft::VisualStudio::Debugger::Native::DkmWin32ExceptionInformation** ppCreatedObject)
{
    return Proc83735219E8CC0CD40DBBF6F68C286948(pRuntimeInstance, pThread, pInstructionAddress, Code, ProcessingStage, ExceptionFlags, ParentExceptionRecordAddress, Address, pExceptionParameters, ppCreatedObject);
}

inline DECLSPEC_NOTHROW UINT64 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::CallStack::DkmX64FrameRegisters::Rip()
{
    return this->m_Rip;
}

inline DECLSPEC_NOTHROW UINT64 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::CallStack::DkmX64FrameRegisters::Rsp()
{
    return this->m_Rsp;
}

inline DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::CallStack::DkmX86FrameRegisters::Eip()
{
    return this->m_Eip;
}

inline DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::CallStack::DkmX86FrameRegisters::Esp()
{
    return this->m_Esp;
}

inline DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::CallStack::DkmX86FrameRegisters::VFrame()
{
    return this->m_VFrame;
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::Evaluation::DkmInspectionSession* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::CallStack::DkmAsyncStackWalkContext::InspectionSession()
{
    return this->m_pInspectionSession;
}

inline DECLSPEC_NOTHROW const GUID& STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::CallStack::DkmAsyncStackWalkContext::TaskProviderId()
{
    return this->m_TaskProviderId;
}

_Ret_opt_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::CallStack::DkmStackWalkFrame* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::CallStack::DkmAsyncStackWalkContext::TaskIdentityStackFrame()
{
    return this->m_pTaskIdentityStackFrame;
}

_Ret_opt_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::CallStack::DkmStackWalkFrame* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::CallStack::DkmAsyncStackWalkContext::InternalStackFrame()
{
    return this->m_pInternalStackFrame;
}

_Ret_opt_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::Evaluation::DkmSuccessEvaluationResult* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::CallStack::DkmAsyncStackWalkContext::FrameObject()
{
    return this->m_pFrameObject;
}

_Ret_opt_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::ParallelTasks::DkmTask* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::CallStack::DkmAsyncStackWalkContext::Task()
{
    return this->m_pTask;
}

_Ret_opt_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<Microsoft::VisualStudio::Debugger::Evaluation::DkmSuccessEvaluationResult*>* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::CallStack::DkmAsyncStackWalkContext::ReturnStackFunctions()
{
    return this->m_pReturnStackFunctions;
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmRuntimeInstance* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::CallStack::DkmAsyncStackWalkContext::RuntimeInstance()
{
    return this->m_pRuntimeInstance;
}

inline DECLSPEC_NOTHROW const GUID& STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::CallStack::DkmAsyncStackWalkContext::UniqueId()
{
    return this->m_UniqueId;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::CallStack::DkmAsyncStackWalkContext::Create(Microsoft::VisualStudio::Debugger::Evaluation::DkmInspectionSession* pInspectionSession, const GUID& TaskProviderId, Microsoft::VisualStudio::Debugger::CallStack::DkmStackWalkFrame* pTaskIdentityStackFrame, Microsoft::VisualStudio::Debugger::CallStack::DkmStackWalkFrame* pInternalStackFrame, Microsoft::VisualStudio::Debugger::Evaluation::DkmSuccessEvaluationResult* pFrameObject, Microsoft::VisualStudio::Debugger::ParallelTasks::DkmTask* pTask, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<Microsoft::VisualStudio::Debugger::Evaluation::DkmSuccessEvaluationResult*>* pReturnStackFunctions, Microsoft::VisualStudio::Debugger::DkmRuntimeInstance* pRuntimeInstance, const Microsoft::VisualStudio::Debugger::DkmDataItem& DataItem, Microsoft::VisualStudio::Debugger::CallStack::DkmAsyncStackWalkContext** ppCreatedObject)
{
    return Proc0820CA92D0247DC5DF701F1C1ECEA7DF(pInspectionSession, TaskProviderId, pTaskIdentityStackFrame, pInternalStackFrame, pFrameObject, pTask, pReturnStackFunctions, pRuntimeInstance, DataItem, ppCreatedObject);
}

#ifndef EXCLUDE_IDE_ONLY_APIS
inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::CallStack::DkmAsyncStackWalkContext::GetTaskCreationStack(Microsoft::VisualStudio::Debugger::DkmWorkList* pWorkList, Microsoft::VisualStudio::Debugger::DkmThread* pThread, Microsoft::VisualStudio::Debugger::IDkmCompletionRoutine<Microsoft::VisualStudio::Debugger::CallStack::DkmGetTaskCreationStackAsyncResult>* pCompletionRoutine)
{
    return Proc86FDCE2F5D7CA7AEEFDCA32E39728044(this, pWorkList, pThread, pCompletionRoutine);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::CallStack::DkmAsyncStackWalkContext::GetTaskContinuationFrames(Microsoft::VisualStudio::Debugger::DkmWorkList* pWorkList, Microsoft::VisualStudio::Debugger::DkmThread* pThread, Microsoft::VisualStudio::Debugger::IDkmCompletionRoutine<Microsoft::VisualStudio::Debugger::CallStack::DkmGetTaskContinuationFramesAsyncResult>* pCompletionRoutine)
{
    return Proc4CE2773DE0FDDAF90435E6FDFCFAAAED(this, pWorkList, pThread, pCompletionRoutine);
}
#endif // #ifndef EXCLUDE_IDE_ONLY_APIS

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::CallStack::DkmAsyncStackWalkContext::GetAsyncCallStack(Microsoft::VisualStudio::Debugger::DkmWorkList* pWorkList, Microsoft::VisualStudio::Debugger::DkmThread* pThread, Microsoft::VisualStudio::Debugger::IDkmCompletionRoutine<Microsoft::VisualStudio::Debugger::CallStack::DkmGetAsyncCallStackAsyncResult>* pCompletionRoutine)
{
    return Proc1C7E85CB433B74A1BE139D8B40E53768(this, pWorkList, pThread, pCompletionRoutine);
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmThread* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::DkmClrCaughtExceptionInformation::Thread()
{
    return this->m_pThread;
}

inline DECLSPEC_NOTHROW UINT64 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::DkmClrCaughtExceptionInformation::FrameStart()
{
    return this->m_FrameStart;
}

inline DECLSPEC_NOTHROW UINT64 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::DkmClrCaughtExceptionInformation::FrameEnd()
{
    return this->m_FrameEnd;
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmInstructionAddress* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::DkmClrCaughtExceptionInformation::InstructionAddress()
{
    return this->m_pInstructionAddress;
}

inline DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::DkmClrCaughtExceptionInformation::CatchHandlerILOffset()
{
    return this->m_CatchHandlerILOffset;
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmString* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::DkmClrCaughtExceptionInformation::Name()
{
    return this->m_pName;
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmProcess* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::DkmClrCaughtExceptionInformation::Process()
{
    return this->m_pThread->Process();
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::DkmClrCaughtExceptionInformation::Create(Microsoft::VisualStudio::Debugger::DkmThread* pThread, UINT64 FrameStart, UINT64 FrameEnd, Microsoft::VisualStudio::Debugger::DkmInstructionAddress* pInstructionAddress, UINT32 CatchHandlerILOffset, Microsoft::VisualStudio::Debugger::DkmString* pName, Microsoft::VisualStudio::Debugger::Clr::DkmClrCaughtExceptionInformation** ppCreatedObject)
{
    return Proc7A6C7A0227D6BD610F97D032767448A8(pThread, FrameStart, FrameEnd, pInstructionAddress, CatchHandlerILOffset, pName, ppCreatedObject);
}

#ifndef EXCLUDE_MONITOR_ONLY_APIS
inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::DkmClrCaughtExceptionInformation::OnClrDebugMonitorExceptionCaught()
{
    return ProcAB099C958E2B4BDC4A6A8969DF728294(this);
}
#endif // #ifndef EXCLUDE_MONITOR_ONLY_APIS

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::Clr::NativeCompilation::DkmClrNcRuntimeInstance* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::NativeCompilation::DkmClrNcContainerModuleInstance::RuntimeInstance()
{
    return static_cast<Microsoft::VisualStudio::Debugger::Clr::NativeCompilation::DkmClrNcRuntimeInstance*>(DkmModuleInstance::RuntimeInstance());
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::NativeCompilation::DkmClrNcContainerModuleInstance::FindEmbeddedModule(UINT32 Index, Microsoft::VisualStudio::Debugger::Clr::NativeCompilation::DkmClrNcModuleInstance** ppEmbeddedModule)
{
    return Proc75FF43FC6B24BBA9BCB13405C170E6F2(this, Index, ppEmbeddedModule);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::NativeCompilation::DkmClrNcContainerModuleInstance::GetEmbeddedModules(Microsoft::VisualStudio::Debugger::DkmArray<Microsoft::VisualStudio::Debugger::Clr::NativeCompilation::DkmClrNcModuleInstance*>* pEmbeddedModules)
{
    return Proc07F31C87616869864CBF6033F37DAAB9(this, pEmbeddedModules);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::NativeCompilation::DkmClrNcContainerModuleInstance::GetAssemblyImageBytes(UINT32 RVA, UINT32 BytesRequested, Microsoft::VisualStudio::Debugger::DkmArray<BYTE>* pImageBytes)
{
    return ProcD535CEE9B7C2831AB2793C7873F721C8(this, RVA, BytesRequested, pImageBytes);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::NativeCompilation::DkmClrNcContainerModuleInstance::GetClassInfo(Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<BYTE>* pClassSignature, Microsoft::VisualStudio::Debugger::DkmArray<Microsoft::VisualStudio::Debugger::Clr::NativeCompilation::DkmClrNcInstanceFieldSymbol*>* pInstanceFields, UINT32* pSize)
{
    return ProcB9BAA2DA346F0AF91423145A3413CA27(this, pClassSignature, pInstanceFields, pSize);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::NativeCompilation::DkmClrNcContainerModuleInstance::GetGenericDictionaryInfo(Microsoft::VisualStudio::Debugger::DkmArray<BYTE>* pManagedNativeGenericInfoBytes)
{
    return Proc719588163E7E4FA81DEDFC45467F9A5D(this, pManagedNativeGenericInfoBytes);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::NativeCompilation::DkmClrNcContainerModuleInstance::CreateInstructionAddressFromRva(Microsoft::VisualStudio::Debugger::DkmWorkList* pWorkList, UINT32 Rva, Microsoft::VisualStudio::Debugger::IDkmCompletionRoutine<Microsoft::VisualStudio::Debugger::Clr::NativeCompilation::DkmCreateInstructionAddressFromRvaAsyncResult>* pCompletionRoutine)
{
    return Proc8D74EF2700984C5AE6DB6F9891E5AFEB(this, pWorkList, Rva, pCompletionRoutine);
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmString* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::NativeCompilation::DkmClrNcInstanceFieldSymbol::Name()
{
    return this->m_pName;
}

inline DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::NativeCompilation::DkmClrNcInstanceFieldSymbol::Size()
{
    return this->m_Size;
}

inline DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::NativeCompilation::DkmClrNcInstanceFieldSymbol::Offset()
{
    return this->m_Offset;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::NativeCompilation::DkmClrNcInstanceFieldSymbol::Create(Microsoft::VisualStudio::Debugger::DkmString* pName, UINT32 Size, UINT32 Offset, Microsoft::VisualStudio::Debugger::Clr::NativeCompilation::DkmClrNcInstanceFieldSymbol** ppCreatedObject)
{
    return Proc0CF9D0EC7EF8995BD39E312B58463B27(pName, Size, Offset, ppCreatedObject);
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::Clr::NativeCompilation::DkmClrNcRuntimeInstance* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::NativeCompilation::DkmClrNcInstructionAddress::RuntimeInstance()
{
    return static_cast<Microsoft::VisualStudio::Debugger::Clr::NativeCompilation::DkmClrNcRuntimeInstance*>(DkmClrInstructionAddress::RuntimeInstance());
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::Clr::NativeCompilation::DkmClrNcModuleInstance* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::NativeCompilation::DkmClrNcInstructionAddress::ModuleInstance()
{
    return static_cast<Microsoft::VisualStudio::Debugger::Clr::NativeCompilation::DkmClrNcModuleInstance*>(DkmClrInstructionAddress::ModuleInstance());
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::Clr::NativeCompilation::DkmClrNcContainerModuleInstance* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::NativeCompilation::DkmClrNcInstructionAddress::ContainerModule()
{
    return this->m_pContainerModule;
}

_Ret_opt_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<BYTE>* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::NativeCompilation::DkmClrNcInstructionAddress::GenericParameters()
{
    return this->m_pGenericParameters;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::NativeCompilation::DkmClrNcInstructionAddress::Create(const Microsoft::VisualStudio::Debugger::Clr::DkmClrMethodId& MethodId, UINT32 NativeOffset, UINT32 ILOffset, Microsoft::VisualStudio::Debugger::Clr::NativeCompilation::DkmClrNcRuntimeInstance* pRuntimeInstance, Microsoft::VisualStudio::Debugger::Clr::NativeCompilation::DkmClrNcModuleInstance* pModuleInstance, Microsoft::VisualStudio::Debugger::Clr::NativeCompilation::DkmClrNcContainerModuleInstance* pContainerModule, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<BYTE>* pGenericParameters, const Microsoft::VisualStudio::Debugger::DkmInstructionAddress::CPUInstruction* pCPUInstruction, Microsoft::VisualStudio::Debugger::Clr::NativeCompilation::DkmClrNcInstructionAddress** ppCreatedObject)
{
    return Proc9B089C79F9336B6ABA00EF766311F77F(MethodId, NativeOffset, ILOffset, pRuntimeInstance, pModuleInstance, pContainerModule, pGenericParameters, pCPUInstruction, ppCreatedObject);
}

inline DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::NativeCompilation::DkmClrNcInstructionSymbol::EmbeddedModuleIndex()
{
    return this->m_EmbeddedModuleIndex;
}

inline DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::NativeCompilation::DkmClrNcInstructionSymbol::NativeOffset()
{
    return this->m_NativeOffset;
}

_Ret_opt_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<BYTE>* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::NativeCompilation::DkmClrNcInstructionSymbol::GenericParameters()
{
    return this->m_pGenericParameters;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::NativeCompilation::DkmClrNcInstructionSymbol::Create(Microsoft::VisualStudio::Debugger::Symbols::DkmModule* pModule, const Microsoft::VisualStudio::Debugger::Clr::DkmClrMethodId& MethodId, UINT32 ILOffset, UINT32 EmbeddedModuleIndex, UINT32 NativeOffset, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<BYTE>* pGenericParameters, Microsoft::VisualStudio::Debugger::Clr::NativeCompilation::DkmClrNcInstructionSymbol** ppCreatedObject)
{
    return Proc249AAF78F1239055957393B3DC7BE289(pModule, MethodId, ILOffset, EmbeddedModuleIndex, NativeOffset, pGenericParameters, ppCreatedObject);
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::Clr::NativeCompilation::DkmClrNcRuntimeInstance* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::NativeCompilation::DkmClrNcModuleInstance::RuntimeInstance()
{
    return static_cast<Microsoft::VisualStudio::Debugger::Clr::NativeCompilation::DkmClrNcRuntimeInstance*>(DkmClrModuleInstance::RuntimeInstance());
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::Clr::NativeCompilation::DkmClrNcContainerModuleInstance* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::NativeCompilation::DkmClrNcModuleInstance::ContainerModule()
{
    return this->m_pContainerModule;
}

inline DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::NativeCompilation::DkmClrNcModuleInstance::Index()
{
    return this->m_Index;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::NativeCompilation::DkmClrNcModuleInstance::CreateInstructionAddressesFromILAddress(Microsoft::VisualStudio::Debugger::DkmWorkList* pWorkList, const Microsoft::VisualStudio::Debugger::Clr::DkmClrMethodId& MethodId, UINT32 ILOffset, Microsoft::VisualStudio::Debugger::IDkmCompletionRoutine<Microsoft::VisualStudio::Debugger::Clr::NativeCompilation::DkmCreateInstructionAddressesFromILAddressAsyncResult>* pCompletionRoutine)
{
    return ProcFD92FC444A902CC21FC67149BB551442(this, pWorkList, MethodId, ILOffset, pCompletionRoutine);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::NativeCompilation::DkmClrNcRuntimeInstance::Create(Microsoft::VisualStudio::Debugger::DkmProcess* pProcess, const Microsoft::VisualStudio::Debugger::DkmRuntimeInstanceId& Id, Microsoft::VisualStudio::Debugger::DkmRuntimeCapabilities_t Capabilities, Microsoft::VisualStudio::Debugger::DkmRuntimeInstance* pParentRuntime, Microsoft::VisualStudio::Debugger::DkmString* pRuntimeVersion, const Microsoft::VisualStudio::Debugger::DkmDataItem& DataItem, Microsoft::VisualStudio::Debugger::Clr::NativeCompilation::DkmClrNcRuntimeInstance** ppCreatedObject)
{
    return ProcC6E2961BDBDC1A9CA97272FF4B74A350(pProcess, Id, Capabilities, pParentRuntime, pRuntimeVersion, DataItem, ppCreatedObject);
}

#ifndef EXCLUDE_MONITOR_ONLY_APIS
_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::Clr::DkmClrModuleInstance* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::DkmClrType::ModuleInstance()
{
    return this->m_pModuleInstance;
}

inline DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::DkmClrType::Token()
{
    return this->m_Token;
}

_Ret_opt_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<Microsoft::VisualStudio::Debugger::Clr::DkmClrType*>* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::DkmClrType::GenericArguments()
{
    return this->m_pGenericArguments;
}

_Ret_opt_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::Clr::DkmClrType* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::DkmClrType::ElementType()
{
    // This method was introduced after the initial version of the API. The caller is
    // responsible for taking steps to ensure that this method is not called when running
    // against earlier versions of vsdebugeng.dll.
    ATLASSERT(DkmComponentManager::IsApiVersionSupported(DkmApiVersion::VS14RTM) || !"Invalid usage detected. Process will crash or bogus data will be returned");
    return this->m__pExtendedData->pElementType;
}

inline DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::DkmClrType::CorElementType()
{
    // This method was introduced after the initial version of the API. The caller is
    // responsible for taking steps to ensure that this method is not called when running
    // against earlier versions of vsdebugeng.dll.
    ATLASSERT(DkmComponentManager::IsApiVersionSupported(DkmApiVersion::VS14RTM) || !"Invalid usage detected. Process will crash or bogus data will be returned");
    return this->m__pExtendedData->CorElementType;
}

inline DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::DkmClrType::ArrayRank()
{
    // This method was introduced after the initial version of the API. The caller is
    // responsible for taking steps to ensure that this method is not called when running
    // against earlier versions of vsdebugeng.dll.
    ATLASSERT(DkmComponentManager::IsApiVersionSupported(DkmApiVersion::VS14RTM) || !"Invalid usage detected. Process will crash or bogus data will be returned");
    return this->m__pExtendedData->ArrayRank;
}

inline DECLSPEC_NOTHROW const GUID& STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::DkmClrType::SyntheticMvid()
{
    // This method was introduced after the initial version of the API. The caller is
    // responsible for taking steps to ensure that this method is not called when running
    // against earlier versions of vsdebugeng.dll.
    ATLASSERT(DkmComponentManager::IsApiVersionSupported(DkmApiVersion::VS14RTM) || !"Invalid usage detected. Process will crash or bogus data will be returned");
    return this->m__pExtendedData->SyntheticMvid;
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::Clr::DkmClrAppDomain* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::DkmClrType::AppDomain()
{
    return this->m_pModuleInstance->AppDomain();
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::Clr::DkmClrRuntimeInstance* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::DkmClrType::RuntimeInstance()
{
    return this->m_pModuleInstance->RuntimeInstance();
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::DkmClrType::Create(Microsoft::VisualStudio::Debugger::Clr::DkmClrModuleInstance* pModuleInstance, UINT32 Token, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<Microsoft::VisualStudio::Debugger::Clr::DkmClrType*>* pGenericArguments, Microsoft::VisualStudio::Debugger::Clr::DkmClrType** ppCreatedObject)
{
    return ProcEDF0FCE8A74B5D0C131F7752E8991D3D(pModuleInstance, Token, pGenericArguments, ppCreatedObject);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::DkmClrType::Create(Microsoft::VisualStudio::Debugger::Clr::DkmClrModuleInstance* pModuleInstance, UINT32 Token, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<Microsoft::VisualStudio::Debugger::Clr::DkmClrType*>* pGenericArguments, Microsoft::VisualStudio::Debugger::Clr::DkmClrType* pElementType, UINT32 CorElementType, UINT32 ArrayRank, const GUID& SyntheticMvid, Microsoft::VisualStudio::Debugger::Clr::DkmClrType** ppCreatedObject)
{
    return Proc52C1C31C0DF8AA33BE89FC83CE9BEA43(pModuleInstance, Token, pGenericArguments, pElementType, CorElementType, ArrayRank, SyntheticMvid, ppCreatedObject);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::DkmClrType::ResolveMethodName(Microsoft::VisualStudio::Debugger::DkmString* pMethodName, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<Microsoft::VisualStudio::Debugger::Clr::DkmClrType*>* pParameterTypes, Microsoft::VisualStudio::Debugger::Clr::DkmClrMethodId* pResult)
{
    return Proc8538455986C021ACA81FB03C2A62E0A6(this, pMethodName, pParameterTypes, pResult);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::DkmClrType::GetEvalAttributes(Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<Microsoft::VisualStudio::Debugger::Evaluation::ClrCompilation::DkmClrEvalAttribute*>** ppAttributes)
{
    return Proc1904FE3D3F1FF1F186B011743A677EA1(this, ppAttributes);
}
#endif // #ifndef EXCLUDE_MONITOR_ONLY_APIS

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::Evaluation::DkmLanguage* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmCompiledVisualizationData::Language()
{
    return this->m_pLanguage;
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::Evaluation::DkmInspectionSession* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmCompiledVisualizationData::InspectionSession()
{
    return this->m_pInspectionSession;
}

inline DECLSPEC_NOTHROW const GUID& STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmCompiledVisualizationData::UniqueId()
{
    return this->m_UniqueId;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmCompiledVisualizationData::Close()
{
    return Proc323D69516EBA1BCDC37105AA207724E0(this);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmCompiledVisualizationData::Create(Microsoft::VisualStudio::Debugger::Evaluation::DkmLanguage* pLanguage, Microsoft::VisualStudio::Debugger::Evaluation::DkmInspectionSession* pInspectionSession, const Microsoft::VisualStudio::Debugger::DkmDataItem& DataItem, Microsoft::VisualStudio::Debugger::Evaluation::DkmCompiledVisualizationData** ppCreatedObject)
{
    return ProcFA215BDCF150EB6AB9820C4A27727AC2(pLanguage, pInspectionSession, DataItem, ppCreatedObject);
}

#ifndef EXCLUDE_IDE_ONLY_APIS
inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmCompiledVisualizationData::Initialize(const Microsoft::VisualStudio::Debugger::DkmArray<Microsoft::VisualStudio::Debugger::DkmString*>& VisualizationFiles)
{
    return ProcA39016543127594E0FEB0444CDC3DF07(this, VisualizationFiles);
}
#endif // #ifndef EXCLUDE_IDE_ONLY_APIS

#ifndef EXCLUDE_MONITOR_ONLY_APIS
_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmVariant* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::DkmILInterpreterPrimitiveValue::Value()
{
    return this->m_pValue;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::DkmILInterpreterPrimitiveValue::Create(Microsoft::VisualStudio::Debugger::Clr::DkmClrRuntimeInstance* pRuntimeInstance, Microsoft::VisualStudio::Debugger::DkmVariant* pValue, Microsoft::VisualStudio::Debugger::Clr::DkmILInterpreterPrimitiveValue** ppCreatedObject)
{
    return Proc9EB16C97D0F941B559CA036DF7F4341E(pRuntimeInstance, pValue, ppCreatedObject);
}
#endif // #ifndef EXCLUDE_MONITOR_ONLY_APIS

#ifndef EXCLUDE_MONITOR_ONLY_APIS
_Ret_opt_ inline DECLSPEC_NOTHROW ICorDebugHandleValue* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::DkmILInterpreterReferenceValue::Value()
{
    return this->m_pValue;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::DkmILInterpreterReferenceValue::Create(Microsoft::VisualStudio::Debugger::Clr::DkmClrRuntimeInstance* pRuntimeInstance, ICorDebugHandleValue* pValue, Microsoft::VisualStudio::Debugger::Clr::DkmILInterpreterReferenceValue** ppCreatedObject)
{
    return Proc16C7D428BB76D469DE0C081CC2EB0A62(pRuntimeInstance, pValue, ppCreatedObject);
}
#endif // #ifndef EXCLUDE_MONITOR_ONLY_APIS

#ifndef EXCLUDE_MONITOR_ONLY_APIS
inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::Clr::DkmILInterpreterValue::Tag_t STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::DkmILInterpreterValue::TagValue()
{
    return this->m_TagValue;
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::Clr::DkmClrRuntimeInstance* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::DkmILInterpreterValue::RuntimeInstance()
{
    return this->m_pRuntimeInstance;
}
#endif // #ifndef EXCLUDE_MONITOR_ONLY_APIS

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmString* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmIntermediateEvaluationResult::Expression()
{
    return this->m_pExpression;
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::Evaluation::DkmLanguage* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmIntermediateEvaluationResult::IntermediateLanguage()
{
    return this->m_pIntermediateLanguage;
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmRuntimeInstance* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmIntermediateEvaluationResult::TargetRuntime()
{
    return this->m_pTargetRuntime;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmIntermediateEvaluationResult::Create(Microsoft::VisualStudio::Debugger::Evaluation::DkmInspectionContext* pInspectionContext, Microsoft::VisualStudio::Debugger::CallStack::DkmStackWalkFrame* pStackFrame, Microsoft::VisualStudio::Debugger::DkmString* pName, Microsoft::VisualStudio::Debugger::DkmString* pFullName, Microsoft::VisualStudio::Debugger::DkmString* pExpression, Microsoft::VisualStudio::Debugger::Evaluation::DkmLanguage* pIntermediateLanguage, Microsoft::VisualStudio::Debugger::DkmRuntimeInstance* pTargetRuntime, const Microsoft::VisualStudio::Debugger::DkmDataItem& DataItem, Microsoft::VisualStudio::Debugger::Evaluation::DkmIntermediateEvaluationResult** ppCreatedObject)
{
    return Proc1061F6811AA7AD0D33CC213D93488771(pInspectionContext, pStackFrame, pName, pFullName, pExpression, pIntermediateLanguage, pTargetRuntime, DataItem, ppCreatedObject);
}

inline DECLSPEC_NOTHROW void STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::DkmManagedHeapRootInfo::Release(Microsoft::VisualStudio::Debugger::Clr::DkmManagedHeapRootInfo* pItem)
{
    return Proc0C053A2A86820E43F81FB08DAC8CE244(pItem);
}

inline DECLSPEC_NOTHROW const GUID& STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::DkmManagedHeapSampler::UniqueId()
{
    return this->m_UniqueId;
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmRuntimeInstance* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::DkmManagedHeapSampler::RuntimeInstance()
{
    return this->m_pRuntimeInstance;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::DkmManagedHeapSampler::Close()
{
    return Proc94B18169AB0EDFAE1D81988AA6E03752(this);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::DkmManagedHeapSampler::Create(Microsoft::VisualStudio::Debugger::DkmRuntimeInstance* pRuntimeInstance, const Microsoft::VisualStudio::Debugger::DkmDataItem& DataItem, Microsoft::VisualStudio::Debugger::Clr::DkmManagedHeapSampler** ppCreatedObject)
{
    return ProcD924583F9543AD80E04AE68B28A15BDE(pRuntimeInstance, DataItem, ppCreatedObject);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::DkmManagedHeapSampler::InitializeHeapObjectWalk(UINT32 TargetObjectCount, bool LiveObjectStatsOnly)
{
    return ProcCC7C33549F96E9BFCC53D8D4796C4789(this, TargetObjectCount, LiveObjectStatsOnly);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::DkmManagedHeapSampler::NextObjects(UINT32 RequestCount, UINT32* pFetchedCount)
{
    return Proc3A6D0DF639ECB96F5A8FCD3BFF85AE11(this, RequestCount, pFetchedCount);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::DkmManagedHeapSampler::NextReferences(UINT32 RequestCount, UINT32* pFetchedCount)
{
    return ProcE8071A89F43A788EBFEBB41CBC4489AA(this, RequestCount, pFetchedCount);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::DkmManagedHeapSampler::NextRoots(UINT32 RequestCount, UINT32* pFetchedCount)
{
    return ProcBBB2B6145A59219AFF600BAA441C73A8(this, RequestCount, pFetchedCount);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::DkmManagedHeapSampler::GetSampledHeapData(UINT32 RequestCount, Microsoft::VisualStudio::Debugger::DkmArray<BYTE>* pItems)
{
    return ProcE7DE701BDD91AE12A722F8CC317D19BC(this, RequestCount, pItems);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::DkmManagedHeapSampler::GetSampledHeapTypeStats(Microsoft::VisualStudio::Debugger::DkmArray<Microsoft::VisualStudio::Debugger::Clr::DkmManagedHeapTypeInfo>* pItems)
{
    return ProcFFE0C8AF37E73BF497ECBCABECEEA17A(this, pItems);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::DkmManagedHeapSampler::GetRoots(Microsoft::VisualStudio::Debugger::DkmArray<Microsoft::VisualStudio::Debugger::Clr::DkmManagedHeapRootInfo>* pItems)
{
    return ProcD96B04D45E8105CE11F115D9F742F71C(this, pItems);
}

inline DECLSPEC_NOTHROW void STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::DkmManagedHeapTypeInfo::Release(Microsoft::VisualStudio::Debugger::Clr::DkmManagedHeapTypeInfo* pItem)
{
    return ProcBEDC326A3D66F01DD50255E127A47AEA(pItem);
}

inline DECLSPEC_NOTHROW const GUID& STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::DkmManagedHeapWalker::UniqueId()
{
    return this->m_UniqueId;
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmRuntimeInstance* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::DkmManagedHeapWalker::RuntimeInstance()
{
    return this->m_pRuntimeInstance;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::DkmManagedHeapWalker::Close()
{
    return Proc79FC2AA34BD6D341512F69F8135965C1(this);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::DkmManagedHeapWalker::Create(Microsoft::VisualStudio::Debugger::DkmRuntimeInstance* pRuntimeInstance, const Microsoft::VisualStudio::Debugger::DkmDataItem& DataItem, Microsoft::VisualStudio::Debugger::Clr::DkmManagedHeapWalker** ppCreatedObject)
{
    return Proc01ED18A9A87787ECBAFD76CA6F41C042(pRuntimeInstance, DataItem, ppCreatedObject);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::DkmManagedHeapWalker::InitializeHeapObjectWalk()
{
    return ProcB3C9F5EA2C9BFB8EB3DB4F9E5D8BB6DE(this);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::DkmManagedHeapWalker::InitializeHeapReferenceWalk()
{
    return ProcE18D30D305F175DD1817B8F658179FD9(this);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::DkmManagedHeapWalker::InitializeHeapRootsWalk()
{
    return Proc797764A0BAC725C4193977B374A1E5A4(this);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::DkmManagedHeapWalker::NextObjects(UINT32 RequestCount, Microsoft::VisualStudio::Debugger::DkmArray<Microsoft::VisualStudio::Debugger::Clr::DkmManagedHeapObjectInfo>* pItems)
{
    return Proc39D50FE942130684A08B74A259BEAAD4(this, RequestCount, pItems);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::DkmManagedHeapWalker::NextReferences(UINT32 RequestCount, Microsoft::VisualStudio::Debugger::DkmArray<Microsoft::VisualStudio::Debugger::Clr::DkmManagedObjectReferenceInfo>* pItems)
{
    return Proc089C4F654C8E15E4AE89DDF3A1A857B2(this, RequestCount, pItems);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::DkmManagedHeapWalker::NextRoots(UINT32 RequestCount, Microsoft::VisualStudio::Debugger::DkmArray<Microsoft::VisualStudio::Debugger::Clr::DkmManagedHeapRootInfo>* pItems)
{
    return ProcBDA1C4B8B62A848BDDA4ED914C3950B5(this, RequestCount, pItems);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::DkmManagedHeapWalker::GetTypeNames(const Microsoft::VisualStudio::Debugger::DkmArray<Microsoft::VisualStudio::Debugger::Clr::DkmManagedTypeId>& TypeIds, Microsoft::VisualStudio::Debugger::DkmArray<Microsoft::VisualStudio::Debugger::DkmString*>* pTypeNames)
{
    return ProcDDC4469B03A149435C884CD60D958A3E(this, TypeIds, pTypeNames);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::DkmManagedHeapWalker::GetSegments(Microsoft::VisualStudio::Debugger::DkmArray<Microsoft::VisualStudio::Debugger::Clr::DkmManagedHeapSegmentInfo>* pSegments)
{
    return Proc0789C5EB42EE609273BB5E426139B584(this, pSegments);
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmThread* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::DkmManagedReturnStackFrame::Thread()
{
    return this->m_pThread;
}

inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::CallStack::DkmStackWalkFrameFlags_t STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::DkmManagedReturnStackFrame::Flags()
{
    return this->m_Flags;
}

inline DECLSPEC_NOTHROW const Microsoft::VisualStudio::Debugger::Clr::DkmClrMethodId& STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::DkmManagedReturnStackFrame::Method()
{
    return this->m_Method;
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::Clr::DkmClrModuleInstance* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::DkmManagedReturnStackFrame::ModuleInstance()
{
    return this->m_pModuleInstance;
}

inline DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::DkmManagedReturnStackFrame::AwaitIndex()
{
    return this->m_AwaitIndex;
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::CallStack::DkmAsyncStackWalkContext* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::DkmManagedReturnStackFrame::AsyncStackWalkContext()
{
    return this->m_pAsyncStackWalkContext;
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::CallStack::DkmStackWalkFrameData* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::DkmManagedReturnStackFrame::Data()
{
    return this->m_pData;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::DkmManagedReturnStackFrame::Create(Microsoft::VisualStudio::Debugger::DkmThread* pThread, Microsoft::VisualStudio::Debugger::CallStack::DkmStackWalkFrameFlags_t Flags, const Microsoft::VisualStudio::Debugger::Clr::DkmClrMethodId& Method, Microsoft::VisualStudio::Debugger::Clr::DkmClrModuleInstance* pModuleInstance, UINT32 AwaitIndex, Microsoft::VisualStudio::Debugger::CallStack::DkmAsyncStackWalkContext* pAsyncStackWalkContext, Microsoft::VisualStudio::Debugger::CallStack::DkmStackWalkFrameData* pData, Microsoft::VisualStudio::Debugger::Clr::DkmManagedReturnStackFrame** ppCreatedObject)
{
    return ProcF307798AFAEC3339F0F539394CF897AD(pThread, Flags, Method, pModuleInstance, AwaitIndex, pAsyncStackWalkContext, pData, ppCreatedObject);
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmThread* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::DkmManagedReturnValueContext::Thread()
{
    return this->m_pThread;
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmRuntimeInstance* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::DkmManagedReturnValueContext::Runtime()
{
    return this->m_pRuntime;
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::Clr::DkmClrInstructionAddress* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::DkmManagedReturnValueContext::Address()
{
    return this->m_pAddress;
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmString* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::DkmManagedReturnValueContext::Name()
{
    return this->m_pName;
}

_Ret_opt_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmString* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::DkmManagedReturnValueContext::FullName()
{
    return this->m_pFullName;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::DkmManagedReturnValueContext::Create(Microsoft::VisualStudio::Debugger::DkmThread* pThread, Microsoft::VisualStudio::Debugger::DkmRuntimeInstance* pRuntime, Microsoft::VisualStudio::Debugger::Clr::DkmClrInstructionAddress* pAddress, Microsoft::VisualStudio::Debugger::DkmString* pName, Microsoft::VisualStudio::Debugger::DkmString* pFullName, Microsoft::VisualStudio::Debugger::Clr::DkmManagedReturnValueContext** ppCreatedObject)
{
    return Proc3190D0E445D2FE7421CF79FA67C8F250(pThread, pRuntime, pAddress, pName, pFullName, ppCreatedObject);
}

#ifndef EXCLUDE_MONITOR_ONLY_APIS
inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::DkmManagedReturnValueContext::GetReturnValueInfo(Microsoft::VisualStudio::Debugger::Clr::DkmManagedReturnValueInfo** ppValueInfo)
{
    return Proc978E4E1F1C2A124CCD52C37CE7B3FE2F(this, ppValueInfo);
}
#endif // #ifndef EXCLUDE_MONITOR_ONLY_APIS

inline DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::DkmManagedReturnValueCopy::CorElementType()
{
    return this->m_CorElementType;
}

inline DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::DkmManagedReturnValueCopy::Size()
{
    return this->m_Size;
}

inline DECLSPEC_NOTHROW UINT64 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::DkmManagedReturnValueCopy::Address()
{
    return this->m_Address;
}

_Ret_opt_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<BYTE>* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::DkmManagedReturnValueCopy::ValueBuffer()
{
    return this->m_pValueBuffer;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::DkmManagedReturnValueCopy::Create(ICorDebugType* pCorType, UINT32 CorElementType, UINT32 Size, UINT64 Address, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<BYTE>* pValueBuffer, Microsoft::VisualStudio::Debugger::Clr::DkmManagedReturnValueCopy** ppCreatedObject)
{
    return ProcD87D1398C6DB7E1C5819A7AEF3065005(pCorType, CorElementType, Size, Address, pValueBuffer, ppCreatedObject);
}

inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::Clr::DkmManagedReturnValueInfo::Tag_t STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::DkmManagedReturnValueInfo::TagValue()
{
    return this->m_TagValue;
}

_Ret_ inline DECLSPEC_NOTHROW ICorDebugType* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::DkmManagedReturnValueInfo::CorType()
{
    return this->m_pCorType;
}

_Ret_opt_ inline DECLSPEC_NOTHROW ICorDebugValue* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::DkmManagedReturnValueReference::CorValue()
{
    return this->m_pCorValue;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::DkmManagedReturnValueReference::Create(ICorDebugType* pCorType, ICorDebugValue* pCorValue, Microsoft::VisualStudio::Debugger::Clr::DkmManagedReturnValueReference** ppCreatedObject)
{
    return ProcD5CA6002328EC4403BAE43C674FC3C77(pCorType, pCorValue, ppCreatedObject);
}

inline DECLSPEC_NOTHROW void STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::ParallelTasks::DkmManagedTaskInfo::Release(Microsoft::VisualStudio::Debugger::ParallelTasks::DkmManagedTaskInfo* pItem)
{
    return Proc1E701FEAF4CA56487DDB8AD758EC4739(pItem);
}

inline DECLSPEC_NOTHROW int STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::DkmManagedTypeId::CompareTo(const Microsoft::VisualStudio::Debugger::Clr::DkmManagedTypeId& other) const
{
    return Proc0ACB29B8C23F835357243E566EC6301C(*this, other);
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::Clr::DkmManagedReturnValueContext* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmRawManagedReturnValue::Context()
{
    return this->m_pContext;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmRawManagedReturnValue::Create(Microsoft::VisualStudio::Debugger::DkmInstructionAddress* pReturnFrom, Microsoft::VisualStudio::Debugger::Clr::DkmManagedReturnValueContext* pContext, Microsoft::VisualStudio::Debugger::Evaluation::DkmRawManagedReturnValue** ppCreatedObject)
{
    return Proc8D47D19688BAF506460B4626D5B8D8EF(pReturnFrom, pContext, ppCreatedObject);
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmString* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmRegistryTweak::ValueName()
{
    return this->m_pValueName;
}

inline DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmRegistryTweak::Data()
{
    return this->m_Data;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmRegistryTweak::Create(Microsoft::VisualStudio::Debugger::DkmString* pValueName, UINT32 Data, Microsoft::VisualStudio::Debugger::DkmRegistryTweak** ppCreatedObject)
{
    return Proc4BD013B67BCF30535C934FEC828B0D2F(pValueName, Data, ppCreatedObject);
}

#ifndef EXCLUDE_IDE_ONLY_APIS
_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<Microsoft::VisualStudio::Debugger::DkmInstructionAddress*>* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::CallStack::DkmStackTraceContext::Frames()
{
    return this->m_pFrames;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::CallStack::DkmStackTraceContext::Create(Microsoft::VisualStudio::Debugger::Evaluation::DkmInspectionSession* pInspectionSession, Microsoft::VisualStudio::Debugger::DkmThread* pThread, Microsoft::VisualStudio::Debugger::CallStack::DkmCallStackFilterOptions_t FilterOptions, const Microsoft::VisualStudio::Debugger::CallStack::DkmFrameFormatOptions& FormatOptions, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<BYTE>* pThreadContext, Microsoft::VisualStudio::Debugger::CallStack::DkmAsyncStackWalkContext* pAsyncContext, Microsoft::VisualStudio::Debugger::CallStack::DkmStackWalkOperation_t Operation, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<Microsoft::VisualStudio::Debugger::DkmInstructionAddress*>* pFrames, const Microsoft::VisualStudio::Debugger::DkmDataItem& DataItem, Microsoft::VisualStudio::Debugger::CallStack::DkmStackTraceContext** ppCreatedObject)
{
    return Proc096C4143603B1A366F404656A77DF808(pInspectionSession, pThread, FilterOptions, FormatOptions, pThreadContext, pAsyncContext, Operation, pFrames, DataItem, ppCreatedObject);
}
#endif // #ifndef EXCLUDE_IDE_ONLY_APIS

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::Evaluation::DkmInspectionSession* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::CallStack::DkmStackWalkFrameData::InspectionSession()
{
    return this->m_pInspectionSession;
}

inline DECLSPEC_NOTHROW const GUID& STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::CallStack::DkmStackWalkFrameData::UniqueId()
{
    return this->m_UniqueId;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::CallStack::DkmStackWalkFrameData::Create(Microsoft::VisualStudio::Debugger::Evaluation::DkmInspectionSession* pInspectionSession, const Microsoft::VisualStudio::Debugger::DkmDataItem& DataItem, Microsoft::VisualStudio::Debugger::CallStack::DkmStackWalkFrameData** ppCreatedObject)
{
    return Proc75D8E6CFCFD2990F41F14B42601A66B9(pInspectionSession, DataItem, ppCreatedObject);
}

#ifndef EXCLUDE_MONITOR_ONLY_APIS
_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmProcess* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Start::DkmLoadCompleteEventDeferral::Process()
{
    return this->m_pProcess;
}

inline DECLSPEC_NOTHROW const GUID& STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Start::DkmLoadCompleteEventDeferral::Id()
{
    return this->m_Id;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Start::DkmLoadCompleteEventDeferral::Create(Microsoft::VisualStudio::Debugger::DkmProcess* pProcess, const GUID& Id, Microsoft::VisualStudio::Debugger::Start::DkmLoadCompleteEventDeferral** ppCreatedObject)
{
    return Proc5EC0E1ADE23A70FE021DAD12CAFFC595(pProcess, Id, ppCreatedObject);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Start::DkmLoadCompleteEventDeferral::Add()
{
    return Proc1F9658A9DD9C06D2D908C3ACB74E7E37(this);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Start::DkmLoadCompleteEventDeferral::Remove()
{
    return ProcD463863E27EBF9AED0D4A4E73EC97E94(this);
}
#endif // #ifndef EXCLUDE_MONITOR_ONLY_APIS

_Ret_opt_ inline DECLSPEC_NOTHROW const Microsoft::VisualStudio::Debugger::Exceptions::DkmStowedExceptionInformation::NestedException* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Exceptions::DkmStowedExceptionInformation::NestedExceptionPart()
{
    return this->m_pNestedException;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Exceptions::DkmStowedExceptionInformation::ResultCode()
{
    return this->m_ResultCode;
}

inline DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Exceptions::DkmStowedExceptionInformation::ThreadId()
{
    return this->m_ThreadId;
}

_Ret_opt_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmString* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Exceptions::DkmStowedExceptionInformation::ErrorText()
{
    return this->m_pErrorText;
}

inline DECLSPEC_NOTHROW UINT64 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Exceptions::DkmStowedExceptionInformation::ExceptionAddress()
{
    return this->m_ExceptionAddress;
}

inline DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Exceptions::DkmStowedExceptionInformation::StackTraceWordSize()
{
    return this->m_StackTraceWordSize;
}

inline DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Exceptions::DkmStowedExceptionInformation::StackTraceWords()
{
    return this->m_StackTraceWords;
}

inline DECLSPEC_NOTHROW UINT64 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Exceptions::DkmStowedExceptionInformation::StackTrace()
{
    return this->m_StackTrace;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Exceptions::DkmStowedExceptionInformation::Create(HRESULT ResultCode, UINT32 ThreadId, Microsoft::VisualStudio::Debugger::DkmString* pErrorText, UINT64 ExceptionAddress, UINT32 StackTraceWordSize, UINT32 StackTraceWords, UINT64 StackTrace, const Microsoft::VisualStudio::Debugger::Exceptions::DkmStowedExceptionInformation::NestedException* pNestedException, Microsoft::VisualStudio::Debugger::Exceptions::DkmStowedExceptionInformation** ppCreatedObject)
{
    return Proc3249D3C9EA46E0FD18272AB7760482C4(ResultCode, ThreadId, pErrorText, ExceptionAddress, StackTraceWordSize, StackTraceWords, StackTrace, pNestedException, ppCreatedObject);
}

inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::Clr::DkmClrAliasKind_t STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::DkmClrAlias::Kind()
{
    return this->m_Kind;
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmString* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::DkmClrAlias::Name()
{
    return this->m_pName;
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmString* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::DkmClrAlias::FullName()
{
    return this->m_pFullName;
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmString* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::DkmClrAlias::Type()
{
    return this->m_pType;
}

inline DECLSPEC_NOTHROW const GUID& STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::DkmClrAlias::CustomTypeInfoPayloadTypeId()
{
    return this->m_CustomTypeInfoPayloadTypeId;
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<BYTE>* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::DkmClrAlias::CustomTypeInfoPayload()
{
    return this->m_pCustomTypeInfoPayload;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Clr::DkmClrAlias::Create(Microsoft::VisualStudio::Debugger::Clr::DkmClrAliasKind_t Kind, Microsoft::VisualStudio::Debugger::DkmString* pName, Microsoft::VisualStudio::Debugger::DkmString* pFullName, Microsoft::VisualStudio::Debugger::DkmString* pType, const GUID& CustomTypeInfoPayloadTypeId, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<BYTE>* pCustomTypeInfoPayload, Microsoft::VisualStudio::Debugger::Clr::DkmClrAlias** ppCreatedObject)
{
    return ProcF1B1DA50551A6B51735C9A51AA4CEAE4(Kind, pName, pFullName, pType, CustomTypeInfoPayloadTypeId, pCustomTypeInfoPayload, ppCreatedObject);
}

inline DECLSPEC_NOTHROW const GUID& STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::ClrCompilation::DkmClrCustomTypeInfo::PayloadTypeId()
{
    return this->m_PayloadTypeId;
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<BYTE>* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::ClrCompilation::DkmClrCustomTypeInfo::Payload()
{
    return this->m_pPayload;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::ClrCompilation::DkmClrCustomTypeInfo::Create(const GUID& PayloadTypeId, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<BYTE>* pPayload, Microsoft::VisualStudio::Debugger::Evaluation::ClrCompilation::DkmClrCustomTypeInfo** ppCreatedObject)
{
    return ProcF0E5919982A4F1DB7B9372D231C26F61(PayloadTypeId, pPayload, ppCreatedObject);
}

#ifndef EXCLUDE_MONITOR_ONLY_APIS
inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::Evaluation::ClrCompilation::DkmClrDebuggerBrowsableAttributeState_t STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::ClrCompilation::DkmClrDebuggerBrowsableAttribute::State()
{
    return this->m_State;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::ClrCompilation::DkmClrDebuggerBrowsableAttribute::Create(Microsoft::VisualStudio::Debugger::Clr::DkmClrType* pTargetType, Microsoft::VisualStudio::Debugger::DkmString* pTargetMember, Microsoft::VisualStudio::Debugger::Evaluation::ClrCompilation::DkmClrDebuggerBrowsableAttributeState_t State, Microsoft::VisualStudio::Debugger::Evaluation::ClrCompilation::DkmClrDebuggerBrowsableAttribute** ppCreatedObject)
{
    return Proc8D1736155FDC81F1E58139DE347B7E41(pTargetType, pTargetMember, State, ppCreatedObject);
}
#endif // #ifndef EXCLUDE_MONITOR_ONLY_APIS

#ifndef EXCLUDE_MONITOR_ONLY_APIS
_Ret_opt_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmString* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::ClrCompilation::DkmClrDebuggerDisplayAttribute::OriginatingAssemblyName()
{
    return this->m_pOriginatingAssemblyName;
}

_Ret_opt_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<BYTE>* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::ClrCompilation::DkmClrDebuggerDisplayAttribute::OriginatingAssemblyPublicKeyToken()
{
    return this->m_pOriginatingAssemblyPublicKeyToken;
}

_Ret_opt_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmString* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::ClrCompilation::DkmClrDebuggerDisplayAttribute::Value()
{
    return this->m_pValue;
}

_Ret_opt_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmString* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::ClrCompilation::DkmClrDebuggerDisplayAttribute::Name()
{
    return this->m_pName;
}

_Ret_opt_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmString* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::ClrCompilation::DkmClrDebuggerDisplayAttribute::TypeName()
{
    return this->m_pTypeName;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::ClrCompilation::DkmClrDebuggerDisplayAttribute::Create(Microsoft::VisualStudio::Debugger::Clr::DkmClrType* pTargetType, Microsoft::VisualStudio::Debugger::DkmString* pTargetMember, Microsoft::VisualStudio::Debugger::DkmString* pOriginatingAssemblyName, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<BYTE>* pOriginatingAssemblyPublicKeyToken, Microsoft::VisualStudio::Debugger::DkmString* pValue, Microsoft::VisualStudio::Debugger::DkmString* pName, Microsoft::VisualStudio::Debugger::DkmString* pTypeName, Microsoft::VisualStudio::Debugger::Evaluation::ClrCompilation::DkmClrDebuggerDisplayAttribute** ppCreatedObject)
{
    return ProcB14B5FE34DBC117808112FEC057E8D54(pTargetType, pTargetMember, pOriginatingAssemblyName, pOriginatingAssemblyPublicKeyToken, pValue, pName, pTypeName, ppCreatedObject);
}
#endif // #ifndef EXCLUDE_MONITOR_ONLY_APIS

#ifndef EXCLUDE_MONITOR_ONLY_APIS
_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::Clr::DkmClrType* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::ClrCompilation::DkmClrDebuggerTypeProxyAttribute::ProxyType()
{
    return this->m_pProxyType;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::ClrCompilation::DkmClrDebuggerTypeProxyAttribute::Create(Microsoft::VisualStudio::Debugger::Clr::DkmClrType* pTargetType, Microsoft::VisualStudio::Debugger::DkmString* pTargetMember, Microsoft::VisualStudio::Debugger::Clr::DkmClrType* pProxyType, Microsoft::VisualStudio::Debugger::Evaluation::ClrCompilation::DkmClrDebuggerTypeProxyAttribute** ppCreatedObject)
{
    return ProcB145D365DC91297B6CB026CB1B5BC3DD(pTargetType, pTargetMember, pProxyType, ppCreatedObject);
}
#endif // #ifndef EXCLUDE_MONITOR_ONLY_APIS

#ifndef EXCLUDE_MONITOR_ONLY_APIS
_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmString* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::ClrCompilation::DkmClrDebuggerVisualizerAttribute::UISideVisualizerTypeName()
{
    return this->m_pUISideVisualizerTypeName;
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmString* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::ClrCompilation::DkmClrDebuggerVisualizerAttribute::UISideVisualizerAssemblyName()
{
    return this->m_pUISideVisualizerAssemblyName;
}

inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::Evaluation::DkmClrCustomVisualizerAssemblyLocation_t STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::ClrCompilation::DkmClrDebuggerVisualizerAttribute::UISideVisualizerAssemblyLocation()
{
    return this->m_UISideVisualizerAssemblyLocation;
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmString* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::ClrCompilation::DkmClrDebuggerVisualizerAttribute::DebuggeeSideVisualizerTypeName()
{
    return this->m_pDebuggeeSideVisualizerTypeName;
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmString* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::ClrCompilation::DkmClrDebuggerVisualizerAttribute::DebuggeeSideVisualizerAssemblyName()
{
    return this->m_pDebuggeeSideVisualizerAssemblyName;
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmString* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::ClrCompilation::DkmClrDebuggerVisualizerAttribute::VisualizerDescription()
{
    return this->m_pVisualizerDescription;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::ClrCompilation::DkmClrDebuggerVisualizerAttribute::Create(Microsoft::VisualStudio::Debugger::Clr::DkmClrType* pTargetType, Microsoft::VisualStudio::Debugger::DkmString* pTargetMember, Microsoft::VisualStudio::Debugger::DkmString* pUISideVisualizerTypeName, Microsoft::VisualStudio::Debugger::DkmString* pUISideVisualizerAssemblyName, Microsoft::VisualStudio::Debugger::Evaluation::DkmClrCustomVisualizerAssemblyLocation_t UISideVisualizerAssemblyLocation, Microsoft::VisualStudio::Debugger::DkmString* pDebuggeeSideVisualizerTypeName, Microsoft::VisualStudio::Debugger::DkmString* pDebuggeeSideVisualizerAssemblyName, Microsoft::VisualStudio::Debugger::DkmString* pVisualizerDescription, Microsoft::VisualStudio::Debugger::Evaluation::ClrCompilation::DkmClrDebuggerVisualizerAttribute** ppCreatedObject)
{
    return Proc39A1A14313605335F7629F87A8D822EA(pTargetType, pTargetMember, pUISideVisualizerTypeName, pUISideVisualizerAssemblyName, UISideVisualizerAssemblyLocation, pDebuggeeSideVisualizerTypeName, pDebuggeeSideVisualizerAssemblyName, pVisualizerDescription, ppCreatedObject);
}
#endif // #ifndef EXCLUDE_MONITOR_ONLY_APIS

#ifndef EXCLUDE_MONITOR_ONLY_APIS
inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::Evaluation::ClrCompilation::DkmClrEvalAttribute::Tag_t STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::ClrCompilation::DkmClrEvalAttribute::TagValue()
{
    return this->m_TagValue;
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::Clr::DkmClrType* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::ClrCompilation::DkmClrEvalAttribute::TargetType()
{
    return this->m_pTargetType;
}

_Ret_opt_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmString* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::ClrCompilation::DkmClrEvalAttribute::TargetMember()
{
    return this->m_pTargetMember;
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::Clr::DkmClrModuleInstance* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::ClrCompilation::DkmClrEvalAttribute::ModuleInstance()
{
    return this->m_pTargetType->ModuleInstance();
}
#endif // #ifndef EXCLUDE_MONITOR_ONLY_APIS

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmString* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::ClrCompilation::DkmClrLocalVariableInfo::VariableName()
{
    return this->m_pVariableName;
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmString* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::ClrCompilation::DkmClrLocalVariableInfo::FullName()
{
    return this->m_pFullName;
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmString* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::ClrCompilation::DkmClrLocalVariableInfo::MethodName()
{
    return this->m_pMethodName;
}

inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::Evaluation::ClrCompilation::DkmClrCompilationResultFlags_t STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::ClrCompilation::DkmClrLocalVariableInfo::CompilationFlags()
{
    return this->m_CompilationFlags;
}

inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::Evaluation::DkmEvaluationResultCategory_t STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::ClrCompilation::DkmClrLocalVariableInfo::ResultCategory()
{
    return this->m_ResultCategory;
}

_Ret_opt_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::Evaluation::ClrCompilation::DkmClrCustomTypeInfo* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::ClrCompilation::DkmClrLocalVariableInfo::CustomTypeInfo()
{
    return this->m_pCustomTypeInfo;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::ClrCompilation::DkmClrLocalVariableInfo::Create(Microsoft::VisualStudio::Debugger::DkmString* pVariableName, Microsoft::VisualStudio::Debugger::DkmString* pFullName, Microsoft::VisualStudio::Debugger::DkmString* pMethodName, Microsoft::VisualStudio::Debugger::Evaluation::ClrCompilation::DkmClrCompilationResultFlags_t CompilationFlags, Microsoft::VisualStudio::Debugger::Evaluation::DkmEvaluationResultCategory_t ResultCategory, Microsoft::VisualStudio::Debugger::Evaluation::ClrCompilation::DkmClrCustomTypeInfo* pCustomTypeInfo, Microsoft::VisualStudio::Debugger::Evaluation::ClrCompilation::DkmClrLocalVariableInfo** ppCreatedObject)
{
    return Proc14A0AAE890048630D46A2E955241D0CF(pVariableName, pFullName, pMethodName, CompilationFlags, ResultCategory, pCustomTypeInfo, ppCreatedObject);
}

#ifndef EXCLUDE_MONITOR_ONLY_APIS
_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::Evaluation::DkmInspectionSession* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::ClrCompilation::DkmClrValue::InspectionSession()
{
    return this->m_pInspectionSession;
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::Evaluation::DkmLanguage* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::ClrCompilation::DkmClrValue::Language()
{
    return this->m_pLanguage;
}

_Ret_opt_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::Clr::DkmClrType* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::ClrCompilation::DkmClrValue::Type()
{
    return this->m_pType;
}

inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::Evaluation::DkmEvaluationResultCategory_t STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::ClrCompilation::DkmClrValue::Category()
{
    return this->m_Category;
}

inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::Evaluation::DkmEvaluationResultAccessType_t STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::ClrCompilation::DkmClrValue::Access()
{
    return this->m_Access;
}

inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::Evaluation::DkmEvaluationResultStorageType_t STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::ClrCompilation::DkmClrValue::StorageType()
{
    return this->m_StorageType;
}

inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::Evaluation::DkmEvaluationResultTypeModifierFlags_t STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::ClrCompilation::DkmClrValue::TypeModifierFlags()
{
    return this->m_TypeModifierFlags;
}

inline DECLSPEC_NOTHROW bool STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::ClrCompilation::DkmClrValue::IsNull()
{
    return this->m_IsNull;
}

_Ret_opt_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmVariant* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::ClrCompilation::DkmClrValue::HostObjectValue()
{
    return this->m_pHostObjectValue;
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::CallStack::DkmStackWalkFrame* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::ClrCompilation::DkmClrValue::StackFrame()
{
    return this->m_pStackFrame;
}

inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::Evaluation::DkmEvaluationResultFlags_t STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::ClrCompilation::DkmClrValue::EvalFlags()
{
    return this->m_EvalFlags;
}

inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::Evaluation::DkmClrValueFlags_t STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::ClrCompilation::DkmClrValue::ValueFlags()
{
    return this->m_ValueFlags;
}

inline DECLSPEC_NOTHROW UINT64 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::ClrCompilation::DkmClrValue::NativeComPointer()
{
    return this->m_NativeComPointer;
}

_Ret_opt_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::Evaluation::DkmDataAddress* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::ClrCompilation::DkmClrValue::Address()
{
    return this->m_pAddress;
}

_Ret_opt_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmString* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::ClrCompilation::DkmClrValue::Alias()
{
    return this->m_pAlias;
}

_Ret_opt_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<UINT32>* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::ClrCompilation::DkmClrValue::ArrayDimensions()
{
    return this->m_pArrayDimensions;
}

_Ret_opt_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<UINT32>* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::ClrCompilation::DkmClrValue::ArrayLowerBounds()
{
    return this->m_pArrayLowerBounds;
}

inline DECLSPEC_NOTHROW const GUID& STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::ClrCompilation::DkmClrValue::UniqueId()
{
    return this->m_UniqueId;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::ClrCompilation::DkmClrValue::Close()
{
    return ProcA210DBF525D74CF809345A94627A2672(this);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::ClrCompilation::DkmClrValue::Create(Microsoft::VisualStudio::Debugger::Evaluation::DkmInspectionSession* pInspectionSession, Microsoft::VisualStudio::Debugger::Evaluation::DkmLanguage* pLanguage, Microsoft::VisualStudio::Debugger::Clr::DkmClrType* pType, Microsoft::VisualStudio::Debugger::Evaluation::DkmEvaluationResultCategory_t Category, Microsoft::VisualStudio::Debugger::Evaluation::DkmEvaluationResultAccessType_t Access, Microsoft::VisualStudio::Debugger::Evaluation::DkmEvaluationResultStorageType_t StorageType, Microsoft::VisualStudio::Debugger::Evaluation::DkmEvaluationResultTypeModifierFlags_t TypeModifierFlags, bool IsNull, Microsoft::VisualStudio::Debugger::DkmVariant* pHostObjectValue, Microsoft::VisualStudio::Debugger::CallStack::DkmStackWalkFrame* pStackFrame, Microsoft::VisualStudio::Debugger::Evaluation::DkmEvaluationResultFlags_t EvalFlags, Microsoft::VisualStudio::Debugger::Evaluation::DkmClrValueFlags_t ValueFlags, UINT64 NativeComPointer, Microsoft::VisualStudio::Debugger::Evaluation::DkmDataAddress* pAddress, Microsoft::VisualStudio::Debugger::DkmString* pAlias, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<UINT32>* pArrayDimensions, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<UINT32>* pArrayLowerBounds, const Microsoft::VisualStudio::Debugger::DkmDataItem& DataItem, Microsoft::VisualStudio::Debugger::Evaluation::ClrCompilation::DkmClrValue** ppCreatedObject)
{
    return Proc2021ABFAEFCB327E6372E6E40E399D27(pInspectionSession, pLanguage, pType, Category, Access, StorageType, TypeModifierFlags, IsNull, pHostObjectValue, pStackFrame, EvalFlags, ValueFlags, NativeComPointer, pAddress, pAlias, pArrayDimensions, pArrayLowerBounds, DataItem, ppCreatedObject);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::ClrCompilation::DkmClrValue::GetValueString(Microsoft::VisualStudio::Debugger::Evaluation::DkmInspectionContext* pInspectionContext, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<Microsoft::VisualStudio::Debugger::DkmString*>* pFormatSpecifiers, Microsoft::VisualStudio::Debugger::DkmString** ppValueString)
{
    return Proc6C4DE7505B979C71E3E02EB952475CC3(this, pInspectionContext, pFormatSpecifiers, ppValueString);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::ClrCompilation::DkmClrValue::HasUnderlyingString(Microsoft::VisualStudio::Debugger::Evaluation::DkmInspectionContext* pInspectionContext, bool* pResult)
{
    return Proc890C63B33FF2E68F5B265D7634690B8F(this, pInspectionContext, pResult);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::ClrCompilation::DkmClrValue::GetUnderlyingString(Microsoft::VisualStudio::Debugger::Evaluation::DkmInspectionContext* pInspectionContext, Microsoft::VisualStudio::Debugger::DkmString** ppResult)
{
    return ProcBF98F87C306590B3E18C3BA27F89ADD2(this, pInspectionContext, ppResult);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::ClrCompilation::DkmClrValue::GetResult(Microsoft::VisualStudio::Debugger::DkmWorkList* pWorkList, Microsoft::VisualStudio::Debugger::Clr::DkmClrType* pDeclaredType, Microsoft::VisualStudio::Debugger::Evaluation::ClrCompilation::DkmClrCustomTypeInfo* pCustomTypeInfo, Microsoft::VisualStudio::Debugger::Evaluation::DkmInspectionContext* pInspectionContext, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<Microsoft::VisualStudio::Debugger::DkmString*>* pFormatSpecifiers, Microsoft::VisualStudio::Debugger::DkmString* pResultName, Microsoft::VisualStudio::Debugger::DkmString* pResultFullName, Microsoft::VisualStudio::Debugger::IDkmCompletionRoutine<Microsoft::VisualStudio::Debugger::Evaluation::ClrCompilation::DkmEvaluationAsyncResult>* pCompletionRoutine)
{
    return ProcAFCF06128BDFB93D5DF0C0F44D50448F(this, pWorkList, pDeclaredType, pCustomTypeInfo, pInspectionContext, pFormatSpecifiers, pResultName, pResultFullName, pCompletionRoutine);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::ClrCompilation::DkmClrValue::EvaluateToString(Microsoft::VisualStudio::Debugger::Evaluation::DkmInspectionContext* pInspectionContext, Microsoft::VisualStudio::Debugger::DkmString** ppResult)
{
    return Proc3AF35B63B30CFA5A1D212BEE27AC26D5(this, pInspectionContext, ppResult);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::ClrCompilation::DkmClrValue::EvaluateDebuggerDisplayString(Microsoft::VisualStudio::Debugger::DkmWorkList* pWorkList, Microsoft::VisualStudio::Debugger::Evaluation::DkmInspectionContext* pInspectionContext, Microsoft::VisualStudio::Debugger::Clr::DkmClrType* pTargetType, Microsoft::VisualStudio::Debugger::DkmString* pFormatString, Microsoft::VisualStudio::Debugger::IDkmCompletionRoutine<Microsoft::VisualStudio::Debugger::Evaluation::ClrCompilation::DkmEvaluateDebuggerDisplayStringAsyncResult>* pCompletionRoutine)
{
    return Proc400088C369C8C66604FDFF13B813C730(this, pWorkList, pInspectionContext, pTargetType, pFormatString, pCompletionRoutine);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::ClrCompilation::DkmClrValue::InstantiateProxyType(Microsoft::VisualStudio::Debugger::Evaluation::DkmInspectionContext* pInspectionContext, Microsoft::VisualStudio::Debugger::Clr::DkmClrType* pType, Microsoft::VisualStudio::Debugger::Evaluation::ClrCompilation::DkmClrValue** ppResult)
{
    return Proc91C4EC61807E297F57957A40CAB27100(this, pInspectionContext, pType, ppResult);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::ClrCompilation::DkmClrValue::InstantiateResultsViewProxy(Microsoft::VisualStudio::Debugger::Evaluation::DkmInspectionContext* pInspectionContext, Microsoft::VisualStudio::Debugger::Clr::DkmClrType* pEnumerableType, Microsoft::VisualStudio::Debugger::Evaluation::ClrCompilation::DkmClrValue** ppResult)
{
    return Proc22EEA4C695BED5B20A3D86A0C0082B66(this, pInspectionContext, pEnumerableType, ppResult);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::ClrCompilation::DkmClrValue::InstantiateDynamicViewProxy(Microsoft::VisualStudio::Debugger::Evaluation::DkmInspectionContext* pInspectionContext, Microsoft::VisualStudio::Debugger::Evaluation::ClrCompilation::DkmClrValue** ppResult)
{
    return Proc456DE515A7AD07EAA1EC0FF44DC197A8(this, pInspectionContext, ppResult);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::ClrCompilation::DkmClrValue::GetMemberValue(Microsoft::VisualStudio::Debugger::DkmString* pMemberName, UINT32 MemberType, Microsoft::VisualStudio::Debugger::DkmString* pParentTypeName, Microsoft::VisualStudio::Debugger::Evaluation::DkmInspectionContext* pInspectionContext, Microsoft::VisualStudio::Debugger::Evaluation::ClrCompilation::DkmClrValue** ppResult)
{
    return Proc6243C5A4A929D860DA0B917987F9D8AA(this, pMemberName, MemberType, pParentTypeName, pInspectionContext, ppResult);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::ClrCompilation::DkmClrValue::GetArrayElement(const Microsoft::VisualStudio::Debugger::DkmArray<UINT32>& Index, Microsoft::VisualStudio::Debugger::Evaluation::DkmInspectionContext* pInspectionContext, Microsoft::VisualStudio::Debugger::Evaluation::ClrCompilation::DkmClrValue** ppResult)
{
    return ProcA590A504A81E76260F0F8227960A9E01(this, Index, pInspectionContext, ppResult);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::ClrCompilation::DkmClrValue::Dereference(Microsoft::VisualStudio::Debugger::Evaluation::DkmInspectionContext* pInspectionContext, Microsoft::VisualStudio::Debugger::Evaluation::ClrCompilation::DkmClrValue** ppResult)
{
    return Proc90CD4ED530C25300CB93AB8F04C67D8E(this, pInspectionContext, ppResult);
}
#endif // #ifndef EXCLUDE_MONITOR_ONLY_APIS

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<BYTE>* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::ClrCompilation::DkmCompiledClrInspectionQuery::Binary()
{
    return this->m_pBinary;
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmString* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::ClrCompilation::DkmCompiledClrInspectionQuery::TypeName()
{
    return this->m_pTypeName;
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmString* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::ClrCompilation::DkmCompiledClrInspectionQuery::MethodName()
{
    return this->m_pMethodName;
}

_Ret_opt_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<Microsoft::VisualStudio::Debugger::DkmString*>* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::ClrCompilation::DkmCompiledClrInspectionQuery::FormatSpecifiers()
{
    return this->m_pFormatSpecifiers;
}

inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::Evaluation::ClrCompilation::DkmClrCompilationResultFlags_t STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::ClrCompilation::DkmCompiledClrInspectionQuery::CompilationFlags()
{
    return this->m_CompilationFlags;
}

inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::Evaluation::DkmEvaluationResultCategory_t STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::ClrCompilation::DkmCompiledClrInspectionQuery::ResultCategory()
{
    return this->m_ResultCategory;
}

inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::Evaluation::DkmEvaluationResultAccessType_t STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::ClrCompilation::DkmCompiledClrInspectionQuery::Access()
{
    return this->m_Access;
}

inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::Evaluation::DkmEvaluationResultStorageType_t STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::ClrCompilation::DkmCompiledClrInspectionQuery::StorageType()
{
    return this->m_StorageType;
}

inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::Evaluation::DkmEvaluationResultTypeModifierFlags_t STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::ClrCompilation::DkmCompiledClrInspectionQuery::TypeModifierFlags()
{
    return this->m_TypeModifierFlags;
}

_Ret_opt_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::Evaluation::ClrCompilation::DkmClrCustomTypeInfo* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::ClrCompilation::DkmCompiledClrInspectionQuery::CustomTypeInfo()
{
    return this->m_pCustomTypeInfo;
}

inline DECLSPEC_NOTHROW const GUID& STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::ClrCompilation::DkmCompiledClrInspectionQuery::UniqueId()
{
    return this->m_UniqueId;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::ClrCompilation::DkmCompiledClrInspectionQuery::Create(Microsoft::VisualStudio::Debugger::DkmRuntimeInstance* pRuntimeInstance, Microsoft::VisualStudio::Debugger::Evaluation::DkmCustomDataContainer* pDataContainer, const Microsoft::VisualStudio::Debugger::Evaluation::DkmCompilerId& LanguageId, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<BYTE>* pBinary, Microsoft::VisualStudio::Debugger::DkmString* pTypeName, Microsoft::VisualStudio::Debugger::DkmString* pMethodName, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<Microsoft::VisualStudio::Debugger::DkmString*>* pFormatSpecifiers, Microsoft::VisualStudio::Debugger::Evaluation::ClrCompilation::DkmClrCompilationResultFlags_t CompilationFlags, Microsoft::VisualStudio::Debugger::Evaluation::DkmEvaluationResultCategory_t ResultCategory, Microsoft::VisualStudio::Debugger::Evaluation::DkmEvaluationResultAccessType_t Access, Microsoft::VisualStudio::Debugger::Evaluation::DkmEvaluationResultStorageType_t StorageType, Microsoft::VisualStudio::Debugger::Evaluation::DkmEvaluationResultTypeModifierFlags_t TypeModifierFlags, Microsoft::VisualStudio::Debugger::Evaluation::ClrCompilation::DkmClrCustomTypeInfo* pCustomTypeInfo, Microsoft::VisualStudio::Debugger::Evaluation::ClrCompilation::DkmCompiledClrInspectionQuery** ppCreatedObject)
{
    return Proc74D790147FCAC34024A1CD668561842F(pRuntimeInstance, pDataContainer, LanguageId, pBinary, pTypeName, pMethodName, pFormatSpecifiers, CompilationFlags, ResultCategory, Access, StorageType, TypeModifierFlags, pCustomTypeInfo, ppCreatedObject);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::ClrCompilation::DkmCompiledClrInspectionQuery::Execute(Microsoft::VisualStudio::Debugger::DkmWorkList* pWorkList, Microsoft::VisualStudio::Debugger::Evaluation::DkmInspectionContext* pInspectionContext, Microsoft::VisualStudio::Debugger::Evaluation::DkmILContext* pILContext, Microsoft::VisualStudio::Debugger::DkmString* pExpressionName, Microsoft::VisualStudio::Debugger::IDkmCompletionRoutine<Microsoft::VisualStudio::Debugger::Evaluation::ClrCompilation::DkmExecuteClrInspectionQueryAsyncResult>* pCompletionRoutine)
{
    return Proc2CB7A3C8059AAC75AF28E0B1E84A9917(this, pWorkList, pInspectionContext, pILContext, pExpressionName, pCompletionRoutine);
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<BYTE>* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::ClrCompilation::DkmCompiledClrLocalsQuery::Binary()
{
    return this->m_pBinary;
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmString* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::ClrCompilation::DkmCompiledClrLocalsQuery::TypeName()
{
    return this->m_pTypeName;
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<Microsoft::VisualStudio::Debugger::Evaluation::ClrCompilation::DkmClrLocalVariableInfo*>* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::ClrCompilation::DkmCompiledClrLocalsQuery::LocalInfo()
{
    return this->m_pLocalInfo;
}

inline DECLSPEC_NOTHROW const GUID& STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::ClrCompilation::DkmCompiledClrLocalsQuery::UniqueId()
{
    return this->m_UniqueId;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::ClrCompilation::DkmCompiledClrLocalsQuery::Create(Microsoft::VisualStudio::Debugger::DkmRuntimeInstance* pRuntimeInstance, Microsoft::VisualStudio::Debugger::Evaluation::DkmCustomDataContainer* pDataContainer, const Microsoft::VisualStudio::Debugger::Evaluation::DkmCompilerId& LanguageId, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<BYTE>* pBinary, Microsoft::VisualStudio::Debugger::DkmString* pTypeName, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<Microsoft::VisualStudio::Debugger::Evaluation::ClrCompilation::DkmClrLocalVariableInfo*>* pLocalInfo, Microsoft::VisualStudio::Debugger::Evaluation::ClrCompilation::DkmCompiledClrLocalsQuery** ppCreatedObject)
{
    return Proc4DD91DB37653F5E07597467950976083(pRuntimeInstance, pDataContainer, LanguageId, pBinary, pTypeName, pLocalInfo, ppCreatedObject);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::ClrCompilation::DkmCompiledClrLocalsQuery::GetLocalValues(Microsoft::VisualStudio::Debugger::DkmWorkList* pWorkList, Microsoft::VisualStudio::Debugger::Evaluation::DkmInspectionContext* pInspectionContext, Microsoft::VisualStudio::Debugger::Evaluation::DkmILContext* pILContext, UINT32 FirstLocalIndex, UINT32 Count, Microsoft::VisualStudio::Debugger::IDkmCompletionRoutine<Microsoft::VisualStudio::Debugger::Evaluation::ClrCompilation::DkmGetLocalValuesAsyncResult>* pCompletionRoutine)
{
    return Proc005392F2C0BF0145335ECA55C374B2A2(this, pWorkList, pInspectionContext, pILContext, FirstLocalIndex, Count, pCompletionRoutine);
}

inline DECLSPEC_NOTHROW const GUID& STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmCustomDataContainer::UniqueId()
{
    return this->m_UniqueId;
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmProcess* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmCustomDataContainer::Process()
{
    return this->m_pProcess;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmCustomDataContainer::Close()
{
    return Proc571451A6697E1B721711E9473EF39285(this);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmCustomDataContainer::Create(Microsoft::VisualStudio::Debugger::DkmProcess* pProcess, const Microsoft::VisualStudio::Debugger::DkmDataItem& DataItem, Microsoft::VisualStudio::Debugger::Evaluation::DkmCustomDataContainer** ppCreatedObject)
{
    return ProcFDC6780AC8E93F157C9371DF0C755468(pProcess, DataItem, ppCreatedObject);
}

inline DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Start::DkmDebugProcessRequest::ProcessId()
{
    return this->m_ProcessId;
}

inline DECLSPEC_NOTHROW UINT64 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Start::DkmDebugProcessRequest::StartTime()
{
    return this->m_StartTime;
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmProcess* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Start::DkmDebugProcessRequest::LogicalParentProcess()
{
    return this->m_pLogicalParentProcess;
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmString* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Start::DkmDebugProcessRequest::Path()
{
    return this->m_pPath;
}

_Ret_opt_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<GUID>* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Start::DkmDebugProcessRequest::EngineFilter()
{
    return this->m_pEngineFilter;
}

inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::Start::DkmDebugProcessRequestFlags_t STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Start::DkmDebugProcessRequest::Flags()
{
    return this->m_Flags;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Start::DkmDebugProcessRequest::Create(UINT32 ProcessId, UINT64 StartTime, Microsoft::VisualStudio::Debugger::DkmProcess* pLogicalParentProcess, Microsoft::VisualStudio::Debugger::DkmString* pPath, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<GUID>* pEngineFilter, Microsoft::VisualStudio::Debugger::Start::DkmDebugProcessRequestFlags_t Flags, Microsoft::VisualStudio::Debugger::Start::DkmDebugProcessRequest** ppCreatedObject)
{
    return ProcCA7B631362F38C18B5D8C2D9CE4FE491(ProcessId, StartTime, pLogicalParentProcess, pPath, pEngineFilter, Flags, ppCreatedObject);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Start::DkmDebugProcessRequest::Send(Microsoft::VisualStudio::Debugger::DkmWorkList* pWorkList, Microsoft::VisualStudio::Debugger::IDkmCompletionRoutine<Microsoft::VisualStudio::Debugger::Start::DkmDebugProcessRequestAsyncResult>* pCompletionRoutine)
{
    return Proc43CF0BC35847CC7DAA444A86904AAF19(this, pWorkList, pCompletionRoutine);
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmString* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DefaultPort::DkmDeviceInfo::DeviceFamily()
{
    return this->m_pDeviceFamily;
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmString* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DefaultPort::DkmDeviceInfo::DeviceFamilyVersion()
{
    return this->m_pDeviceFamilyVersion;
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmString* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DefaultPort::DkmDeviceInfo::DeviceForm()
{
    return this->m_pDeviceForm;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DefaultPort::DkmDeviceInfo::Create(Microsoft::VisualStudio::Debugger::DkmString* pDeviceFamily, Microsoft::VisualStudio::Debugger::DkmString* pDeviceFamilyVersion, Microsoft::VisualStudio::Debugger::DkmString* pDeviceForm, Microsoft::VisualStudio::Debugger::DefaultPort::DkmDeviceInfo** ppCreatedObject)
{
    return Proc082C271A47113D797444C427094AAEDF(pDeviceFamily, pDeviceFamilyVersion, pDeviceForm, ppCreatedObject);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILCheckTimeout::Create(Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILCheckTimeout** ppCreatedObject)
{
    return Proc4B7457AF46268ED8D57C1BFC79F8BC79(ppCreatedObject);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILExtractBytesPopArguments::Create(Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILExtractBytesPopArguments** ppCreatedObject)
{
    return Proc5022149BA7EB46392DCD117CA2FEF386(ppCreatedObject);
}

inline DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILPushLocalVariablePseudoAddress::Index()
{
    return this->m_Index;
}

inline DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILPushLocalVariablePseudoAddress::ByteOffset()
{
    return this->m_ByteOffset;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILPushLocalVariablePseudoAddress::Create(UINT32 Index, UINT32 ByteOffset, Microsoft::VisualStudio::Debugger::Evaluation::IL::DkmILPushLocalVariablePseudoAddress** ppCreatedObject)
{
    return ProcFBD8048E323DAC88D7FF8393F688ED91(Index, ByteOffset, ppCreatedObject);
}

inline DECLSPEC_NOTHROW UINT64 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::ParallelTasks::DkmJsAsyncStackFrame::DocumentId()
{
    return this->m_DocumentId;
}

inline DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::ParallelTasks::DkmJsAsyncStackFrame::SourceLocationStartIndex()
{
    return this->m_SourceLocationStartIndex;
}

inline DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::ParallelTasks::DkmJsAsyncStackFrame::SourceLocationLength()
{
    return this->m_SourceLocationLength;
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmString* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::ParallelTasks::DkmJsAsyncStackFrame::Name()
{
    return this->m_pName;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::ParallelTasks::DkmJsAsyncStackFrame::Create(UINT64 DocumentId, UINT32 SourceLocationStartIndex, UINT32 SourceLocationLength, Microsoft::VisualStudio::Debugger::DkmString* pName, Microsoft::VisualStudio::Debugger::ParallelTasks::DkmJsAsyncStackFrame** ppCreatedObject)
{
    return ProcB6D7212BE816425F674E88BD06E78AE0(DocumentId, SourceLocationStartIndex, SourceLocationLength, pName, ppCreatedObject);
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmString* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Telemetry::DkmNameValuePair::Name()
{
    return this->m_pName;
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmVariant* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Telemetry::DkmNameValuePair::Value()
{
    return this->m_pValue;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Telemetry::DkmNameValuePair::Create(Microsoft::VisualStudio::Debugger::DkmString* pName, Microsoft::VisualStudio::Debugger::DkmVariant* pValue, Microsoft::VisualStudio::Debugger::Telemetry::DkmNameValuePair** ppCreatedObject)
{
    return ProcA362BD15F58DE8F2A1F626F0A7DBA97E(pName, pValue, ppCreatedObject);
}

inline DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmPerformanceCounters::StartStopCounter()
{
    return this->m_StartStopCounter;
}

inline DECLSPEC_NOTHROW UINT64 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmPerformanceCounters::SystemTime()
{
    return this->m_SystemTime;
}

inline DECLSPEC_NOTHROW UINT64 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmPerformanceCounters::UserTime()
{
    return this->m_UserTime;
}

inline DECLSPEC_NOTHROW UINT64 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmPerformanceCounters::KernelTime()
{
    return this->m_KernelTime;
}

inline DECLSPEC_NOTHROW UINT64 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmPerformanceCounters::RuntimeOverhead()
{
    return this->m_RuntimeOverhead;
}

inline DECLSPEC_NOTHROW UINT64 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmPerformanceCounters::OSOverhead()
{
    return this->m_OSOverhead;
}

inline DECLSPEC_NOTHROW UINT64 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmPerformanceCounters::TotalOverhead()
{
    return this->m_TotalOverhead;
}

inline DECLSPEC_NOTHROW UINT64 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmPerformanceCounters::Id()
{
    return this->m_Id;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmPerformanceCounters::Create(UINT32 StartStopCounter, UINT64 SystemTime, UINT64 UserTime, UINT64 KernelTime, UINT64 RuntimeOverhead, UINT64 OSOverhead, UINT64 TotalOverhead, UINT64 Id, Microsoft::VisualStudio::Debugger::DkmPerformanceCounters** ppCreatedObject)
{
    return ProcB5B3FB396ABDFD2A6B8D805FDC61EE50(StartStopCounter, SystemTime, UserTime, KernelTime, RuntimeOverhead, OSOverhead, TotalOverhead, Id, ppCreatedObject);
}

inline DECLSPEC_NOTHROW UINT64 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmProcessExecutionCounters::QueryPerformanceCounterTime()
{
    return this->m_QueryPerformanceCounterTime;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::DkmProcessExecutionCounters::Create(UINT64 QueryPerformanceCounterTime, Microsoft::VisualStudio::Debugger::DkmProcessExecutionCounters** ppCreatedObject)
{
    return ProcF54928607EEFC725D831257A3CC72386(QueryPerformanceCounterTime, ppCreatedObject);
}

#ifndef EXCLUDE_MONITOR_ONLY_APIS
_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DefaultPort::DkmTransportConnection* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Start::DkmProcessLaunchEnvironmentFilterInputData::Connection()
{
    return this->m_pConnection;
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::Start::DkmDebugLaunchSettings* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Start::DkmProcessLaunchEnvironmentFilterInputData::DebugLaunchSettings()
{
    return this->m_pDebugLaunchSettings;
}

_Ret_opt_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmString* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Start::DkmProcessLaunchEnvironmentFilterInputData::ExecutablePath()
{
    return this->m_pExecutablePath;
}

_Ret_opt_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DefaultPort::DkmAppPackageId* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Start::DkmProcessLaunchEnvironmentFilterInputData::AppPackageId()
{
    return this->m_pAppPackageId;
}

inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::Start::DkmProcessLaunchFlags_t STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Start::DkmProcessLaunchEnvironmentFilterInputData::LaunchFlags()
{
    return this->m_LaunchFlags;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Start::DkmProcessLaunchEnvironmentFilterInputData::Create(Microsoft::VisualStudio::Debugger::DefaultPort::DkmTransportConnection* pConnection, Microsoft::VisualStudio::Debugger::Start::DkmDebugLaunchSettings* pDebugLaunchSettings, Microsoft::VisualStudio::Debugger::DkmString* pExecutablePath, Microsoft::VisualStudio::Debugger::DefaultPort::DkmAppPackageId* pAppPackageId, Microsoft::VisualStudio::Debugger::Start::DkmProcessLaunchFlags_t LaunchFlags, Microsoft::VisualStudio::Debugger::Start::DkmProcessLaunchEnvironmentFilterInputData** ppCreatedObject)
{
    return Proc199972430544F641DFC1A35754AF1EC0(pConnection, pDebugLaunchSettings, pExecutablePath, pAppPackageId, LaunchFlags, ppCreatedObject);
}
#endif // #ifndef EXCLUDE_MONITOR_ONLY_APIS

#ifndef EXCLUDE_MONITOR_ONLY_APIS
inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Start::DkmProcessLaunchEnvironmentFilterList140::GetAdditionalEnvironmentVariables(UINT32 ImplementationIndex, Microsoft::VisualStudio::Debugger::Start::DkmProcessLaunchEnvironmentFilterInputData* pInputData, Microsoft::VisualStudio::Debugger::DkmString** ppAdditionalEnvironmentBlock)
{
    return ProcD9DC7CF02117F80BE2495AB906AC64B0(this, ImplementationIndex, pInputData, ppAdditionalEnvironmentBlock);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Start::DkmProcessLaunchEnvironmentFilterList140::Create(Microsoft::VisualStudio::Debugger::Start::DkmProcessLaunchEnvironmentFilterList140** ppCreatedObject)
{
    return Proc0C211680A7F9624327EDD6ED30FD1C19(ppCreatedObject);
}
#endif // #ifndef EXCLUDE_MONITOR_ONLY_APIS
_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::Evaluation::DkmInspectionSession* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmRawReturnValueContainer::InspectionSession()
{
    return this->m_pInspectionSession;
}

inline DECLSPEC_NOTHROW UINT32 STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmRawReturnValueContainer::Id()
{
    return this->m_Id;
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::Evaluation::DkmRawReturnValue* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmRawReturnValueContainer::RawReturnValue()
{
    return this->m_pRawReturnValue;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Evaluation::DkmRawReturnValueContainer::Create(Microsoft::VisualStudio::Debugger::Evaluation::DkmInspectionSession* pInspectionSession, UINT32 Id, Microsoft::VisualStudio::Debugger::Evaluation::DkmRawReturnValue* pRawReturnValue, const Microsoft::VisualStudio::Debugger::DkmDataItem& DataItem, Microsoft::VisualStudio::Debugger::Evaluation::DkmRawReturnValueContainer** ppCreatedObject)
{
    return Proc7E505E32958900398D69C6DFB3CC8958(pInspectionSession, Id, pRawReturnValue, DataItem, ppCreatedObject);
}

_Ret_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmString* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Telemetry::DkmTelemetryEvent::EventName()
{
    return this->m_pEventName;
}

_Ret_opt_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<Microsoft::VisualStudio::Debugger::Telemetry::DkmNameValuePair*>* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Telemetry::DkmTelemetryEvent::Properties()
{
    return this->m_pProperties;
}

_Ret_opt_ inline DECLSPEC_NOTHROW Microsoft::VisualStudio::Debugger::DkmProcess* STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Telemetry::DkmTelemetryEvent::Process()
{
    return this->m_pProcess;
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Telemetry::DkmTelemetryEvent::Create(Microsoft::VisualStudio::Debugger::DkmString* pEventName, Microsoft::VisualStudio::Debugger::DkmReadOnlyCollection<Microsoft::VisualStudio::Debugger::Telemetry::DkmNameValuePair*>* pProperties, Microsoft::VisualStudio::Debugger::DkmProcess* pProcess, Microsoft::VisualStudio::Debugger::Telemetry::DkmTelemetryEvent** ppCreatedObject)
{
    return Proc460DDFA12EC13DA36A7F58D811507AD7(pEventName, pProperties, pProcess, ppCreatedObject);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Telemetry::DkmTelemetryEvent::Post()
{
    return ProcC7B5FDEAB2F8AA4877A954A64B765D38(this);
}

inline DECLSPEC_NOTHROW HRESULT STDMETHODCALLTYPE Microsoft::VisualStudio::Debugger::Telemetry::DkmTelemetryEvent::Post(Microsoft::VisualStudio::Debugger::DkmWorkList* pWorkList, Microsoft::VisualStudio::Debugger::IDkmCompletionRoutine<Microsoft::VisualStudio::Debugger::Telemetry::DkmPostAsyncResult>* pCompletionRoutine)
{
    return ProcAE0CE43A914209353DDCF288F1A32E1A(this, pWorkList, pCompletionRoutine);
}

#endif // for #ifndef __INTELLISENSE__
#pragma warning(pop)

#pragma pack(pop)
#pragma warning(pop)

#endif // #ifndef _INC_VSDEBUGENG_

